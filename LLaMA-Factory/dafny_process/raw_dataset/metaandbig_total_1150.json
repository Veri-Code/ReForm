[
{
    "dafny": "predicate Sorted(a:array<int>, low:int, high:int)\n\treads a\n{\n\t0 <= low <= high <= a.Length &&\n\tforall i,j :: low <= i < j < high ==> a[i] <= a[j]\n}\nmethod CocktailSort(a:array<int>)\n\tmodifies a\n\trequires a.Length > 1\n\tensures Sorted(a, 0, a.Length)\n\tensures multiset(a[..]) == multiset(old(a[..]))\n{\n    var start := 0;\n    var end := a.Length - 1;\n\twhile (start < end)\n        invariant start >= 0 && end <= a.Length-1\n\t\tinvariant forall x :: end < x < a.Length ==> forall y :: 0 <= y < end ==> a[x] >= a[y]\n        invariant forall x :: 0 <= x < start ==> forall y :: start <= y < a.Length ==> a[x] <= a[y]\n\t\tinvariant Sorted(a, 0, start) && Sorted(a, end, a.Length)\n\t\tinvariant multiset(a[..]) == multiset(old(a[..]))\n\t{\n\t\tvar j := start;\n\t\twhile (j < end)\n\t\t\tinvariant start <= j <= end\n\t\t\tinvariant forall k :: 0 <= k <= j ==> a[k] <= a[j]\n            invariant forall x :: 0 <= x < start ==> forall y :: start <= y < a.Length ==> a[x] <= a[y]\n\t\t\tinvariant forall x :: end < x < a.Length ==> forall y :: 0 <= y < end ==> a[x] >= a[y]\n\t\t\tinvariant Sorted(a, 0, start) && Sorted(a, end, a.Length)\n\t\t\tinvariant multiset(a[..]) == multiset(old(a[..]))\n\t\t{\n\t\t\tif (a[j] > a[j+1])\n\t\t\t{\n\t\t\t\ta[j], a[j+1] := a[j+1], a[j];\n\t\t\t}\n\t\t\tj := j + 1;\n\t\t}\n        end := end - 1;\n        j := end;\n        while (j > start)\n\t\t\tinvariant start <= j <= end\n\t\t\tinvariant forall k :: j <= k <= end ==> a[k] >= a[j]\n\t\t\tinvariant forall x :: 0 <= x < start ==> forall y :: start <= y < a.Length ==> a[x] <= a[y]\n            invariant forall x :: end < x < a.Length ==> forall y :: 0 <= y < end ==> a[x] >= a[y]\n\t\t\tinvariant Sorted(a, 0, start) && Sorted(a, end, a.Length)\n\t\t\tinvariant multiset(a[..]) == multiset(old(a[..]))\n\t\t{\n\t\t\tif (a[j] < a[j-1])\n\t\t\t{\n\t\t\t\ta[j], a[j-1] := a[j-1], a[j];\n\t\t\t}\n\t\t\tj := j - 1;\n\t\t}\n        start := start + 1;\n\t}\n}"
},
{
    "dafny": "function max(a: int, b: int): int\n{\n\tif a > b then a else b\n}\nmethod Main()\n{\n\tassert max(500, -500) == 500;\n\tassert max(500, 0) == 500;\n\tassert max(-500, -501) == -500;\n}"
},
{
    "dafny": "method Main() {\n  var m := new M0.MyClass.Init(20);\n  print m.a, \", \", m.b, \", \", m.c, \"\\n\";\n  var r0 := new Regression.A.Make0();\n  var r1 := new Regression.A.Make1();\n  assert r0.b != r1.b;\n  print r0.b, \", \", r1.b, \"\\n\";\n}\nmodule M0 {\n  class MyClass {\n    var a: nat\n    const b := 17\n    var c: real\n    constructor Init(x: nat)\n    {\n      this.a := x;\n      c := 3.14;\n      new;\n      a := a + b;\n      assert c == 3.14;\n      assert this.a == 17 + x;\n    }\n    constructor (z: real)\n      ensures c <= 2.0 * z\n    {\n      a, c := 50, 2.0 * z;\n      new;\n    }\n    constructor Make()\n      ensures 10 <= a\n    {\n      new;\n      a := a + b;\n    }\n    constructor Create()\n      ensures 30 <= a\n    {\n      new;\n      a := a + 2*b;\n    }\n  }\n}\nmodule M1 refines M0 {\n  class MyClass ... {\n    const d := 'D'\n    var e: char\n    constructor Init...\n    {\n      e := 'e';\n      new;\n      e := 'x';\n      ...;\n      assert e == 'x';\n    }\n    constructor ...\n    {\n      e := 'y';\n      new;\n    }\n    constructor Make...\n    {\n      new;\n      e := 'z';\n    }\n    constructor Create...\n    {\n      e := 'w';\n    }\n  }\n}\nmodule TypeOfThis {\n  class LinkedList<T(0)> {\n    ghost var Repr: set<LinkedList<T>>\n    ghost var Rapr: set<LinkedList?<T>>\n    ghost var S: set<object>\n    ghost var T: set<object?>\n    constructor Init()\n    {\n      Repr := {this};  \n    }\n    constructor Init'()\n    {\n      Rapr := {this};\n    }\n    constructor Create()\n    {\n      S := {this};  \n    }\n    constructor Create'()\n    {\n      T := {this};\n    }\n    constructor Two()\n    {\n      new;\n      var ll: LinkedList? := this;\n      var o: object? := this;\n      if\n      case true =>  T := {o};\n      case true =>  S := {o};\n      case true =>  Repr := {ll};\n      case true =>  Rapr := {ll};\n      case true =>  S := {ll};\n      case true =>  T := {ll};\n    }\n    method Mutate()\n      modifies this\n    {\n      Repr := {this};\n      Rapr := {this};\n      S := {this};\n      T := {this};\n    }\n  }\n}\nmodule Regression {\n  class A {\n    var b: bool\n    var y: int\n    constructor Make0()\n      ensures b == false  \n    {\n      b := false;\n    }\n    constructor Make1()\n      ensures b == true\n    {\n      b := true;\n    }\n    constructor Make2()\n    {\n      b := false;\n      new;  \n      assert !b;  \n    }\n    constructor Make3()\n      ensures b == false && y == 65\n    {\n      b := false;\n      y := 65;\n      new;\n      assert !b;  \n      assert y == 65;\n    }\n    constructor Make4(bb: bool, yy: int)\n      ensures b == bb && y == yy\n    {\n      b, y := bb, yy;\n    }\n  }\n}"
},
{
    "dafny": "class Trisupport {\n constructor() \n ensures printed() == 0\n ensures row() == 1\n ensures col() == 0\n {test_printed := 0; test_col :=0; test_row :=1; }\n var test_printed : nat;\n var test_row : nat;\n var test_col : nat;\n function    printed() : (r : nat)  reads this`test_printed {test_printed}\n function    row() : (r : nat) reads this`test_row {test_row}\n function    col() : (r : nat) reads this`test_col {test_col}\n method star() \n   ensures test_printed == old(test_printed) + 1\n   ensures test_col == old(test_col + 1)\n   modifies this`test_printed, this`test_col\n   {test_printed := test_printed + 1; test_col := test_col + 1; print \"* \";}\n method space()\n  { print \" \";}\n method cr() \n  modifies this`test_row, this`test_col\n  ensures test_row == old(test_row) + 1\n  ensures test_col == 0\n  {\n   print \"row=\", test_row, \" printed=\", test_printed, \"\\n\";\n   test_row := test_row + 1; test_col := 0;  }\n}"
},
{
    "dafny": "newtype uint8 = x : int | 0 <= x < 256\nmethod Main() {\n  var y := 0x80 as bv8;\n  var x := (y >> 4) as uint8;\n  print y, \" >> 4 == \", x, \"\\n\";\n  assert x != 248; \n  assert x == 0x8;\n  if x == 248 {\n    var x := 1/0; \n  }\n  var z: bv32 := 12;\n  assert (z >> 31) == 0;\n  print \"12 >> 31 == \", z >> 31, \", \";\n  assert (z >> 32) == 0;\n  print \"12 >> 32 == \", z >> 32, \"\\n\";\n  Right();\n  Left();\n}\nmethod Right() {\n  var m: bv0 := 0;\n  print m >> 0, \"\\n\"; \n  var n: bv1 := 1;\n  print n >> 0, \" \", n >> 1, \"\\n\"; \n  var a: bv7 := 12;\n  print a >> 0, \" \", a >> 1, \" \", a >> 6, \" \", a >> 7, \" \"; \n  a := -1;\n  print a >> 0, \" \", a >> 6, \"\\n\"; \n  var b: bv8 := 12;\n  print b >> 0, \" \", b >> 1, \" \", b >> 7, \" \", b >> 8, \" \"; \n  b := -1;\n  print b >> 0, \" \", b >> 7, \"\\n\"; \n  var r: bv15 := 12;\n  print r >> 0, \" \", r >> 1, \" \", r >> 14, \" \", r >> 15, \" \"; \n  r := -1;\n  print r >> 0, \" \", r >> 14, \"\\n\"; \n  var s: bv16 := 12;\n  print s >> 0, \" \", s >> 1, \" \", s >> 15, \" \", s >> 16, \" \"; \n  s := -1;\n  print s >> 0, \" \", s >> 15, \"\\n\"; \n  var w: bv31 := 12;\n  print w >> 0, \" \", w >> 1, \" \", w >> 30, \" \", w >> 31, \" \"; \n  w := -1;\n  print w >> 0, \" \", w >> 30, \"\\n\"; \n  var x: bv32 := 12;\n  print x >> 0, \" \", x >> 1, \" \", x >> 31, \" \", x >> 32, \" \"; \n  x := -1;\n  print x >> 0, \" \", x >> 31, \"\\n\"; \n  var y: bv63 := 12;\n  print y >> 0, \" \", y >> 1, \" \", y >> 62, \" \", y >> 62, \" \"; \n  y := -1;\n  print y >> 0, \" \", y >> 62, \"\\n\"; \n  var z: bv64 := 12;\n  print z >> 0, \" \", z >> 1, \" \", z >> 63, \" \", z >> 64, \" \"; \n  z := -1;\n  print z >> 0, \" \", z >> 63, \"\\n\"; \n  var u: bv100 := 12;\n  print u >> 0, \" \", u >> 1, \" \", u >> 99, \" \", u >> 100, \" \"; \n  u := -1;\n  print u >> 0, \" \", u >> 99, \"\\n\"; \n}\nmethod Left() {\n  var m: bv0 := 0;\n  print m << 0, \"\\n\"; \n  var n: bv1 := 1;\n  print n << 0, \" \", n << 1, \"\\n\"; \n  var a: bv7 := 12;\n  print a << 0, \" \", a << 1, \" \", a << 6, \" \", a << 7, \" \"; \n  a := -1;\n  print a << 0, \" \", a << 6, \"\\n\"; \n  var b: bv8 := 12;\n  print b << 0, \" \", b << 1, \" \", b << 7, \" \", b << 8, \" \"; \n  b := -1;\n  print b << 0, \" \", b << 7, \"\\n\"; \n  var r: bv15 := 12;\n  print r << 0, \" \", r << 1, \" \", r << 14, \" \", r << 15, \" \"; \n  r := -1;\n  print r << 0, \" \", r << 14, \"\\n\"; \n  var s: bv16 := 12;\n  print s << 0, \" \", s << 1, \" \", s << 15, \" \", s << 16, \" \"; \n  s := -1;\n  print s << 0, \" \", s << 15, \"\\n\"; \n  var w: bv31 := 12;\n  print w << 0, \" \", w << 1, \" \", w << 30, \" \", w << 31, \" \"; \n  w := -1;\n  print w << 0, \" \", w << 30, \"\\n\"; \n  var x: bv32 := 12;\n  print x << 0, \" \", x << 1, \" \", x << 31, \" \", x << 32, \" \"; \n  x := -1;\n  print x << 0, \" \", x << 31, \"\\n\"; \n  var y: bv63 := 12;\n  print y << 0, \" \", y << 1, \" \", y << 62, \" \", y << 62, \" \"; \n  y := -1;\n  print y << 0, \" \", y << 62, \"\\n\"; \n  var z: bv64 := 12;\n  print z << 0, \" \", z << 1, \" \", z << 63, \" \", z << 64, \" \"; \n  z := -1;\n  print z << 0, \" \", z << 63, \"\\n\"; \n  var u: bv100 := 12;\n  print u << 0, \" \", u << 1, \" \", u << 99, \" \", u << 100, \" \"; \n  u := -1;\n  print u << 0, \" \", u << 99, \"\\n\"; \n}"
},
{
    "dafny": "module  M {\n  trait T {\n    ghost function f(): nat\n  }\n  class C extends T {\n    constructor () { }\n    ghost function f(): nat { 0 }\n  }\n}\nmethod Test0() {\n  var c := new M.C();\n  assert c.f() == 0;\n  var g: M.T := c;\n  assert g.f() == 0;  \n}\nmethod Test1() {\n  var c := new M.C();  \n  var g: M.T := c;\n  assert c.f() == 0;  \n}\nmethod Test2() {\n  var c := new M.C();\n  assert c.f() == 0;\n}\nmethod Test3() {\n  var c: M.C := new M.C();  \n  var g: M.T := c;\n  assert c.f() == 0;\n}\nmethod Test4(c: M.C, g: M.T)\n  requires c == g\n{\n  assert c.f() == 0;\n  assert g.f() == 0;  \n}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n   ensures index == -1 || (0 <= index ==> index < a.Length && a[index] == key)\n{\n    index := 0;\n    while (index < a.Length)\n        invariant 0 <= index <= a.Length\n        decreases a.Length - index\n    {\n        if (a[index] == key)\n        {\n            return index;\n        }\n        index := index + 1;\n    }\n    return -1;\n}"
},
{
    "dafny": "method CountToAndReturnN(n: int) returns (r: int)\n    requires n >= 0\n    ensures r == n \n{\n    var i := 0;\n    while i < n\n    invariant 0 <= i <= n\n    {\n        i := i + 1;\n    }\n    r := i;\n}"
},
{
    "dafny": "method swap(arr: array<int>, i: int, j: int)\n  requires arr != null\n  requires 0 <= i <= j < arr.Length\n  modifies arr\n  ensures arr[i] == old(arr[j])\n  ensures arr[j] == old(arr[i])\n  ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n  ensures forall k, l :: 0 <= k <= i && j < l <= arr.Length ==> multiset(arr[k..l]) == old(multiset(arr[k..l]))\n{\n  var temp := arr[i];\n  arr[i] := arr[j];\n  arr[j] := temp;\n}\nmethod partition(arr: array<int>, pivot : int, begin: int, end: int) returns (smaller: int, larger: int)\n  requires arr != null\n  modifies arr\n  requires 0 <= begin <= pivot < end <= arr.Length\n  ensures begin <= smaller < larger <= end\n  ensures forall i :: begin <= i < smaller ==> arr[i] < arr[smaller]\n  ensures forall i :: smaller <= i < larger ==> arr[i] == arr[smaller]\n  ensures forall i :: larger <= i < end ==> arr[i] > arr[smaller]\n  requires forall i, j :: 0 <= i < begin && begin <= j < end ==> arr[i] < arr[j]\n  requires forall i, j :: end <= i < arr.Length && begin <= j < end ==> arr[i] > arr[j]\n  ensures forall i, j :: 0 <= i < begin && begin <= j < end ==> arr[i] < arr[j]\n  ensures forall i, j :: end <= i < arr.Length && begin <= j < end ==> arr[i] > arr[j]\n  ensures forall i :: 0 <= i < begin || end <= i < arr.Length ==> arr[i] == old(arr[i])\n  ensures old(multiset(arr[begin..end])) == multiset(arr[begin..end])\n  ensures forall k, l :: 0 <= k <= begin && end <= l <= arr.Length ==> multiset(arr[k..l]) == old(multiset(arr[k..l]))\n{\n  var i := begin + 1;\n  var temp := arr[pivot];\n  arr[pivot] := arr[begin];\n  arr[begin] := temp;\n  var j := begin;\n  var k := begin + 1;\n  while (i < end)\n    invariant begin < i <= end\n    invariant begin <= j < k <= i\n    invariant forall l :: begin <= l < j ==> arr[l] < arr[j]\n    invariant forall l :: j <= l < k ==> arr[l] == arr[j]\n    invariant forall l :: k <= l < i ==> arr[l] > arr[j]\n    invariant forall i, j :: 0 <= i < begin && begin <= j < end ==> arr[i] < arr[j]\n    invariant forall i, j :: end <= i < arr.Length && begin <= j < end ==> arr[i] > arr[j]\n    invariant forall i :: 0 <= i < begin || end <= i < arr.Length ==> arr[i] == old(arr[i])\n    invariant forall k, l :: 0 <= k <= begin && end <= l <= arr.Length ==> multiset(arr[k..l]) == old(multiset(arr[k..l]))\n  {\n    if (arr[i] < arr[j]) {\n      swap(arr, j, i);\n      swap(arr, k, i);\n      j := j + 1;\n      k := k + 1;\n    }\n    else if (arr[i] == arr[j]) {\n      swap(arr, k, i);\n      k := k + 1;\n    }\n    i := i + 1;\n  }\n  smaller := j;\n  larger := k;\n}\nmethod sort_aux(arr: array<int>, begin: int, end: int)\n  requires arr != null\n  modifies arr\n  decreases end - begin\n  requires 0 <= begin < end <= arr.Length\n  requires forall i, j :: 0 <= i < begin && begin <= j < end ==> arr[i] < arr[j]\n  requires forall i, j :: end <= i < arr.Length && begin <= j < end ==> arr[i] > arr[j]\n  ensures forall i, j :: 0 <= i < begin && begin <= j < end ==> arr[i] < arr[j]\n  ensures forall i, j :: end <= i < arr.Length && begin <= j < end ==> arr[i] > arr[j]\n  ensures forall i :: 0 <= i < begin || end <= i < arr.Length ==> arr[i] == old(arr[i])\n  ensures forall k, l :: 0 <= k <= begin && end <= l <= arr.Length ==> multiset(arr[k..l]) == old(multiset(arr[k..l]))\n  ensures forall i :: begin <= i < end - 1 ==> arr[i] <= arr[i + 1]\n{\n  if (arr.Length == 0) {\n    return;\n  }\n  var backup := arr[..];\n  var smaller, larger := partition(arr, begin, begin, end);\n  if (begin < smaller) {\n    var backup := arr[..];\n    sort_aux(arr, begin, smaller);\n  }\n  if (larger < end) {\n    var backup := arr[..];\n    sort_aux(arr, larger, end);\n  }\n}\nlemma sequence_boundary_elimination(s: seq<int>)\n  ensures s[0..|s|] == s[..]\nmethod sort(arr: array<int>)\n  requires arr != null\n  modifies arr\n  ensures forall i :: 0 <= i < arr.Length - 1 ==> arr[i] <= arr[i + 1]\n  ensures multiset(arr[..]) == old(multiset(arr[..]))\n{\n  if (arr.Length == 0) {\n    return;\n  }\n  sort_aux(arr, 0, arr.Length);\n  sequence_boundary_elimination(arr[..]);\n  sequence_boundary_elimination(old(arr[..]));\n}"
},
{
    "dafny": "predicate Identical(a:array<char>, b:array<char>, index: int)\n\treads a\n\treads b\n{\n\ta.Length == b.Length &&\n\t0 <= index <= a.Length &&\n\tforall i :: 0 <= i < index ==> a[i] == b[i]\n}\nmethod Strcmp(a:array<char>, b:array<char>) returns (identical:bool)\n\tensures identical == Identical(a,b, a.Length)\n{\n\tif (a.Length != b.Length){\n\t\tidentical := false;\n\t\treturn;\n\t}\n\tvar index := 0;\n\tidentical := true;\n\twhile (index < a.Length)\n\t\tinvariant 0 <= index <= a.Length\n\t\tinvariant identical == Identical(a, b, index)\n\t{\n\t\tif (a[index] != b[index])\n\t\t{\n\t\t\tidentical := false;\n\t\t}\n\t\tindex := index + 1;\n\t}\n}\nmethod UniqueUsername(usernames:array<array<char>>, newUsername:array<char>) returns (unique: bool)\n\tensures unique ==> forall x :: 0 <= x < usernames.Length ==> !Identical(usernames[x], newUsername, newUsername.Length)\n{\n\tvar i := 0;\n\tunique := true;\n\twhile (i < usernames.Length)\n\t\tinvariant 0 <= i <= usernames.Length\n\t\tinvariant unique ==> forall x :: 0 <= x < i ==> !Identical(usernames[x], newUsername, newUsername.Length)\n\t{\n\t\tvar identical := Strcmp(usernames[i], newUsername);\n\t\tif (identical)\n\t\t{\n\t\t\tunique := false;\n\t\t}\n\t\ti := i + 1;\n\t}\t\n}"
},
{
    "dafny": "const one:int := 1\nconst two:int := one * 2\nconst three:int := one + two\nconst Pi:real := 3.14\nclass Calendar {\n  static const months:int := 12\n  static const weeks:int := 52\n}\nmethod Main() {\n  print \"one := \", one, \"\\n\";\n  print \"two := \", two, \"\\n\";\n  print \"three := \", three, \"\\n\";\n  assert three == 3;\n  print \"Pi := \", Pi, \"\\n\";\n  assert Pi == 3.14;\n  var weeks := Calendar.weeks;\n  print \"months := \", Calendar.months, \"\\n\";\n  print \"weeks := \", weeks, \"\\n\";\n  assert weeks == 52;\n  var c := new C;\n  var tu := c.M();  \n  print tu, \" \";\n  print c.G(c), \" \";  \n  print c.H(c), \" \";  \n  print C.x, \" \";  \n  var g := new Generic<real>;\n  var putItHere := g.y;\n  print putItHere, \" \";  \n  var go := g.M();\n  print go, \"\\n\";  \n  var noRhs := new NoRHS;\n  print \"noRhs.y = \", noRhs.y, \"\\n\";\n  var cl := new Class;\n  cl.Test();\n  var ii := new InstanceInit(13);\n  print ii.x0, \" \", ii.x1, \" \", ii.y2, \" \", ii.y3, \" \", ii.r, \"\\n\";  \n  print mmgg, \" \", UninterpretedStaticsTrait.mmtt, \" \", UninterpretedStaticsClass.mmcc, \"\\n\";\n  InitializationDependencies.PrintEm();\n}\nclass C {\n  static const x: int := y+1\n  static const y: int := 5\n  var z: int\n  static function G(c: C): int\n    ensures G(c) == 16\n  {\n    x + y + c.y\n  }\n  const a: int := b+2\n  const b: int := 50\n  function H(c: C): int\n    ensures H(c) == 50 + 52 + 50 + 6 + 5 + 5 + 5 == 173\n  {\n    a + b + c.b + x + y + c.y + C.y\n  }\n  method M() returns (r: int)\n    ensures r == 11\n  {\n    r := x + y;\n  }\n}\nclass Generic<G> {\n  const y: int := 63\n  method M() returns (q: int)\n    ensures q == 63\n  {\n    q := this.y;\n  }\n}\nnewtype Six = x | 6 <= x witness 6\nclass NoRHS {\n  const y: Six\n}\ntrait Trait {\n  const x0: Six\n  const x1: Six := 7\n  static const y: Six := 7\n}\nclass Class extends Trait {\n  method Test() {\n    assert x1 == 7 && y == 7;\n    print x0, \" \", x1, \" \", y, \"\\n\";\n  }\n}\nmethod MMethod(tr: Trait?) {\n  assert Trait.y == 7;\n  assert tr.y == 7;\n  assert tr == null || tr.x1 == 7;\n}\nclass InstanceInit extends Trait {\n  const y2: Six\n  const y3: Six := 12\n  const N: int := 20\n  var r: real\n  constructor (u: Six)\n    requires 10 <= u\n  {\n    x0 := 80 + u;\n    var arr := new real[N];\n    arr[8] := 2.7;\n    r := arr[8];\n    y2 := 77 + y3;\n    new;\n    assert x0 == u + 80 && x1 ==7;\n    assert y2 == 89 && y3 == 12;\n    assert arr.Length == 20;\n    arr[9] := 3.14;\n    r := r + arr[8] + arr[9];  \n  }\n}\nconst mmgg: Six\ntrait UninterpretedStaticsTrait {\n  static const mmtt: Six\n}\nclass UninterpretedStaticsClass extends UninterpretedStaticsTrait {\n  static const mmcc: Six\n}\ntype byte = x | 0 <= x < 256\nclass MyClass {\n  const B: array<byte>\n  method M()\n  {\n    var x: array?<byte> := B;\n    var y: array<byte> := x;  \n  }\n}\nclass MyOnePurposeClass {\n  static const z: int\n  static const w: int := 76\n  static const self: MyOnePurposeClass?\n}\nclass MyGenericClass<X(00), Y(00)> {\n  ghost static const x: X\n  ghost static const y: Y\n  static const z: int\n  static const w: int := 76\n  static const self: MyGenericClass?<X,Y>\n  static const almostSelf: MyGenericClass?<Y,X>\n  static const another: MyGenericClass?<byte,seq<X>>\n}\nmodule InitializationDependencies {\n  class C {\n    static const a: int := b\n    static const b: int := D.m\n    static const c: int := b\n  }\n  class D {\n    static const m: int := 20\n  }\n  class R {\n    const a: int := b + b\n    const b: int := this.m\n    const c: int := b\n    const m: int := 21\n    const n: int := F(b)\n    function F(nn: int): int {\n      2 * nn + C.b\n    }\n  }\n  method PrintEm()\n  {\n    print C.a, \" \";\n    print C.b, \" \";\n    print C.c, \"\\n\";\n    print D.m, \"\\n\";\n    var r := new R;\n    print r.a, \" \";\n    print r.b, \" \";\n    print r.c, \" \";\n    print r.m, \"\\n\";\n    print r.n, \"\\n\";\n  }\n}\nmodule A {\n  const x: int := 100\n}\nmodule B refines A {\n  ghost const x: int\n  lemma TestRhsIsInherited() {\n    assert x == 100;\n  }\n}"
},
{
    "dafny": "predicate Sorted(a:array<int>, low:int, high:int) \n    reads a \n    requires 0<= low <= high  <= a.Length\n{\n    forall j,k:: 0<=j<k<high ==> a[j]<=a[k] \n}\npredicate SortedExcept(a:array<int>, high:int, except:int )\n    reads a \n    requires 0<= except <= high  <= a.Length\n{\n    forall j,k:: (0<=j<k<high && j != except && k != except) ==> a[j]<=a[k] \n}\nmethod InsertionSortShuffle(a: array<int>)\nrequires a.Length>1\nensures Sorted(a, 0, a.Length);\nensures multiset(a[..]) == multiset(old(a[..]));\nmodifies a;\n{\n    var up:=1;\n    var injectValue:= a[up];\n    var injectPoint:= up;\n    while (up < a.Length  )\n        decreases a.Length - up \n        invariant 1 <= up <= a.Length;\n        invariant 0<= injectPoint <= up \n        invariant Sorted(a, 0, up);\n        invariant multiset(a[..]) == multiset(old(a[..]));\n    {\n        injectValue := a[up];\n        injectPoint := up;\n        while (injectPoint >= 1 && a[injectPoint-1] > injectValue)\n            decreases injectPoint\n            invariant 0 <= injectPoint <= up;\n            invariant SortedExcept(a, up +1 , injectPoint)\n            invariant forall i :: injectPoint <= i <= up ==>  injectValue <= a[i] \n            invariant multiset(a[..]) == multiset(old(a[..])) + multiset{a[injectPoint]} - multiset{injectValue}\n        {\n            a[injectPoint] := a[injectPoint-1];\n            injectPoint:=injectPoint-1;\n        }\n        a[injectPoint] :=  injectValue;\n        up:=up+1;\n    }\n}\nmethod Main()\n{\nvar a := new int[][6,2,0,6,3,5,0,4,1,6,0]; \nvar msa := multiset(a[..]);\nInsertionSortShuffle(a);\nassert Sorted(a, 0, a.Length);\nvar msa_post := multiset(a[..]);\nassert msa==msa_post;\nvar b := new int[][8,7]; \nInsertionSortShuffle(b);\nprint a[..], b[..];\n}"
},
{
    "dafny": "predicate sorted(a: array<int>)\n  requires a != null\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] < a[j]\n}\npredicate sorted_with_null(a: array<int>)\n  reads a\n{\n  a != null && sorted(a)\n}"
},
{
    "dafny": "method benda(L:array<int>, v0:int, v1:int) returns (x:int, y:int)\n\trequires L != null;\n\trequires forall i::0 <= i < L.Length ==> 0 <= L[i] < L.Length; \n\trequires forall i,j::0 <= i < j < L.Length ==> L[i] != L[j]; \n\trequires v0 !in L[..] && v1 !in L[..] && v0 != v1;\n\tmodifies L; \n\tensures forall j::0 <= j < L.Length ==> L[j] == j; \n\tensures x == v0 && y == v1; \n{\n\tvar i;\n\ti,x,y := 0,v0,v1;\n\twhile (i < L.Length)\n\t\tinvariant 0 <= i <= L.Length;\n\t\tinvariant forall j::i <= j < L.Length ==> i <= L[j] < L.Length; \n\t\tinvariant forall j,k::i <= j < k < L.Length ==> L[j] != L[k]; \n\t\tinvariant forall j::0 <= j < i ==> L[j] == j; \n\t\tinvariant {x,y} == {v0,v1}; \n\t{\n\t\tif (L[i] != i) {    \n\t\t\tx,L[i] := L[i],x;\n\t\t\tx := cycle(L,i,x,(set z | i < z < L.Length && L[z] != z));\n\t\t\t\ty,L[x] := L[x],y;\n\t\t\t\tx,L[x] := L[x],x;\n\t\t\t\ty,L[i] := L[i],y;      \n\t\t}\n\t\ti := i+1;\n\t}\n\tif (x != v0) {\n\t\tx,y := y,x;\n\t} \n}\nmethod cycle(L:array<int>, i:int, a:int, s:set<int>) returns (x:int)\n\trequires L!=null;\n\trequires 0 <= i < a < L.Length; \n\trequires forall j::i < j < L.Length ==> i <= L[j] < L.Length; \n\trequires forall j::i < j < L.Length ==> L[j] != a; \n\trequires forall j,k::i < j < k < L.Length ==> L[j] != L[k]; \n\trequires s == (set z | i < z < L.Length && L[z] != z); \n\tmodifies L;\n\tdecreases s;\n\tensures forall j::0 <= j <= i ==> L[j] == old(L[j]); \n\tensures forall j::i < j < L.Length ==> i <= L[j] < L.Length; \n\tensures forall j::i < j < L.Length ==> L[j] != x; \n\tensures forall j,k::i < j < k < L.Length ==> L[j] != L[k]; \n\tensures i <= x < L.Length; \n\tensures L[x] == i;\n{\n\tx := a;\n\tif (L[x] != i) {\n\t\tx,L[x] := L[x],x;\n\t\tx:=cycle(L,i,x,s-{a});\n\t}\n}\nmethod Main(){\n\tvar a:= new int[5];\n\ta[0],a[1],a[2],a[3],a[4]:= 3,2,1,4,0;\n\tvar x,y:= benda(a, a.Length, a.Length + 1);\n\tprint a[..],\" \",x,\" \",y,\"\\n\";\n}"
},
{
    "dafny": "method Triple(x: int) returns (r: int)\n    ensures r >= 3*x\n{\n    if 0 <= x {\n        var y := Double(x);\n        r := x + y;\n    } else {\n        var y := Double(-x);\n        r := x + y;\n    }\n}\nmethod Double(x: int) returns (r: int)\n    requires 0 <= x\n    ensures r >= 2*x\n{\n    r := x + x;\n}\nmethod SumMax(x: int, y: int) returns (s: int, m: int) \n    ensures s == x + y\n    ensures x <= m && y <= m\n    ensures m == x || m == y\n{   \n    s := x + y;\n    if x < y {\n        m := y;\n    }else {\n        m := x;\n    }\n}"
},
{
    "dafny": "predicate sorted_between(A:array<int>, from:int, to:int)\n    reads A\n{\n    forall i, j :: 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]\n}\npredicate sorted(A:array<int>)\n    reads A\n{\n    sorted_between(A, 0, A.Length-1)\n}\nmethod InsertionSort(A:array<int>)\n    modifies A\n    requires A.Length >= 1\n    ensures multiset(A[..]) == multiset(old(A[..]))\n    ensures sorted(A)\n{\n    var N := A.Length;\n    var i := 1;\n    while i < N\n        invariant 1 <= i <= N\n        invariant multiset(A[..]) == multiset(old(A[..]))\n        invariant sorted_between(A, 0, i-1)\n        decreases N-i\n    {\n        print A[..], \"\\n\";\n        var j := i;\n        while j > 0 && A[j-1] > A[j] \n            invariant 1 <= i <= N-1\n            invariant 0 <= j <= i\n            invariant multiset(A[..]) == multiset(old(A[..]))\n            invariant forall m, n :: 0 <= m < n < i+1 && n != j ==> A[m] <= A[n]\n            decreases j\n        {\n            A[j], A[j-1] := A[j-1], A[j];\n            j := j-1;\n            print A[..], \"\\n\";\n        }\n        i := i+1;\n        print \"\\n\";\n    }\n}\nmethod Main() {\n    var A := new int[10];\n    A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9] := 2, 4, 6, 15, 3, 19, 17, 16, 18, 1;\n    InsertionSort(A);\n    print A[..];\n}"
},
{
    "dafny": "method Main()\n{\n  var z := OutParametersInLetBodies();\n  DoSomeFloors();\n}\nmethod OutParametersInLetBodies() returns (t: int)\n{\n  t := 25;\n  var z := var y := 30; F(t, y);\n  assert z == 55;\n  print z, \"\\n\";\n}\nfunction F(x: int, y: int): int { x + y }\nmethod DoSomeFloors()\n{\n  P(-3.0, -3);\n  P(-2.8, -3);\n  P(-2.2, -3);\n  P(-0.1, -1);\n  P(0.0, 0);\n  P(0.1, 0);\n  P(2.2, 2);\n  P(2.8, 2);\n  P(3.0, 3);\n}\nmethod P(r: real, y: int)\n  requires r.Floor == y\n{\n  var x := r.Floor;\n  print \"Trunc( \", r, \" ) = \", x, \" (expected \", y, \")\\n\";\n}"
},
{
    "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    calc {\n      x;\n    <=  { assert x <= 0; }\n      0;\n    <  \n      1;\n    ==  \n      More(x);\n    }\n  } else {\n    calc {\n      x < More(x);\n    <==  \n      x + 1 < More(x);\n    ==  \n      x + 1 < More(x - 2) + 3;\n    ==  \n      x - 2 < More(x - 2);\n    <==  { Increasing(x - 2); }\n      true;\n    }\n  }\n}"
},
{
    "dafny": "method below_zero(operations: seq<int>) returns (s:array<int>, result:bool)\n{\n  result := false;\n  s := new int[|operations| + 1];\n  var i := 0;\n  s[i] := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant s[0]==0\n    invariant s.Length == |operations| + 1\n    invariant forall x :: 0 <= x < i-1 ==> s[x+1]==s[x]+operations[x]\n  {\n    if i>0{\n        s[i] := s[i - 1] + operations[i - 1];\n    }\n    i := i + 1;\n  }\n  i:=0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> s[x] >= 0\n  {\n    if s[i] < 0 {\n      result := true;\n      return;\n    }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method reverse<T>(input: seq<T>) returns (result: seq<T>)\n  requires |input| > 0\n  ensures |input| == |result| \n  ensures forall x | 0 <= x < |input| :: input[x] == result[(|result| - 1 - x)] \n  {\n  var final : seq<T> := [];\n  var i := |input| - 1;\n  while i >= 0\n    invariant -1 <= i < |input|\n    invariant |input| - 1 == |final| + i\n    invariant forall x | 0 <= x < |input| - 1 - i :: input[(|input| - 1 - x)] == final[x]\n    {\n    final := final + [input[i]];\n    i := i - 1;\n  }\n  return final;\n}"
},
{
    "dafny": "method Test()\n{\n    var a := new int[][2, 8, 6, 5, 2, 2, 7, 4, 1];\n    assert a[..] == [2, 8, 6, 5, 2, 2, 7, 4, 1];\n    Replace(a, 2, 7);\n    assert a[..] == [7, 8, 6, 5, 7, 7, 7, 4, 1];\n}\nmethod Replace(a: array<int>, oldval: int, newval: int)\n    modifies a;\n    ensures  forall i | 0 <= i < a.Length :: old(a[i]) == oldval ==> a[i] == newval;\n    ensures  forall i | 0 <= i < a.Length :: old(a[i]) != oldval ==> a[i] == old(a[i]);\n{\n    var i := 0;\n    while i < a.Length\n        decreases a.Length - i;\n        invariant 0 <= i <= a.Length;\n        invariant a[i..] == old(a[i..]);\n        invariant forall j | 0 <= j < i :: old(a[j]) == oldval ==> a[j] == newval;\n        invariant forall j | 0 <= j < i :: old(a[j]) != oldval ==> a[j] == old(a[j]);\n    {\n        if a[i] == oldval {\n            a[i] := newval;\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "ghost function upCast(o: object): object {o}\ntrait Universe {\n  ghost var content: set<Object>\n  ghost predicate i0() reads this, content {\n    forall o: Object | o in content :: o.universe == this && upCast(o) != this\n  }\n  ghost predicate i() reads * {\n    i0() && forall o: Object | o in content :: o.i()\n  }\n  twostate predicate i2() reads * {\n    forall o: Object | o in old(content) :: o in content && o.i2()\n  }\n  twostate predicate legal0() reads * {\n    forall o: Object | o in old(content) :: unchanged(o) || (o.i2() && o.i())\n  }\n  twostate predicate legal1() reads * {\n    forall o: Object | o in content && o !in old(content) :: o.i()\n  }\n  twostate predicate legal() reads * {\n    old(i()) && i0() && old(content) <= content && legal0() && legal1()\n  }\n  twostate lemma lci()\n    requires legal()\n    ensures i() && i2()\n  {\n    forall o: Object | o in old(content) && o.admPre() ensures o.i2() && o.i() { o.adm(); }\n  }\n}\ntrait Object {\n  ghost const universe: Universe\n  ghost predicate i0() reads * { this in universe.content && universe.i0() }\n  ghost method join()\n    requires universe.i0() && upCast(this) != universe\n    modifies universe \n    ensures i0() && universe.content == old(universe.content) + { this }\n  {\n    universe.content := universe.content + { this }; \n  }\n  twostate predicate admPre() reads * { i0() && old(i0() && universe.i()) && unchanged(this) && universe.legal() }\n  ghost predicate gi() reads * { i0() && universe.i() }\n  twostate predicate gi2() requires old(gi()) reads * { i0() && universe.i2() }\n  ghost predicate i() reads * \n  twostate predicate i2() reads *\n  twostate lemma adm() requires admPre() ensures i2() && i()\n}\nclass ArcAtomicIsize extends Object {\n  var data: int\n  ghost predicate i() reads * {\n    && i0()\n  }\n  twostate predicate i2() reads * {\n    && old(data) <= data\n  }\n  twostate lemma adm() requires admPre() {}\n  constructor (ghost universe: Universe, initial_data: int)\n    requires universe.i()\n    modifies universe\n    ensures universe.i()\n  {\n    this.universe := universe;\n    data := initial_data;\n    new;\n    join();\n    universe.lci();\n  }\n}\nclass WorkerMethod extends Object {\n  var next_stmt: int \n  var counter: ArcAtomicIsize\n  var initial_value: int\n  var final_value: int\n  ghost predicate i() reads * {\n    && i0()\n    && 1 <= next_stmt <= 5\n    && universe == counter.universe\n    && counter.i()\n    && (next_stmt > 1 ==> initial_value <= counter.data)\n    && (next_stmt > 2 ==> initial_value + 1 <= counter.data)\n    && (next_stmt > 3 ==> initial_value + 1 <= final_value <= counter.data)\n  }\n  twostate predicate i2() reads * {\n    && old(next_stmt) <= next_stmt\n    && counter == old(counter)\n    && counter.i2()\n  }\n  twostate lemma adm() requires admPre() ensures i2() && i() {}\n  constructor (ghost universe: Universe, counter: ArcAtomicIsize)\n    requires universe.i() && universe == counter.universe && counter.i()\n    modifies universe\n    ensures universe.i()\n  {   \n    this.universe := universe;\n    this.next_stmt := 1;\n    this.counter := counter;\n    new;\n    join();\n    universe.lci();\n  }\n  method Statement1()\n    requires gi() && next_stmt == 1\n    modifies this\n    ensures gi2()\n  {\n    initial_value := counter.data;\n    next_stmt := next_stmt + 1;\n    universe.lci();\n  }\n  method Statement2()\n    requires gi() && next_stmt == 2\n    modifies this, counter\n    ensures gi2()\n  {\n    counter.data := counter.data + 1;\n    universe.lci();\n  }\n  method Statement3()\n    requires gi() && next_stmt == 3\n    modifies this\n    ensures gi2()\n  {\n    final_value := counter.data;\n    next_stmt := next_stmt + 1;\n    universe.lci();\n  }\n  method Statement4()\n    requires gi() && next_stmt == 4\n    modifies this\n    ensures gi2()\n  {\n    assert initial_value + 1 <= final_value;\n    next_stmt := next_stmt + 1;\n    universe.lci();\n  }\n  method Statement5()\n    requires gi() && next_stmt == 5\n    modifies this\n    ensures gi2()\n  {\n    assert true;\n    universe.lci();\n  }\n}"
},
{
    "dafny": "predicate P(s: set)\n  requires s != {}\n{\n  var e :| e in s;\n  e == e\n}\nfunction F(s: set): int\n  requires s != {}\n{\n  var p :=\n    var e :| e in s;\n    e == e;\n  if p then 6 else 8\n}\nmethod Main() {\n  var s := {12, 20};\n  var b := P(s);\n  var x := F(s);\n  print s, \" \", b, \" \", x, \"\\n\";\n}"
},
{
    "dafny": "predicate summingPair(i: nat, j: nat, nums: seq<int>, target: int)\n    requires i < |nums|\n    requires j < |nums|\n{\n    i != j &&  nums[i] + nums[j] == target\n}\nmethod twoSum(nums: seq<int>, target: int) returns (pair: (nat, nat))\n    requires exists i:nat,j:nat :: i < j < |nums| && summingPair(i, j, nums, target) && forall l: nat, m: nat :: l <  m < |nums| && l != i && m != j ==> !summingPair(l, m, nums, target)\n    ensures 0 <= pair.0 < |nums| && 0 <= pair.1 < |nums| && summingPair(pair.0, pair.1, nums, target)\n{\n    pair := (0,0);\n    var i: nat := 0;\n    while i < |nums| \n        invariant i <= |nums|\n        invariant forall z: nat, j: nat :: 0 <= z < i  && z+1 <= j < |nums| ==> !summingPair(z, j, nums, target)\n    {\n        var k: nat := i + 1;\n        while k < |nums| \n            invariant i + 1 <= k <= |nums|\n            invariant forall q: nat :: i+1 <= q < k <= |nums| ==> !summingPair(i,q, nums, target) \n        {\n            if nums[i] + nums[k] == target {\n                pair := (i,k);\n                return pair;\n            }\n            k := k + 1;\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method Min(arr : array?< int >) returns (min : int )\nrequires arr != null && arr.Length > 0;\nensures forall j:int :: 0 <= j < arr.Length ==> arr[j] >= min ;\n{\n  var i := 1;\n  min := arr[0];\n  while (i < arr.Length)\n   invariant i <= arr.Length ;\n   invariant forall k :: 0 <= k < i ==> min <= arr[k];\n  {\n    if (arr[i] < min)\n       {min := arr[i];}\n       i := i +1;\n  }\n}"
},
{
    "dafny": "method div(n: nat, d: nat) returns (q: nat, r: nat)\n requires d > 0\n ensures 0 <= r < d && q * d + r == n\n{\n  q := 0;\n  r := n;  \n  while r >= d\n    decreases r\n    invariant q * d + r == n \n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\nmethod Main()\n{\n    var q, r := div(15, 6);\n    assert q == 2;\n    assert r == 3;\n    print \"q = \", q, \" r=\", \"\\n\";\n}"
},
{
    "dafny": "predicate Sorted(q: seq<int>)\n{\n\tforall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\npredicate HasAddends(q: seq<int>, x: int)\n{\n\texists i,j :: 0 <= i < j < |q| && q[i] + q[j] == x\n}\nmethod FindAddends(q: seq<int>, x: int) returns (i: nat, j: nat)\n\trequires Sorted(q)\n    requires HasAddends(q, x)\n\tensures  i < j < |q| && q[i]+q[j] == x\n{\n        ghost var i_result, j_result :|\n            0 <= i_result < j_result < |q|\n            && q[i_result] + q[j_result] == x;\n    i, j := FindAddends_WithLogicalConstants(q, x, i_result, j_result);\n}\nmethod {:verify true} FindAddends_WithLogicalConstants(q: seq<int>, x: int, ghost i_result : nat, ghost j_result:nat) returns(i: nat, j:nat)\nrequires Sorted(q)\nrequires HasAddends(q, x)\nrequires 0 <= i_result < j_result < |q|\nrequires q[i_result] + q[j_result] == x\nensures i < j < |q| && q[i] + q[j] == x\n{\n    i, j := Init(q, x, i_result, j_result);\n    Lemma_init(q, x, i, j, i_result, j_result);\n    i, j := Iterate(q, x, i, j, i_result, j_result);\n}\nmethod {:verify true} Init(q: seq<int>, x : int, ghost i_result:nat, ghost j_result:nat ) returns (i:nat, j:nat)\nrequires Sorted(q)\nrequires HasAddends(q, x)\nrequires 0 <= i_result < j_result < |q|\nrequires q[i_result] + q[j_result] == x\nensures  0 <= i <= j < |q|\nensures i <= i_result\nensures j_result <= j\nensures Sorted(q)\nensures  0 <= i_result < j_result < |q|\nensures q[i_result] + q[j_result] == x\n{     \n    i, j := 0, |q| - 1;\n}\nlemma Lemma_init(q: seq<int>, x : int, i : nat, j:nat, i_result:nat, j_result:nat )\nrequires  0 <= i <= j < |q|\nrequires i <= i_result\nrequires j_result <= j\nrequires Sorted(q)\nrequires 0 <= i_result < j_result < |q|\nrequires q[i_result] + q[j_result] == x\nensures Inv(q, x, i, j, i_result, j_result)\n{\n}\nmethod {:verify true} Iterate (q: seq<int>,x: int, i0:nat , j0 :nat, ghost i_result:nat, ghost j_result:nat ) returns (i:nat, j:nat)\nrequires Inv(q, x, i0, j0, i_result, j_result)\nensures Inv(q, x, i, j, i_result, j_result)\nensures q[i] + q[j] == x\n{\n    i, j := i0, j0;\n    while q[i] + q[j] != x\n        invariant Inv(q, x,i, j, i_result, j_result)\n        decreases j - i\n        {\n            i, j := LoopBody(q, x, i, j, i_result, j_result);\n        }\n}\nmethod {:verify true} LoopBody(q: seq<int>, x : int, i0 : nat, j0: nat, ghost i_result:nat, ghost j_result:nat) returns (i : nat, j:nat)\nrequires Inv(q, x, i0, j0, i_result, j_result)\nrequires q[i0] + q[j0] != x\nensures Inv(q, x, i, j, i_result, j_result)\nensures (j0 - i0) > (j - i)\n{\n    if (q[i0] + q[j0] < x)\n    {\n        i, j := IncI(q, x, i0, j0, i_result, j_result);\n    }\n    else \n    {\n        i, j := DecJ(q, x, i0, j0, i_result, j_result);\n    }\n}\nmethod {:verify true} IncI(q: seq<int>, x : int, i0 : nat, j0: nat, ghost i_result:nat, ghost j_result:nat) returns (i : nat, j:nat)\nrequires Inv(q, x, i0, j0, i_result, j_result)\nrequires q[i0] + q[j0] < x\nensures Inv(q,x, i, j, i_result, j_result)\nensures (j0 - i0) > (j - i)\n{\n    IncI_Lemma(q, x, i0, j0, i_result, j_result);\n    i, j := i0 + 1, j0;\n}\nmethod {:verify true} DecJ(q: seq<int>, x : int, i0 : nat, j0: nat, ghost i_result:nat, ghost j_result:nat) returns (i : nat, j:nat)\nrequires Inv(q, x, i0, j0, i_result, j_result)\nrequires q[i0] + q[j0] > x\nensures Inv(q, x, i, j, i_result, j_result)\nensures (j0 - i0) > (j - i)\n{\n    DecJ_Lemma(q, x, i0, j0, i_result, j_result);\n    i, j := i0, j0 - 1;\n}\nlemma DecJ_Lemma(q: seq<int>, x : int, i0 : nat, j0: nat, i_result:nat, j_result:nat)\nrequires Inv(q, x, i0, j0, i_result, j_result)\nrequires q[i0] + q[j0] > x\nensures j0 - 1 >= j_result\n{\n}\nlemma IncI_Lemma (q: seq<int>, x : int, i0 : nat, j0: nat, i_result:nat, j_result:nat)\nrequires Inv(q, x, i0, j0, i_result, j_result)\nrequires q[i0] + q[j0] < x\nensures i0 + 1 <= i_result\n{\n}\npredicate Inv(q:seq<int>, x:int, i:nat, j:nat, i_result:nat, j_result:nat)\n{\n    Sorted(q) \n    && 0 <= i_result < j_result < |q|\n    && q[i_result] + q[j_result] == x\n    && 0 <= i <= j < |q|\n    && i <= i_result\n    && j_result <= j\n}\nmethod Main()\n{\n\tvar q := [1,2,4,5,6,7,10,23];\n\tassert Sorted(q);\n\tassert HasAddends(q,10) by { assert q[2]+q[4] == 4+6 == 10; }\n\tvar i,j := FindAddends(q, 10);\n\tprint \"Searching for addends of 10 in q == [1,2,4,5,6,7,10,23]:\\n\";\n\tprint \"Found that q[\";\n\tprint i;\n\tprint \"] + q[\";\n\tprint j;\n\tprint \"] == \";\n\tprint q[i];\n\tprint \" + \";\n\tprint q[j];\n\tprint \" == 10\";\n\tassert i == 2 && j == 4;\n}"
},
{
    "dafny": "method Min(x: int, y: int) returns (m: int)\n    ensures m <= x && m <= y\n    ensures m == x || m == y\n{\n    if x <= y {\n        m := x;\n    } else {\n        m := y;\n    }\n}"
},
{
    "dafny": "type Process(==) = int  \ndatatype CState = Thinking | Hungry | Eating  \nclass TicketSystem\n{\n  var ticket: int  \n  var serving: int  \n  const P: set<Process>  \n  var cs: map<Process, CState>  \n  var t: map<Process, int>  \n  predicate Valid()\n    reads this  \n  {\n    && cs.Keys == t.Keys == P  \n    && serving <= ticket\n    && (forall p ::  \n      p in P && cs[p] != Thinking\n      ==> serving <= t[p] < ticket\n    )\n    && (forall p, q ::  \n      p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking\n      ==> t[p] != t[q]\n    )\n    && (forall p ::  \n      p in P && cs[p] == Eating\n      ==> t[p] == serving\n    )\n  }\n  constructor (processes: set<Process>)\n    ensures Valid()  \n    ensures P == processes  \n  {\n    P := processes;\n    ticket, serving := 0, 0;  \n    cs := map p | p in processes :: Thinking;  \n    t := map p | p in processes :: 0;\n  }\n  method Request(p: Process)\n    requires Valid() && p in P && cs[p] == Thinking  \n    modifies this  \n    ensures Valid()  \n  {\n    t, ticket := t[p := ticket], ticket + 1;  \n    cs := cs[p := Hungry];  \n  }\n  method Enter(p: Process)\n    requires Valid() && p in P && cs[p] == Hungry  \n    modifies this  \n    ensures Valid()  \n  {\n    if t[p] == serving  \n    {\n      cs := cs[p := Eating];  \n    }\n  }\n  method Leave(p: Process)\n    requires Valid() && p in P && cs[p] == Eating  \n    modifies this  \n    ensures Valid()  \n  {\n    serving := serving + 1;  \n    cs := cs[p := Thinking];  \n  }\n  lemma MutualExclusion(p: Process, q: Process)\n    requires Valid() && p in P && q in P\n    requires cs[p] == Eating && cs[q] == Eating\n    ensures p == q\n  {\n  }\n}\nmethod Run(processes: set<Process>)\n  requires processes != {}  \n  decreases *  \n{\n  var ts := new TicketSystem(processes);\n  var schedule := [];  \n  var trace := [(ts.ticket, ts.serving, ts.cs, ts.t)];  \n  while true\n    invariant ts.Valid()\n    decreases *  \n  {\n    var p :| p in ts.P;  \n    match ts.cs[p] {\n      case Thinking => ts.Request(p);\n      case Hungry => ts.Enter(p);\n      case Eating => ts.Leave(p);\n    }\n    schedule := schedule + [p];\n    trace:=trace + [(ts.ticket, ts.serving, ts.cs, ts.t)];\n  }\n}\nmethod RunFromSchedule(processes: set<Process>, schedule: nat -> Process)\n  requires processes != {}\n  requires forall n :: schedule(n) in processes\n  decreases *\n{\n  var ts := new TicketSystem(processes);\n  var n := 0;\n  while true\n    invariant ts.Valid()\n    decreases *  \n  {\n    var p := schedule(n);\n    match ts.cs[p] {\n      case Thinking => ts.Request(p);\n      case Hungry => ts.Enter(p);\n      case Eating => ts.Leave(p);\n    }\n    n := n + 1;\n  }\n}"
},
{
    "dafny": "function power(b: nat, e: nat): nat \ndecreases e\n{\n    if e == 0 then 1 else b * power(b,e-1)\n}\nmethod expoBySquare(x:nat,n:nat) returns (p:nat)\nrequires n>=0\nensures p == power(x,n)\ndecreases *\n{\n    var N,q := n,x;\n    p := 1;\n    while N>=0\n    decreases *\n    {\n        p := if N%2 == 0 then p else p*q;\n        q := q * q;\n        N := if N%2 == 0 then N/2 else (N-1)/2;\n    }\n}"
},
{
    "dafny": "class MyClass {\n  var a: int\n  const b: int\n  const c := 17\n  static const d: int\n  static const e := 18\n  constructor (x: int) {\n    a := 100 + x;\n    b := 200 + x;\n  }\n  function F(): int { 8 }\n  static function G(): int { 9 }\n  method M() returns (r: int) { r := 69; }\n  static method N() returns (r: int) { r := 70; }\n}\ntrait MyTrait {\n  var a: int\n  const b: int\n  const c := 17\n  static const d: int\n  static const e := 18\n  function F(): int { 8 }\n  static function G(): int { 9 }\n  method M() returns (r: int) { r := 69; }\n  static method N() returns (r: int) { r := 70; }\n}\nclass MyTraitInstance extends MyTrait {\n  constructor (x: int) {\n    a := 101 + x;\n    b := 201 + x;\n  }\n  static method SetTraitField(m : MyTrait) modifies m { m.a := N(); }\n}\nmethod CallEm(c: MyClass, t: MyTrait, i: MyTraitInstance)\n  modifies c, t, i\n{\n  print c.a, \" \", t.a, \" \", i.a, \" \";\n  c.a := c.a + 3;\n  t.a := t.a + 3;\n  i.a := i.a + 3;\n  print c.a, \" \", t.a, \" \", i.a, \"\\n\";\n  var u;\n  print c.b, \" \";\n  print c.c, \" \";\n  print c.d, \" \";\n  print c.e, \" \";\n  print c.F(), \" \";\n  print c.G(), \" \";\n  u := c.M();\n  print u, \" \";\n  u := c.N();\n  print u, \"\\n\";\n  print t.b, \" \";\n  print t.c, \" \";\n  print t.d, \" \";\n  print t.e, \" \";\n  print t.F(), \" \";\n  print t.G(), \" \";\n  u := t.M();\n  print u, \" \";\n  u := t.N();\n  print u, \"\\n\";\n  print i.b, \" \";\n  print i.c, \" \";\n  print i.d, \" \";\n  print i.e, \" \";\n  print i.F(), \" \";\n  print i.G(), \" \";\n  u := i.M();\n  print u, \" \";\n  u := i.N();\n  print u, \"\\n\";\n  print MyClass.d, \" \";\n  print MyClass.e, \" \";\n  print MyClass.G(), \" \";\n  u := MyClass.N();\n  print u, \"\\n\";\n  print MyTrait.d, \" \";\n  print MyTrait.e, \" \";\n  print MyTrait.G(), \" \";\n  u := MyTrait.N();\n  print u, \"\\n\";\n  print MyTraitInstance.d, \" \";\n  print MyTraitInstance.e, \" \";\n  print MyTraitInstance.G(), \" \";\n  u := MyTraitInstance.N();\n  print u, \"\\n\";\n  MyTraitInstance.SetTraitField(i);\n  print i.a, \"\\n\";\n}\nmethod Main() {\n  var c := new MyClass(3);\n  var t := new MyTraitInstance(2);\n  var i := new MyTraitInstance(2);\n  print t == t, \" \", i == i, \" \", i == t, \"\\n\";\n  var t2 : MyTrait := t;\n  var t3 : MyTrait;\n  t3 := t;\n  CallEm(c, t, i);\n  DependentStaticConsts.Test();\n  NewtypeWithMethods.Test();\n  TestGhostables(70);\n  TestInitializationMethods();\n}\nmodule Module1 {\n  trait {:termination false} TraitInModule { }\n}\nmodule Module2 {\n  class ClassExtendingTraitInOtherModule extends Module1.TraitInModule { }\n}\nmodule DependentStaticConsts {\n  newtype ID = x: int | 0 <= x < 100\n  const A: ID := 0\n  const B: ID := 1\n  const C: ID := 2\n  const Suite := map[A := \"hello\", B := \"hi\", C := \"bye\", D := \"later\"]\n  const D: ID := 3\n  method Test()\n  {\n    print Suite[B], \" \", Suite[D], \"\\n\";  \n  }\n}\nnewtype NewtypeWithMethods = x | 0 <= x < 42 {\n  function double() : int {\n    this as int * 2\n  }\n  method divide(d : NewtypeWithMethods) returns (q : int, r : int) requires d != 0 {\n    q := (this / d) as int;\n    r := (this % d) as int;\n  }\n  static method Test() {\n    var a : NewtypeWithMethods := 21;\n    var b : NewtypeWithMethods;\n    b := 4;\n    var q : int;\n    var r : int;\n    q, r := a.divide(b);\n    print a, \" \", b, \" \", a.double(), \" \", q, \" \", r, \"\\n\";\n  }\n}\nclass Ghostable {\n  var data: int\n  constructor A(x: int) {\n    data := x;\n  }\n  ghost constructor (x: int) {\n    data := x;\n  }\n}\nclass ConstructorLessGhostable {\n  var data: int\n}\nghost function GInit(index: nat): int {\n  index - 7\n}\nmethod TestGhostables(ghost n: nat) {\n  print \"TestGhostables\\n\";\n  var a0 := new Ghostable.A(10);\n  var a1 := new Ghostable(n); \n  var b0 := new ConstructorLessGhostable;\n  ghost var b1 := new ConstructorLessGhostable; \n  var c0 := new int[10];\n  ghost var c1 := new int[n]; \n  c0 := new int[10](x => x + 2);\n  c1 := new int[n](x => x + n);\n  c1 := new int[100](GInit);\n}\nclass HasInitializationMethod {\n  var data: int\n  method Init(x: int)\n    requires x == 15\n    modifies this\n    ensures data == x + 1\n  {\n    print \"Init called with x=\", x, \"\\n\";\n    data := x + 1;\n  }\n}\nmethod TestInitializationMethods() {\n  var c := new HasInitializationMethod;\n  c.data := 15;\n  print c.data, \"\\n\"; \n  c := new HasInitializationMethod.Init(c.data); \n  print c.data, \"\\n\"; \n}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> a[j] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}"
},
{
    "dafny": "method add_by_inc(n: nat, m: nat) returns (r: nat)\n  ensures r == m + n;\n{\n  r := n;\n  var i := 0;\n  while i < m\n    invariant i <= m;\n    invariant r == n + i;\n    decreases m - i;\n  {\n    i := i + 1;\n    r := r + 1;\n  }\n  return r;\n}\nmethod add_by_inc_Vc(n: nat, m: nat) returns (r: nat)\n{\n  assume(true);\n  r := n;\n  var i := 0;\n  assert(i <= m);\n  assert(r == n + i);\n  i, r := *, *;\n  assume(i <= m);\n  assume(r == n + i);\n  if (i < m)\n  {\n    ghost var rank0 := (m - i);\n    i := i + 1;\n    r := r + 1;\n    assert(i <= m);\n    assert(r == n + i);\n    ghost var rank := (m - i);\n    assert(rank < rank0);\n    assert(rank >= 0);\n    assume(false);\n  }\n  assert r == m + n;\n}\nmethod Product(m: nat, n: nat) returns (res: nat)\n  ensures res == m*n;\n{\n  var m1: nat := m;\n  res := 0;\n  while (m1!=0)\n    invariant m1 >= 0;\n    invariant res == (m - m1) * n;\n    decreases m1;\n  {\n    var n1: nat := n;\n    while (n1 != 0)\n      invariant n1 >= 0;\n      invariant res == (m - m1) * n + (n-n1);\n      decreases n1;\n    {\n      res := res+1;\n      n1 := n1-1;\n    }\n    m1 := m1-1;\n  }\n}\nmethod Product_Vc(m: nat, n: nat) returns (res: nat)\n{\n  assume(true);\n  var m1: nat := m;\n  res := 0;\n  assert(m1 >= 0 && res == (m - m1) * n);\n  res, m1 := *, *;\n  assume(m1 >= 0 && res == (m - m1) * n);\n  if (m1 != 0)\n  {\n    var rankM0 := m1;\n    var n1: nat := n;\n    assert(n1 >= 0 && res == (m - m1) * n + (n - n1));\n    res, n1 := *, *;\n    assume(n1 >= 0 && res == (m - m1) * n + (n - n1));\n    if (n1 != 0)\n    {\n      ghost var rankN0 := n1;\n      res := res+1;\n      n1 := n1-1;\n      assert(n1 >= 0 && res == (m - m1) * n + (n - n1));\n      ghost var rankN := n1;\n      assert(rankN < rankN0 && rankN >= 0);\n      assume(false);\n    }\n    m1 := m1-1;\n    assert(m1 >= 0 && res == (m - m1) * n);\n    var rankM := m1;\n    assert(rankM < rankM0 && rankM >= 0);\n    assume(false);\n  }\n  assert(res == m*n);\n}"
},
{
    "dafny": "predicate member(s: seq<int>, n: int) {\n\texists i :: 0 <= i <|s| && s[i] == n\n}\nmethod linsearch(s: seq<int>, n: int) returns (found:bool, ind:int)\n\tensures !found ==> !member(s, n)\t\t\t\t\t\t\t\t\t\t\n\tensures  found ==>  member(s, n)\n    ensures ind <= |s|\t\t\t\t\t\t\t\t\t\t\n{\n\tind := 0;\n\tfound := false;\n\twhile(ind < |s| && !found)\n\t\tdecreases |s|-ind + (if found then 0 else 1)\t\t\t\t\t\t\t\n\t\tinvariant 0 <= ind <= |s| \n\t\tinvariant !member(s[..ind],n)\t\t\t\t\t\t\t\t\t\t\n\t\tinvariant found ==> member(s,n)\t\t\t\t\t\t\t\t\t\n\t{\n\t\tif (s[ind] == n) { \n\t\t\tfound := true;\n\t\t} else {\n\t\t\tind := ind + 1;\n\t\t}\n\t}\n}\nmethod linsearchInd(s: seq<int>, n:int) returns (found:bool, ind:int)\n\tensures !found ==> !member(s, n)\n\tensures found ==> member(s, n)\n{\n\tind := 0;\n\tfound := false;\n\twhile(ind < |s| && !found)\n\t\tdecreases |s|-ind + (if found then 0 else 1);\t\t\t\t\t\t\n\t\tinvariant 0 <= ind <= |s|\n\t\tinvariant !member(s[..ind],n)\n\t\tinvariant found ==> member(s,n)\n\t{\n\t\tif (s[ind] == n) { \n\t\t\tfound := true;\n\t\t} else {\n\t\t\tind := ind + 1;\n\t\t}\n\t}\n}"
},
{
    "dafny": "datatype Tree = Empty | Node(int,Tree,Tree)\nmethod Main() {\n\tvar tree := Node(5, Node(2, Empty, Empty), Node(8, Node(7, Empty, Empty), Node(8, Empty, Empty)));\n\tassert NumbersInTree(tree) == multiset([2,5,7,8,8]);\n\tassert NumbersInTree(tree)[2] == 1; \n\tassert NumbersInTree(tree)[5] == 1; \n\tassert NumbersInTree(tree)[7] == 1; \n\tassert NumbersInTree(tree)[8] == 2; \n\tassert NumbersInTree(tree)[9] == 0; \n\tassert BST(tree);\n\tvar count8 := CountOccurrences(tree, 8);\n\tprint \"The number of occurrences of 8 in the tree \";\n\tprint tree;\n\tprint \" is \";\n\tprint count8;\n\tassert count8 == 2;\n}\nfunction NumbersInTree(t: Tree): multiset<int>\ndecreases t\n{\n\tmatch t {\n\t\tcase Empty => multiset([])\n\t\tcase Node(n,l,r) => multiset([n])+NumbersInTree(l)+NumbersInTree(r)\n\t}\n}\npredicate BST(t: Tree)\ndecreases t\n{\n\tmatch t {\n\t\tcase Empty => true\n\t\tcase Node(n,l,r) =>\n\t\t\tBST(l) && BST(r) &&\n\t\t\t(forall x :: x in NumbersInTree(l) ==> x < n) &&\n\t\t\t(forall x :: x in NumbersInTree(r) ==> x >= n)\n\t}\n}\nmethod RecEffective(tree: Tree, key: int) returns (count: nat)\n\trequires BST(tree)\n\tdecreases tree\n\tensures count == NumbersInTree(tree)[key]\n  {\n  var leftAcc := 0;\n  var rightAcc := 0;\n\tmatch tree {\n\tcase Empty =>\n\t\tassert tree == Empty;\n\t\tassert 0 == NumbersInTree(tree)[key];\n\t\tcount := 0;\n\t\tassert count == NumbersInTree(tree)[key];\n\tcase Node(val,left,right) =>\n\t\tassert tree == Node(val,left,right);\n\t\tassert left < tree;\n\t\tassert right < tree;\n    if key < val{\n      leftAcc := RecEffective(left, key);\n    }else{\n\t\t\trightAcc:= RecEffective(right, key);\n    }\n\t\tassert (if val == key then 1 else 0) +  leftAcc + rightAcc == NumbersInTree(tree)[key];\n    count := (if val == key then 1 else 0) +  leftAcc + rightAcc;\n\t\tassert count == NumbersInTree(tree)[key];\n\t}\n\tassert count == NumbersInTree(tree)[key];\n}\nmethod CountOccurrences(t: Tree, key: int) returns (count: nat)\n\trequires BST(t)\n\tensures count == NumbersInTree(t)[key]\n  {\n\t\tcount := RecEffective(t, key);\n  }"
},
{
    "dafny": "function sum(a:seq<int>, i:int, j:int) : int \n\trequires 0 <= i <= j <=|a|\n{\n\tif i == j then 0\n\telse sum(a, i, j-1) + a[j-1]\n}\npredicate lowsum(a: seq<int>, k:int, s: int)\n\trequires 0 <= k <= |a|\n{\n\tforall i, j  :: 0 <= i < j <= k ==> s <= sum(a,i,j)\n}\npredicate lowsumend(a: seq<int>, k:int, t: int)\n\trequires 0 <= k <= |a|\n {\n\tforall i :: 0 <= i < k ==> t <= sum(a,i,k)\n}\npredicate issum(a: seq<int>, k:int, s:int)\n\trequires 0 <= k <= |a|\n{\n\texists i,j :: 0 <= i < j <= k && s == sum(a,i,j)\n}\npredicate issumend(a: seq<int>, k:int, t:int)\n\trequires 0 <= k <= |a|\n{\n\texists i:: 0 <= i < k && t == sum(a,i,k)\n}\nlemma issumendL(a: seq<int>, k:int, t:int)\n\trequires 0 < k < |a|\n\trequires issumend(a,k,t)\n\tensures issumend(a,k+1,t+a[k])\n{\n\tassert exists i :: 0 <= i < k && t == sum(a,i,k);\n\tassert exists i :: 0 <= i < k && t+a[k] == sum(a,i,k) + a[k];\n\tassert forall i :: 0 <= i < k ==> sum(a,i,k) + a[k] == sum(a,i,k+1);\n}\nmethod minsum(a: seq<int>) returns (ret:int)\n\trequires |a| > 0\n\tensures lowsum(a,|a|,ret)\n\tensures issum(a,|a|,ret)\t\t\t\t\n{\n\tvar k := 1;\n\tvar t := a[0];\n\tvar s := a[0];\n\tassert s == sum(a,0,1);\t\t\t\t\t\n\twhile (k != |a|)\n\t\tdecreases |a| - k\t\t\t\t\t\n\t\tinvariant 0 < k <= |a|\n\t\tinvariant lowsumend(a,k,t)\t\t\t\n\t\tinvariant lowsum(a,k,s)\t\t\t\t\n\t\tinvariant issumend(a,k,t)\t\t\t\n\t\tinvariant issum(a,k,s)\t\t\t\t\n\t{\n\t\tif (t + a[k] < a[k]) {\n\t\t\tassert issumend(a,k,t);\t\t\t\n\t\t\tissumendL(a,k,t);\t\t\t\t\n\t\t\tt := t + a[k];\n\t\t\tassert issumend(a,k+1,t);\t\t\n\t\t} else {\n\t\t\tt := a[k];\n\t\t\tassert t == sum(a,k, k+1);\t\t\n\t\t}\n\t\tif (t < s) {\n\t\t\ts := t;\n\t\t}\n\t\tk := k + 1;\n\t}\n\treturn s;\n}"
},
{
    "dafny": "method Swap(a: int, b: int) returns (x: int, y: int)\nensures x == b && y == a;\n{\n    x := b;\n    y := a;\n}\nmethod Warn()\n{\n    var x;\n    x := 1;\n    assert x < 10;\n    assert x < 100;\n}\nfunction fact(n : nat): nat\ndecreases n\n{\n    if n == 0 then 1 else n*fact(n-1)\n}\nmethod Factorial (n: nat) returns (p: nat)\nrequires n >= 0;\n{\n    var i: int;\n    i, p := 1, 1;\n    while (i <= n)\n    invariant i <= n + 1;\n    invariant p <= p * i;\n    decreases n + 1 - i;\n    {\n        p := p * i;\n        i := i + 1;\n    }\n}\nmethod something(){\n    var f : int; \n    f := Factorial(0);\n}"
},
{
    "dafny": "function Fib (n : int) : int\n{\n\tif (n < 2) then n\n\telse Fib(n-2) + Fib(n-1)\n}\nmethod Fibonacci (n : int) returns (f : int)\nrequires n >= 0\nensures f == Fib(n)  \n{\n\tvar aux := 0;\n\tif(n<2){f:=n;}\n\telse{\n\t\tvar i := 0;\n\t\tf := 1;\n\t\twhile(i <= n-2)\n\t\tinvariant 0 <= i <= n-1\n\t\tinvariant f == Fib(i+1)\n\t\tinvariant aux == Fib(i)\n\t\t{\n\t\t\tf := f + aux;\n\t\t\taux := f - aux;\n\t\t\ti := i + 1;\n\t\t}\n\t}\n}"
},
{
    "dafny": "datatype list<A> = Nil | Cons(head: A, tail: list<A>)\ndatatype d = A | B(ds: list<d>)\ndatatype d2 = A2 | B2(ds: seq<d2>)\ndatatype d3 = A3 | B3(ds: set<d3>)\nghost function d_size(x: d): int\n{\n  match x\n  case A => 1\n  case B(ds) => 1+ds_size(ds)\n}\nghost function ds_size(xs: list<d>): int\n{\n  match xs\n  case Nil => 1\n  case Cons(head, tail) => d_size(head)+ds_size(tail)\n}\nghost function d2_size(x: d2): int\n{\n  match x\n  case A2 => 1\n  case B2(ds) => 1+ds2_size(ds)\n}\nghost function ds2_size(xs: seq<d2>): int\n{\n  if (|xs|==0) then 1 else 1+d2_size(xs[0])+ds2_size(xs[1..])\n}\nghost function seq_dec_drop(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  1+seq_dec_drop(xs[1..])\n}\nghost function seq_dec_take(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  1+seq_dec_take(xs[..|xs|-1])\n}\nghost function seq_dec(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 < i <= |xs|;\n  i+seq_dec(xs[i..])\n}\nghost function seq_dec'(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 <= i < |xs|;\n  i+seq_dec'(xs[..i])\n}\nghost function seq_dec''(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 <= i < |xs|;\n  assert xs[0..i] == xs[..i];\n  i+seq_dec''(xs[0..i])\n}\nghost function seq_dec'''(xs: seq<int>): int\n  decreases |xs|\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 <= i < |xs|;\n  i+seq_dec'''(xs[..i]+xs[i+1..])\n}\nghost function seq_dec''''(xs: seq<int>): int\n{\n  if (|xs|==0) then 0 else\n  var i :| 0 <= i < |xs|;\n  i+seq_dec''''(xs[..i]+xs[i+1..])\n}"
},
{
    "dafny": "predicate sorted(a: array?<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array?<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}"
},
{
    "dafny": "method mfirstCero(v:array<int>) returns (i:int)\nensures 0 <=i<=v.Length\nensures forall j:: 0<=j<i ==> v[j]!=0 \nensures i!=v.Length ==> v[i]==0  \n{\n i:=0;\n while (i<v.Length && v[i]!=0)\n    invariant 0<=i<=v.Length\n    invariant forall j:: 0<=j<i ==> v[j]!=0 \n   decreases v.Length -i\n  {i:=i+1;}\n}"
},
{
    "dafny": "type T = int \nmethod partition(a: array<T>) returns(pivotPos: int) \n    modifies a\n    requires a.Length > 0\n    ensures 0 <= pivotPos < a.Length \n    ensures forall k :: 0 <= k < pivotPos ==> if k < pivotPos then a[k] < a[pivotPos] else a[k] >= a[pivotPos]\n{\n    pivotPos := a.Length - 1; \n    var i := 0;  \n    var j := 0;  \n    while  j < a.Length-1\n        decreases a.Length-1-j \n        invariant 0 <= i <= j <= a.Length-1\n        invariant forall x :: 0 <= x < i ==> a[x] < a[pivotPos]\n        invariant forall x :: i <= x < j ==> a[x] >= a[pivotPos]\n    {\n      if a[j] < a[pivotPos] {\n        a[i], a[j] := a[j], a[i];\n        i := i + 1;\n      }\n      j := j+1;\n    }\n    a[a.Length-1], a[i] := a[i], a[a.Length-1];\n    pivotPos := i;  \n}"
},
{
    "dafny": "datatype Block<Hash,Transaction,VProof> =\n  Block(prevBlockHash:Hash, txs:seq<Transaction>, proof:VProof)\nfunction GenesisBlock() : Block<int,int,int> {\n  Block(0, [], 0)\n}\nmethod IsGenesisBlock(b : Block<int,int,int>) returns (eq : bool)\n  ensures eq <==> b == GenesisBlock()\n{\n  var gb := GenesisBlock();\n  eq := b == gb;\n}\nmethod Main() {\n  var b := GenesisBlock();\n  var eq := IsGenesisBlock(b);\n  assert eq;\n  print eq, \"\\n\";\n  TestEq();\n}\nnewtype nt = int\nnewtype ntNative = x | -100 <= x < 100\nclass MyClass { var u: int }\ndatatype X = X(bool, char, int, real, nt, ntNative, bv8, bv167, ORDINAL, MyClass)\npredicate TestAny<G(==)>(a: G, b: G)\n  requires a == b\n{\n  a == b\n}\nmethod TestEq()\n{\n  print true == true, \" \", TestAny(true, true), \"\\n\";\n  print 'e' == 'e', \" \", TestAny('e', 'e'), \"\\n\";\n  print 12 == 12, \" \", TestAny(12, 12), \"\\n\";\n  print 37.5 == 37.5, \" \", TestAny(37.5, 37.5), \"\\n\";\n  var m0: nt, m1: nt := 12, 12;\n  print m0 == m1, \" \", TestAny(m0, m1), \"\\n\";\n  var n0: ntNative, n1: ntNative := 12, 12;\n  print n0 == n1, \" \", TestAny(n0, n1), \"\\n\";\n  var b0: bv8, b1: bv8 := 12, 12;\n  print b0 == b1, \" \", TestAny(b0, b1), \"\\n\";\n  var c0: bv167, c1: bv167 := 12, 12;\n  print c0 == c1, \" \", TestAny(c0, c1), \"\\n\";\n  var o0: ORDINAL, o1: ORDINAL := 12, 12;\n  print o0 == o1, \"\\n\";\n  var obj := new MyClass;\n  print obj == obj, \" \", TestAny(obj, obj), \"\\n\";\n  var x0 := X(true, 'e', 12, 37.5, 12, 12, 12, 12, 12, obj);\n  var x1 := X(true, 'e', 12, 37.5, 12, 12, 12, 12, 12, obj);\n  print [x0] == [x1], \" \", TestAny([x0], [x1]), \"\\n\";\n  print {x0} == {x1}, \" \", TestAny({x0}, {x1}), \"\\n\";\n  print multiset{x0} == multiset{x1}, \" \", TestAny(multiset{x0}, multiset{x1}), \"\\n\";\n  print map[x0 := n0] == map[x0 := n1], \" \", TestAny(map[x0 := n0], map[x0 := n1]), \"\\n\";\n}"
},
{
    "dafny": "module basic {\n    predicate predMaxEx(a:int,b:int)\n    {\n        (a >= b && b > 100)\n    }\n}\nmodule maxExample{\n    predicate maxSpec(a:int,b:int,c:int)\n    {\n        c >= a\n        && c >= b\n    }\n    lemma max(a:int,b:int) returns (c:int)\n        ensures maxSpec(a,b,c)\n    {\n        if(a > b){\n            c := a + 100;\n        }else{\n            c := b + 100;\n        }\n    }\n}"
},
{
    "dafny": "method ToArray<A>(s: seq<A>) returns (a: array<A>)\n    ensures a[..] == s\n{\n    a := new A[|s|](i requires 0 <= i < |s| => s[i]);\n}\nclass FileIO\n{\n    static method ReadFileOfNumbers(name: string)\n        returns (numbers: array<nat>)\n    {\n        var nameChars := ToArray(name);\n        numbers := FileIO.ReadFileOfNumbersNative(nameChars);\n    }\n    static method{:axiom} ReadFileOfNumbersNative(name: array<char>)\n        returns (numbers: array<nat>)\n        ensures fresh(numbers)\n}"
},
{
    "dafny": "predicate maxSpec_incorrect(a:int,b:int,c:int) \n    {\n        && (a > b ==> c >= a)\n        && (b > a ==> c >= b)\n    }\n    lemma maxT_incorrect(a:int,b:int) returns (c:int)\n        ensures maxSpec_incorrect(a,b,c)\n    {\n        if(a > b){\n            c := a;\n        }else if(b > a){\n            c := b;\n        }else{\n            c := a + 100;\n        }\n    }\npredicate maxSpec_mutat14(a:int,b:int,c:int)\n{\n    (a > b ==> c == a) && (b > a || c != b)\n}\nlemma instance(a:int,b:int,c:int)\n    requires (a==b==c) || (b < a < c)\n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat14(a,b,c)\n{   \n}\nlemma instance_test1(a:int,b:int,c:int)\n    requires a == b == c == 1 \n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat14(a,b,c)\n{}\nlemma instance_test2(a:int,b:int,c:int)\n    requires b == 1 && a == 2 && c == 3 \n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat14(a,b,c)\n{}\nlemma correct_test1(a:int,b:int,c:int)\n    requires b == 1 && a == 3 && c == 0\n    ensures !maxSpec_mutat14(a,b,c)\n{}\nlemma correct_test2(a:int,b:int,c:int)\n    requires b == 1 && a == 3 && c == 2\n    ensures !maxSpec_mutat14(a,b,c)\n{}\nlemma correct_test3(a:int,b:int,c:int) \n    requires b == 1 && a == 3 && c == 4\n    ensures !maxSpec_mutat14(a,b,c)\n    ensures maxSpec_incorrect(a,b,c)\n{}\nlemma correct_test4(a:int,b:int,c:int)\n    requires b == c == 1 && a == 2\n    ensures !maxSpec_mutat14(a,b,c)\n{}"
},
{
    "dafny": "method Sum() returns (s:int, n:int)\n{\n  n, s := 0, 0;\n  while n != 33\n    invariant s == n * (n + 1) / 2\n  {\n    n := n + 1;\n    s := s + n;\n  }\n}"
},
{
    "dafny": "datatype DT = Make | Create(w: int) {\n  static const b := 30\n  const c := 40\n  function F(): int {\n    if Make? then 92 else 95\n  }\n}\nmethod Test0() {\n  var d: DT := Make;\n  var x := d.c;\n  var y := d.b;\n  var f := d.F;\n  assert x == 40 && y == 30 && f() == 92;\n}\nmethod Test1() {\n  var d: DT := Create(2);\n  var x := d.c;\n  var y := d.b;\n  var f := d.F;\n  assert x == 40 && y == 30 && f() == 95;\n}\nmethod Test2() {\n  var x := Make.c;\n  var y := Make.b;\n  var f := Make.F;\n  assert x == 40 && y == 30 && f() == 92;\n}\nmethod Test3() {\n  var x := Make().c;\n  var y := Make().b;\n  var f := Make().F;\n  assert x == 40 && y == 30 && f() == 92;\n}\nmethod Tesst4() {\n  var x := Create(2).c;\n  var y := Create(2).b;\n  var f := Create(2).F;\n  assert x == 40 && y == 30 && f() == 95;\n}\nmethod Test4() {\n  var x := DT.Make.c;\n  var y := DT.Make.b;\n  var f := DT.Make.F;\n  assert x == 40 && y == 30 && f() == 92;\n}"
},
{
    "dafny": "method Main()\n{\n    var a1: array<int> := new int[7];\n    a1[0], a1[1], a1[2], a1[3], a1[4], a1[5], a1[6] := 0, 10, 20, 30, 40, 50, 60;\n    var a2: array<int> := new int[7];\n    a2[0], a2[1], a2[2], a2[3], a2[4], a2[5], a2[6] := 1, 11, 23, 31, 41, 51, 61;\n    var a3: array<int> := new int[7];\n    a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6] := 2, 11, 22, 32, 42, 52, 62;\n    var donors: seq<array> := [];\n    donors := donors + [a1] + [a2] + [a3];\n    var a4: array<int> := new int[7];\n    a4[0], a4[1], a4[2], a4[3], a4[4], a4[5], a4[6] := 3, 11, 23, 33, 43, 53, 63;\n    var s: seq<array<int>> := addDonor(donors, a4);\n    var j : int := 0;\n    while (j < |s|) {\n        var k : int := 0;\n        while (k < s[j].Length) {\n            print s[j][k];\n            print ' ';\n            k := k + 1;\n        }\n        print '\\n';\n        j := j + 1;\n    }\n}\nmethod addDonor(donors: seq<array<int>>, newDonor : array<int>)  returns (updated: seq <array<int>>)\nrequires newDonor != null;\nrequires donors != [] && |donors| >= 0;\nrequires forall r : int :: (0 <= r < |donors| ==> donors[r] != null);\nrequires forall r : int :: (0 <= r < |donors| ==> donors[r] != newDonor);\nrequires forall r : int :: (0 <= r < |donors| ==> donors[r].Length == 7);\nrequires newDonor.Length == 7;\nensures forall r : int :: (0 <= r < |donors| ==> (donors[r] in updated && newDonor in updated));\nensures forall k : int :: (0 <= k < |updated|  ==> (updated[k] != null));\n{   \n    updated := [];\n    assert updated == [];\n    var i := 0;\n    updated := [];\n    while(i < |donors|)\n    invariant 0 <= i <= |donors|\n    invariant forall k : int :: (0 <= k < i ==> donors[k] in updated)\n    invariant forall k : int :: (0 <= k < |updated|  ==> (updated[k] != null))\n    {\n        assert donors[i] != null;\n        updated := updated + [donors[i]];\n        assert updated[|updated|-1] != null;\n        i := i + 1;\n    }\n    updated := updated + [newDonor];   \n}"
},
{
    "dafny": "predicate isSorted(a: array<int>, start:int, end:int)\nrequires a != null \nrequires 0<=start<=end<=a.Length\nreads a\n{ \n    forall x, y:: start<=x<y<end ==> a[x]<=a[y] \n}\nmethod InsertionSort(toSort: array<int>)\nrequires toSort != null \nrequires toSort.Length > 1\nensures isSorted(toSort, 0, toSort.Length);\nensures multiset(toSort[..]) == multiset(old(toSort[..]));\nmodifies toSort;\n{\n    var sortedUpTo:=1;\n    while (sortedUpTo < toSort.Length)\n    invariant 1 <= sortedUpTo <= toSort.Length;\n    invariant isSorted(toSort, 0, sortedUpTo);\n    invariant multiset(toSort[..]) == multiset(old(toSort[..]));\n    {\n        var start := sortedUpTo; \n        while (start >= 1 && toSort[start-1] > toSort[start])\n        invariant 0 <= start <= sortedUpTo;\n        invariant forall i,j:: (0<=i<j<=sortedUpTo && j!=start) ==> toSort[i]<=toSort[j];\n        invariant multiset(toSort[..]) == multiset(old(toSort[..]));\n        {\n            toSort[start-1], toSort[start] := toSort[start], toSort[start-1];\n            start:=start-1;\n        }\n        sortedUpTo:=sortedUpTo+1;\n    }\n}"
},
{
    "dafny": "method FizzBuzz(i: nat)\n{\n  if i % 15 == 0 {\n    print \"FizzBuzz\\n\";\n  } else if i % 3 == 0 {\n    print \"Fizz\\n\";\n  } else if i % 5 == 0 {\n    print \"Buzz\\n\";\n  } else {\n    print i, \"\\n\";\n  }\n}\nmethod Main() {\n  var i := 0;\n  while i < 100\n    invariant 0 <= i <= 100;\n    decreases 100 - i;\n  {\n    i := i + 1;\n    FizzBuzz(i);\n  }\n}"
},
{
    "dafny": "class {:autocontracts} UserTable\n{\n    var id: int;\n    var username: string;\n    var password: string;\n    var email: string;\n      constructor(user: string, pass: string, email: string)\n      requires |user| > 0 && |pass| > 0 && |email| > 0;\n      ensures this.id == -1 && this.username == user && this.password == pass && this.email == email;\n      {\n          this.id := -1;\n          this.username := user;\n          this.password := pass;\n          this.email := email;\n      }\n      method SetID(id: int)\n      requires id >= 0 && this.id == -1;\n      ensures this.id == id;\n      ensures this.username == old(this.username) && this.password == old(this.password) && this.email == old(this.email);\n      { this.id := id; }\n}\nmethod Login(UserDB: array<UserTable>, username: string, password: string) returns (userID: int)\nensures UserDB[..] == old(UserDB[..]);\nensures -1 <= userID < UserDB.Length;\nensures userID == -1 ==> forall i:: 0 <= i < UserDB.Length ==> (UserDB[i].username != username || UserDB[i].password != password);\nensures userID > -1 ==> UserDB[userID].username == username && UserDB[userID].password == password;\n{\n    var i := 0;\n    userID := -1;\n    while (i < UserDB.Length)\n    invariant 0 <= i <= UserDB.Length;\n    invariant userID == -1 ==> forall j:: 0 <= j < i ==> (UserDB[j].username != username || UserDB[j].password != password);\n    invariant userID > -1 ==> UserDB[userID].username == username && UserDB[userID].password == password;\n    {\n        if (UserDB[i].username == username && UserDB[i].password == password)\n        {\n            return i;\n        }\n        i := i + 1;\n    }\n}\nmethod SignUp(UserDB: array<UserTable>, newUser: UserTable) returns (err: bool)\nensures UserDB[..] == old(UserDB[..]);\nensures err ==> exists i:: 0 <= i < UserDB.Length && (UserDB[i].username == newUser.username || UserDB[i].email == newUser.email);\nensures !err ==> forall i:: 0 <= i < UserDB.Length ==> (UserDB[i].username != newUser.username && UserDB[i].email != newUser.email);\n{\n    err := false;\n    var i := 0;\n    while (i < UserDB.Length && !err)\n    invariant 0 <= i <= UserDB.Length;\n    invariant err ==> exists j:: 0 <= j < i && (UserDB[j].username == newUser.username || UserDB[j].email == newUser.email);\n    invariant !err ==> forall j:: 0 <= j < i ==> (UserDB[j].username != newUser.username && UserDB[j].email != newUser.email);\n    {\n        if (UserDB[i].username == newUser.username)\n        {\n            err := true;\n        }\n        if (UserDB[i].email == newUser.email)\n        {\n            err := true;\n        }\n        i := i + 1;\n    }\n}\nmethod InsertUser(UserDB: array<UserTable>, newUser: UserTable, tempUsers: array<UserTable>) returns (newUserDB: array<UserTable>)\nmodifies tempUsers;\nrequires tempUsers.Length == UserDB.Length + 1;\nensures newUserDB.Length == UserDB.Length + 1;\nensures forall i:: 0 <= i < old(UserDB.Length) ==> newUserDB[i] == old(UserDB[i]);\nensures newUserDB[old(UserDB.Length)] == newUser;\n{\n    forall i | 0 <= i < UserDB.Length { tempUsers[i] := UserDB[i]; }\n    tempUsers[UserDB.Length] := newUser;\n    return tempUsers;\n}\nmethod TestLoginSignup()\n{\n    var Users: array<UserTable> := new UserTable[0];\n    var tmpUser := new UserTable(\"temp\", \"temp\", \"temp\");\n    var admin := new UserTable(\"admin\", \"pass\", \"admin@admin.com\");\n    assert admin.username == \"admin\" && admin.password == \"pass\" && admin.email == \"admin@admin.com\";\n    var err_signup := SignUp(Users, admin);\n    assert !err_signup;\n    admin.SetID(Users.Length);\n    assert admin.username == \"admin\" && admin.password == \"pass\" && admin.email == \"admin@admin.com\" && admin.id == Users.Length;\n    var tempUsers: array<UserTable> := new UserTable[Users.Length + 1][tmpUser];\n    Users := InsertUser(Users, admin, tempUsers);\n    assert Users.Length == 1 && Users[0] == admin;\n    assert admin.username == \"admin\" && admin.password == \"pass\";\n    assert Users.Length == 1 && Users[0] == admin && Users[0].username == admin.username && Users[0].password == admin.password;\n    var err_login := Login(Users, \"admin\", \"pass\");\n    assert err_login == admin.id;\n    assert Users.Length == 1 && Users[0].username != \"hacker\";\n    err_login := Login(Users, \"hacker\", \"hello, world\");\n    assert err_login == -1;\n    var bug := new UserTable(\"admin\", \"not_admin\", \"hello@world.com\");\n    assert bug.username == \"admin\" && bug.password == \"not_admin\" && bug.email == \"hello@world.com\";\n    assert bug.username == admin.username && Users.Length == 1 && Users[0] == admin;\n    err_signup := SignUp(Users, bug);\n    assert err_signup;\n    err_signup := SignUp(Users, admin);\n    assert err_signup;\n}"
},
{
    "dafny": "method Main() returns (x: int, y: int)\n\tensures x == y;\n{\n\tx := 0;\n\ty := 0;\n\tvar w := 1;\n\tvar z := 0;\n\tvar turn := 0;\n\twhile(x != y)\n\tinvariant x == y ==> !(0 <= -z*2/2 && 1 <= -(w-1)*2/2) \n    invariant !((x != y && x - y <= -1) || (x - y >= 1 && -z*2/2 <= 0 && (w-1)*2/2 <= 1))\n    invariant !(w*2/2 <= 0 && ((x != y && (x - y <= -1 || x - y >= 1)) || 1 <= z*2/2))\n\t{\n\t\tif(turn == 0){\n\t\t\tturn := 1;\n\t\t}\n\t\tif(turn == 1){\n\t\t\tif(w % 2 == 1){\n\t\t\t\tx := x + 1;\n\t\t\t}\n\t\t\tif(z % 2 == 0){\n\t\t\t\ty := y + 1;\n\t\t\t}\n\t\t\tturn := 1;\n\t\t}\n\t\telse{\n\t\t\tif(turn == 2){\n\t\t\t\tz := z + y;\n\t\t\t\tw := z + 1;\n\t\t\t\tturn := 0;\n\t\t\t}\n\t\t}\n\t}\n}"
},
{
    "dafny": "const vowels: set<char> := {'a', 'e', 'i', 'o', 'u'}\nfunction FilterVowels(xs: seq<char>): seq<char>\n{\n    if |xs| == 0 then []\n    else if xs[|xs|-1] in vowels then FilterVowels(xs[..|xs|-1]) + [xs[|xs|-1]]\n    else FilterVowels(xs[..|xs|-1])\n}\nmethod FilterVowelsArray(xs: array<char>) returns (ys: array<char>)\n    ensures fresh(ys)\n    ensures FilterVowels(xs[..]) == ys[..]\n{\n    var n := 0;\n    var i := 0;\n    while i < xs.Length\n        invariant 0 <= i <= xs.Length\n        invariant n == |FilterVowels(xs[..i])|\n        invariant forall j :: 0 <= j <= i ==> n >= |FilterVowels(xs[..j])|\n    {\n        assert xs[..i+1] == xs[..i] + [xs[i]];\n        if xs[i] in vowels {\n            n := n + 1;\n        }\n        i := i + 1;\n    }\n    ys := new char[n];\n    i := 0;\n    var j := 0;\n    while i < xs.Length\n        invariant 0 <= i <= xs.Length\n        invariant 0 <= j <= ys.Length\n        invariant ys[..j] == FilterVowels(xs[..i])\n    {\n        assert xs[..i+1] == xs[..i] + [xs[i]];\n        if xs[i] in vowels {\n            assert ys.Length >= |FilterVowels(xs[..i+1])|;\n            ys[j] := xs[i];\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n    assert xs[..] == xs[..i];\n    assert ys[..] == ys[..j];\n}"
},
{
    "dafny": "method addSub(a:int, b:int)  returns (result:int)\n    requires a > 5\n    requires b > 10\n    ensures result >= 0\n{\n   var addition := a + b;\n   var subtraction := a - b;\n   result := addition + subtraction;\n   return result;\n}\nmethod test()\n{\n    var a := 10 ;\n    var b := 20 ;\n    var result := addSub(a,b);\n    assert a > 5 ;\n    assert b > 10 ;\n}"
},
{
    "dafny": "class {:extern \"java.lang.String\"} JavaString {\n  ghost const value: string\n}\nmethod {:extern \"dafny.ExternDafnyString\", \"getStringFromFile\"} GetStringFromFile() returns (s: string)\nmethod Main() {\n  var s := GetStringFromFile();\n  var previousStart := 0;\n  for i := 0 to |s|\n    invariant previousStart <= i\n  {\n    if s[i] == '/' {\n      print s[previousStart..i], \"\\n\";\n      previousStart := i + 1;\n    }\n  }\n  if previousStart != |s| {\n    print s[previousStart..], \"\\n\";\n  }\n}"
},
{
    "dafny": "method ex01(n: nat, b: bool)\n{\n    var i := 0;\n    var j := 0;\n    var R := 0;\n    while i<n\n        invariant i<=n;\n        invariant R<=i;\n    {\n        i := i+1;\n        j := 0;\n        while i<n && b\n            invariant i<=n;\n            invariant R<=i;\n        {\n            i := i+1;\n            j := j+1;\n            R := R+1;\n            assert R<=i; \n        }\n    }\n    assert i<=n; \n    assert R<=n; \n}"
},
{
    "dafny": "method m()\n{\n   var i, n := 0, 20;\n   while i != n\n      invariant 0 <= i <= n \n      decreases n - i\n   {\n      i := i + 1;\n   }\n}"
},
{
    "dafny": "module InsertionSort {\n    function insert(a: int, xs: seq<int>): seq<int>\n    {\n        if xs == [] then\n            [a]\n        else if a <= xs[0] then\n            [a] + xs\n        else\n            [xs[0]] + insert(a, xs[1..])\n    }\n    function sort(xs: seq<int>): seq<int>\n    {\n        if xs == [] then\n            []\n        else\n            insert(xs[0], sort(xs[1..]))\n    }\n    predicate sorted(xs: seq<int>)\n    {\n        forall i | 0 <= i < |xs|-1 :: xs[i] <= xs[i+1]\n    }\n    function insert_sorted(a: int, xs: seq<int>): ()\n        requires sorted(xs)\n        ensures sorted(insert(a, xs))\n    {\n        if xs == [] then\n            ()\n        else if a <= xs[0] then\n            ()\n        else\n            insert_sorted(a, xs[1..])\n    }\n    function sort_sorted(xs: seq<int>): ()\n        ensures sorted(sort(xs))\n    {\n        if xs == [] then\n            ()\n        else\n            var _ := sort_sorted(xs[1..]);\n            insert_sorted(xs[0], sort(xs[1..]))\n    }\n}"
},
{
    "dafny": "method Swap(X: int, Y: int) {\n  var x, y := X, Y;\n  var tmp := x;\n  x := y;\n  y := tmp;\n  assert x == Y && y == X;\n}\nmethod SwapArithetic(X: int, Y: int) {\n  var x, y := X, Y;\n  x := y - x;\n  y := y - x;\n  x := y + x;\n  assert x == Y && y == X;\n}\nmethod SwapBitvectors(X: bv8, Y: bv8) {\n  var x, y := X, Y;\n  x := x ^ y;\n  y := x ^ y;\n  x := x ^ y;\n  assert x == Y && y == X;\n}\nmethod SwapSimultaneous(X: int, Y: int) {\n  var x, y := X, Y;\n  x, y := y, x;\n  assert x == Y && y == X;\n}"
},
{
    "dafny": "module ConcDB\n{\n  predicate Param<T>(N:nat, X:array<T>)\n  {\n    X != null && X.Length == N\n  }\n  predicate Eq(x:int, y:int) { x == y }\n  method ChooseWL(P:set<nat>, WL:set<nat>) returns (i:nat)\n    ensures (i in WL && i in P);\n  {\n    i := *;\n    assume (i in WL && i in P);\n  }\n  method ConcDBSeq\n    ( Cs : set<nat>\n    )\n    decreases *\n  {\n    var PC      : map<nat, nat> := map i | i in Cs :: 0;\n    var X       : map<nat, int> := map i | i in Cs :: 0;\n    var V       : map<nat, int> := map i | i in Cs :: 0;\n    var Status  : map<nat, int> := map i | i in Cs :: 0;\n    var Vp      : map<nat, int> := map i | i in Cs :: 0;\n    var DbID : nat;\n    var DbMsgType : nat;\n    var DbMsgKey : int;\n    var DbMsgVal : int;\n    var DbResponse : int;\n    var DbDb : map<int,int> := map[];\n    var ClientWL := Cs;\n    while ClientWL != {}\n    invariant (Cs == old(Cs))\n    invariant (forall c :: c in ClientWL ==> c in Cs)\n    invariant (forall c :: c in PC <==> c in Cs)\n    invariant (forall c :: c in X  <==> c in Cs)\n    invariant (forall c :: c in V  <==> c in Cs)\n    invariant (forall c :: c in Vp <==> c in Cs)\n    invariant (forall c :: c in Status <==> c in Cs)\n    invariant (forall c :: forall k :: c in Cs && Eq(k,X[c]) ==> (\n                 (PC[c] == 0)\n               || (PC[c] == 1 && Status[c] != 4  && k in DbDb)\n               || (PC[c] == 1 && Status[c] == 4 && k in DbDb && DbDb[k] == V[c])\n               || (PC[c] == 2 && Status[c] == 4 && k in DbDb && V[c] == Vp[c] && DbDb[k] == Vp[c])\n               )\n            )\n      decreases *\n    {\n      var c := ChooseWL(Cs, ClientWL);\n      if PC[c] == 0\n      {\n        var k    := *;\n        var v    := *;\n        X        := X[c := k];\n        V        := V[c := v];\n        DbID     := c;\n        DbMsgKey := X[c];\n        DbMsgVal := V[c];\n        if DbMsgKey in DbDb {\n          DbResponse := 3;\n        } else {\n          DbDb := DbDb[DbMsgKey := DbMsgVal];\n          DbResponse := 4;\n        }\n        Status := Status[c := DbResponse];\n        PC     := PC[c := 1];\n      } else if PC[c] == 1 {\n        if (Status[c] == 4) {\n          DbMsgType := 1;\n          DbMsgKey := X[c];\n          if DbMsgKey in DbDb {\n            DbResponse := DbDb[DbMsgKey];\n          } else {\n            DbResponse := *;\n          }\n          Vp := Vp[c := DbResponse];\n          PC := PC[c := 2];\n          ClientWL := ClientWL - {c};\n          assert (Vp[c] == V[c]);\n        }\n      }\n    }\n  }\n}"
},
{
    "dafny": "module product_sol{ \nmethod CalcProduct(m: int, n: int)returns (res:int)\n\trequires n > 0\n\trequires m > 0\n\tensures res == m*n{\n\tvar m1 := m;\n\tres := 0;\n\twhile m1 != 0 \n\t\tinvariant res == (m-m1)*n{\n\t\tvar n1 := n;\n\t\tghost var old_res := res;\n\t\twhile n1 != 0 \n\t\t\tinvariant res == old_res + (n-n1);{\n\t\t\tres := res + 1;\n\t\t\tn1 := n1 - 1;\n\t\t}\n\t\tm1 := m1 - 1;\n\t}\n\treturn;\n}\n}"
},
{
    "dafny": "module Client {\n  method Main() {\n    print \"PriorityQueue_extrinsic: \", Test_extrinsic(), \"\\n\";\n    print \"PriorityQueue_layered: \", Test_layered(), \"\\n\";\n    print \"PriorityQueue_intrinsic: \", Test_intrinsic(), \"\\n\";\n    print \"PriorityQueue_on_intrinsic: \", Test_on_intrinsic(), \"\\n\";\n    print \"PriorityQueue_direct: \", Test_direct(), \"\\n\";\n  }\n  function Test_extrinsic(): int\n    ensures Test_extrinsic() == 3\n  {\n    var p0 := A.Empty();\n    var p1 := A.Insert(p0, 4);\n    var p2 := A.Insert(p1, 3);\n    A.AboutEmpty();\n    A.AboutInsert(p0, 4);\n    A.AboutInsert(p1, 3);\n    assert A.Elements(p2) == multiset{3,4};\n    A.AboutMin(p2);\n    var m := A.Min(p2);\n    m\n  }\n  function Test_layered(): int\n    ensures Test_layered() == 3\n  {\n    var p0 := B.Empty();\n    var p1 := B.Insert(p0, 4);\n    var p2 := B.Insert(p1, 3);\n    assert B.Elements(p2) == multiset{3,4};\n    var m := B.Min(p2);\n    m\n  }\n  function Test_intrinsic(): int\n    ensures Test_intrinsic() == 3\n  {\n    var p0 := C.Empty();\n    var p1 := C.Insert(p0, 4);\n    var p2 := C.Insert(p1, 3);\n    assert C.Elements(p2) == multiset{3,4};\n    var m := C.Min(p2);\n    m\n  }\n  function Test_on_intrinsic(): int\n    ensures Test_on_intrinsic() == 3\n  {\n    var p0 := D.Empty();\n    var p1 := D.Insert(p0, 4);\n    var p2 := D.Insert(p1, 3);\n    assert D.Elements(p2) == multiset{3,4};\n    var m := D.Min(p2);\n    m\n  }\n  function Test_direct(): int\n    ensures Test_direct() == 3\n  {\n    var p0 := E.Empty();\n    var p1 := E.Insert(p0, 4);\n    var p2 := E.Insert(p1, 3);\n    assert E.Elements(p2) == multiset{3,4};\n    var m := E.Min(p2);\n    m\n  }\n}\nmodule PriorityQueue_layered {\n  export\n    provides T, Elements, Empty, Insert, Min\n  type T = t: PQ.T | PQ.Valid(t) witness (PQ.AboutEmpty(); PQ.Empty())\n  ghost function Elements(t: T): multiset<int> {\n    PQ.Elements(t)\n  }\n  function Empty(): T\n    ensures Elements(Empty()) == multiset{}\n  {\n    PQ.AboutEmpty();\n    PQ.Empty()\n  }\n  function Insert(t: T, x: int): T\n    ensures Elements(Insert(t, x)) == Elements(t) + multiset{x}\n  {\n    PQ.AboutInsert(t, x);\n    PQ.Insert(t, x)\n  }\n  function Min(t: T): int\n    requires Elements(t) != multiset{}\n    ensures var m := Min(t);\n      m in Elements(t) &&\n      forall x :: x in Elements(t) ==> m <= x\n  {\n    PQ.AboutMin(t);\n    PQ.Min(t)\n  }\n}\nmodule PriorityQueue_on_intrinsic {\n  export\n    provides T, Elements, Empty, Insert, Min\n  type T = t: PQ.T | PQ.Valid(t) witness PQ.Empty()\n  ghost function Elements(t: T): multiset<int> {\n    PQ.Elements(t)\n  }\n  function Empty(): T\n    ensures Elements(Empty()) == multiset{}\n  {\n    PQ.Empty()\n  }\n  function Insert(t: T, x: int): T\n    ensures Elements(Insert(t, x)) == Elements(t) + multiset{x}\n  {\n    PQ.Insert(t, x)\n  }\n  function Min(t: T): int\n    requires Elements(t) != multiset{}\n    ensures var m := Min(t);\n      m in Elements(t) &&\n      forall x :: x in Elements(t) ==> m <= x\n  {\n    PQ.Min(t)\n  }\n}\nmodule PriorityQueue_intrinsic {\n  export\n    provides T, Valid, Elements, Empty, Insert, Min\n  type T = PQ.T\n  ghost predicate Valid(t: T) {\n    PQ.Valid(t)\n  }\n  ghost function Elements(t: T): multiset<int> {\n    PQ.Elements(t)\n  }\n  function Empty(): T\n    ensures var t' := Empty();\n      Valid(t') && Elements(t') == multiset{}\n  {\n    PQ.AboutEmpty();\n    PQ.Empty()\n  }\n  function Insert(t: T, x: int): T\n    requires Valid(t)\n    ensures var t' := Insert(t, x);\n      Valid(t') && Elements(t') == Elements(t) + multiset{x}\n  {\n    PQ.AboutInsert(t, x);\n    PQ.Insert(t, x)\n  }\n  function Min(t: T): int\n    requires Valid(t) && Elements(t) != multiset{}\n    ensures var m := Min(t);\n      m in Elements(t) &&\n      forall x :: x in Elements(t) ==> m <= x\n  {\n    PQ.AboutMin(t);\n    PQ.Min(t)\n  }\n}\nmodule PriorityQueue_extrinsic {\n  export\n    provides T, Valid, Elements, Empty, Insert, Min\n    provides AboutEmpty, AboutInsert, AboutMin\n  datatype T = Leaf | Node(val: int, left: T, right: T)\n  ghost predicate Valid(t: T)\n  {\n    match t\n    case Leaf => true\n    case Node(x, left, right) =>\n      Valid(left) && Valid(right) &&\n      (left == Leaf || x <= left.val) &&\n      (right == Leaf || x <= right.val)\n  }\n  ghost function Elements(t: T): multiset<int> {\n    match t\n    case Leaf => multiset{}\n    case Node(x, left, right) => multiset{x} + Elements(left) + Elements(right)\n  }\n  function Empty(): T\n  {\n    Leaf\n  }\n  lemma AboutEmpty()\n    ensures var t' := Empty();\n      Valid(t') && Elements(t') == multiset{}\n  {\n  }\n  function Insert(t: T, x: int): T\n  {\n    if t == Leaf then\n      Node(x, Leaf, Leaf)\n    else if x < t.val then\n      Node(x, Insert(t.right, t.val), t.left)\n    else\n      Node(t.val, Insert(t.right, x), t.left)\n  }\n  lemma AboutInsert(t: T, x: int)\n    requires Valid(t)\n    ensures var t' := Insert(t, x);\n      Valid(t') &&\n      Elements(t') == Elements(t) + multiset{x}\n  {\n  }\n  function Min(t: T): int\n    requires Elements(t) != multiset{}\n  {\n    t.val\n  }\n  lemma AboutMin(t: T)\n    requires Valid(t) && Elements(t) != multiset{}\n    ensures var m := Min(t);\n      m in Elements(t) &&\n      forall x :: x in Elements(t) ==> m <= x\n  {\n  }\n}\nmodule PriorityQueue_direct {\n  export\n    provides T, Elements, Empty, Insert, Min\n  datatype T' = Leaf | Node(val: int, left: T', right: T')\n  ghost predicate Valid(t: T')\n  {\n    match t\n    case Leaf => true\n    case Node(x, left, right) =>\n      Valid(left) && Valid(right) &&\n      (left == Leaf || x <= left.val) &&\n      (right == Leaf || x <= right.val)\n  }\n  type T = t: T' | Valid(t) witness Leaf\n  ghost function Elements(t: T): multiset<int> {\n    match t\n    case Leaf => multiset{}\n    case Node(x, left, right) => multiset{x} + Elements(left) + Elements(right)\n  }\n  function Empty(): T\n    ensures Elements(Empty()) == multiset{}\n  {\n    Leaf\n  }\n  function Insert(t: T, x: int): T\n    ensures Elements(Insert(t, x)) == Elements(t) + multiset{x}\n  {\n    if t == Leaf then\n      Node(x, Leaf, Leaf)\n    else if x < t.val then\n      Node(x, Insert(t.right, t.val), t.left)\n    else\n      Node(t.val, Insert(t.right, x), t.left)\n  }\n  function Min(t: T): int\n    requires Elements(t) != multiset{}\n    ensures var m := Min(t);\n      m in Elements(t) &&\n      forall x :: x in Elements(t) ==> m <= x\n  {\n    AboutMin(t);\n    t.val\n  }\n  lemma AboutMin(t: T)\n    requires t != Leaf\n    ensures t.val in Elements(t) &&\n            forall x :: x in Elements(t) ==> t.val <= x\n  {\n  }\n}"
},
{
    "dafny": "function {:fuel 10} Sum(s: seq<nat>): nat {\n  if |s| == 0 then 0\n  else s[0] + Sum(s[1..])\n}\nlemma Sum1(s: seq<nat>)\n  requires |s| == 1\n  ensures Sum(s) == s[0]\n{\n}\nlemma Sum2(s: seq<nat>)\n  requires |s| == 2\n  ensures Sum(s) == s[0] + s[1]\n{\n}\nlemma Sum3(s: seq<nat>)\n  requires |s| == 3\n  ensures Sum(s) == s[0] + s[1] + s[2]\n{\n}"
},
{
    "dafny": "ghost function pow(a: int, e: nat): int {\n    if e == 0 then 1 else a*pow(a, e-1)\n}\nmethod Pow(a: nat, n: nat) returns (y: nat)\nensures y == pow(a, n)\n{\n    var x:nat := 1;\n    var k:nat := 0;\n    while k < n\n    invariant x == pow(a, k)\n    invariant 0 <= k <= n\n    decreases n-k\n    {\n        assert x == pow(a, k);\n        x := a*x;\n        assert x == a*pow(a, k);\n        assert x == pow(a, k+1);\n        k := k + 1;\n        assert x == pow(a, k);\n    }\n    assert k == n;\n    y := x;\n    assert y == pow(a, n);\n}"
},
{
    "dafny": "datatype Student = Student(firstName: string, lastName: string, number: int, graduated: bool)\nfunction hashCode(a: Student): int\n{\n    a.number % 5\n}\nfunction equals(a: Student, b: Student): bool\n{\n    a.number == b.number && a.firstName == b.firstName\n}\nmethod Main() {\n    assert forall x, y: Student :: equals(x, y) ==> hashCode(x) == hashCode(y);\n}"
},
{
    "dafny": "method triangle(n:int) returns (t:int)\n  requires n >=0\n  ensures t == n * (n+1) / 2 \n{\n  t := 0;\n  var i := 0;\n  while i < n\n    invariant i <= n\n    invariant t == i * (i+1) / 2\n    decreases n - i\n  {\n    i := i+1;\n    t := t+i;\n  }\n  return t;                         \n}\nmethod max (a:int, b:int) returns (r:int) \n  ensures r >= a\n  ensures r >= b\n  ensures r == a || r == b\n{\n  if a>b {\n    return a;\n  } else {\n    return b;\n  }\n}\npredicate contains_upto(A:array<int>, hi:int, v:int) \n  reads A\n  requires hi <= A.Length\n{\n  exists j :: 0 <= j < hi && v == A[j]\n}\npredicate contains(A:array<int>, v:int) \n  reads A\n{\n  contains_upto(A, A.Length, v)\n}\nmethod maxarray (A:array<int>) returns (r:int) \n  requires A.Length > 0\n  ensures contains(A, r)\n  ensures forall j :: 0 <= j < A.Length ==> r >= A[j]\n{\n  r := A[0];\n  var i := 1;\n  while i < A.Length \n    invariant 1 <= i <= A.Length\n    invariant contains_upto(A, i, r)\n    invariant forall j :: 0 <= j < i ==> r >= A[j]\n    decreases A.Length - i\n  {\n    if r < A[i] {\n      r := A[i];\n    }\n    i := i+1;\n  }\n  assert i == A.Length;\n}\nmethod Main() {\n  var m:int := max(3,5);\n  print m, \"\\n\";\n}"
},
{
    "dafny": "predicate sorted(a: array<int>, l: int, u: int)\n  reads a\n  requires a != null\n  {\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]\n  }\npredicate partitioned(a: array<int>, i: int)\n  reads a\n  requires a != null\n  {\n    forall k, k' :: 0 <= k <= i < k' < a.Length ==> a[k] <= a[k']\n  }\nmethod BubbleSort(a: array<int>)\n  modifies a\n  requires a != null\n  ensures sorted(a, 0, a.Length-1)\n  {\n    var i := a.Length - 1;\n    while(i > 0)\n      invariant i < 0 ==> a.Length == 0 \n      invariant sorted(a, i, a.Length-1)\n      invariant partitioned(a, i)\n      {\n        var j := 0;\n        while (j < i)\n          invariant 0 < i < a.Length && 0 <= j <= i\n          invariant sorted(a, i, a.Length-1)\n          invariant partitioned(a, i)\n          invariant forall k :: 0 <= k <= j ==> a[k] <= a[j]\n          {\n            if(a[j] > a[j+1])\n              {\n                a[j], a[j+1] := a[j+1], a[j];\n              }\n              j := j + 1;\n          }\n          i := i -1;\n      }\n  }\nmethod Main() {\n  var data : array<int> := new int[5];\n  data[0] := 500;\n  data[1] := 250;\n  data[2] := 750;\n  data[3] := 500;\n  data[4] := 1000;\n  print data[..], '\\n';\n  BubbleSort(data);\n  print data[..], '\\n';\n}"
},
{
    "dafny": "module {:extern} Options {\n  datatype Option<V> = None | Some(value:V)\n  function MapOption<V0, V1>(opt: Option<V0>, f: V0 ~> V1) : (result: Option<V1>)\n  requires opt.Some? ==> f.requires(opt.value)\n  ensures opt.Some? <==> result.Some?\n  ensures result.Some? ==> result.value == f(opt.value)\n  reads if opt.Some? then f.reads(opt.value) else {}\n  {\n    match opt {\n      case Some(v) => Some(f(v))\n      case None => None\n    }\n  }\n  function FlatMapOption<V0, V1>(opt: Option<V0>, f: V0 ~> Option<V1>) : (result: Option<V1>)\n  requires opt.Some? ==> f.requires(opt.value)\n  ensures opt.Some? && f(opt.value).Some? ==> result.Some?\n  ensures opt.Some? && f(opt.value).Some? ==> result.value == f(opt.value).value\n  reads if opt.Some? then f.reads(opt.value) else {}\n  {\n    match opt {\n      case Some(v) => f(v)\n      case None => None\n    }\n  }\n}"
},
{
    "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    assert More(x) == 1; \n  } else {\n    assert More(x) == More(x - 2) + 3; \n    Increasing(x - 2); \n    assert More(x) == More(x - 2) + 3 &&\n           x - 2 < More(x - 2);\n    assert More(x) == More(x - 2) + 3 &&\n           x + 1 < More(x - 2) + 3;\n    assert x + 1 < More(x);\n  }\n}"
},
{
    "dafny": "method SearchRecursive( a: seq<int>, i: int, j: int, x: int ) returns (k: int)\n    decreases j-i;\n    requires 0 <= i <= j <= |a|;\n    ensures i <= k < j || k == -1;\n    ensures k != -1 ==> a[k] == x;\n    ensures k != -1 ==> forall r | k < r < j :: a[r] != x;\n    ensures k == -1 ==> forall r | i <= r < j :: a[r] != x;\n{\n    if j == i\n    {\n        k := -1;\n        return;\n    }\n    if a[j-1] == x\n    {\n        k := j-1;\n        return;\n    }\n    else\n    {\n        k := SearchRecursive(a, i, j-1, x);\n    }\n}\nmethod SearchLoop( a: seq<int>, i: int, j: int, x: int ) returns (k: int)\n    requires 0 <= i <= j <= |a|;\n    ensures i <= k < j || k == -1;\n    ensures k != -1 ==> a[k] == x;\n    ensures k != -1 ==> forall r | k < r < j :: a[r] != x;\n    ensures k == -1 ==> forall r | i <= r < j :: a[r] != x;\n{\n    if i == j\n    {\n        return -1;\n    }\n    var t := j;\n    while t > i\n        decreases t;\n        invariant forall p | t <= p < j :: a[p] != x; \n    {\n        if a[t-1] == x\n        {\n            k := t-1;\n            return;\n        }\n        else \n        {\n            t := t - 1;\n        }\n    }\n    k := -1;\n}"
},
{
    "dafny": "predicate just1(a:array<int>,key:int)\n   reads a\n   requires a != null\n{\n  ((exists k | 0 <= k < a.Length :: a[k] == key) && !(exists k,j | 0 <= k < j < a.Length :: a[k] == key && a[j] == key))\n}\nmethod Just1(a: array<int>, key: int) returns (b: bool)\nrequires a != null\nensures just1(a,key) == b\n{\n    var count := 0;\n    var i := 0;\n    b:=false;\n    if(a.Length == 0){\n        return;\n    }\n    while i < a.Length\n    invariant 0 <= i <= a.Length;\n    invariant !(exists k | 0 <= k < i :: a[k] == key)\n    decreases a.Length - i\n    {\n        if a[i] == key \n        {\n            var next := i+1;\n            assert (next == i+1) && (next > i);\n            assert a[i] == key ==> exists j | 0 <= j <= i :: a[j] == key;\n            if(next == a.Length){\n                assert ((a[a.Length - 1] == key) && (forall k :: 0 <= k < (a.Length - 1) ==> a[k] != key));\n                b := true;\n                return;\n            }\n            while next < a.Length\n            invariant a[i] == key\n            invariant i+1 <= next <= a.Length;\n            invariant forall k:: i+1<= k < next ==> a[k] != key\n            decreases a.Length - next\n            {\n                if(a[next] == key){\n                   assert forall k :: 0 <= k < i ==> a[k] != key && a[i] == key && !(forall j ::0<= i < j < a.Length ==> a[i] == key ==> a[j] != key);\n                   assert exists  k,j | 0 <= k < j < a.Length :: a[k] == key ==> a[j] == key;\n                   b:= false;\n                   return;\n                }\n                next := next+1;\n            }\n            assert forall k :: (i + 1) <= k < a.Length ==> a[k] != key;\n            assert a[i] == key && forall m :: 0 <= m < i ==> a[m] != key;\n            b:= true;\n            return;\n        }\n        i:=i+1;\n    }\n    assert i == a.Length;\n    assert forall k :: 0<= k < a.Length ==> a[k] != key;\n    assert !(exists k | 0 <= k < a.Length :: a[k] == key);\n    b:= false;\n    return;\n}\nmethod Main(){\n    var arr :=new int[4];\n    arr[0], arr[1], arr[2], arr[3]:= 1,1,2,1;\n    var res:= Just1(arr, 1);\n    assert arr[0]==1;\n    assert arr[1]==1;\n    assert arr[2]==2;\n    assert arr[3]==1;\n    assert !res;\n    print res;\n    print \"\\n\";\n    res:= Just1(arr, 2);\n    assert res;\n    print res;\n    print \"\\n\";\n    res:= Just1(arr, 3);\n    assert !res;\n    print res;\n    print \"\\n\";\n    var arr1 :=new int[1];\n    arr1[0]:=1;\n    res := Just1(arr1, 1);\n    assert arr1[0]==1;\n    assert res;\n    print res;\n    print \"\\n\";\n    res:= Just1(arr1, 2);\n    assert !res;\n    print res;\n    print \"\\n\";\n    var arr2 := new int[0];\n    res := Just1(arr2, 1);\n    assert !res;\n    print res;\n    print \"\\n\";\n}"
},
{
    "dafny": "method buscar(a:array<int>, x:int) returns (r:int)\nensures r < 0 ==> forall i :: 0 <= i <a.Length ==> a[i] != x\nensures 0 <= r < a.Length ==> a[r] == x\n{\n    r := 0;\n    while r < a.Length\n    decreases a.Length - r\n    invariant 0 <= r <= a.Length\n    invariant forall i :: 0 <= i < r ==> a[i] != x\n    {\n        if a[r] == x\n        {\n            return r;\n        }\n        r := r + 1;\n    }\n    return -1;\n}"
},
{
    "dafny": "method Abs(x : int) returns (y : int)\n       ensures 0 <= x ==> y == x;\n       ensures x < 0 ==> y == -x;\n       ensures 0 <= y;\n     {\n       if (x < 0)\n        { y := -x; }\n       else\n        { y := x; }\n     }\n     function abs(x : int) : int\n     {\n       if x < 0 then -x else x\n     }"
},
{
    "dafny": "method contains_duplicate(nums: seq<int>) returns (result: bool)\n    requires 1 <= |nums| <= 100000\n    requires forall i :: 0 <= i < |nums| ==> -1000000000 <= nums[i] <= 1000000000\n    ensures result <==> distinct(nums)\n{  \n    var i := 0;\n    var s: set<int> := {};\n    while (i < |nums|)\n        invariant i <= |nums|\n        invariant forall j :: j in nums[..i] <==> j in s\n        invariant distinct(nums[..i])\n    {\n        var num := nums[i];\n        if (num in s)\n        {\n            return false;\n        }\n        s := s + {num};\n        i := i + 1;\n    }\n    return true;\n}\npredicate distinct(nums: seq<int>) {\n    forall i, j :: 0 <= i < j < |nums| ==> nums[i] != nums[j]\n}"
},
{
    "dafny": "module A {\n  ghost predicate Init(s: int) {\n    s == 0\n  }\n  ghost predicate Next(s: int, s': int) {\n    s' == s + 1\n  }\n  least predicate Reachable(s: int)\n  {\n    Init(s) || (exists s0 :: Reachable(s0) && Next(s0, s))\n  }\n}\nmodule B {\n  least lemma ReachableImpliesNonneg(s: int)\n  requires A.Reachable(s)\n  ensures s >= 0\n  {\n    if A.Init(s) {\n    } else {\n      var s0: int :| A.Reachable(s0) && A.Next(s0, s);\n      ReachableImpliesNonneg(s0);\n    }\n  }\n}"
},
{
    "dafny": "method IsPrime (n: nat) returns (b: bool) \n    ensures b <==> prime(n)\n    {\n    if (n < 2) {\n        b := true;\n    } else {\n        b := true;\n        var factor: nat := 2;\n        while (b && factor < n)\n            invariant b == forall k: int :: 1 < k < factor ==> n % k != 0\n            invariant factor <= n;\n        {\n            if (n % factor == 0) {\n                b := false;\n            }\n            assert b == (n % factor != 0);\n            factor := factor + 1;\n        }        \n    }\n    assert b <==> prime(n);\n}\nfunction prime (n: nat) : bool {\n    forall k: int :: 1 < k < n ==> n % k != 0\n}"
},
{
    "dafny": "method Main() {\n  var sieve := new bool[1000004];\n  var primes := new int[1000004];\n  var primes_pos := 0;\n  var i := 0;\n  var j := 0;\n  while i < 1000004 {\n    sieve[i] := true;\n    i := i + 1;\n  }\n  sieve[0] := false;\n  sieve[1] := false;\n  i := 2;\n  while i < 1000004 invariant primes_pos < 1000004 {\n    if sieve[i] {\n      primes[primes_pos] := i;\n      if primes_pos < 1000003 {\n        primes_pos := primes_pos + 1;\n      }\n      j := i + i;\n      while (j < 1000004) {\n        sieve[j] := false;\n        j := j + i;\n      }\n      assert primes_pos < 1000004;\n    }\n    i := i + 1;\n  }\n  var sum := 0;\n  var idx := 2;\n  while idx < primes_pos - 1 {\n    var p1 := primes[idx];\n    var p2 := primes[idx + 1];\n    var m := 1;\n    while m < p1 {\n        m := m * 10;\n    }\n    var old_r := p2;\n    var r := m;\n    var old_s := 1;\n    var s := 0;\n    var old_t := 0;\n    var t := 1;\n    while r != 0 {\n      var quotient := old_r / r;\n      var tmp := 0;\n      tmp := old_r;\n      old_r := r;\n      r := tmp - quotient * r;\n      tmp := old_s;\n      old_s := s;\n      s := tmp - quotient * s;\n      tmp := old_t;\n      old_t := t;\n      t := tmp - quotient * t;\n    }\n    var inv := (old_s % m + m) % m;\n    var smallest := ((p1 * inv) % m) * p2;\n    sum := sum + smallest;\n    idx := idx + 1;\n  }\n  print sum;\n  print \"\\n\";\n}"
},
{
    "dafny": "type MyArray = array<int>\ntype MyMatrix = m: array2<int> | m.Length0 == m.Length1 witness *\nclass State\n{  \n  var arr: MyArray\n  var m: MyMatrix\n  var count: nat\n  constructor () {\n    arr, m := new int[100], new int[100, 100];\n  }\n  method Process(i: nat)\n    requires i < arr.Length < m.Length0\n    modifies this, arr, m\n  {\n    arr[i], m[i, i], count := 0, 0, 0;\n  }\n}"
},
{
    "dafny": "method ifelsenested(x : int) returns (result : int)\nensures result > 7\nrequires x > 6\n{\n   if(x < 10) {   \n     if(x == 8) {   \n        result := 9;\n      } else {\n                result := 10;\n            }\n      }\n   else {\n            result := 11;\n        }\n   return result;\n}\nmethod Main(){\n  var z1 :=8;\n  assert z1 == 8;\n  var result1 := ifelsenested(z1);\n  print result1;\n}"
},
{
    "dafny": "method Maximum(values: seq<int>) returns (max: int)\n  requires values != []\n  ensures max in values\n  ensures forall i | 0 <= i < |values| :: values[i] <= max\n{\n  max := values[0];\n  var idx := 0;\n  while (idx < |values|)\n    invariant max in values\n    invariant idx <= |values|\n    invariant forall j | 0 <= j < idx :: values[j] <= max\n  {\n    if (values[idx] > max) {\n      max := values[idx];\n    }\n    idx := idx + 1;\n  }\n}"
},
{
    "dafny": "function total(a: array<bool>, i:int, key: bool): int\nrequires a != null;\nreads a;\n{\n\tif i < 0\n  \t\tthen 0\n \telse if (a.Length == 0)\n  \t\tthen 0\n  \telse if 0<=i<a.Length && a[i] == key\n  \t\tthen total(a, i-1, key) + 1\n  \telse total(a, i-1, key)\n}\npredicate compare(a: array<bool>, a1: array<bool>)\nreads a;\nreads a1;\nrequires a != null;\nrequires a1 != null;\n{\n\tforall key:bool :: total(a, a.Length, key) == total(a1, a1.Length, key)\n}\nmethod TwoWaySort(a:array<bool>)\n  requires a != null;\n  modifies a;\n  ensures compare(a, old(a)); \n  ensures forall k:: forall l:: 0 <= k < l < a.Length ==> !a[k] || a[l]; \n{\n\tvar i:int := 0;\n\tvar j:int := a.Length - 1;\n\twhile (i <= j)\n\tinvariant 0 <= i <= (j+1);\n\tinvariant (i-1) <= j < a.Length;\t\n\tdecreases (j+1) - i;\n\tdecreases j - (i-1);    \n    invariant forall k:: 0 <= k < i ==> !a[k];\n    invariant forall l:: j < l < a.Length ==> a[l];\n\t{\n\t\tif a[i] == false \n\t\t{\n\t\t\ti := i + 1;\n\t\t}\n\t\telse if a[j] == true \n\t\t{\n\t\t\tj := j - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t    var t:bool := a[i];\n\t        a[i] := a[j];\n    \t    a[j] := t;\n\t\t\ti := i + 1;\n\t\t\tj := j - 1;\n\t\t}\n\t}\n}\nmethod Main() \n{\n  var a := new bool[3];\n  a[0] := false;\n  a[1] := true;\n  a[2] := false;\n  TwoWaySort(a);\n  var i:int := 0;\n  while (i < a.Length)\n  {\n    print a[i];\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "trait Animal {\n    function           not_opaque() : ( rv : int)\n    function {:opaque} iam_opaque() : ( rv : int) \n    predicate depends_on_not_opaque() \n       ensures  not_opaque() == 42 \n    predicate depends_on_iam_opaque() \n       ensures  iam_opaque() == 42 \n}\nclass Cat extends Animal {\n    function           not_opaque() : ( rv : int) { 42 } \n    function {:opaque} iam_opaque() : ( rv : int) \n         { reveal iam_opaque();  42 } \n    predicate depends_on_not_opaque() \n       ensures not_opaque() == 42 {true}\n    predicate depends_on_iam_opaque() \n       ensures iam_opaque() == 42 {reveal iam_opaque(); true}\n}\ntrait T {\n  predicate Valid(x: int)\n  method MyMethod(x: int) requires Valid(x)\n}\nclass C extends T {\n  predicate {:opaque} Valid(x: int) { true }\n  method MyMethod(x: int) requires Valid(x) {\n  }\n}"
},
{
    "dafny": "class C { }\nfunction f(c: C): C\nfunction g(c: C): C\nfunction h(c: C, i: int): C\nmethod M0(i: int, j: int, sc: set<C>) {\n  assert forall c | c in sc :: true || h(c, i) == h(h(c, j), j);\n}\nmethod M1(f: int -> int, g: int -> int) {\n  assert forall x :: true || f(x) == g(f(x));\n}\nmethod M2(sc: set<C>) {\n  assert forall c | c in sc :: true || f(c) == old(f(f(c)));\n}"
},
{
    "dafny": "method Test1()\n{\n  var tuple0 := (ghost 0:=123, ghost 1:=234);\n  var tuple1 := (ghost 123, ghost 234);\n  assert tuple0 == tuple1;\n}\nmethod Test2()\n{\n  var tuple0 := (ghost 10:=10, 3:=3, 0:=0, 1:=1, 2:=2, 4:=4, 5:=5, 6:=6, 7:=7, 8:=8, 9:=9);\n  var tuple1 := (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ghost 10);\n  assert tuple0 == tuple1;\n}"
},
{
    "dafny": "function sum(ns: seq<int>): int {\n    if ns == [] then 0 else sum(ns[..|ns| - 1]) + ns[|ns| - 1]\n}\nmethod Sum(ns: array<int>) returns (result: int)\nensures result == sum(ns[..]);\n{\n    var i := 0;\n    result := 0;\n    while i < ns.Length\n        invariant 0 <= i <= ns.Length && result == sum(ns[..i])\n    {\n        assert sum(ns[..i + 1]) == sum(ns[..i + 1][..i]) + ns[..i + 1][i];\n        assert ns[..i + 1][..i] == ns[..i];\n        assert ns[..i + 1][i] == ns[i];\n        result := result + ns[i];\n        i := i + 1;\n    }\n    assert ns[..i] == ns[..];\n}"
},
{
    "dafny": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n    decreases shrink\n    invariant shrink + grow == numbers\n    invariant grow !! shrink\n    invariant count == |set i | i in grow && i < threshold|\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n    assert (set i | i in grow' && i < threshold) ==\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}"
},
{
    "dafny": "module ListLibrary {\n  datatype List<B> = Nil | Cons(head: B, tail: List<B>)\n}\nmodule Q {\n  datatype Queue<T> = FQ(front: LL.List<T>, rear: LL.List<T>)\n  function MyCons<W>(w: W, ws: LL.List<W>): LL.List<W>\n  {\n    LL.Cons(w, ws)\n  }\n  method Test<A>(q: Queue<A>, x: A) returns (r: LL.List<A>)\n  {\n    var r0 := MyCons(x, q.rear);\n    var r1 := var qr := q.rear; LL.Cons(x, qr);\n    var r2 := LL.Cons(x, q.rear);  \n    assert r0.tail == r1.tail == r2.tail;\n    r := r2;\n  }\n}\nmethod Main()\n{\n  var q := Q.FQ(ListLibrary.Nil, ListLibrary.Nil);\n  var x := 28.0;\n  var ll := Q.Test(q, x);\n  print ll, \"\\n\";\n}"
},
{
    "dafny": "function fib(n: nat): nat\n  decreases n;\n{\n  if n == 0 then 0 \n  else if n == 1 then 1 \n  else fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == fib(n);\n{\n  if (n == 0) \n    { f := 0; }\n  else {\n    var i := 1;\n    var f_2 := 0;\n    var f_1 := 0;\n        f   := 1;    \n    while (i < n) \n      decreases n - i;\n      invariant i <= n;\n      invariant f_1 == fib(i - 1);\n      invariant f   == fib(i);\n    {\n      f_2 := f_1;\n      f_1 := f; \n      f   := f_1 + f_2;\n      i := i + 1;\n    }\n  }\n}"
},
{
    "dafny": "method findMax (a : array<int>, n : int) returns (r:int)\n    requires n >= 1 && n<=a.Length;\n    ensures 0<=r<n;\n    ensures forall l :: 0 <= l < n ==> a[r] >= a[l];\n    ensures exists l :: 0 <= l < n && a[r] == a[l];\n{\n  var mi;\n  var i;\n  mi := 0;\n  i := 0;\n  while (i < n)\n  invariant 0 <= i <=n;\n  invariant 0 <= mi <n;\n  invariant forall l :: 0 <= l < i ==>  a[mi] >= a[l];\n  decreases n-i;\n  {\n    if (a[i] > a[mi])\n    { mi := i; }\n    i := i + 1;\n  }\n  return mi;\n}"
},
{
    "dafny": "method Q3(n0 : int, m0 : int) returns (res : int)\n    ensures n0 * m0 == res;\n{\n    var n, m : int;\n    res := 0;\n    if (n0 >= 0) \n        {n,m := n0, m0;} \n    else \n        {n,m := -n0, -m0;}\n    while (0 < n)\n        invariant 0 <= n \n        invariant n0 >= 0 ==> (n0 - n) * m == res;\n        invariant n0 < 0 ==> (-n0 - n) * m == res;\n        decreases n\n  { \n        res := res + m; \n        n := n - 1; \n    }\n}\nmethod Main() {\n    var r := Q3(2, 5);\n    assert r == 10;\n    var i := 0;\n    while i < 100\n        decreases  100 - i\n    {\n        r := Q3(i, i);\n        assert r == (i * i);\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "module Gas {\n    const STATICCALL : nat := 0xfa\n    function f(op: nat, s: int): int\n    {\n        match op\n            case STATICCALL => 0\n            case _ => s\n    }\n    lemma MatchIsCorrect() {\n      assert f(0, 2) == 2;\n    }\n}"
},
{
    "dafny": "lemma noExistsz_Lemma(x: int, y: int)\n\trequires x % 2 == 1 && y % 2 == 1\n\tensures !exists z: int :: x*x + y*y == z*z\n{\n\tif exists z: int :: x*x + y*y == z*z {\n\t\tvar k: int :| x*x + y*y == k*k;\n\t\tassert x % 2 == 1 && y % 2 == 1;\n\t\tvar a := (x-1)/2;\n\t\tvar b := (y-1)/2;\n\t\tassert k*k == (2*a+1)*(2*a+1) + (2*b+1)*(2*b+1) == \n\t\t\t4*a*a + 4*a + 1 + 4*b*b + 4*b + 1 == \n\t\t\t2*(2*a*a + 2*a + 2*b*b + 2*b + 1);\n\t\tassert k*k % 2 == 0;\n\t\tCuadr1_Lemma(k);\n\t\tassert k % 2 == 0;\n\t\tvar c := k/2;\n\t\tassert (2*c)*(2*c) == 2*(2*a*a + 2*a + 2*b*b + 2*b + 1);\n\t\tassert 2*(2*c*c) == 2*(2*a*a + 2*a + 2*b*b + 2*b + 1);\n\t\tassert 2*c*c == 2*a*a + 2*a + 2*b*b + 2*b + 1;\n\t\tassert 2*(c*c) == 2*(a*a + a + b*b + b) + 1;\n\t\tassert false;\n\t}\n}\nlemma Cuadr1_Lemma(n: int)\n\trequires (n*n) % 2 == 0\n\tensures n % 2 == 0\n{\n\tif n % 2 != 0 {\n\t\tvar k := (n-1)/2;\n\t\tassert n*n == (2*k + 1)*(2*k + 1) == 4*k*k + 4*k + 1 == 2*(2*k*k + 2*k) + 1;\n\t}\n}"
},
{
    "dafny": "class Counter {\n  var value : int ;\n  constructor init()\n  ensures value == 0\n  {\n    value := 0;\n  }\n  method getValue() returns (x:int)\n  ensures x == value\n  {\n    x := value;\n  }\n  method inc()\n  modifies `value\n  ensures value == old(value) + 1\n  {\n    value := value + 1;\n  }\n  method dec()\n  modifies `value\n  ensures value == old(value) - 1\n  { \n    value := value - 1 ;\n  }\n  method Main ()\n  {\n   var count := new Counter.init() ;\n   count.inc();\n   count.inc();\n   count.dec();\n   count.inc();\n   var aux : int := count.getValue();\n   assert (aux == 2);\n  }\n}"
},
{
    "dafny": "method findInEven (a: array<int>, x:int) returns (r:int)\nrequires a != null\nensures  r != -1 ==> 0 <= r < a.Length;\nensures  r != -1 ==> a[r] == x;\nensures r != -1 ==>  r % 2 == 0\nensures r == -1 ==> \n forall k::0 <= k < a.Length && k % 2 == 0 ==> a[k] != x;\n{\n  r := -1;\n  var i := 0;\n  while (i < a.Length)\n  invariant 0 <= i <= a.Length + 1\n  invariant i % 2 == 0 \n  invariant r == -1 || r % 2 == 0\n  invariant r < a.Length\n  invariant r != -1 ==> a[r] == x\n  invariant r == -1 && 0 < i < a.Length ==> forall y:: 0<= y < i && y % 2 == 0 ==> a[y] != x\n  invariant r == -1 && i >= a.Length ==> forall y:: 0 <=y < a.Length && y % 2 == 0 ==> a[y] != x\n  decreases a.Length - i\n  {\n    if (x == a[i]) { r := i; }\n    i := i + 2;\n  }\n}"
},
{
    "dafny": "module MathDivR {\n    lemma LemmaConverseRealDiv(a:real,b:real,c:real)\n    requires b != 0.0\n    requires a == b *c\n    ensures c == a/b;\n    {}    \n    lemma LemmaRealSumDistributeOverDiv(a:real,b:real,c:real)\n    requires c!= 0.0\n    ensures (a+b)/c == a/c + b/c \n    {}\n    lemma LemmaRealSubDistributeOverDiv(a:real,b:real,c:real)\n    requires c!= 0.0\n    ensures (a-b)/c == a/c - b/c \n    {}\n}"
},
{
    "dafny": "function Ack(m: nat, n: nat): nat\n{\n    if m == 0 then\n        n + 1\n    else if n == 0 then\n        Ack(m - 1, 1)\n    else\n        Ack(m - 1, Ack(m, n - 1))\n}\nlemma {:induction false} Ack_Gt0(m: nat, n: nat)\n    ensures Ack(m, n) > 0\n{\n    if m == 0 {\n    } else if n == 0 {\n        Ack_Gt0(m - 1, 1);\n    } else {\n        Ack_Gt0(m - 1, Ack(m, n - 1));\n    }\n}"
},
{
    "dafny": "method Half(x: int) returns (r: int)\n  requires x >= 0\n  ensures r == x/2\n{\n  var i: int :=0;\n  var x1: int:=x/2 * 2;\n  assert x1 == (x1/2)*2 ; \n  assert x1 %2 ==0;       \n  assert x1/2 == x/2;     \n  r:=0;\n  while (i<x1) \n    invariant i <=x1\n    invariant r == i/2 && i%2 == 0\n    decreases x1-i\n  {\n     r:=r+1; i:=i+2;\n  }\n}"
},
{
    "dafny": "method M1()\n{\n  var m := map [{10, 20} := 33];\n  assert {10, 20} in m; \n  print {10, 20} in m, \"\\n\"; \n}\nmethod M1'()\n{\n  var m := map [{10, 20} := 33];\n  assert {10, 20} == {20, 10};\n  assert {20, 10} in m; \n  print {20, 10} in m, \"\\n\"; \n}\nmethod M2()\n{\n  var m := map [(map [1 := 10, 2 := 20]) := 33];\n  assert (map [1 := 10, 2 := 20]) in m; \n  print (map [1 := 10, 2 := 20]) in m, \"\\n\"; \n}\nmethod M2'()\n{\n  var m := map [(map [1 := 10, 2 := 20]) := 33];\n  assert (map [1 := 10, 2 := 20] == map [2 := 20, 1 := 10]);\n  assert (map [2 := 20, 1 := 10]) in m; \n  print (map [2 := 20, 1 := 10]) in m, \"\\n\"; \n}\nmethod M3()\n{\n  var m := map [(multiset{10, 20}) := 33];\n  assert (multiset{10, 20}) in m; \n  print (multiset{10, 20}) in m, \"\\n\"; \n}\nmethod M3'()\n{\n  var m := map [(multiset{10, 20}) := 33];\n  assert multiset{10, 20} == multiset{20, 10};\n  assert (multiset{20, 10}) in m; \n  print (multiset{20, 10}) in m, \"\\n\"; \n}\nmethod M4()\n{\n  var m := map [[10, 20] := 33];\n  assert [10, 20] in m; \n  print [10, 20] in m, \"\\n\"; \n}\nmethod Main()\n{\n  M1();\n  M1'();\n  M2();\n  M2'();\n  M3();\n  M3'();\n  M4();\n}"
},
{
    "dafny": "method isPrime (n: nat) returns (b: bool)\nrequires n > 0\nensures b == true <==> n == 2 || forall x :: ((2 <= x < n) ==> (n % x != 0))\n{\n    if (n<2){\n        b:=true;\n    }\n    else{\n        b:=true;\n        var factor: nat := 2;\n        while(b && factor < n)\n            invariant factor <= n\n            invariant b == true <==> (forall x :: (2 <= x < factor) ==> (n % x != 0))\n            {\n            if(n%factor == 0){\n                b:= false;\n            }\n            factor:= factor+1;\n        }\n    }\n}"
},
{
    "dafny": "type interval = iv: (int, int) | iv.0 <= iv.1 witness (0, 0)\nghost function length(iv: interval): int {\n  iv.1 - iv.0\n}\nghost predicate valid_interval(s: string, iv: interval) {\n  && (0 <= iv.0 <= iv.1 <= |s|)                             \n  && (forall i, j | iv.0 <= i < j < iv.1 :: s[i] != s[j])   \n}\nmethod lengthOfLongestSubstring(s: string) returns (n: int, ghost best_iv: interval)\n  ensures valid_interval(s, best_iv) && length(best_iv) == n    \n  ensures forall iv | valid_interval(s, iv) :: length(iv) <= n  \n{\n  var lo, hi := 0, 0;             \n  var char_set: set<char> := {};  \n  n, best_iv := 0, (0, 0);        \n  while hi < |s|\n    decreases |s| - hi, |s| - lo\n    invariant 0 <= lo <= hi <= |s|\n    invariant valid_interval(s, (lo, hi))\n    invariant char_set == set i | lo <= i < hi :: s[i]\n    invariant valid_interval(s, best_iv) && length(best_iv) == n\n    invariant forall iv: interval | iv.1 <= hi && valid_interval(s, iv) :: length(iv) <= n  \n    invariant forall iv: interval | iv.1 > hi && iv.0 < lo :: !valid_interval(s, iv)        \n  {\n    if s[hi] !in char_set {  \n      char_set := char_set + {s[hi]};\n      hi := hi + 1;\n      if hi - lo > n {  \n        n := hi - lo;\n        best_iv := (lo, hi);\n      }\n    } else {  \n      char_set := char_set - {s[lo]};\n      lo := lo + 1;\n    }\n  }\n}\nmethod lengthOfLongestSubstring'(s: string) returns (n: int, ghost best_iv: interval)\n  ensures valid_interval(s, best_iv) && length(best_iv) == n\n  ensures forall iv | valid_interval(s, iv) :: length(iv) <= n\n{\n  var lo, hi := 0, 0;\n  var char_to_index: map<char, int> := map[];  \n  n, best_iv := 0, (0, 0);        \n  while |s| - lo > n                    \n    decreases |s| - hi\n    invariant 0 <= lo <= hi <= |s|\n    invariant valid_interval(s, (lo, hi))\n    invariant forall i | 0 <= i < hi :: s[i] in char_to_index\n    invariant forall c | c in char_to_index ::\n      var i := char_to_index[c];  \n      0 <= i < hi && s[i] == c\n      && (forall i' | i < i' < hi :: s[i'] != c)  \n    invariant valid_interval(s, best_iv) && length(best_iv) == n\n    invariant forall iv: interval | iv.1 <= hi && valid_interval(s, iv) :: length(iv) <= n\n    invariant forall iv: interval | iv.1 > hi && iv.0 < lo :: !valid_interval(s, iv)\n  {\n    if s[hi] in char_to_index && char_to_index[s[hi]] >= lo {  \n      lo := char_to_index[s[hi]] + 1;\n    }\n    char_to_index := char_to_index[s[hi] := hi];\n    hi := hi + 1;\n    if hi - lo > n {\n      n := hi - lo;\n      best_iv := (lo, hi);\n    }\n  }\n}"
},
{
    "dafny": "method Main()\n{\n    var vazia: seq<int> := [];\n    var s := [1,2,3,4,5];\n    assert |s| == 5;\n    assert s[0] == 1;\n    assert s[1..3] == [2,3];\n    assert s[1..] == [2,3,4,5];\n    assert s[..3] == [1,2,3];\n    assert 1 in s;\n    assert 0 !in s;\n    assert [1,2] + [3,4] == [1,2,3,4];\n    assert vazia < s; \n    assert [1,2] < s; \n    assert [1,2,3,4,5] <= s; \n    assert s[2 := 0] == [1,2,0,4,5]; \n}"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} MutableMapTrait {\n  trait {:termination false} MutableMapTrait<K(==),V(==)> {\n    function content(): map<K, V>\n      reads this\n    method Put(k: K, v: V)\n      modifies this\n      ensures this.content() == old(this.content())[k := v]   \n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}\n      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}\n    function Keys(): (keys: set<K>)\n      reads this\n      ensures keys == this.content().Keys\n    predicate HasKey(k: K)\n      reads this\n      ensures HasKey(k) <==> k in this.content().Keys\n    function Values(): (values: set<V>)\n      reads this\n      ensures values == this.content().Values\n    function Items(): (items: set<(K,V)>)\n      reads this\n      ensures items == this.content().Items\n      ensures items == set k | k in this.content().Keys :: (k, this.content()[k])\n    function Select(k: K): (v: V)\n      reads this\n      requires this.HasKey(k)\n      ensures v in this.content().Values\n      ensures this.content()[k] == v\n    method Remove(k: K)\n      modifies this\n      ensures this.content() == old(this.content()) - {k}\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values\n    function Size(): (size: int)\n      reads this\n      ensures size == |this.content().Items|\n  }\n}"
},
{
    "dafny": "predicate exist1(a: array<int>, x:int)\nreads a\n{ exists m :: (0 <= m < a.Length) && (a[m] == x) && (!(exist2(a, x))) }\npredicate exist2(a: array<int>, x:int)\nreads a\n{ exists m :: 0 <= m < a.Length && exists n :: 0 <= n < a.Length && m != n && a[m] == x && a[n] == x}\npredicate tail(a: array<int>)\nreads a\n{ forall m :: ((0 <= m < a.Length-1) && (a[m] == 0)) ==> a[m+1] == 0 }\nmethod testExist1()\n{\n\tvar a: array<int> := new int[][3,3,1,0,0,0];\n\tassert a[0] == 3 && a[1] == 3 && a[2] == 1 && a[3] == 0 && a[4] == 0 && a[5] == 0;\n\tvar x: int := 1;\n\tassert exist1(a,x);\n\tx := 0;\n\tassert !exist1(a,x);\n\tx := 3;\n\tassert !exist1(a,x);\n\tx := 42;\n\tassert !exist1(a,x);\n}\nmethod testExist2()\n{\n\tvar a: array<int> := new int[][3,3,1,0,0,0];\n\tassert a[0] == 3 && a[1] == 3 && a[2] == 1 && a[3] == 0 && a[4] == 0 && a[5] == 0;\n\tvar x: int := 1;\n\tassert !exist2(a,x);\n\tx := 0;\n\tassert exist2(a,x);\n\tx := 3;\n\tassert exist2(a,x);\n\tx := 42;\n\tassert !exist2(a,x);\n}\nmethod testTail()\n{\n\tvar a: array<int> := new int[][3,3,1,0,0,0];\n\tassert a[0] == 3 && a[1] == 3 && a[2] == 1 && a[3] == 0 && a[4] == 0 && a[5] == 0;\n\tassert tail(a);\n\tvar b: array<int> := new int[][0,0];\n\tassert b[0] == 0 && b[1] == 0;\n\tassert tail(b);\n\tvar c: array<int> := new int[][];\n\tassert tail(c);\n\tvar d: array<int> := new int[][9,1,3,8,5];\n\tassert d[0] == 9 && d[1] == 1 && d[2] == 3 && d[3] == 8 && d[4] == 5;\n\tassert tail(d);\n\tvar e: array<int> := new int[][1,0,2];\n\tassert e[0] == 1 && e[1] == 0 && e[2] == 2;\n\tassert !tail(e);\n\tvar f: array<int> := new int[][0,1];\n\tassert f[0] == 0 && f[1] == 1;\n\tassert !tail(f);\n}"
},
{
    "dafny": "method MultipleReturns(n: int)\n  returns (j: int)\n  requires n > 0\n  ensures j >= 0\n{\n  var i := 0;\n  while i < n\n    invariant 0 <= i\n\tdecreases n - i\n  {\n    i := i+1;\n  }\n  return i;\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\r\n{\r\n\t(|pre| <= |str|) &&\r\n\tpre == str[..|pre|]\r\n}\r\npredicate isNotPrefixPred(pre:string, str:string)\r\n{\r\n\t(|pre| > |str|) ||\r\n\tpre != str[..|pre|]\r\n}\r\nlemma PrefixNegationLemma(pre:string, str:string)\r\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\r\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\r\n{}\r\nmethod isPrefix(pre: string, str: string) returns (res:bool)\r\n\tensures !res <==> isNotPrefixPred(pre,str)\r\n\tensures  res <==> isPrefixPred(pre,str)\r\n{\r\n\tif(|pre| > |str|)\n  {\n    return false;\n  }\n\tif(pre == str[0..|pre|])\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\r\npredicate isSubstringPred(sub:string, str:string)\r\n{\r\n\t(exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\r\n}\r\npredicate isNotSubstringPred(sub:string, str:string)\r\n{\r\n\t(forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\r\n}\r\nlemma SubstringNegationLemma(sub:string, str:string)\r\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\r\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\r\n{}\r\nmethod isSubstring(sub: string, str: string) returns (res:bool)\r\n\tensures  res <==> isSubstringPred(sub, str)\r\n{\r\n\tres := false;\n\tif |sub| > |str| \n\t{\n\t\treturn res;\n\t}\n\tvar lowerBound := 0;\n\twhile(lowerBound <= |str|)\n\t\tinvariant 0 <= lowerBound <= |str| + 1\n\t\tinvariant !res <==> forall i ::( 0 <= i < lowerBound ==> isNotPrefixPred(sub, str[i..]))\n\t\tdecreases |str| - lowerBound\n\t{\n\t\tvar prefResult := isPrefix(sub, str[lowerBound..]);\n\t\tif prefResult == true\n\t\t{\n\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t\tlowerBound := lowerBound + 1;\n\t}\n\treturn res;\n}\r\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\r\n{\r\n\texists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\r\n}\r\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\r\n{\r\n\tforall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\r\n}\r\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\r\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\r\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\r\n{}\r\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\r\n\tensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\r\n{\r\n\tfound := false;\n\tif |str1| < k || |str2| < k \n  {\n    return found;\n  }\n\tassert |str1| >= k && |str2| >= k;\n\tvar lowerBound := 0;\n\twhile((lowerBound + k) <= |str1|)\n\t\tinvariant lowerBound <= |str1| - k + 1\n\t\tinvariant !found <==> forall i, j :: (0 <= i < lowerBound && j == i + k  ==> isNotSubstringPred(str1[i..j], str2))\n\t\tdecreases |str1| - lowerBound\n\t{\n\t\tvar result := isSubstring(str1[lowerBound..lowerBound + k], str2);\n\t\tif result == true\n\t  {\n\t    found := true;\n\t\t\tbreak;\n\t  }\n\t\tlowerBound := lowerBound + 1;\n\t}\n  return found;\n}\r\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\r\n\trequires (|str1| <= |str2|)\r\n\tensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\r\n\tensures haveCommonKSubstringPred(len,str1,str2)\r\n{\r\n\tlen := |str1|;\n\twhile(len > 0)\n\t\tinvariant forall i :: (len < i <= |str1| ==> !haveCommonKSubstringPred(i, str1, str2))\n\t\tdecreases len\n\t{\n\t\tvar kSubsRes := haveCommonKSubstring(len, str1, str2);\n\t\tif kSubsRes == true\n\t\t{\n\t\t\treturn len;\n\t\t}\n\t\tlen := len - 1;\n\t}\n\tassert isPrefixPred(str1[0..0], str2[0..]); \n\treturn len;\n}"
},
{
    "dafny": "function fib(n: nat): nat\n{\n    if n == 0 then 0 else\n    if n == 1 then 1 else\n                    fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  \n{\n    var i: int := 0;\n        b := 0;\n    var c := 1;\n    while i < n\n        invariant 0 <= i <= n\n        invariant b == fib(i)\n        invariant c == fib(i + 1)\n    {\n        b, c := c, c + b;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "module ProtocolImpl {\n    export reveals *\n    export Spec provides ProtoT, Init\n    type ProtoT = bool\n    ghost predicate Init(p:ProtoT) { p }\n    method orange(i:nat) returns (j:nat)\n    {\n        j := i + 1;\n    }\n}\nmodule HostImpl {\n    export reveals *\n    export Spec provides HostT, foo, P\n    type HostT = int\n    function foo(h:HostT) : P.ProtoT\n    {\n        h != 0\n    }\n    method apple(i:nat) returns (j:nat)\n    {\n        j := i + 1;\n    }\n}\nmodule MainImpl {\n    export reveals *\n    export Spec provides Test, HISpec, PISpec\n    method Test(h1:HISpec.HostT, h2:HISpec.HostT)\n        requires HISpec.foo(h1) == HISpec.foo(h2)\n        requires PISpec.Init(HISpec.foo(h1))\n    {\n        var a := HI.foo(h1);\n        print \"HI.foo(h1) => \", a, \"\\n\";\n        var b := HI.foo(h2);\n        print \"HI.foo(h2) => \", b, \"\\n\";\n        var i := PI.orange(1);\n        print \"PI.orange(1) => \", i, \"\\n\";\n        var j := HI.apple(2);\n        print \"PI.apple(2) => \", j, \"\\n\";\n    }\n    method Main()\n    {\n        Test(-1, 1);\n    }\n}"
},
{
    "dafny": "module SequencesLite {\n  function Last<E>(run: seq<E>) : E\n    requires |run| > 0;\n  {\n    run[|run|-1]\n  }\n  function DropLast<E>(run: seq<E>) : seq<E>\n    requires |run| > 0;\n  {\n    run[..|run|-1]\n  }\n}"
},
{
    "dafny": "method Main()\n{\n    var ms0 : multiset<int> := multiset{};\n    var ms1 := multiset{1,1,1,2};\n    var ms2 := multiset{1,1};\n    assert |ms1| == 4;\n    assert ms1[1] == 3;\n    assert 1 in ms1;\n    assert 0 !in ms1;\n    assert ms1 == multiset{1,2,1,1};\n    assert ms1 != multiset{};\n    assert multiset{1,2} <= ms1;\n    assert ms1 + ms2 == multiset{1,1,1,1,1,2};\n    assert ms1 * ms2 == multiset{1,1};\n    assert ms1 - ms2 == multiset{1,2};\n    assert ms1[2:=0] == multiset{1,1,1};\n}"
},
{
    "dafny": "module MapComprehension {\n  method Main()\n  {\n    var a := map[2 := (3, 5), 3 := (5, 8)];\n    var one := map k | k in a :: k := a[k].0;\n    var two := map k | k in a :: a[k].0;\n    print one, \" =?= \", two;\n    assert one == two;\n  }\n}"
},
{
    "dafny": "method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n   requires 0 < y\n   ensures less < x < more\n{\n   more := x + y;\n   less := x - y;\n}\nmethod Main() {\n  var a: int;\n  var b: int;\n  a := 3;\n  b := 5;\n  var minus, plus := MultipleReturns(a, b);\n  print \"Minus: \" , minus, \" Plus: \", plus;\n}"
},
{
    "dafny": "class C { }\nfunction f(c: C): C\nfunction g(c: C): C\nfunction h(c: C, i: int): C\nmethod M(sc: set<C>)\n  ensures forall c | c in sc :: true || c == old(f(c))\n  ensures forall c | c in sc :: true || f(c) == old(f(f(c)))\n  ensures forall c | c in sc :: true || old(f(f(c))) == old(g(f(c))) || old(f(g(c))) == g(f(c)) || f(g(c)) == g(f(c))\n  ensures forall c | c in sc :: true || f(c) == old(g(f(c)))\n  ensures forall c | c in sc :: true || f(c) == old(f(c)) || old(g(f(c))) == g(f(c))\n{\n}"
},
{
    "dafny": "method abs (x: int) returns (y : int)\n    ensures true; \n{\n    if (x < 0) {\n        y := -x;\n    } else {\n        y :=  x;\n    }\n}\nmethod max (x: int, y: int) returns (m : int)\nrequires true;\nensures true;\n{\n    var r : int;\n    if ( x > y ) {\n        r := 0;\n    } else {\n        r := 1;\n    }\n    m := r;\n}\nmethod ex1 (n: int)\n    requires true\n    ensures true\n    decreases *\n{\n    var i := 0;\n    while (i < n)\n        invariant true;\n        decreases *;    \n    {\n        i := i + 1;\n    }\n}\nmethod find (a: seq<int>, key: int) returns (index : int)\nrequires true;\nensures true\n{\n    index := 0;\n    while (index < |a|)\n        invariant true ;\n        {\n            if ( a[index] == key ) { \n                return 0;\n            }\n            index := index + 2;\n        }\n    index := -10;\n}\npredicate sorted (a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\nmethod unique(a: seq<int>) returns (b: seq<int>) \n    requires sorted(a)\n    ensures forall k :: 0 <= k < |b| ==> b[k] in a\n    ensures forall k :: 0 <= k < |a| ==> a[k] in b\n    ensures sorted(b)\n    ensures forall k :: 0 <= k < |b|-1 ==> b[k] !in b[k+1..]\n{\n    if(|a| == 0) {\n        return [];\n    }\n    var i := 1;\n    b := [a[0]];\n    while i < |a| \n    decreases |a| - i\n    invariant 1 <= i <= |a|\n    invariant sorted(b)\n    invariant forall k :: 0 <= k < i ==> a[k] in b\n    invariant forall k :: 0 <= k < |b| ==> b[k] in a\n    invariant forall k :: (0 <= k < |b| - 1 ==> b[k] !in b[k+1..])\n    invariant a[i-1] == b[|b|-1];\n    {\n        if(a[i] != a[i-1]) {\n            b := b + [a[i]];\n        }\n        i := i + 1;\n    }\n}\nmethod Main() {\n    var r := find([], 1);   \n    print r, \"\\n\";\n    r := find([0,3,5,7], 5);  \n    print r, \"\\n\";\n    var s := unique([0,1,3,3,5,5,7]);\n    print s, \"\\n\";\n}"
},
{
    "dafny": "method flip (a: array?<int>, num: int)\nrequires a != null && a.Length > 0;\nrequires 0<= num <a.Length;\nmodifies a;\nensures multiset(old(a[..])) == multiset(a[..]);\nensures forall n:: 0 <= n <= num  ==> a[n] == old(a[num-n]);\nensures forall n:: num < n < a.Length ==> a[n] == old(a[n]);\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\n    decreases num - i;\n    invariant i + j ==num;\n    invariant 0 <= i <= num/2 + 1;\n    invariant num/2-1 <= j <=num;\n    invariant multiset(old(a[..])) == multiset(a[..]);\n    invariant forall n :: 0<= n <i ==> a[n] == old(a[num-n]);\n    invariant forall n:: num < n < a.Length ==> a[n] == old(a[n]);\n    invariant forall n :: 0<= n <i ==> a[num-n] == old(a[n]);\n    invariant forall n :: i<= n <= j ==> a[n] == old(a[n]); \n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}"
},
{
    "dafny": "function min(a: nat, b: nat): nat\n{\n    if a < b then a else b\n}\nmethod eat(number: nat, need: nat, remaining: nat) returns (totalEaten: nat, leftOver: nat)\n    requires number <= 1000\n    requires need <= 1000\n    requires remaining <= 1000\n    ensures totalEaten == min(number + need, number + remaining)\n    ensures leftOver == if number + need <= remaining then remaining - need else 0\n{\n    totalEaten := min(number + need, number + remaining);\n    if (number + need <= remaining) {\n        leftOver := remaining - need;\n    } else {\n        leftOver := remaining - min(number + need, remaining);\n    }\n}"
},
{
    "dafny": "method max(a: array<int>) returns (max: nat)\n  requires a != null && a.Length > 0;\n  requires forall j:: 0<=j<a.Length ==> a[j] >= 0;\n  ensures forall j:: 0<=j<a.Length ==> a[j] <= max;\n  ensures exists j:: 0<=j<a.Length && a[j]==max;\n{\n  max := 0;\n  var i := 0;\n  while (i < a.Length)\n    invariant 0 <= i <= a.Length;\n    invariant forall j:: 0<=j<i ==> a[j] <= max;\n    invariant i!=0 ==> exists j:: 0<=j<i && a[j]==max;\n    invariant i==0 ==> a[0] >= max;\n{\n \tif (a[i] > max) {\n\t  max := a[i]; \n    }\n     i := i + 1;\n  }\n}\nfunction product(a: array<int>): int\n    requires a!=null;\n\treads a;\n{\n  productAux(a,0,a.Length-1) \n}\nfunction productAux(a: array<int>, from:nat, to:int): int\n\trequires a!=null && to < a.Length; \n\treads a;\n\tdecreases to-from;\n{\n  if ( from > to )\n\tthen 1\n  else if ( from==to )\n\tthen a[to] \n\telse productAux(a,from,to-1) * a[to] \n}\nfunction productAuxAlt(a: array<int>, from:nat, to:int): int\n\trequires a!=null && to < a.Length; \n\treads a;\n \tdecreases to-from;\n{\n  if ( from > to )\n\tthen 1\n  else if ( from==to )\n\tthen a[to] \n\telse a[from] * productAuxAlt(a,from+1,to)   \n}\nghost method Lemma(a: array<int>, from:nat, to:int)\n   requires a!=null && to < a.Length;\n   ensures productAux(a,from,to) == productAuxAlt(a,from,to);\n   decreases to-from;\n { if (from>to)  {   }\n   else { if (from==to) { }\n          else {assume false; } }\n }\nmethod Product(a: array<int>)\n  returns (p: int)\n  requires a != null;\n  ensures p == product(a);\n{\n  var i := 0;\n  p := 1;\n  while (i < a.Length)\n\t\tinvariant 0 <= i <= a.Length;\n\t\tinvariant p == productAux(a,0,i-1);\n  {\n\t\tp := p * a[i];\n\t\ti := i + 1;\n  }\n}\nmethod ProductAlt(a: array<int>) returns (p: int)\n  requires a != null;\n  ensures p == product(a);\n{\n  var i := a.Length-1;\n  p := 1;\n  while (i >= 0)\n\t\t    invariant -1 <= i <= a.Length;\n\t\t\tinvariant p == productAuxAlt(a,i+1,a.Length-1);\n  {\n\t\tp := p * a[i];\n\t\ti := i - 1;\n  }\n  Lemma(a,0,a.Length-1);\n}"
},
{
    "dafny": "newtype uint8 = i:int | 0 <= i < 0x100\nnewtype uint32 = i:int | 0 <= i < 0x100000000\nclass C {\n  var x:uint8\n}\nmethod TestSeqOfClass() returns (s:seq<C>)\n{\n  return [];\n}\ntype fixed = t:seq<uint32> | |t| == 2 witness [0,0]\ntype buffer<T> = a:array?<T> | a == null || a.Length < 0x100000000\ntype buffer_t = buffer<uint8>\nmethod BoundedLength(s:seq<uint8>)\n  requires |s| < 10\n{\n  var x := |s| as uint32;\n  print x;\n}\nmethod BufferTest(b:buffer_t)\n  requires b != null\n{\n  var t := b[..];\n  print t;\n}\nmethod Test(name:string, b:bool)\n  requires b\n{\n  if b {\n    print name, \": This is expected\\n\";\n  } else {\n    print name, \": This is *** UNEXPECTED *** !!!!\\n\";\n  }\n}\nmethod Print(s:string) {\n   print s, \"\\n\";\n}\nmethod PrintTest() {\n  Print(\"Hello world!\");\n}\nmethod Basic() {\n  var s:seq<uint32> := [1, 2, 3, 4];\n  print \"Head second:\", s[1], \"\\n\";\n  var end := s[1..];\n  print \"Trunc first:\", end[0], \"\\n\";\n  Test(\"Head trunc\", end != s);\n  var start := s[..1];\n  var combine := start + end;\n  Test(\"Combine\", combine == s);\n  var s' := s[0 := 330];\n  Test(\"Replace1\", s[0] != 330);\n  Test(\"Replace2\", s[0] == 1);\n  var a := new uint32[3][12, 13, 14];\n  var a_seq := a[..];\n  a[0] := 42;\n  var a_seq' := a[..];\n  Test(\"Immutability\", a_seq != a_seq');\n}\nmethod ValueEquality() {\n  var m0:seq<uint32> := [1, 2, 3];\n  var m1:seq<uint32> := m0[1..];\n  var m2:seq<uint32> := [2, 3];\n  Test(\"ValueEquality\", m1 == m2);\n}\nmethod Contains() {\n  var m1:seq<uint32> := [1];\n  var m2:seq<uint32> := [1, 2];\n  var m3:seq<uint32> := [1, 2, 3];\n  var m3identical:seq<uint32> := [1, 2, 3];\n  var mm := [m1, m3, m1];\n  Test(\"Membership 1\", m1 in mm);\n  Test(\"Membership 2\", !(m2 in mm));\n  Test(\"Membership 3\", m3 in mm);\n  Test(\"Membership 3 value equality\", m3identical in mm);\n}\nmethod Main() {\n  Basic();\n  ValueEquality();\n  Contains();\n  PrintTest();\n  var c := TestSeqOfClass();\n}"
},
{
    "dafny": "abstract module Specification {\n  type Name(==)\n  type Date\n  const John: Name\n  const Mike: Name\n  const Susan: Name\n  const Mar25: Date\n  const Dec20: Date\n  class {:autocontracts} BirthdayBook {\n    var known: set<Name>\n    var birthday: map<Name, Date>\n    ghost predicate Valid() {\n      known == birthday.Keys\n    }\n    method AddBirthday(name: Name, date: Date)\n      requires name !in known\n      modifies this\n      ensures birthday == old(birthday)[name := date]\n    method ConsequenceOfAddBirthday(name: Name, date: Date)\n      requires name !in known\n    {\n      AddBirthday(name, date);\n      assert known == old(known) + {name};  \n      calc {\n        known;\n      ==  { assert Valid(); }  \n        birthday.Keys;\n      ==  \n        (old(birthday)[name := date]).Keys;\n      ==  \n        old(birthday).Keys + (map[name := date]).Keys;\n      ==  \n        old(birthday).Keys + {name};\n      == { assert old(Valid()); }  \n        old(known) + {name};\n      }\n    }\n    method FindBirthday(name: Name) returns (date: Date)\n      requires name in known\n      ensures unchanged(this)\n      ensures date == birthday[name]\n    method Remind(today: Date) returns (cards: set<Name>)\n      ensures unchanged(this)  \n      ensures cards == set n | n in known && birthday[n] == today\n    method ConsequenceOfRemind(today: Date, m: Name)\n    {\n      var cards := Remind(today);\n      assert m in cards <==> m in known && birthday[m] == today;\n    }\n    constructor Init()\n      ensures known == {}\n    method ConsequenceOfInit()\n    {\n      var bb := new BirthdayBook.Init();\n      assert bb.birthday == map[];\n    }\n  }\n}\nmodule Implementation refines Specification {\n  type Name = string\n  type Date = int\n  const John := \"John\"\n  const Mike := \"Mike\"\n  const Susan := \"Susan\"\n  const Mar25 := 325\n  const Dec20 := 1220\n  class BirthdayBook ... {\n    method AddBirthday...\n    {\n      known := known + {name};\n      birthday := birthday[name := date];\n    }\n    method FindBirthday(name: Name) returns (date: Date)\n    {\n      date := birthday[name];\n    }\n    method Remind(today: Date) returns (cards: set<Name>)\n    {\n      cards := set n | n in known && birthday[n] == today;\n    }\n    constructor Init...\n    {\n      known, birthday := {}, map[];\n      Repr := {this};\n    }\n  }\n}\nmethod Main() {\n  var bb := new Implementation.BirthdayBook.Init();\n  bb.AddBirthday(Implementation.John, Implementation.Mar25);\n  bb.AddBirthday(Implementation.Mike, Implementation.Dec20);\n  bb.AddBirthday(Implementation.Susan, Implementation.Dec20);\n  var f := bb.FindBirthday(Implementation.John);\n  assert f == Implementation.Mar25;\n  var cards := bb.Remind(Implementation.Dec20);\n  print \"Send cards to: \", cards, \"\\n\";\n}"
},
{
    "dafny": "method swap(x0: int, y0: int) returns (x: int,y: int)\n ensures y == x0 && x == y0;\n{\n     x := x0; y := y0; \n     assert x==x0 && y==y0;\n       assert y==y0 && x==x0;\n    var t := x;\n        assert y==y0 && t==x0;\n    x := y;\n        assert x==y0 && t==x0;\n    y := t;\n}"
},
{
    "dafny": "predicate isSorted(a: array<int>)\n  reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\nmethod binarySearch(a: array<int>, x: int) returns (index: int)\n    requires isSorted(a)\n    ensures -1 <= index < a.Length\n    ensures 0 <= index < a.Length ==> a[index] == x\n    ensures index == -1 ==> (forall i:: 0 <= i < a.Length ==> a[i] != x)\n{   \n    var low, high := 0, a.Length;\n    while low < high \n        decreases high - low\n        invariant 0 <= low <= high <= a.Length\n        invariant isSorted(a)\n        invariant forall i:: 0 <= i < low ==> a[i] < x \n        invariant forall i:: high <= i < a.Length ==> a[i] > x \n    {\n        var mid := low + (high - low) / 2;\n        if \n        {\n            case a[mid]  < x => low := mid + 1;\n            case a[mid]  > x => high := mid;\n            case a[mid] == x => return mid;\n        }\n    }\n    return -1;\n}\npredicate sorted(a: array<int>, from: nat, to: nat)\n  requires 0 <= from <= to <= a.Length\n  reads a\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j] \n}\nmethod insertionSort(a: array<int>)\n    modifies a\n    ensures isSorted(a)\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    var i := 0;\n    while i < a.Length \n        decreases a.Length - i\n        invariant 0 <= i <= a.Length\n        invariant forall m, n :: 0 <= m < n < i ==> a[m] <= a[n]\n        invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n        var j := i;\n        while j > 0 && a[j-1] > a[j]\n            decreases j\n            invariant 0 <= j <= i\n            invariant forall m, n :: 0 <= m < n < i+1 && n !=j ==> a[m] <= a[n]\n            invariant multiset(a[..]) == multiset(old(a[..]))\n        {\n            a[j-1], a[j] := a[j], a[j-1];\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method Search1000( a: array<int>, x: int ) returns ( k: int )\n    requires a.Length >= 1000;\n    requires forall p,q | 0 <= p < q < 1000 :: a[p] <= a[q];\n    ensures 0 <= k <= 1000;\n    ensures forall r | 0 <= r < k :: a[r] < x;\n    ensures forall r | k <= r < 1000 :: a[r] >= x;\n{\n    k := 0;\n    if a[500] < x   { k := 489;   }\n    if a[k+255] < x { k := k+256; }\n    if a[k+127] < x { k := k+128; }\n    if a[k+63] < x  { k := k+64;  }\n    if a[k+31] < x  { k := k+32;  }\n    if a[k+15] < x  { k := k+16;  }\n    if a[k+7] < x   { k := k+8;   }\n    if a[k+3] < x   { k := k+4;   }\n    if a[k+1] < x   { k := k+2;   }\n    if a[k] < x     { k := k+1;   }\n}\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\nmethod Search2PowLoop( a: array<int>, i: int, n: int, x: int ) returns ( k: int )\n    requires 0 <= i <= i+n <= a.Length;\n    requires forall p,q | i <= p < q < i+n :: a[p] <= a[q];\n    requires Is2Pow(n+1);\n    ensures i <= k <= i+n;\n    ensures forall r | i <= r < k :: a[r] < x;\n    ensures forall r | k <= r < i+n :: a[r] >= x;\n{\n    k := i;\n    var c := n;\n    while c != 0\n        decreases c;\n        invariant Is2Pow(c+1);\n        invariant i <= k <= k+c <= i+n;\n        invariant forall r | i <= r < k :: a[r] < x;\n        invariant forall r | k+c <= r < i+n :: a[r] >= x;\n    {\n        c := c/2;\n        if a[k+c] < x { k := k+c+1; }\n    }\n}\nmethod Search2PowRecursive( a: array<int>, i: int, n: int, x: int ) returns ( k: int )\n    decreases n;\n    requires 0 <= i <= i+n <= a.Length;\n    requires forall p,q | i <= p < q < i+n :: a[p] <= a[q];\n    requires Is2Pow(n+1);\n    ensures i <= k <= i+n;\n    ensures forall r | i <= r < k :: a[r] < x;\n    ensures forall r | k <= r < i+n :: a[r] >= x;\n{\n    if n==0 { return i; }\n    if a[i+n/2] < x\n    {\n        k := Search2PowRecursive(a,i+n/2+1,n/2,x);\n    }\n    else\n    {\n        k := Search2PowRecursive(a,i,n/2,x);\n    }\n}"
},
{
    "dafny": "function C(n: nat): nat \n    decreases n\n{\n    if n == 0 then 1 else (4 * n - 2) * C(n-1) / (n + 1) \n}\nmethod calcC(n: nat) returns (res: nat)\n    ensures res == C(n)\n{\n    var i := 0;\n    res := 1;\n  assert res == C(i) && 0 <= i <= n;\n    while i < n \n        decreases n - i \n        invariant res == C(i) && 0 <= i <= n \n    {\n      ghost var v0 := n - i;\n      assert res == C(i) && 0 <= i <= n && i < n && n - i == v0;\n        i := i + 1;\n        res := (4 * i - 2) * res / (i + 1);\n      assert res == C(i) && 0 <= i <= n && 0 <= n - i < v0;\n    }\n   assert res == C(i) && 0 <= i <= n && i >= n; \n}"
},
{
    "dafny": "predicate sorted(s: seq<int>){ forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j] }\npredicate sorted2(s: seq<int>){ 0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) && sorted2(s[1..]) }\nmethod ej2()\n{\n    var s := [1, 2, 3, 4, 5];\n    assert s[|s|-1] == 5; \n    assert s[|s|-1..|s|] == [5]; \n    assert s[1..] == [2, 3, 4, 5]; \n    assert s[..|s|-1] == [1, 2, 3, 4]; \n    assert s == s[0..] == s[..|s|] == s[0..|s|]; \n    assert [1,2,3] == [1] + [2,3];\n    assert s == s + [];\n    assert forall i :: 0 <= i <= |s| ==> s == s[..i] + s[i..];\n    var s2 := [1, 2, 3, 4, 5];\n    assert s2[..|s2|-1] == [1, 2, 3, 4]; \n    assert forall a: seq<int>, b: seq<int>, c: seq<int> :: (a + b) + c == a + (b + c);\n    assert 5 in s;\n    assert 0 !in s;\n    var p := [2,3,1,0];\n    var s3 := [1,2,3,4];\n    assert s3[2 := 6] == [1,2,6,4];\n    var a := new int[3]; \n    a[0], a[1], a[2] := 0, 3, -1;\n    var s4 := a[..];\n}"
},
{
    "dafny": "module A {\n    predicate P()\n    class C\n    {\n        static method{:axiom} M()\n            ensures P();\n    }\n}\nabstract module B {\n}\nabstract module C {\n}"
},
{
    "dafny": "abstract module S {\n  class C {\n    var f: int\n    ghost var g: int\n    var h: int\n    method m()\n      modifies this\n  }\n}\nmodule T refines S {\n  class C ... {\n    ghost var h: int  \n    ghost var j: int\n    var k: int\n    constructor () { }\n    method m()\n      ensures h == h\n      ensures j == j\n    {\n      assert k == k;\n    }\n  }\n}\nmethod Main() {\n  var c := new T.C();\n  c.m();\n}"
},
{
    "dafny": "method LongestCommonPrefix(str1: seq<char>, str2: seq<char>) returns (prefix: seq<char>)\n{\n  prefix := [];\n  var minLength := if |str1| <|str2| then |str1| else |str2|;\n  for idx:= 0 to minLength\n    invariant |prefix|==idx <=  minLength<=|str1| && minLength<=|str2|\n    invariant |prefix| <= |str1| && prefix == str1[0..|prefix|]&& |prefix| <= |str2| && prefix == str2[0..|prefix|]\n  {\n    if str1[idx] != str2[idx] {\n      return;\n    }\n    prefix := prefix + [str1[idx]];\n  }\n}"
},
{
    "dafny": "method Busca<T(==)>(a:array<T>, x:T) returns (r:int)\n  ensures 0 <= r ==> r < a.Length && a[r] == x\n  ensures r < 0 ==> forall i :: 0 <= i < a.Length ==> a[i] != x\n{\n    r :=0;\n    while r < a.Length\n      invariant 0 <= r <= a.Length\n      invariant forall i :: 0 <= i < r ==> a[i] != x\n    {\n        if a[r]==x\n        {\n            return;\n        }\n        r := r +  1;\n    }\n    r := -1;\n}"
},
{
    "dafny": "method Main()\n{\n    var s1: set<int> := {};\n    var s2 := {1,2,3};\n    assert {1,2} == {2,1};\n    assert {1,1,2,2,2,3} == s2; \n    assert s1 != s2;\n    assert 1 in s2;\n    assert 0 !in s2; \n    assert |s1| == 0; \n    assert {} < {1,2}; \n    assert {1,2} <= {1,2};\n    assert {1,2} > {1};\n    assert {1,2} >= {1,2};\n    var s3 := {1,2};\n    var s4 := {3,4};\n    assert s3 + s4 == {1,2,3,4};\n    assert s2 * s3 == {1,2};\n    assert s2 - s3 == {3};\n    assert s3 - s2 == {};\n    assert s3 !! s4;\n}"
},
{
    "dafny": "predicate permutation (A:seq<int>, B:seq<int>)\n{ multiset (A) == multiset (B)}\npredicate partOrdered (A:array<int>, lo:int, hi:int)\n\trequires A != null\n\trequires 0 <= lo <= hi <= A.Length\n\treads A\n{ forall i,j:: lo <= i < j < hi ==> A[i] <= A[j] }\npredicate ordered (A:array<int>)\n\trequires A != null\n\treads A\n\t{\n\t\tpartOrdered (A, 0, A.Length)\n\t}\nmethod selectionSort (A:array<int>)\n\trequires A != null\n\tmodifies A\n\tensures ordered(A)\n\tensures permutation (A[..], old(A[..]))\n{\n\tif A.Length > 1\n\t{\n\t\tvar i := A.Length-1;\n\t\twhile i >= 0\n\t\t\tinvariant -1 <= i < A.Length\n\t\t\tinvariant forall j, k:int :: 0 <= j <= i && i < k < A.Length ==> A[j] <= A[k]\n\t\t\tinvariant partOrdered (A, i+1, A.Length)\n\t\t\tinvariant permutation (A[..], old(A[..]))\n\t\t\tdecreases i - 0\n\t\t{\n\t\t\tselect (A, i);\n\t\t\ti := i-1;\n\t\t}\n\t}\n}\nmethod findMax (A:array<int>, lo:int, hi:int) returns (index:int)\n\trequires A != null \n\trequires 0 <= lo <= hi < A.Length\n\tensures lo <= index <= hi\n\tensures forall j:int :: (lo <= j <= hi) ==> A[index] >= A[j]\n{\n\tindex := hi ;\n\tvar i := hi-1 ;\n\twhile i >= lo\n\t\tinvariant lo-1 <= i <= hi \n\t\tinvariant i < index <= hi\n\t\tinvariant forall k:int :: (i < k <= hi) ==> (A[index] >= A[k])\n\t\tdecreases i - lo\n\t{\n\t\tif(A[i] > A[index])\n\t\t{\n\t\t\tindex := i ;\n\t\t}\n\t\ti := i-1 ;\n\t}\n} \nmethod select (A:array<int>, i:int)\n\trequires A != null && 0 <= i < A.Length\n\trequires partOrdered (A, i+1, A.Length)\n\trequires forall j,k :int :: 0 <= j <= i && i < k < A.Length ==> A[j] <= A[k]\n\tmodifies A\n\tensures forall j,k :int :: 0 <= j < i && i <= k < A.Length ==> A[j] <= A[k]\n\tensures partOrdered (A, i, A.Length)\n\tensures permutation (A[..], old(A[..]))\n{\n\tvar ind := findMax (A, 0, i) ;\n\tA[ind], A[i] := A[i], A[ind] ;\n}\nmethod Main ()\n{\n\tvar A:= new int[10];\n\tA[0],A[1],A[2],A[3],A[4],A[5],A[6],A[7],A[8],A[9] := \n\t4,8,8,3,5,10,9,9,4,7;\n\tprint \"A = \", A[..], \"\\n\";\n\tselectionSort (A);\n\tprint \"A = \", A[..], \"\\n\\n\";\n\tA[0],A[1],A[2],A[3],A[4],A[5],A[6],A[7],A[8],A[9] := \n\t4,-8,-8,3,5,10,-9,9,4,-7;\n\tprint \"A = \", A[..], \"\\n\";\n\tselectionSort (A);\n\tprint \"A = \", A[..], \"\\n\\n\";\n\tA[0],A[1],A[2],A[3],A[4],A[5],A[6],A[7],A[8],A[9] := \n\t8,8,8,8,8,8,8,8,8,8;\n\tprint \"A = \", A[..], \"\\n\";\n\tselectionSort (A);\n\tprint \"A = \", A[..], \"\\n\\n\";\n\tA[0],A[1],A[2],A[3],A[4],A[5],A[6],A[7],A[8],A[9] := \n\t1,2,3,4,5,6,7,8,9,10;\n\tprint \"A = \", A[..], \"\\n\";\n\tselectionSort (A);\n\tprint \"A = \", A[..], \"\\n\";\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && pre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t|pre| > |str| || !(pre == str[..|pre|])  \n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\npredicate isSubstringPred(sub:string, str:string) {\n\t|sub| <= |str| && |sub| > 0 &&\n\texists x :: 0 <= x <= (|str| - |sub|) && isPrefixPred(sub, str[x..])\n}\npredicate isNotSubstringPred(sub:string, str:string) {\n\t|sub| > |str| || |sub| <= 0 || \n\tforall x :: 0 <= x <= (|str| - |sub|) ==> isNotPrefixPred(sub, str[x..])\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string) {\n\t|str1| >= k && |str2| >= k && \n\texists x :: 0 <= x <= (|str1| - k) && isSubstringPred(str1[x..][..k], str2) \n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string) {\n\t|str1| < k || |str2| < k ||\n\tforall x :: 0 <= x <= (|str1| - k) ==> isNotSubstringPred(str1[x..][..k], str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==> haveNotCommonKSubstringPred(k,str1,str2)\n{}"
},
{
    "dafny": "predicate f(x: int)\npredicate g(x: int)\nmethod M() {\n  assert forall n :: n >= 0 || n < 0;\n  assert forall n {:nowarn} :: n >= 0 || n < 0;\n  assert forall n {:autotriggers false} :: n >= 0 || n < 0;\n  assert forall n: nat :: (n != 0) == f(n) || true;\n  assert forall n: nat {:nowarn} :: (n != 0) == f(n) || true;\n  assert forall n: nat {:autotriggers false} :: (n != 0) == f(n) || true;\n  assert forall n: nat :: f(n) == f(n+1) || g(n) || true;\n  assert forall n: nat {:nowarn} :: (n != 0) == f(n) || true;\n  assert forall n: nat {:autotriggers false} :: (n != 0) == f(n) || true;\n}"
},
{
    "dafny": "predicate VerifyCheckBlood(id: int, b: string, v: int, s: bool, \n  u: int, l: string, dn: string, de: string, o: bool) \n{\n  (b == \"A+\" || b == \"A-\"  || b == \"B+\" || b == \"B-\" || \n   b == \"AB+\" || b == \"AB-\" || b == \"O+\" || b == \"O-\") &&\n  id > 0 && v > 0 && u > 0 && l != \"\" && dn != \"\" && de != \"\" &&\n  (s == true || s == false) && o == false\n}\nmethod CheckBlood(id: int, b: string, v: int, s: bool, \n  u: int, l: string, dn: string, de: string) returns (o: bool, valid_blood: bool)\nensures valid_blood == VerifyCheckBlood(id, b, v, s, u, l, dn, de, o)\n{\n  o := false;\n  valid_blood := true;\n  if b != \"A+\" && b != \"A-\"  && b != \"B+\" && b != \"B-\" &&\n     b != \"AB+\" && b != \"AB-\" && b != \"O+\" && b != \"O-\" \n  {\n    valid_blood := false;\n  } else if id <= 0 || v <= 0 || u <= 0 || \n    l == \"\" || dn == \"\" || de == \"\" \n  {\n    valid_blood := false;\n  }\n  assert o == false;\n}"
},
{
    "dafny": "method SumMax(x:int, y:int) returns (s:int, m:int) \n requires x >= 0 && y >= 0\n ensures s == x + y\n ensures x <= m && y <= m\n ensures m == x || m == y\n{\n    s := x + y;\n    if x < y {\n        m := y;\n    } else {\n        m := x;\n    }\n}"
},
{
    "dafny": "method hasLowBlood(m: array<int>, val: int, key: int) returns (b: bool)\n\trequires m != null\n    ensures b <==> 0 <= key < m.Length && m[key] < val;\n{\n    if (0<= key < m.Length && m[key] < val)\n\t\t{\n    \treturn true;\n    }\n    return false;\n}\nmethod Test()\n{\n  var e:array<int> := new int[6];\n  e[0]:=2; e[1]:= 1; e[2]:=4;e[3]:= 1; e[4]:= 6; e[5] := 1;\n  var result := hasLowBlood(e,2, 1);\n  assert result == true;\n  result := hasLowBlood(e,3,2);\n  assert result == false;\n  result := hasLowBlood(e,1,5);\n  assert result == false;\n  result := hasLowBlood(e,1,6);\n  assert result == false;\n  var a:array<int> := new int[0];\n  result:= hasLowBlood(a,1,2);\n  assert result == false;\n}"
},
{
    "dafny": "method Multiply(N: int, M: nat) returns (R: int)\n  ensures R == M*N;\n  requires N>=0 && M>=0;\n{\n  var a := N;\n  var b := M;\n  var x := 0;\n  while (b > 0)\n  invariant b >= 0;\n  invariant M*N == x + a*b;\n  decreases b;\n  {\n    while (b % 10 != 0)\n    invariant b >= 0;\n    invariant M*N == x + a*b;\n    decreases b\n    {\n      x := x + a;\n      b := b - 1;\n    }\n    a := 10 * a;\n    b := b / 10;\n  }\n  R := x;\n}"
},
{
    "dafny": "method filled(a:array<int>, v:int, n:int) returns(s:bool)\n  requires n >= 0;\n  requires a != null && a.Length >= n;\n  ensures s == true ==> forall j :: 0 <= j < n ==> a[j] == v;\n  ensures s == false ==> exists j :: 0 <= j < n && a[j] != v;\n{\n  var i:int := 0;\n  s := true;\n  while(i<n)\n  invariant 0 <= i <= n;\n  invariant s == true ==> forall j :: 0 <= j < i ==> a[j] == v;\n  invariant s == false ==> exists j :: 0 <= j < i && a[j] != v;\n  {\n    if (a[i] != v) {\n      s := false;\n      break;\n    }\n    i:= i + 1;\n  }\n}"
},
{
    "dafny": "method Main() {\n  var a := new int[10];\n  var index := 6;\n  a[8] := 1;\n  a[index], index := 3, index+1;\n  assert a[6] == 3;\n  assert index == 7;\n  print index, \" \", a[6], a[7], a[8], \"\\n\";  \n  index, a[index] := index+1, 9;\n  assert index == 8;\n  assert a[7] == 9;\n  assert a[8] == 1; \n  expect a[8] == 1; \n  print index, \" \", a[6], a[7], a[8], \"\\n\";  \n  a[index+1], index := 7, 6;\n  assert a[9] == 7 && index == 6;\n  expect a[9] == 7 && index == 6;\n  var o := new F(2);\n  var oo := o;\n  print o.f, \" \", oo.f, \"\\n\";\n  assert o.f == 2;\n  assert oo.f == 2;\n  var ooo := new F(4);\n  o.f, o := 5, ooo;\n  print o.f, \" \", oo.f, \"\\n\";\n  assert o.f == 4;\n  assert oo.f == 5;\n  var oooo := new F(6);\n  o, o.f := oooo, 7;\n  assert o.f == 6;\n  assert ooo.f == 7;\n  expect ooo.f == 7;  \n  print o.f, \" \", ooo.f, \"\\n\";\n  var aa := new int[9,9];\n  var j := 4;\n  var k := 5;\n  aa[j,k] := 8;\n  j, k, aa[j,k] := 2, 3, 7;\n  print j, \" \", k, \" \", aa[4,5], \" \", aa[2,3], \"\\n\"; \n  assert aa[4,5] == 7;\n  expect aa[4,5] == 7; \n  j, aa[j,k], k := 5, 6, 1;\n  assert j == 5 && aa[2,3] == 6 && k == 1;\n  expect j == 5 && aa[2,3] == 6 && k == 1; \n  aa[j,k], k, j := 5, 6, 1;\n  assert j == 1 && aa[5,1] == 5 && k == 6;\n  expect j == 1 && aa[5,1] == 5 && k == 6;\n}\nclass F {\n  var f: int\n  constructor (f: int) ensures this.f == f { this.f := f; }\n}"
},
{
    "dafny": "type T = int \npredicate isSorted(a: seq<T>) \n{\n    forall i, j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}\nmethod binarySearch(a: array<T>, x: T) returns (index: int) \n    requires isSorted(a[..])\n    ensures 0 <= index <= a.Length \n    ensures index < a.Length ==> a[index] >= x\n    ensures index > 0 ==> a[index-1] <= x\n{\n    var low, high := 0, a.Length;\n    while low < high \n        decreases high - low\n        invariant 0 <= low <= high <= a.Length\n        invariant forall k :: 0 <= k < low ==> a[k] < x\n        invariant forall k :: high <= k < a.Length ==> a[k] > x\n    {\n        var mid := low + (high - low) / 2;\n        if {\n            case a[mid] < x => low := mid + 1;\n            case a[mid] > x => high := mid;\n            case a[mid] == x => return mid;\n        }\n    }\n    return low;\n}\nmethod testBinarySearch() \n{\n    var a := new int[2] [1, 3];\n    var id0 := binarySearch(a, 0);\n    assert id0 == 0;\n    var id1 := binarySearch(a, 1);\n    assert id1 in {0, 1};\n    var id2 := binarySearch(a, 2);\n    assert id2 == 1;\n    var id3 := binarySearch(a, 3);\n    assert id3 in {1, 2};\n    var id4 := binarySearch(a, 4);\n    assert id4 == 2;\n}"
},
{
    "dafny": "method Min(arr : array?< int >) returns (min : int )\nrequires arr != null && arr.Length > 0;\nensures forall k :: (0 <= k < arr.Length) ==> (arr[k] >= min);\n{\n  var i := 1;\n  min := arr[0];\n  while (i < arr.Length)\n    decreases arr.Length - i;\n    invariant i < arr.Length + 1 ;\n    invariant i > 0 ==> min <= arr[i-1] ;\n    invariant arr != null && arr.Length > 0;\n    invariant forall k :: 0 <= k < i ==> min <= arr[k];\n  {\n    if (arr[i] < min)\n       {min := arr[i];}\n       i := i +1;\n  }\n}"
},
{
    "dafny": "method Q3(n0 : int, m0 : int) returns (res : int)\n  ensures res == m0 * n0;\n{\n  var n, m : int;\n  res := 0;\n  if (n0 >= 0)\n       {n,m := n0, m0;}\n  else\n       {n,m := -n0, -m0;}\n  while (0 < n)\n  decreases n\n  invariant m0 * n0 == res + (m * n);\n  {\n    res := res + m;\n    n := n - 1;\n  }\n}"
},
{
    "dafny": "newtype smallPrime = x: int | x in {2, 3, 5, 7} witness 2\nfunction posId(x: smallPrime): smallPrime {\n  x\n}\nmethod posIdMeth(x: smallPrime) returns (r: int)\n  ensures r > 0\n{\n  r := posId(x) as int;\n}\nabstract module AM1\n{\n  trait T2\n  {\n    method Calc(i:int, j:int) returns (k:int)\n  }\n  class T2Client extends T2\n  {\n    method Calc(ii:int, jj:int) returns (kk:int)\n  }\n}"
},
{
    "dafny": "class Sort\n{\n  var a: array<int>;\n  predicate Valid()\n  reads this;\n  {\n    a != null\n  }\n  constructor (input: array<int>)\n  requires input != null;\n  ensures Valid();\n  modifies this;\n  ensures a == input;\n  {\n    a := input;\n  }\n  predicate sorted(a: array<int>, l: int, u: int)\n  reads a\n  requires a != null\n  {\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]\n  }\n  predicate partitioned(a: array<int>, i: int)\n  reads a\n  requires a != null\n  {\n    forall k, k' :: 0 <= k <= i < k' < a.Length ==> a[k] <= a[k']\n  }\n  method BubbleSort()\n  requires Valid(); ensures Valid();\n  modifies a\n  requires a != null\n  ensures sorted(a, 0, a.Length-1)\n  {\n    var i := a.Length - 1;\n    while(i > 0)\n      invariant i < 0 ==> a.Length == 0 \n      invariant sorted(a, i, a.Length-1)\n      invariant partitioned(a, i)\n      {\n        var j := 0;\n        while (j < i)\n          invariant 0 < i < a.Length && 0 <= j <= i\n          invariant sorted(a, i, a.Length-1)\n          invariant partitioned(a, i)\n          invariant forall k :: 0 <= k <= j ==> a[k] <= a[j]\n          {\n            if(a[j] > a[j+1])\n              {\n                a[j], a[j+1] := a[j+1], a[j];\n              }\n              j := j + 1;\n          }\n          i := i - 1;\n      }\n  }\n}\nmethod main (){\n    var a := new int[5];\n    a[0], a[1], a[2], a[3], a[4] := 20190211, 20200120, 20191203, 20191127, 20200101;\n    assert a[0] == 20190211;\n    assert a[1] == 20200120;\n    assert a[2] == 20191203;\n    assert a[3] == 20191127;\n    assert a[4] == 20200101;\n    var sort := new Sort(a);\n    assert sort.a[0] == 20190211;\n    assert sort.a[1] == 20200120;\n    assert sort.a[2] == 20191203;\n    assert sort.a[3] == 20191127;\n    assert sort.a[4] == 20200101;\n    assert sort.a.Length == 5;\n    assert !sort.sorted(sort.a, 0, sort.a.Length - 1);\n    sort.BubbleSort();  \n    assert sort.sorted(sort.a, 0, sort.a.Length - 1);\n    var a1 := new int[5];\n    a1[0], a1[1], a1[2], a1[3], a1[4] := 20130111, 20100913, 20210203, 20191230, 20200101;\n    assert a1[0] == 20130111;\n    assert a1[1] == 20100913;\n    assert a1[2] == 20210203;\n    assert a1[3] == 20191230;\n    assert a1[4] == 20200101;\n    var sort1 := new Sort(a1);\n    assert sort1.a[0] == 20130111;\n    assert sort1.a[1] == 20100913;\n    assert sort1.a[2] == 20210203;\n    assert sort1.a[3] == 20191230;\n    assert sort1.a[4] == 20200101;\n    assert sort1.a.Length == 5;\n    assert !sort1.sorted(sort1.a, 0, sort1.a.Length - 1);\n    sort1.BubbleSort();  \n    assert sort1.sorted(sort1.a, 0, sort1.a.Length - 1);\n}"
},
{
    "dafny": "method Main() {\n  Int8Test();\n  Int16Test();\n  BvTests();\n}\nnewtype {:nativeType \"sbyte\"} int8 = x | -0x80 <= x < 0x80\nnewtype {:nativeType \"short\"} int16 = x | -0x8000 <= x < 0x8000\nmethod Int8Test() {\n  var a, b := 20, 30;\n  var r0 := MInt8(a, b);\n  var r1 := MInt8(b, a);\n  var r2 := MInt8(-2, b);\n  print a, \" \", b, \"\\n\";\n  print r0, \" \", r1, \" \", r2, \"\\n\";\n}\nmethod MInt8(m: int8, n: int8) returns (r: int8) {\n  if m < 0 || n < 0 {\n    r := 18;\n  } else if m < n {\n    r := n - m;\n  } else {\n    r := m - n;\n  }\n}\nmethod Int16Test() {\n  var a, b := 20, 30;\n  var r0 := MInt16(a, b);\n  var r1 := MInt16(b, a);\n  var r2 := MInt16(-2, b);\n  print a, \" \", b, \"\\n\";\n  print r0, \" \", r1, \" \", r2, \"\\n\";\n}\nmethod MInt16(m: int16, n: int16) returns (r: int16) {\n  if m < 0 || n < 0 {\n    r := 18;\n  } else if m < n {\n    r := n - m;\n  } else {\n    r := m - n;\n  }\n}\nmethod BvTests() {\n  var a: bv8 := 250;\n  a := a + 6;\n  assert a == 0;\n  var b: bv7 := 126;\n  b := b + 5;\n  assert b == 3;\n  var c: bv16 := 0xfffa;\n  c := c + 10;\n  assert c == 4;\n  var d: bv15 := 0x7ffb;\n  d := d + 6;\n  assert d == 1;\n  print a, \" \", b, \" \", c, \" \", d, \"\\n\";\n}"
},
{
    "dafny": "function is_drng(n: int, der: seq<int>): bool\n  requires n > 1\n{\n    |der| == n &&\n    forall i :: (0 <= i < n) ==> (der[i] != i && 0 <= der[i] < n)\n}\nfunction same_len(der_list: seq<seq<int>>): bool\n{\n    forall i, j :: \n        (0 <= i < |der_list| && 0 <= j < |der_list|) ==> \n            |der_list[i]| == |der_list[j]|\n}\nfunction uniq_list(lst: seq<seq<int>>): bool\n{\n    forall i, j :: \n        (i != j && 0 <= i < |lst| && 0 <= j < |lst|) ==>\n            lst[i] != lst[j]\n}\nfunction diff_index(n : int, d1: seq<int>, d2: seq<int>, i: int): int\n    requires n > 1;\n    requires is_drng(n, d1);\n    requires is_drng(n, d2);\n    requires 0 <= i < |d1|;\n    requires d1[i..] != d2[i..];\n    ensures i <= diff_index(n, d1, d2, i) < |d1| && \n            d1[diff_index(n, d1, d2, i)] != d2[diff_index(n, d1, d2, i)];\n    decreases |d1| - i;\n{\n    if (d1[i] != d2[i]) \n        then i\n        else diff_index(n, d1, d2, i+1)\n}\nfunction extension(der: seq<int>, c: int): seq<int>\n  requires |der| > 1;\n  requires is_drng(|der|, der);\n  requires 0 <= c < |der|\n  ensures is_drng(|der|+1, extension(der, c));\n{\n  var extn := der + [|der|];\n  extn[|der| := extn[c]][c := |der|]\n}\nlemma extensions_differ_l(der1: seq<int>, der2: seq<int>, c: int)\n  requires |der1| > 1;\n  requires |der2| > 1;\n  requires |der1| == |der2|;\n  requires is_drng(|der1|, der1);\n  requires is_drng(|der2|, der2);\n  requires 0 <= c < |der1|;\n  requires 0 <= c < |der2|;\n  requires der1 != der2;\n  ensures extension(der1, c) != extension(der2, c);\n{\n  var e1 := extension(der1, c);\n  var e2 := extension(der2, c);\n  var len := |der1|;\n  var i := diff_index(len, der1, der2, 0);\n  assert i < len;\n  assert (i == c) ==> e1[len] != e2[len];\n  assert (i != c) ==> e1[i] != e2[i];\n}\nlemma extensions_differ_r(der: seq<int>, c1: int, c2:int)\n  requires |der| > 1;\n  requires is_drng(|der|, der);\n  requires 0 <= c1 < |der|;\n  requires 0 <= c2 < |der|;\n  requires c1 != c2;\n  ensures extension(der, c1) != extension(der, c2);\n{\n  var e1 := extension(der, c1);\n  var e2 := extension(der, c2);\n  assert (c1 != |der| && c2 != |der|) ==> e1[c1] != e2[c1];\n}\nlemma extensions_differ_lr(der1: seq<int>, der2: seq<int>, c1: int, c2:int)\n  requires |der1| > 1;\n  requires |der2| > 1;\n  requires |der1| == |der2|;\n  requires is_drng(|der1|, der1);\n  requires is_drng(|der2|, der2);\n  requires 0 <= c1 < |der1|;\n  requires 0 <= c2 < |der2|;\n  requires der1 != der2 || c1 != c2;\n  ensures extension(der1, c1) != extension(der2, c2);\n{\n  var e1 := extension(der1, c1);\n  var e2 := extension(der2, c2);\n  var len := |der1|;\n  if (der1 != der2 && c1 == c2) {\n    extensions_differ_l(der1, der2, c1);\n  } else if (der1 == der2 && c1 != c2) {\n    extensions_differ_r(der1, c1, c2);\n  } else if (der1 != der2 && c1 != c2) {\n    assert e1[c1] == len;\n    assert e1[c2] != len;\n    assert e2[c2] == len;\n    assert e1 != e2;\n  } else {\n    assert false;\n  }\n}"
},
{
    "dafny": "method Main()\n{\n    var a := new int[5];\n    var i := 0;\n    forall i | 0 <= i < a.Length\n    {\n        a[i] := 0;\n    }\n    var v := a[3];\n    assert v == 0;\n}"
},
{
    "dafny": "type Id(==)\nghost function F(s: set<Id>): int\nlemma Test(x: Id)\n{\n  var X := {x};\n  var a := map i | i <= X :: F(i);\n  var b := map[{} := F({}), X := F(X)];\n  assert a.Keys == b.Keys by {  \n    forall i\n      ensures i in a.Keys <==> i in b.Keys\n    {\n      calc {\n        i in a.Keys;\n      ==\n        i <= X;\n      ==  { assert i <= X <==> i == {} || i == X; }\n        i in b.Keys;\n      }\n    }\n  }\n}"
},
{
    "dafny": "module A {\n  export Specf provides T, f\n  export Bodyg provides T, g\n  export SpecF provides T, F\n  export BodyG provides T, G\n  type T = T2\n  datatype T2 = C(x: T2) | N\n  ghost function f(x: T, y: int): T { if y <= 0 then x else f(x, y-1) }\n  ghost function g(x: T): T\n   decreases x\n   { match x\n     case C(x') => g(x')\n     case N => x\n   }\n  method F(x: T, y: int) {\n    if (y > 0) {\n       F(x, y-1);\n    }\n  }\n  method G(x: T)\n  decreases x\n  {\n    match (x) {\n       case C(x') =>\n            G(x');\n       case N =>\n           assert true;\n    }\n  }\n}\nmodule B {\n  ghost function h(x: A.T): A.T { A.f(x, 1) }\n}\nmodule C {\n  ghost function i(x: A.T): A.T { A.g(x) }\n}\nmodule D {\n  method H(x: A.T) {\n     A.F(x, 2);\n  }\n}\nmodule E {\n  method I(x: A.T) {\n    A.G(x);\n  }\n}"
},
{
    "dafny": "method Main()\n{\n    var s1: set<int> := {};\n    var s2 := {1,2,3};\n    assert {1,2} == {2,1};\n    assert {1,1,2} == {1,2};\n    assert s2 != s1;\n    assert |s1| == 0;\n    assert |s2| == 3;\n    assert 1 in s2;\n    assert 0 !in s1;\n    assert {1} <= {1,2};\n    assert {} < {1,2};\n    assert {1,2} >= {1,2};\n    assert {1,2} > {};\n    assert {1,2} !! {3,4};\n    assert {1,2} + {2,3,4} == {1,2,3,4};\n    assert {1,2} * {2,3,4} == {2};\n    assert {1,2,3} - {1,2} == {3};\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n    ensures 0 <= y\n    ensures x >= 0 ==> y == x\n    ensures x < 0 ==> y == -x\n{\n    if x < 0 {\n        return -x;\n    } else {\n        return x;\n    }\n}\nmethod Testing()\n{\n    var v: int := Abs(3);\n    assert 0 <= v;\n    assert v == 3;\n    var z: int := Abs(-3);\n    assert z >= 0;\n    assert z == 3;\n}"
},
{
    "dafny": "method isPrefix(pre: string, str: string) returns (res: bool)\n  requires |pre| <= |str|;  \n{\n  if (|pre| == 0) {\n    return true;\n  }\n  var i: nat := 0;\n  var a: char;\n  var b: char;\n  while (i < |pre|)\n    decreases |pre| - i;\n    invariant 0 <= i <= |pre|\n  {\n    a := pre[i];\n    b := str[i];\n    if (a != b) {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\nmethod isSubstring(sub: string, str: string) returns (res: bool)\n  requires |sub| <= |str|; \n{\n  if (|sub| == 0){\n    return true;\n  }\n  var i: nat := 0;\n  while (i <= (|str| - |sub|))\n    decreases |str| - |sub| - i;\n    invariant 0 <= i;\n    invariant i <= (|str| - |sub|) + 1;\n  {\n    var slice: string := str[i..];\n    var subIsPrefixOfSlice: bool := isPrefix(sub, slice);\n    if (subIsPrefixOfSlice) {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n  ensures (k > |str1| || k > |str2|) ==> found == false;\n  ensures found == true ==> (k <= |str1| && k <= |str2|);\n{\n  var candidate: string;\n  var i: nat := 0;\n  var isASubstring: bool;\n  if (k == 0) {\n    return true;\n  }\n  if (k > |str1| || k > |str2|) {\n    return false;\n  }\n  while (i <= |str1| - k)\n    decreases |str1| - k - i;\n    invariant i <= i+k-1;\n  {\n    candidate := str1[i..i+k-1];\n    isASubstring := isSubstring(candidate, str2);\n    if (isASubstring) {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\nmethod maxKCommonSubString(str1: string, str2: string) returns (k: nat)\n  ensures k <= |str1| && k <= |str2|;\n  ensures (|str1| == 0 || |str2| == 0 ) ==> k == 0;\n{\n  var shorter: string;\n  var longer: string;\n  var thereIsACommonSubstring: bool := false;\n  k := 0;\n  if (|str1| <= |str2|) {\n    shorter := str1;\n    longer := str2;\n  } else {\n    shorter := str2;\n    longer := str1;\n  }\n  while (k <= |shorter|)\n    decreases |shorter| - k;\n  {\n    thereIsACommonSubstring := haveCommonKSubstring(k, shorter, longer);\n    if (!thereIsACommonSubstring) {\n        break;\n    }\n    k := k + 1;\n  }\n  return 0;\n}"
},
{
    "dafny": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n    decreases shrink\n    invariant shrink + grow == numbers\n    invariant grow !! shrink\n    invariant count == |set i | i in grow && i < threshold|\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n    assert (set i | i in grow' && i < threshold) ==\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}"
},
{
    "dafny": "method ifelseifelse(x : int) returns (result : int)\n  ensures result > 0\n  requires x > 0\n{\n  if(x == 3){\n    result :=4 ;\n  }\n  else if(x == 4){\n    result := 5;\n  }\n  else{\n    result := 6;\n  }\n  assert result > 0;\n  return result;\n}\nmethod Main(){\n  var z1 :=3;\n  assert z1 == 3;\n  var result1 := ifelseifelse(z1);\n  print result1;\n}"
},
{
    "dafny": "method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  ensures more == x+y\n  ensures less == x-y\n{\n  more := x + y;\n  less := x - y;\n}\nmethod TestMethod() {\n  var more, less := MultipleReturns(9,3);\n  print(\"Test 1: MultipleReturns(9,3) = \", more, \",\", less, \"\\n\");\n  more, less := MultipleReturns(100,25);\n  print(\"Test 2: MultipleReturns(100,25) = \", more, \",\", less, \"\\n\");\n  more, less:= MultipleReturns(-4,2);\n  print(\"Test 3: MultipleReturns(-4,2) = \", more, \",\", less, \"\\n\");\n  more, less:= MultipleReturns(10,-5);\n  print(\"Test 4: MultipleReturns(10,-5) = \", more, \",\", less, \"\\n\");\n  more, less:= MultipleReturns(0,0);\n  print(\"Test 5: MultipleReturns(0,0) = \", more, \",\", less, \"\\n\");\n}\nmethod Main() {\n  TestMethod();\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n    ensures y >= 0\n    requires x < 0\n{\n    return -x;\n}\nmethod TestBench()\n{\n    var minusFive := Abs(-5);\n    assert 0 <= minusFive;\n}"
},
{
    "dafny": "method plus_one (x: int) returns (r:int)\n  requires x >= 0;\n  ensures r == x + 1;\n{return x+1;}\nmethod add_by_one (x:int, y:int) returns (r:int)\n{\n  assume (y >= 0);\n  var i:int := 0;\n  r := x;\n  assert (i <= y);\n  assert (r == x + i);\n  r := *;\n  i := *;\n  assume (i <= y);\n  assume (r == x + i);\n  if (i < y)\n  {\n    assume (i < -2);\n    var t := y - i;\n    r := r + 1;\n    i := i + 1;\n    assert (i <= y);\n    assert (r == x + i);\n    assert (y-i >= 0);\n    assert (y-i < t);\n    assume (false);\n  }\n  assert (r == x + y);\n  return r;\n}"
},
{
    "dafny": "datatype Tree<Data> = Nil | Leaf(key: int, value: Data)\n\t\t| Tree(key: int, value: Data, left: Tree, right: Tree)\ndatatype Option<T> = None | Some(T) \nfunction LookUp<Data>(key: int, t: Tree): Option<Data> \n{\n\tmatch t\n\tcase Nil => None\n\tcase Leaf(k, v) => if k == key then Some(v) else None\n\tcase Tree(k, v, l, r) => if k == key then Some(v)\n\t\telse if key < k then LookUp(key, l) else LookUp(key, r)         \n}\nfunction Add<Data>(key: int, value: Data, t: Tree): Tree\n{\n\tmatch t\n    case Nil => Leaf(key, value)\n\tcase Leaf(k, v) => if k == key then Leaf(k, value) \n                       else if key < k then Tree(k,v,Leaf(key, value), Nil) \n                           else Tree(k, v, Nil, Leaf(key, value)) \n    case Tree(k, v, l, r) => if k == key then Tree(k, value, l, r)\n                             else if key < k then Tree(k, v, Add(key, value, l), r)\n                                  else Tree(k, v, l, Add(key, value, r))\n}\npredicate Ordered<Data>(t: Tree<Data>) {\n    match t\n    case Nil => true\n    case Leaf(_, _) => true\n    case Tree(k, _, l, r) => (l != Nil ==> k > l.key && Ordered(l)) && \n                             (r != Nil ==> k < r.key && Ordered(r))\n}\nlemma AddLemma<Data>(k: int, v: Data, t:Tree<Data>)\n    requires Ordered(t)\n    ensures Ordered(Add(k,v,t))\n{}"
},
{
    "dafny": "function max(x:nat, y:nat) : nat\n{\n  if (x < y) then y else x\n}\nmethod slow_max(a: nat, b: nat) returns (z: nat)\n  ensures z == max(a, b);\n{\n  z := 0;\n  var x := a;\n  var y := b;\n  while (z < x && z < y)\n    invariant 0 <= x <= a;\n    invariant 0 <= y <= b;\n    invariant z == a-x || z == b-y;\n    invariant a-x == b-y;\n    decreases x - z;\n    decreases y - z;\n  {\n    z := z + 1;\n    x := x - 1;\n    y := y - 1;\n  }\n if (x <= y) { return b; }\n else { return a;}\n}"
},
{
    "dafny": "function F(n: nat): nat { if n <= 2 then n else F(n-1) + F(n-3)}\nmethod calcF(n: nat) returns (res: nat)  \n ensures res == F(n) \n{\n  var a, b, c := 0, 1, 2;\n  var i := 0;\n  assert a == F(0) && b == F(1) && c == F(2); \n  while i < n \n  decreases n - i\n  invariant 0 <= i <= n\n  invariant a == F(i) && b == F(i + 1) && c == F(i + 2)\n  {\n    a, b, c := b, c, a + c;        \n    i := i + 1;\n\tassert 0 <= i <= n && a == F(i) && b == F(i + 1) && c == F(i + 2);\n  }\n  res := a;\n  assert (a == F(i) && b == F(i + 1) && c == F(i + 2)) ==> res == F(n);\n}"
},
{
    "dafny": "function OnId(f : (bool -> bool) -> int) : int\n  reads f.reads(x => x);\n  requires f.requires(y => y);\n{\n  f(z => z)\n}\nmethod Equal() {\n  var id1 : bool -> bool := x => x;\n  var id2                := y => y;\n  assert forall x :: id1(x) == id2(x);\n  assert id1 == id2;\n}\nmethod K<A,B>(P : (A -> A) -> bool)\n  requires P.requires(x => x);\n  requires P(y => y);\n{\n  assert P(z => z);\n  assert (x => y => x) == ((a : A) => (b : B) => a);\n}"
},
{
    "dafny": "lemma EcCuadDiv2_Lemma (x:int)\n    requires x >= 1 \n    ensures (x*x + x) % 2 == 0\n{\n    if x != 1 { \n        EcCuadDiv2_Lemma(x-1);\n        assert x*x+x == ((x-1)*(x-1) + (x-1)) + 2*x;\n    }\n}\nlemma EcCubicaDiv6_Lemma (x:int)\n    requires x >= 1\n    ensures (x*x*x + 3*x*x + 2*x) % 6 == 0\n{\n    if x>1 {\n        EcCubicaDiv6_Lemma(x-1);\n        assert (x*x*x - 3*x*x + 3*x -1 + 3*x*x - 6*x + 3 + 2*x -2) % 6 == 0; \n        assert (x*x*x - x) % 6 == 0; \n        assert x*x*x + 3*x*x + 2*x == (x*x*x - x) + 3*(x*x + x);\n        EcCuadDiv2_Lemma(x);\n    }\n}\nlemma cubEven_Lemma (x:int)\n    requires (x*x*x + 5) % 2 == 1\n    ensures x % 2 == 0\n{\n    if x%2 == 1 {\n        var k := (x-1)/2;\n        assert x*x*x + 5 == (2*k+1)*(2*k+1)*(2*k+1) + 5\n                == 8*k*k*k + 12*k*k + 6*k + 6\n                == 2*(4*k*k*k + 6*k*k + 3*k + 3);\n        assert false;\n    }\n}\nlemma perfectCube_Lemma (x:int)\n    ensures exists z :: (x*x*x == 3*z || x*x*x == 3*z + 1 || x*x*x == 3*z - 1);\n{\n    if x%3 == 0 {\n        var k := x/3;\n        assert x*x*x == 27*k*k*k == 3*(9*k*k*k);\n    }\n    else if x%3 == 1 {\n        var k := (x-1)/3;\n        assert x*x*x == (3*k+1)*(3*k+1)*(3*k+1) == 27*k*k*k + 27*k*k + 9*k + 1;\n        assert x*x*x == 3*(9*k*k*k + 9*k*k + 3*k) + 1;\n    }\n    else {\n        var k := (x-2)/3;\n        assert x*x*x == (3*k+2)*(3*k+2)*(3*k+2) == 27*k*k*k + 54*k*k + 36*k + 8;\n        assert x*x*x == 3*(9*k*k*k + 18*k*k + 12*k + 3) - 1;\n    }\n}\nfunction exp(x:int, e:nat):int\n{\n    if e == 0 then 1 else x * exp(x,e-1)\n}\nlemma expGET1_Lemma(x:int, e:nat)\t\t\t\n    requires x >= 1 \n    ensures exp(x,e) >= 1\n{}\nlemma prodMon_Lemma(z:int, a:int, b:int)\n    requires z >= 1 && a >= b >= 1\n    ensures  z*a >= z*b\n{}\nlemma expMon_Lemma(x:int, n:nat)\n\trequires x >= 1 && n >= 1\n\tensures exp(x+1,n) >= exp(x,n) + 1 \n{\n    if n != 1 { \n        calc {\n            exp(x+1,n);\n            ==\n            (x+1)*exp(x+1,n-1);\n            == \n            x*exp(x+1,n-1) + exp(x+1,n-1);\n            >= {\n                expGET1_Lemma(x+1,n-1);\n            }\n            x*exp(x+1,n-1);\n            >= {\n                expMon_Lemma(x,n-1);\n                expGET1_Lemma(x+1,n-1);\n                expGET1_Lemma(x,n-1);\n                prodMon_Lemma(x, exp(x+1,n-1), exp(x,n-1) + 1);\n            }\n            x*(exp(x,n-1) + 1); \n            ==\n            x*exp(x,n-1) + x;\n            >=\n            exp(x,n)+1;\n        }\n    }\n}"
},
{
    "dafny": "static lemma lemma_vacuous_statement_about_a_sequence(intseq:seq<int>, j:int)\n    requires 0<=j<|intseq|;\n    ensures intseq[0..j]==intseq[..j];\n{\n}\nstatic lemma lemma_painful_statement_about_a_sequence(intseq:seq<int>)\n    ensures intseq==intseq[..|intseq|];\n{\n}\nstatic lemma lemma_obvious_statement_about_a_sequence(boolseq:seq<bool>, j:int)\n    requires 0<=j<|boolseq|-1;\n    ensures boolseq[1..][j] == boolseq[j+1];\n{\n}\nstatic lemma lemma_obvious_statement_about_a_sequence_int(intseq:seq<int>, j:int)\n    requires 0<=j<|intseq|-1;\n    ensures intseq[1..][j] == intseq[j+1];\n{\n}\nstatic lemma lemma_straightforward_statement_about_a_sequence(intseq:seq<int>, j:int)\n    requires 0<=j<|intseq|;\n    ensures intseq[..j] + intseq[j..] == intseq;\n{\n}\nstatic lemma lemma_sequence_reduction(s:seq<int>, b:nat)\n    requires 0<b<|s|;\n    ensures s[0..b][0..b-1] == s[0..b-1];\n{\n    var t := s[0..b];\n    forall (i | 0<=i<b-1)\n        ensures s[0..b][0..b-1][i] == s[0..b-1][i];\n    {\n    }\n}\nstatic lemma lemma_seq_concatenation_associative(a:seq<int>, b:seq<int>, c:seq<int>)\n    ensures (a+b)+c == a+(b+c);\n{\n}\nstatic lemma lemma_subseq_concatenation(s: seq<int>, left: int, middle: int, right: int)\n    requires 0 <= left <= middle <= right <= |s|;\n    ensures s[left..right] == s[left..middle] + s[middle..right];\n{\n}\nstatic lemma lemma_seq_equality(a:seq<int>, b:seq<int>, len:int)\n    requires |a| == |b| == len;\n    requires forall i {:trigger a[i]}{:trigger b[i]} :: 0 <= i < len ==> a[i] == b[i];\n    ensures a == b;\n{\n    assert forall i :: 0 <= i < len ==> a[i] == b[i];\n}\nstatic lemma lemma_seq_suffix(s: seq<int>, prefix_length: int, index: int)\n    requires 0 <= prefix_length <= index < |s|;\n    ensures s[index] == s[prefix_length..][index - prefix_length];\n{\n}"
},
{
    "dafny": "method join(a:array<int>,b:array<int>) returns (c:array<int>)\nensures a[..] + b[..] == c[..]\nensures multiset(a[..] + b[..]) == multiset(c[..])\nensures multiset(a[..]) + multiset(b[..]) == multiset(c[..])\nensures a.Length+b.Length == c.Length\nensures forall i :: 0<=i<a.Length ==> c[i] == a[i]\nensures forall i_2,j_2::\n    a.Length <= i_2 < c.Length &&\n    0<=j_2< b.Length && i_2 - j_2 == a.Length  ==> c[i_2] == b[j_2]\n{\n    c := new int[a.Length+b.Length];\n    var i:= 0;\n    while(i < a.Length)\n    invariant 0 <= i <=a.Length\n    invariant c[..i] == a[..i]\n    invariant multiset(c[..i]) == multiset(a[..i])\n    invariant forall k :: 0<=k<i<a.Length ==> c[k] == a[k]\n    {\n        c[i] := a[i];\n        i := i +1;\n    }\n    i:= a.Length;\n    var j := 0;\n    while(i < c.Length && j<b.Length) \n    invariant 0<=j<=b.Length \n    invariant 0 <= a.Length <= i <= c.Length \n    invariant c[..a.Length] == a[..a.Length]\n    invariant c[a.Length..i] == b[..j] \n    invariant c[..a.Length] + c[a.Length..i] == a[..a.Length] + b[..j] \n    invariant multiset(c[a.Length..i]) == multiset(b[..j]) \n    invariant multiset( c[..a.Length] + c[a.Length..i]) == multiset(a[..a.Length] + b[..j]) \n    invariant forall k :: 0<=k<a.Length ==> c[k] == a[k]  \n    invariant forall i_2,j_2::\n    a.Length <= i_2 < i &&\n    0<=j_2< j && i_2 - j_2 == a.Length  ==> c[i_2] == b[j_2] \n    invariant forall k_2,i_2,j_2::\n    0<=k_2<a.Length &&\n    a.Length <= i_2 < i &&\n    0<=j_2< j && i_2 - j_2 == a.Length  ==> c[i_2] == b[j_2] && c[k_2] == a[k_2] \n    {\n        c[i] := b[j];\n        i := i +1;\n        j := j +1;\n    }\n    assert a[..] + b[..] == c[..];\n    assert multiset(a[..]) + multiset(b[..]) == multiset(c[..]); \n}\nmethod Check(){\n    var a := new int[][1,2,3];\n    var b := new int[][4,5];\n    var c := new int[][1,2,3,4,5];\n    var d:= join(a,b);\n    assert d[..] == a[..] + b[..]; \n    assert multiset(d[..]) == multiset(a[..] + b[..]);\n    assert multiset(d[..]) == multiset(a[..]) + multiset(b[..]);\n    assert d[..] == c[..]; \n    assert d[..] == c[..]; \n}"
},
{
    "dafny": "datatype Exp = Const(int) | Var(string) | Plus(Exp, Exp) |  Mult(Exp, Exp)\nfunction eval(e:Exp, store:map<string, int>):int\n{\n\tmatch(e)\n\t\tcase Const(n) => n\n\t\tcase Var(s) => if(s in store) then store[s] else -1\n\t\tcase Plus(e1, e2) => eval(e1, store) + eval(e2, store)\n\t\tcase Mult(e1, e2) => eval(e1, store) * eval(e2, store)\n}\nfunction optimize(e:Exp):Exp\n{\n\tmatch e\n\tcase Mult(Const(0), e) => Const(0)\n\tcase Mult(e, Const(0)) => Const(0)\n\tcase Mult(Const(1), e) => e\n\tcase Mult(e, Const(1)) => e\n\tcase Mult(Const(n1), Const(n2)) => Const(n1*n2)\n\tcase Plus(Const(0), e) => e\n\tcase Plus(e, Const(0)) => e\n\tcase Plus(Const(n1), Const(n2)) => Const(n1+ n2)\n\tcase e => e\n} \nmethod optimizeCorrect(e:Exp, s:map<string, int>)\nensures eval(e,s) == eval(optimize(e), s)\n{\n}\nmethod optimizeFeatures()\n{\n\tassert( optimize(Mult(Var(\"x\"), Const(0))) == Const(0) );\n\tassert( optimize(Mult(Var(\"x\"), Const(1))) == Var(\"x\") );\n\tassert( optimize(Mult(Const(0), Var(\"x\"))) == Const(0) );\n\tassert( optimize(Mult(Const(1), Var(\"x\"))) == Var(\"x\") );\n\tassert( optimize(Plus(Const(0), Var(\"x\"))) == Var(\"x\") );\n\tassert( optimize(Plus(Var(\"x\"), Const(0))) == Var(\"x\") );\n\tassert( optimize(Plus(Const(3),Const(4))) == Const(7) );\n\tassert( optimize(Mult(Const(3),Const(4))) == Const(12) );\n\tassert( optimize(Plus(Plus(Var(\"x\"), Var(\"y\")), Const(0))) == Plus(Var(\"x\"), Var(\"y\")) );\n}"
},
{
    "dafny": "module A {\n  export reveals a\n  const a := 10;\n  const b := 20;\n}\nmodule B {\n  method m() {\n    assert A.a == 10; \n  }\n}"
},
{
    "dafny": "method is_anagram(s: string, t: string) returns (result: bool)\n    requires |s| == |t|\n    ensures (multiset(s) == multiset(t)) == result\n{\n    result := is_equal(multiset(s), multiset(t));\n}\nmethod is_equal(s: multiset<char>, t: multiset<char>) returns (result: bool)\n    ensures (s == t) <==> result\n{\n    var s_removed := multiset{};\n    var s_remaining := s;\n    while (|s_remaining| > 0)\n        invariant s_remaining == s - s_removed\n        invariant forall removed :: removed in s_removed ==> (removed in s &&\n                                                              removed in t &&\n                                                              s[removed] == t[removed])\n    {\n        var remaining :| remaining in s_remaining;\n        if !(remaining in s &&\n             remaining in t &&\n             s[remaining] == t[remaining]) {\n           return false; \n        }\n        var temp := multiset{};\n        s_removed := s_removed + temp[remaining := s[remaining]];\n        s_remaining := s_remaining - temp[remaining := s[remaining]];\n    }\n    var t_removed := multiset{};\n    var t_remaining := t;\n    while (|t_remaining| > 0)\n        invariant t_remaining == t - t_removed\n        invariant forall removed :: removed in t_removed ==> (removed in s &&\n                                                              removed in t &&\n                                                              s[removed] == t[removed])\n    {\n        var remaining :| remaining in t_remaining;\n        if !(remaining in s &&\n             remaining in t &&\n             s[remaining] == t[remaining]) {\n           return false; \n        }\n        var temp := multiset{};\n        t_removed := t_removed + temp[remaining := t[remaining]];\n        t_remaining := t_remaining - temp[remaining := t[remaining]];\n    }\n    return true;\n}"
},
{
    "dafny": "predicate sorted_between(A:array<int>, from:int, to:int)\n    reads A\n{\n    forall i, j :: 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]\n}\npredicate sorted(A:array<int>)\n    reads A\n{\n    sorted_between(A, 0, A.Length-1)\n}\nmethod BubbleSort(A:array<int>)\n    modifies A\n    ensures sorted(A)\n    ensures multiset(A[..]) == multiset(old(A[..]))\n{\n    var N := A.Length;\n    var i := N-1;\n    while 0 < i\n        invariant multiset(A[..]) == multiset(old(A[..]))\n        invariant sorted_between(A, i, N-1)\n        invariant forall n, m :: 0 <= n <= i < m < N ==> A[n] <= A[m]\n        decreases i\n    {\n        print A[..], \"\\n\";\n        var j := 0;\n        while j < i\n            invariant 0 < i < N\n            invariant 0 <= j <= i\n            invariant multiset(A[..]) == multiset(old(A[..]))\n            invariant sorted_between(A, i, N-1)\n            invariant forall n, m :: 0 <= n <= i < m < N ==> A[n] <= A[m]\n            invariant forall n :: 0 <= n <= j ==> A[n] <= A[j]\n            decreases i - j\n        {\n            if A[j] > A[j+1]\n            {\n                A[j], A[j+1] := A[j+1], A[j];\n                print A[..], \"\\n\";\n            }\n            j := j+1;\n        } \n        i := i-1;\n        print \"\\n\";\n    }\n}\nmethod Main() {\n    var A := new int[10];\n    A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9] := 2, 4, 6, 15, 3, 19, 17, 16, 18, 1;\n    BubbleSort(A);\n    print A[..];\n}"
},
{
    "dafny": "module ProdCons {\n    type Process(==) \n    type T\n    class ProdCons { \n        const P: set<Process>\n        var maxBufferSize : nat \n        var buffer : seq<T> \n        predicate valid() \n            reads this\n        {\n            maxBufferSize > 0 && P != {} &&\n            0 <= |buffer| <= maxBufferSize \n        }\n        constructor (processes: set<Process>, m: nat ) \n            requires processes != {}        \n            requires m >= 1                 \n            ensures valid()                 \n        { \n            P := processes;\n            buffer := [];\n            maxBufferSize := m;\n        }\n        predicate putEnabled(p : Process) \n            reads this\n        {\n            |buffer| < maxBufferSize\n        }\n        method put(p: Process, t : T) \n            requires valid()                \n            requires putEnabled(p)          \n            modifies this \n        { \n            buffer := buffer + [t] ;\n        }\n        predicate getEnabled(p : Process) \n            reads this\n        {\n            |buffer| >= 1\n        }\n        method get(p: Process) \n            requires getEnabled(p)\n            requires valid()                \n            ensures |buffer| == |old(buffer)| - 1   \n            modifies this \n        { \n           buffer := buffer[1..];\n        }\n        lemma noDeadlock() \n            requires valid() \n            ensures exists p :: p in P && (getEnabled(p) || putEnabled(p))\n        { \n          var p: Process :| p in P ;\n            if ( |buffer| > 0 ) {\n                assert (getEnabled(p));\n            }\n            else {\n                assert(|buffer| == 0);\n                assert (|buffer| < maxBufferSize); \n                assert(putEnabled(p));\n            }\n        }\n    }\n}"
},
{
    "dafny": "datatype HAlign = Left | Center | Right\ndatatype VAlign = Top | Middle | Bottom\ndatatype TextAlign = TextAlign(hAlign:HAlign, vAlign:VAlign)\ndatatype GraphicsAlign = Square | Round\ndatatype PageElement = Text(t:TextAlign) | Graphics(g:GraphicsAlign)\nlemma NumPageElements()\n  ensures exists eltSet:set<HAlign> :: |eltSet| == 3  \n  ensures forall eltSet:set<HAlign> :: |eltSet| <= 3  \n{\n  var maxSet := { Left, Center, Right };\n  assert |maxSet| == 3;\n  forall eltSet:set<HAlign>\n    ensures |eltSet| <= 3\n  {\n    forall elt | elt in eltSet ensures elt in maxSet {\n      if elt.Left? { }  \n    }\n    subsetCardinality(eltSet, maxSet);\n  }\n}\nlemma subsetCardinality<T>(a:set<T>, b:set<T>)\n  requires a <= b\n  ensures |a| <= |b|\n{\n  if a == {} {\n    assert |a| <= |b|;\n  } else {\n    var e :| e in a;\n    if e in b {\n      subsetCardinality(a - {e}, b - {e});\n      assert |a| <= |b|;\n    } else {\n      subsetCardinality(a - {e}, b);\n      assert |a| <= |b|;\n    }\n  }\n}"
},
{
    "dafny": "method foo(xs: set) {\n   assert (set x | x in xs) == xs;\n}\nmethod bar(xs: iset) {\n   assert (iset x | x in xs) == xs;\n}\nghost function domain<U, V>(m: map<U,V>): set<U>\n   ensures forall i :: i in domain(m) ==> i in m\n   ensures forall i :: i in domain(m) <== i in m\n{\n   set s | s in m\n}\nghost function idomain<U, V>(m: imap<U,V>): iset<U>\n   ensures forall i :: i in idomain(m) ==> i in m\n   ensures forall i :: i in idomain(m) <== i in m\n{\n   iset s | s in m\n}\nmethod foo2(xs: map) {\n\t  assert (set x | x in xs) == domain(xs);\n}\nmethod bar2(xs: imap) {\n\t  assert (iset x | x in xs) == idomain(xs);\n}"
},
{
    "dafny": "method FindMax(a: array<int>) returns (max: int)\n   requires a != null && a.Length > 0;\n   ensures 0 <= max < a.Length;\n   ensures forall x :: 0 <= x < a.Length ==> a[max] >= a[x];\n{\n  var i := 0;\n  max := 0;\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant 0 <= max;\n    invariant max == 0 || 0 < max < i;\n    invariant forall k :: 0 <= k < i ==> a[max] >= a[k]\n  {\n    if (a[i] > a[max]) { max := i; }\n    i := i + 1;\n  }\n  return max;\n}"
},
{
    "dafny": "method MergeSort(a1:array<int>) returns (a:array<int>)\n  requires a1 != null && a1.Length > 0;\n  ensures a != null;\n  ensures forall k:: forall l:: 0 <= k < l < a.Length ==> a[k] <= a[l];\n{\n  a := ms(a1, 0, a1.Length-1);\n  return;\n}\nmethod ms(a1:array<int>, l:int, u:int) returns (a:array<int>)\n  requires a1 != null;\n  decreases u - l;\n  requires 0 <= l < a1.Length;\n  requires 0 <= u < a1.Length;\n  ensures a != null;\n  ensures a.Length == a1.Length;\n  ensures forall i:: forall j:: l <= i <= j <= u ==> a[i] <= a[j]; \n  ensures forall i:: 0 <= i < l ==> a[i] == a1[i]; \n  ensures forall i:: u < i < a.Length ==> a[i] == a1[i]; \n{\n  a := new int[a1.Length];\n  assume forall k:: 0 <= k < a1.Length ==> a[k] == a1[k];\n  if (l >= u)\n  {\n    return;\n  }\n  else\n  {\n    var m:int := (l + u) / 2;\n    a := ms(a, l, m);\n    a := ms(a, m+1, u);\n    a := merge(a, l, m, u);\n    return;\n  }\n}\nmethod merge(a1:array<int>, l:int, m:int, u:int) returns (a:array<int>)\n  requires a1 != null;\n  requires 0 <= l <= m <= u < a1.Length;\n  requires forall i:: forall j:: l <= i <= j <= m ==> a1[i] <= a1[j]; \n  requires forall i:: forall j:: m + 1 <= i <= j <= u ==> a1[i] <= a1[j]; \n  requires a1.Length > 1;\n  ensures a != null;\n  ensures a.Length == a1.Length;\n  ensures forall i:: forall j:: l <= i <= j <= u ==> a[i] <= a[j]; \n  ensures forall i:: 0 <= i < l ==> a[i] == a1[i]; \n  ensures forall i:: u < i < a.Length ==> a[i] == a1[i]; \n{\n  a := new int[a1.Length];\n  assume forall k:: 0 <= k < a1.Length ==> a[k] == a1[k]; \n  var buf := new int[u-l+1];\n  var i:int := l;\n  var j:int := m + 1;\n  var k:int := 0;\n  while (k < u-l+1)\n    modifies buf;\n    invariant m+1 <= j;\n    invariant l <= i;\n    invariant (i - l) + (j - m - 1) == k;\n    invariant k <= u - l + 1;\n    invariant buf.Length == u-l+1;\n    invariant forall ip:: forall jp:: l <= ip <= jp <= m ==> a[ip] <= a[jp]; \n    invariant forall i:: forall j:: m+1 <= i <= j <= u ==> a[i] <= a[j]; \n    invariant k > 0 ==> forall ip:: forall jp:: forall kp:: (j <= jp <= u && \n      i <= ip <= m && \n      0 <= kp < k) ==> \n      buf[kp] <= a[ip] && buf[kp] <= a[jp]; \n    invariant i > m ==> forall ip:: forall jp:: (0 <= ip < k && \n      j <= jp <= u) ==> buf[ip] <= a[jp]; \n    invariant i <= m && j > u ==> forall ip:: forall jp:: (0 <= ip < k && \n      i <= jp <= m) ==> buf[ip] <= a[jp]; \n    invariant forall i:: forall j:: 0 <= i <= j < k ==> buf[i] <= buf[j]; \n  {\n    if (i > m)\n    {\n      buf[k] := a[j];\n      j := j + 1;\n    }\n    else if (j > u)\n    {\n      buf[k] := a[i];\n      i := i + 1;\n    }\n    else if (a[i] <= a[j])\n    {\n      buf[k] := a[i];\n      i := i + 1;\n    }\n    else\n    {\n      buf[k] := a[j];\n      j := j + 1;\n    }\n    k := k + 1;\n  }\n  k := 0;\n  while (k < u-l+1)\n    invariant forall i:: 0 <= i < l ==> a[i] == a1[i]; \n    invariant forall i:: u < i < a.Length ==> a[i] == a1[i]; \n    invariant k <= u- l + 1;\n    invariant forall i:: forall j:: 0 <= i <= j < u - l + 1 ==> buf[i] <= buf[j]; \n\t\tinvariant forall i:: l <= i < l+k ==> a[i] == buf[i-l]; \n  {\n    a[l + k] := buf[k];\n    k := k + 1;\n  }\n}"
},
{
    "dafny": "method maxArray(items: array<int>) returns (r: int)\n  requires items != null\n  requires items.Length > 0\n  ensures forall k: nat :: 0 <= k < items.Length ==> r >= items[k]\n{\n  var i: int := 1;\n  r := items[0];\n  while i < items.Length\n    invariant 0 < i <= items.Length\n    invariant forall k: nat :: k < i ==> r >= items[k]\n  {\n    if items[i] > r\n      { r := items[i]; }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method Max(a: int, b: int) returns (c: int)\n    ensures c == a || c == b\n    ensures c >= a\n    ensures c >= b\n{\n    if (a > b) {\n        c := a;\n    } else {\n        c := b;\n    }\n}\nmethod Testing ()\n{\n    var value: int  := Max(3, 4);\n    assert value >= 3;\n    assert value >= 4;\n    assert value == 3 || value == 4;\n}"
},
{
    "dafny": "function fact(m: int): int\n  requires 0 <= m;\n  ensures 1 <= fact(m);\n{\n if m == 0 then 1 else fact(m-1) * m\n }\nmethod ComputeFact(n : nat) returns (res : nat)\n  requires n > 0;\n  ensures res == fact(n);\n {\n  res := 1;\n  var i := 2;\n  while (i <= n)\n  invariant i <= n + 1;\n  invariant res == fact(i-1);\n  {\n    res := res * i;\n    i := i + 1;\n  }\n }"
},
{
    "dafny": "ghost function foo() : (int, int)\n{\n    (5, 10)\n}\nghost function bar() : int\n{\n    var (x, y) := foo();\n    x + y\n}\nlemma test()\n{\n    var (x, y) := foo();\n}\nfunction foo2() : (int,int)\n{\n    (5, 10)\n}\nmethod test2()\n{\n    var (x, y) := foo2();\n}\nmethod Main()\n{\n    var (x, y) := foo2();\n    assert (x+y == 15);\n    print(x+y);\n}"
},
{
    "dafny": "datatype coord = coord (x:int,y:int)\ndatatype seqcoord = seqcoord (seq<(int,int)>)\nmethod PlanReasoningAgent(PlanSet:seq<(seq<(int,int)>)>, threshold : int, b: int) returns (plan:seq<(int,int)>, recharge:bool)\nrequires [] in PlanSet;\nensures b < threshold  ==> (recharge == true) && plan ==[];\nensures threshold <= b && |plan|<= b ==> recharge == false;\nensures plan in PlanSet;\nensures threshold>=b && recharge == false && plan != [] && |plan|<= b ==> forall x :: x in PlanSet  ==> |x| >= |plan|;\n{\n  plan := PlanSet[0];\n  recharge := false;\n if (b < threshold) {\n    recharge := true;\n    plan := [];\n  }\n  else if (threshold>=b){\n    var i:= 0; \n    while(i<|PlanSet|)\n    invariant 0<=i<=|PlanSet|;\n    invariant plan in PlanSet;\n    invariant forall x :: 0 <= x < i ==> |PlanSet[x]| >= |plan|;\n    {\n      if(|PlanSet[i]| < |plan|)\n      {\n        plan := PlanSet[i];\n      }\n      i:= i+1;\n    }\n  }\n}"
},
{
    "dafny": "method integerDivision (A: int, B: int) returns (q: int, r: int)\nrequires A > 0\nrequires B > 0\nensures A == q * B + r\nensures 0 <= r\nensures r < B\n{\n    q := 0;\n    r := A;\n    while r >= B\n        invariant A == q * B + r\n        invariant 0 <= r\n        decreases r\n    {\n        q := q +1;\n        r := r - B;\n    }\n}\nfunction fact(x: int): int\nrequires x >= 0\ndecreases x\n{\n    if (x == 0) then 1 else x * fact(x-1)\n}\nmethod factorial(x: int) returns (y: int)\nrequires x >= 0\nensures y == fact(x)\n{\n    y := 1;\n    var z := 0;\n    while z != x\n        invariant y == fact(z)\n        invariant z <= x\n        decreases x - z\n    {\n        z := z + 1;\n        y := y * z;\n    }\n}\nfunction gcd(a: nat, b: nat): nat\nrequires a > 0\nrequires b > 0\ndecreases a, b\n{\n    if (a == b) then a\n    else if (a > b) then gcd(a-b, b)\n    else gcd(a, b-a)\n}\nmethod euclides(M: nat, N: nat) returns (x: nat, y: nat)\nrequires 0 < M\nrequires 0 < N\nensures x == y\nensures x == gcd(M, N)\n{\n    x := M;\n    y := N;\n    while x != y\n        invariant x > 0\n        invariant y > 0\n        invariant gcd(x, y) == gcd(M, N)\n        decreases x + y\n    {\n        if x < y {\n            y := y - x;\n        } else {\n            x := x - y;\n        }\n    }\n}\nfunction pow(a: int, b: int): int\nrequires b >= 0\ndecreases b\n{\n    if b == 0 then 1 else a * pow(a, b-1)\n}\nmethod exponentiation(A: int, B: int) returns (r: int)\nrequires A >= 0\nrequires B >= 0\nensures r == pow(A, B)\n{\n    r := 1;\n    var x := 0;\n    while x != B\n        invariant r == pow(A, x)\n        invariant x <= B\n        decreases B - x\n    {\n        r := r * A;\n        x := x + 1;\n    }\n}\nmethod squareRoot(n: nat) returns (r: int)\nensures r*r <= n\nensures (r+1)*(r+1) >= n\n{\n    r := 0;\n    while r*r > n || (r+1)*(r+1) < n\n        invariant r*r <= n\n        decreases n - r\n    {\n        r := r + 1;\n    }\n}\nmethod nth_odd (n: nat) returns (j: int)\nensures j == 1 + 2*n\n{\n    var k := 0;\n    j := 1;\n    while k < n\n        invariant k <= n\n        invariant j == 1 + 2*k\n        decreases n - k\n    {\n        k := k + 1;\n        j := j + 2;\n    }\n}\nmethod nth_even (n: nat) returns (j: int)\nensures j == 2*n\n{\n    var k := 0;\n    j := 0;\n    while k < n\n        invariant k <= n\n        invariant j == 2*k\n        decreases n - k\n    {\n        k := k + 1;\n        j := j + 2;\n    }\n}\nmethod loop(x: int) returns (ret:int)\nrequires x > 0\nensures ret == x * x\n{\n    var y := x;\n    var z := 0;\n    while (y > 0) \n        invariant z == x * (x - y)\n        decreases y\n    {\n        z := z + x;\n        y := y - 1;\n    }\n    return z;\n}\nmethod loop2 (n: nat) returns (j : nat)\nensures j == pow(2, n)\n{\n    var k := 0;\n    j := 1;\n    while k < n\n        invariant k <= n\n        invariant j == pow(2, k)\n        decreases n - k\n    {\n        k := k + 1;\n        j := 2 * j ;\n    }\n}"
},
{
    "dafny": "function F(n: nat): nat { if n <= 2 then n else F(n-1) + F(n-3)}\nmethod calcF(n: nat) returns (res: nat)  \n ensures res == F(n) \n{\n  var a, b, c := 0, 1, 2;\n  var i := 0;\n  while i < n\n    decreases n-i\n    invariant 0 <= i <= n\n    invariant a == F(i) && b == F(i+1) && c == F(i+2)\n   {\n    a, b, c := b, c, a + c;        \n    i := i + 1;\n  }\n  res := a;\n}"
},
{
    "dafny": "module Utils {\n  function max(a: int, b: int): int\n    ensures max(a, b) >= a\n    ensures max(a, b) >= b\n    ensures max(a, b) == a || max(a, b) == b\n  {\n    if a >= b then a else b\n  }\n  function min(a: int, b: int): int\n    ensures min(a, b) <= a\n    ensures min(a, b) <= b\n    ensures min(a, b) == a || min(a, b) == b\n  {\n    if a <= b then a else b\n  }\n  function maps<P,Q> (xs: seq<P>, f:P->Q): seq<Q>\n    ensures |xs| == |maps(xs, f)|\n    ensures forall i :: 0 <= i < |xs| ==> f(xs[i]) == maps(xs, f)[i]\n  {\n    if |xs| == 0 then [] else [f(xs[0])] + maps(xs[1..], f)\n  }\n  function filter<P> (xs: seq<P>, p: P -> bool): seq<P>\n    ensures |xs| <= |maps(xs, p)|\n    ensures forall i :: 0 <= i < |xs| ==> (p(xs[i]) ==> xs[i] in filter(xs, p))\n    ensures forall i :: 0 <= i < |filter(xs,p)| ==> p(filter(xs,p)[i])\n  {\n    if |xs| == 0 then [] else (if p(xs[0]) then [xs[0]] else []) + filter(xs[1..], p)\n  }\n}"
},
{
    "dafny": "module MyModule {\n  export provides MyType, Empty, MyLemma\n  type MyType<A>\n  ghost function Empty<B>(): MyType<B>\n  lemma MyLemma<C>(m: MyType<C>)\n    requires m != Empty()  \n}\nmodule Library {\n  export provides MyType, MyFunction\n  type MyType<A>\n  ghost function MyFunction<B>(q: MyType<B>, b: B): MyType<B>\n}\nmodule Client {\n  method Test() {\n  }\n}"
},
{
    "dafny": "method doub(a:real, b:real) returns (c:int)\n    requires 0.0 < a < b\n    ensures c >= 1\n    decreases *\n{\n    var a1: real := a;\n    c := 1;\n    while a1 < b\n        decreases *;\n    {\n        a1 := a1 * 2.0;\n        c := c + 1;\n    }\n} \nmethod Main()\n    decreases *\n{\n    var c:= doub(2.0, 5.0);\n    print c;\n}"
},
{
    "dafny": "datatype Heap = H(a: array<int>, size: int, capacity: int)\npredicate valid_heap(h: Heap)\n\treads h.a\n{\n\th.a != null && h.a.Length == h.capacity + 1 && 0 <= h.size <= h.capacity &&\n\t    forall i :: 1 < i <= h.size ==> h.a[i] <= h.a[i / 2]\n}\nmethod init_heap(cap: int) returns (h: Heap)\n\trequires 0 <= cap\n\tensures valid_heap(h)\n\tensures h.size == 0 && h.capacity == cap\n\tensures fresh(h.a)\n{\n\tvar a := new int[cap + 1];\n\tvar size := 0;\n\tvar capacity := cap;\n\th := H(a, size, capacity);\n}\nmethod insert(x: int, h: Heap) returns (h': Heap)\n\trequires valid_heap(h)\n\trequires h.size < h.capacity\n\tensures valid_heap(h')\n\tensures h'.size == h.size + 1 && h'.capacity == h.capacity\n\tensures fresh(h'.a)\n{\n\tvar size := h.size + 1;\n\tvar cap := h.capacity;\n\tvar a := new int[cap + 1];\n\tvar i := 1;\n\twhile (i <= h.size)\n\t\tdecreases h.size - i\n\t\tinvariant forall j :: 1 <= j < i ==> j <= h.size && a[j] == h.a[j]\n\t{\n\t\ta[i] := h.a[i];\n\t\ti := i + 1;\n\t}\n\tassert forall i :: 1 <= i <= h.size ==> a[i] == h.a[i];\n\ta[size] := a[size / 2];\n\tvar current_place := size;\n\twhile(current_place > 1 && x > a[current_place / 2])\n\t\tinvariant 1 <= current_place <= h.size + 1 \n\t\tinvariant forall i :: 1 < i <= h.size + 1 ==> a[i] <= a[i / 2]\n\t\tinvariant forall i :: 1 < i <= h.size + 1 && i/2 == current_place ==> a[i] <= x\n\t\tdecreases current_place\n\t{\n\t\ta[current_place] := a[current_place / 2];\n\t\tcurrent_place := current_place / 2;\n\t}\n\ta[current_place]:= x;\n\th' := H(a, size, cap);\n}\nlemma max_heap(h: Heap)\n\trequires valid_heap(h)\n\trequires h.size >= 1\n\tensures forall i :: 1 < i <= h.size ==> h.a[i] <= h.a[1]\n{\n\tassert forall i {:induction i} :: 1 < i <= h.size ==> ancestor (i, 1);\n\tassert forall i, j {:induction i, j} :: 1 <= i < j <= h.size && ancestor(j, i) ==> h.a[j] <= h.a[i];\n}\npredicate ancestor(a: int, b: int)\n\tdecreases a\n\trequires 0 < a && 0 < b\n{\n\tb < a && (b == a / 2 || ancestor(a/2, b))\n}\nmethod extract(h: Heap) returns (x: int, h': Heap)\n\trequires valid_heap(h)\n\trequires 0 < h.size\n\tensures valid_heap(h')\n\tensures h'.size == h.size - 1\n\tensures forall i :: 1 <= i <= h'.size ==> h'.a[i] <= x\n\tensures x == h.a[1]\n\tensures fresh(h'.a)\n{\n\tmax_heap(h);\n\tx := h.a[1];\n\tvar a := new int[h.capacity + 1];\n\tvar i := 1;\n\twhile (i <= h.size)\n\t\tdecreases h.size - i\n\t\tinvariant forall j :: 1 <= j < i ==> j <= h.size && a[j] == h.a[j]\n\t{\n\t\ta[i] := h.a[i];\n\t\ti := i + 1;\n\t}\n\tassert forall i :: 1 <= i <= h.size ==> a[i] == h.a[i];\n\tif(h.size == 1)\n\t{\n\t\th' := H(a, h.size - 1, h.capacity);\n\t\treturn;\n\t}\n\tvar pivot := a[h.size];\n\tvar place := 1;\n  \twhile((place * 2 < h.size && a[place * 2] >= pivot) || (place * 2 + 1 < h.size && a[place * 2 + 1] >= pivot))\n\tinvariant 1 <= place < h.size \n\tinvariant forall i :: 1 < i < h.size ==> a[i] <= a[i / 2] \n\tinvariant forall i :: 1 <= i <= h.size ==> a[i] <= x\n\tinvariant a[place] >= pivot\n\tdecreases h.size - place * 2\n\t{\n    \tif (place * 2 < h.size && a[place * 2] >= pivot && (place * 2 + 1 >= h.size || a[place * 2] >= a[place * 2 + 1]))\n\t\t{\n\t\t\tassert a[place*2] <= a[(place*2) / 2]; \n      \t\ta[place] := a[place * 2];\n      \t\tplace := place * 2;\n\t\t}\n    \telse\n\t\t{\n      \t\tif (place * 2 + 1 < h.size && a[place * 2 + 1] >= pivot && a[place * 2 + 1] > a[place * 2])\n\t\t\t{\n\t\t\t\tassert a[place*2 + 1] <= a[(place*2 + 1) / 2]; \n        \t\ta[place] := a[place * 2 + 1];\n        \t\tplace := place * 2 + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[place] := pivot;\n\t\t\t\tplace := h.size - 1;\n\t\t\t}\n\t\t}\n\t}\n\tassert forall i :: 1 < i < h.size && place == i / 2 ==> pivot >= a[i];\n\ta[place] := pivot;\n    h' := H(a, h.size - 1, h.capacity);\n}\nclass Heapsort\n{\n\tvar h: Heap;\n\tmethod sort(a: array<int>)\n\t\trequires 0 <= a.Length\n\t\tensures forall i :: 0 <= i < a.Length - 1 ==> a[i] >= a[i + 1]\n\t\tmodifies this, h.a, a\n\t{\n\t\tthis.h := init_heap(a.Length);\n\t\tassert this.h.size == 0;\n\t\tif(a.Length == 0) {\n\t\t\treturn;\n\t\t}\n\t\twhile (this.h.size < a.Length)\n\t\tinvariant valid_heap(this.h)\n\t\tinvariant a.Length == this.h.capacity\n\t\tdecreases a.Length - this.h.size\n\t\t{\n\t\t\tassert(this.h.size < this.h.capacity);\n\t\t\tvar k := a[this.h.size];\n\t\t\tthis.h := insert(k, this.h);\n\t\t}\n\t\tassert this.h.size == a.Length;\n\t\twhile(this.h.size >= 1)\n\t\tinvariant valid_heap(this.h)\n\t\tinvariant forall i :: 0 <= i < a.Length - this.h.size - 1 ==> a[i] >= a[i + 1]\n\t\tinvariant forall i :: 0 <= i <= a.Length - this.h.size - 1 && this.h.size > 0 ==> a[i] >= this.h.a[1]\n\t\tdecreases this.h.size\n\t\t{\n\t\t\tvar j;\n\t\t\tj, this.h := extract(this.h);\n\t\t\tassert this.h.size < a.Length;\n\t\t\ta[a.Length - this.h.size - 1] := j;\n\t\t\tif(this.h.size > 0)\n\t\t\t{\n\t\t\t\tassert a[a.Length - this.h.size - 1] >= this.h.a[1];\n\t\t\t}\n\t\t}\n\t}\n}"
},
{
    "dafny": "method Abs(x : int) returns (y : int)\n  ensures 0 <= y;\n  ensures 0 <= x ==> y == x;\n  ensures x < 0 ==> y == -x;\n{\n  if (x < 0)\n   {y := -x;}\n  else\n   {y := x;}\n}"
},
{
    "dafny": "method filter(a:array<int>, key:int) returns (b:seq<int>)\n\tensures |b| <= a.Length;\n\tensures forall k :: 0 <= k < |b| ==> b[k] == key;  \n\tensures forall j :: 0 <= j < |b| ==> b[j] in a[0..]; \n\tensures forall k :: 0 <= k < a.Length && a[k] == key ==> a[k] in b;\n{\n\tvar i:int := 0;\n\tb := [];\n\twhile (i < a.Length)\n\t\tinvariant |b| <= i <= a.Length;\n\t\tinvariant forall k :: 0 <= k < |b|==> b[k] == key;\n\t\tinvariant forall j:: 0 <= j < |b| ==> b[j] in a[0..i];\n\t\tinvariant forall k :: 0 <= k < i && a[k]==key ==> a[k] in b;\n\t\tdecreases a.Length-i;\n\t{\n\t\tif (a[i] == key) \n\t\t{ \n\t\t\tb := b + [a[i]];\n\t\t}\n\t\ti := i + 1;\n\t}\n}"
},
{
    "dafny": "module {:options \"--function-syntax:4\"} Dafny.Wrappers {\n  datatype Option<+T> = None | Some(value: T) {\n    predicate IsFailure() {\n      None?\n    }\n    function PropagateFailure<U>(): Option<U>\n      requires None?\n    {\n      None\n    }\n    function Extract(): T\n      requires Some?\n    {\n      value\n    }\n    function GetOr(default: T): T {\n      match this\n      case Some(v) => v\n      case None() => default\n    }\n    function ToResult<E>(error: E): Result<T, E> {\n      match this\n      case Some(v) => Success(v)\n      case None() => Failure(error)\n    }\n    function ToOutcome<E>(error: E): Outcome<E> {\n      match this\n      case Some(v) => Pass\n      case None() => Fail(error)\n    }\n    function Map<FC>(rewrap: Option<T> -> FC): FC\n    {\n      rewrap(this)\n    }\n  }\n  datatype Result<+R, +E> = | Success(value: R) | Failure(error: E) {\n    predicate IsFailure() {\n      Failure?\n    }\n    function PropagateFailure<U>(): (r: Result<U, E>)\n      requires Failure?\n    {\n      Failure(this.error)\n    }\n    function Extract(): R\n      requires Success?\n    {\n      value\n    }\n    function GetOr(default: R): R\n    {\n      match this\n      case Success(s) => s\n      case Failure(e) => default\n    }\n    function ToOption(): Option<R>\n    {\n      match this\n      case Success(s) => Some(s)\n      case Failure(e) => None()\n    }\n    function ToOutcome(): Outcome<E>\n    {\n      match this\n      case Success(s) => Pass\n      case Failure(e) => Fail(e)\n    }\n    function Map<FC>(rewrap: Result<R,E> -> FC): FC\n    {\n      rewrap(this)\n    }\n    function MapFailure<NewE>(reWrap: E -> NewE): Result<R, NewE>\n    {\n      match this\n      case Success(s) => Success(s)\n      case Failure(e) => Failure(reWrap(e))\n    }\n  }\n  datatype Outcome<+E> = Pass | Fail(error: E) {\n    predicate IsFailure() {\n      Fail?\n    }\n    function PropagateFailure(): Outcome<E>\n      requires Fail?\n    {\n      this\n    }\n    function ToOption<R>(r: R): Option<R>\n    {\n      match this\n      case Pass => Some(r)\n      case Fail(e) => None()\n    }\n    function ToResult<R>(r: R): Result<R,E>\n    {\n      match this\n      case Pass => Success(r)\n      case Fail(e) => Failure(e)\n    }\n    function Map<FC>(rewrap: Outcome<E> -> FC): FC\n    {\n      rewrap(this)\n    }\n    function MapFailure<T,NewE>(rewrap: E-> NewE, default: T): Result<T, NewE>\n    {\n      match this\n      case Pass => Success(default)\n      case Fail(e) => Failure(rewrap(e))\n    }\n    static function Need(condition: bool, error: E): (result: Outcome<E>)\n    {\n      if condition then Pass else Fail(error)\n    }\n  }\n  datatype OutcomeResult<+E> = Pass' | Fail'(error: E) {\n    predicate IsFailure() {\n      Fail'?\n    }\n    function PropagateFailure<U>(): Result<U,E>\n      requires IsFailure()\n    {\n      Failure(this.error)\n    }\n  }\n  function Need<E>(condition: bool, error: E): (result: OutcomeResult<E>)\n  {\n    if condition then Pass' else Fail'(error)\n  }\n  method Expect(condition: bool, message: string)\n    requires condition\n  {\n    expect condition, message;\n  }\n}"
},
{
    "dafny": "function fib(n: nat): nat\n{\n    if n == 0 then\n        0\n    else if n == 1 then\n        1\n    else\n        fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n    ensures b == fib(n)\n{\n    if n == 0 {\n        return 0;\n    }\n    var i: int := 1;\n    var c := 1;\n    b := 1;\n    while i < n\n        invariant 0 < i <= n\n        invariant b == fib(i)\n        invariant c == fib(i + 1)\n    {\n        b, c := c, b + c;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "datatype ABC = ABC(nameonly a: int, nameonly b: int, nameonly c: int)\nfunction JustChangeB(abc: ABC): ABC {\n  abc.(b := 42)\n}\nfunction ChangeEvathang(abc: ABC): ABC {\n  abc.(b := 42, a := 100, c := 90)\n}\ndatatype XYZ = XYZ(x: int, nameonly y: int := 5, z: int := 7)\nfunction MakeSureDefaultValuesAreNotUsedInUpdate(xyz: XYZ): XYZ {\n  xyz.(x := 3)\n}\nmethod Main() {\n  var abc := ABC(a := 19, c := 23, b := 21);\n  assert abc.b == 21;\n  print abc, \"\\n\"; \n  abc := JustChangeB(abc);\n  assert abc.b == 42 && abc.c == 23;\n  print abc, \"\\n\"; \n  abc := ChangeEvathang(abc);\n  assert abc.b == 42 && abc.c == 90;\n  print abc, \"\\n\"; \n  var xyz := XYZ(0);\n  assert xyz.y == 5;\n  print xyz, \"\\n\"; \n  xyz := XYZ(88, y := 89, z := 90);\n  assert xyz.y == 89;\n  print xyz, \"\\n\"; \n  xyz := MakeSureDefaultValuesAreNotUsedInUpdate(xyz);\n  assert xyz.y == 89;\n  print xyz, \"\\n\"; \n}"
},
{
    "dafny": "class Stack {\n  ghost var s:seq<int>;\n  function AbsInv(): bool { true }\n  var a:array<int>;\n  var size:int;\n  function RepInv(): bool\n  function Sound(): bool\n  function Empty():bool\n  constructor() \n  ensures AbsInv() && Empty()\n  method push(x:int)\n  requires AbsInv()\n  ensures AbsInv() && s == old(s) + [x]\n  method pop() returns (x:int)\n  requires AbsInv() && !Empty()\n  ensures AbsInv() && s + [x] == old(s)\n  static method main() {\n    var stack:Stack := new Stack();\n    stack.push(0);\n    var v0 := stack.pop();\n    stack.push(1);\n    stack.push(2);\n    var v1 := stack.pop();\n    var v2 := stack.pop();\n    assert stack.s == [];\n    assert v1 == 2 && v2 == 1;\n  }  \n}"
},
{
    "dafny": "method contract1(x :  int ) returns ( result : int)\n    requires x == 0 ;\n    ensures result > 3;\n{\n    if x == 3\n    {\n        result := 4;\n        return result;\n    }\n    else if x == 4\n    {\n        result := 5 ;\n        return result ;\n    }\n    else\n    {\n        result := 6;\n        return result;\n    }\n}"
},
{
    "dafny": "datatype PhantomData<T> = PhantomData(ghost value: T)\nmethod Test0(t0: (ghost int)) { print \"Test0: \", t0, \"\\n\"; }\nmethod Test1(t1: (ghost int, int)) { print \"Test1: \", t1, \"\\n\"; }\nmethod Test2(t2: (int, ghost int, int)) { print \"Test2: \", t2, \"\\n\"; }\nmethod Test3(t3: ((ghost int), (ghost int, int), ghost int)) { print \"Test3: \", t3, \"\\n\"; }\nmethod Main() {\n  var p := PhantomData(123);\n  var t0, t1, t2, t3 := *, *, *, *;\n  Test0(t0);\n  Test1(t1);\n  Test2(t2);\n  Test3(t3);\n  t0 := (ghost 00);\n  t1 := (ghost 11, 22);\n  t2 := (33, ghost 44, 55);\n  t3 := ((ghost 66), (ghost 77, 88), ghost 99);\n  Test0(t0);\n  Test1(t1);\n  Test2(t2);\n  Test3(t3);\n  TestDestructors();\n  TestMatchDestructions();\n  var sss := TestSingletons();\n  print sss.1, \"\\n\"; \n  MoreSingletonTests();\n}\nmethod TestDestructors() {\n  var u := (100, 200);\n  print u.0, \" \", u.1, \"\\n\"; \n  var a, b, c, d := *, *, *, *; \n  print a, \" \", b, \" \", c, \" \", d, \"\\n\"; \n  a := (5, ghost 7, 9);\n  b := (ghost 9, ghost 16, 25, 36);\n  c := (ghost 7, 5);\n  d := (ghost 9, ghost 16, 25);\n  print a.2, \" \", b.2, \"\\n\"; \n  print c.1, \" \", d.2, \"\\n\"; \n}\nmethod TestMatchDestructions() {\n  var e := (ghost 15);\n  var a := (5, ghost 7, 9);\n  var b := (ghost 9, ghost 16, 25, 36);\n  var c := (ghost 7, 5);\n  var d := (ghost 9, ghost 16, 25);\n  match e {\n    case (_) => print e, \"\\n\"; \n  }\n  match a {\n    case (x, _, y) => print x, \" \", y, \"\\n\"; \n  }\n  match b {\n    case (_, _, x, y) => print x, \" \", y, \"\\n\"; \n  }\n  match c {\n    case (_, x) => print x, \"\\n\"; \n  }\n  match d {\n    case (_, _, x) => print x, \"\\n\"; \n  }\n  var ee := match e case (_) => e;\n  var aa := match a case (x, _, y) => x + y; \n  var bb := match b case (_, _, x, y) => x + y; \n  var cc := match c case (_, x) => x; \n  var dd := match d case (_, _, x) => x; \n  print ee, \" \", aa, \" \", bb, \" \", cc, \" \", dd, \"\\n\";\n}\nmethod TestSingletons() returns (r: (ghost int, int, ghost real, ghost real)) {\n  var s0 := Singleton0();\n  var s1 := Singleton1();\n  print s1, \"\\n\"; \n  var s2 := Singleton2();\n  var c := SingletonConst;\n  var u := (if s0.1 == s1.0 then 1100 else 1099) + s2.2 + c.0;\n  assert u == 1212;\n  r := (ghost u + 50, u, ghost s0.1, ghost s2.0);\n  var x;\n  match s2 {\n    case (a, b, c, d) => x := c;\n  }\n  x := x + match s2 case (a, b, c, d) => 1 - c;\n  assert x == 1;\n  return r.(1 := r.1 + x);\n}\nfunction Singleton0(): (ghost int, real) {\n  (ghost 2, 3.2)\n}\nfunction Singleton1(): (real, ghost int) {\n  (3.2, ghost 2)\n}\nfunction Singleton2(): (ghost real, ghost (), int, ghost char) {\n  (ghost 5.0, ghost (), 100, ghost 'D')\n}\nconst SingletonConst := (12, ghost 13)\ntype SX = (ghost int, int, ghost int)\ntype SX2 = (SX, ghost real)\ndatatype SX3 = SX3(a: SX, ghost b: real)\nmethod MoreSingletonTests() {\n  var r := (ghost 2, 3, ghost 4);\n  print r, \"\\n\"; \n  var arr := new SX[20];\n  arr[3] := (ghost 200, 100, ghost 400);\n  PrintOneSx(arr[3]); \n  print arr[0], \" \", arr[3], \"\\n\"; \n  UpdateArray(arr, (ghost 99, 9, ghost 999));\n  print arr[1], \" \", arr[2], \"\\n\"; \n  UpdateSxArray(arr, (ghost 99, 19, ghost 999));\n  print arr[4], \" \", arr[5], \"\\n\"; \n  var sx2 := (arr[5], ghost 2.0);\n  print sx2, \"\\n\"; \n  var arr2 := new SX2[20];\n  UpdateArray(arr2, ((ghost 5, 15, ghost 25), ghost 3.0));\n  print arr2[1], \" \", arr2[2], \"\\n\"; \n  var sx3 := SX3(arr[2], 4.0);\n  print sx3, \"\\n\"; \n  var arr3 := new SX3[20];\n  UpdateArray(arr3, sx3);\n  print arr3[1], \" \", arr3[2], \"\\n\"; \n}\nmethod PrintOneSx(g: SX) {\n  print g, \"\\n\";\n}\nmethod UpdateArray<T(0)>(arr: array<T>, t: T)\n  requires 10 <= arr.Length\n  modifies arr\n{\n  var tt: T := *;\n  arr[1] := tt;\n  arr[2] := t;\n}\nmethod UpdateSxArray(arr: array<SX>, t: SX)\n  requires 10 <= arr.Length\n  modifies arr\n{\n  var tt: SX := *;\n  arr[4] := tt;\n  arr[5] := t;\n}"
},
{
    "dafny": "predicate sorted_between (a:array<int>, from:nat, to:nat)\n  reads a;\n  requires a != null;\n  requires from <= to;\n  requires to <= a.Length;\n{\n  forall i,j :: from <= i < j < to && 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\npredicate sorted (a:array<int>)\n  reads a;\n  requires a!=null;\n{\n  sorted_between (a, 0, a.Length)\n}\npredicate beq(a:seq<int>, b:seq<int>, k1:nat, k2:nat)\n  requires k1 <= k2 < |a|;\n  requires |a| == |b|;\n{\n  forall i :: k1 <= i <= k2 ==> a[i] == b[i]\n}\npredicate partitioned(a:array<int>, l1:nat, u1:nat, l2:nat, u2:nat)\n  requires a != null;\n  requires l1 <= u1 <= l2 <= u2 < a.Length;\n  reads(a);\n{\n  forall i, j :: l1 <= i <= u1 < l2 <= j <= u2 ==> a[i] <= a[j]\n}"
},
{
    "dafny": "method MinOfMultiset( m: multiset<int> ) returns( min: int )\n    requires m != multiset{};\n    ensures min in m;\n    ensures forall z | z in m :: min <= z;\n{\n    min :| min in m;\n    var done := multiset{min};\n    var m' := m-done;\n    while m' != multiset{}\n        decreases m';\n        invariant m == done+m';\n        invariant min in done;\n        invariant forall z | z in done :: min <= z;\n    {\n        var z :| z in m';\n        done := done+multiset{z};\n        m' := m'-multiset{z};\n        if z < min { min := z; }\n    }\n}\nmethod Test( m: multiset<int> )\n{\n    var s := Sort(m);\n    assert multiset(s) == m;\n    assert forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n}\nmethod Main()\n{\n    var m := multiset{0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9};\n    var s := Sort(m);\n    assert multiset(s) == m;\n    assert forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    print s;\n}\nmethod Sort( m: multiset<int> ) returns ( s: seq<int> )\n    ensures multiset(s) == m;\n    ensures forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n{\n    s := [];\n    var m' := m;\n    while m' != multiset{}\n        decreases m';\n        invariant m == m'+multiset(s);\n        invariant forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n        invariant forall z | z in m' :: forall r | 0 <= r < |s| :: z >= s[r];\n    {\n        var x := MinOfMultiset(m');\n        m' := m' - multiset{x};\n        s := s + [x];\n    }\n    return s;\n}"
},
{
    "dafny": "module RealArith {\n  function Abs(r: real): real {\n    if r >= 0.0 then r else -r\n  }\n  function Max(x: real, y: real): real {\n    if x >= y then x else y\n  }\n  function Min(x: real, y: real): real {\n    if x <= y then x else y\n  }\n  function Dist(x: real, y: real): real {\n    Abs(x - y)\n  }\n  lemma TriangleInequality(a: real, b: real, c: real)\n    ensures Dist(a, c) <= Dist(a, b) + Dist(b, c)\n  {}\n  lemma AbsMul(x: real, y: real)\n    ensures Abs(x * y) == Abs(x) * Abs(y)\n  {}\n  lemma MulMonotonicStrict(factor: real, x: real, y: real)\n    requires x < y\n    requires factor > 0.0\n    ensures x * factor < y * factor\n    ensures factor * x < factor * y\n  {}\n  lemma MulMonotonic(factor: real, x: real, y: real)\n    requires x <= y\n    requires factor >= 0.0\n    ensures x * factor <= y * factor\n    ensures factor * x <= factor * y\n  {}\n  lemma DivMulEqualsMulDiv(a: real, b: real, c: real)\n    requires b != 0.0\n    ensures a / b * c == a * c / b\n  {}\n  lemma DivMulEqualsDivDiv(a: real, b: real, c: real)\n    requires b != 0.0\n    requires c != 0.0\n    ensures a / (b * c) == a / b / c\n  {}\n  lemma DivMulEqualsDivDiv2(a: real, b: real, c: real)\n    requires b != 0.0\n    requires c != 0.0\n    ensures a / (b / c) == a * c / b\n  {}\n  lemma AbsDiv(a: real, b: real)\n    requires b != 0.0\n    ensures Abs(a / b) == Abs(a) / Abs(b)\n  {\n    if a >= 0.0 {}\n  }\n  lemma MultiplicationCancelMonotonic(factor:real, x: real, y: real)\n    requires factor > 0.0\n    ensures x * factor <= y * factor ==> x <= y\n  {}\n  lemma DivisionIsMonotonic(a: real, b: real, c: real)\n    requires c > 0.0\n    requires a <= b\n    ensures a / c <= b / c\n  {}\n  lemma DivisionIsMonotonicStrict(a: real, b: real, c: real)\n    requires c > 0.0\n    requires a < b\n    ensures a / c < b / c\n  {}\n  lemma DivisionIsAntiMonotonic(a: real, b: real, c: real)\n    requires a >= 0.0\n    requires b > 0.0\n    requires c > 0.0\n    requires c <= b\n    ensures a / b <= a / c\n  {}\n  lemma DivisionIsAntiMonotonicStrict(a: real, b: real, c: real)\n    requires a > 0.0\n    requires b > 0.0\n    requires c > 0.0\n    ensures (c < b) <==> (a / b < a / c)\n  {}\n}"
},
{
    "dafny": "method SelectionSort(a: array<int>)\n    modifies a;\n    ensures  Sorted(a, 0, a.Length);\n    ensures  multiset(a[..]) == multiset(old(a[..]));\n{\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length;\n        invariant Sorted(a, 0, i);\n        invariant multiset(a[..]) == multiset(old(a[..]));\n        invariant forall j, k | 0 <= j < i <= k < a.Length :: a[j] <= a[k];\n        decreases a.Length - i;\n    {\n        var min := i;\n        var j := i + 1;\n        while j < a.Length\n            invariant i + 1 <= j <= a.Length;\n            invariant i <= min < a.Length;\n            invariant forall k | i <= k < j :: a[min] <= a[k];\n            decreases a.Length - j;\n        {\n            if a[j] < a[min] {\n                min := j;\n            }\n            j := j + 1;\n        }\n        a[i], a[min] := a[min], a[i];\n        i := i + 1;\n    }\n}\npredicate Sorted(a: array<int>, l: int, r: int)\n    reads a;\n    requires 0 <= l <= r <= a.Length;\n{\n    forall i, j | l <= i < j < r :: a[i] <= a[j]\n}"
},
{
    "dafny": "method Main() {\n  var c := '\\0';\n  assert c == 0 as char;\n  expect c == 0 as char;\n  var s := \"\\03\";\n  assert |s| == 2;\n  expect |s| == 2;\n  assert s[0] == 0 as char;\n  expect s[0] == 0 as char;\n  assert s[1] == '3';\n  expect s[1] == '3';\n}"
},
{
    "dafny": "method IncDec(x:int,y:int)returns(sum:int)\n    ensures sum == x + y;\n{\n  var count :=0;\n  var j := y;\n  if(j < 0){\n    j := -y;\n  }\n  sum := x;\n  assert sum == x;\n  assert y >= 0 ==> j ==y;\n  assert y < 0 ==> j == -y;\n  while count < j\n     invariant 0 <= count <= j\n     invariant y >= 0 ==> sum == x + count;\n     invariant y <= 0 ==> sum == x - count;\n     decreases j - count\n  {\n    if(y >= 0){\n      sum := sum + 1;\n    }\n    else{\n      sum := sum - 1;\n    }\n    count := count + 1;\n  }\n  assert y >= 0 ==> count == j == y;\n  assert y < 0 ==> -count == -j == y; \n  assert y >= 0 ==> sum == x + count == x + j == x + y;\n  assert y < 0 ==> sum == x - count == x + y;\n}\nmethod Main(){\n   var sum := IncDec(5,15);\n   assert sum == 20;\n   sum := IncDec(5,-15);\n   assert sum == -10;\n   sum := IncDec(5,0);\n   assert sum == 5;\n   sum := IncDec(-5,15);\n   assert sum == 10;\n   sum := IncDec(-5,-15);\n   assert sum == -20;\n   sum := IncDec(-5,0);\n   assert sum == -5;\n}"
},
{
    "dafny": "method Main() {\n  var e := 9999;\n  while e > 0\n    decreases e\n    invariant e >= 0\n    {\n      print \"e\";\n      e := e - 1;\n    }\n}"
},
{
    "dafny": "predicate Sorted(a: array <int >, low: int , high: int)\nreads a\n{\n    forall i, j :: 0  <= low  <= i  <= j  < high <= a.Length ==> a[i]  <= a[j]\n}\nmethod BubbleSort(a: array <int>)\nmodifies a;\nensures Sorted(a, 0, a.Length);\nensures multiset(a[..]) == multiset(old(a[..]));\n{\n    var i := a.Length - 1;\n    while(i > 0)\n    invariant i < 0 ==> a.Length == 0;\n    invariant Sorted(a, i, a.Length);\n    invariant forall x, y :: 0  <= x  <= i < y < a.Length ==> a[x] <= a[y]; \n    invariant multiset(a[..]) == multiset(old(a[..]));\n    {\n        var j := 0;\n        while (j < i)\n        invariant 0 <= j <= i;\n        invariant Sorted(a, i, a.Length);\n        invariant forall x, y :: 0  <= x  <= i < y < a.Length ==> a[x] <= a[y];\n        invariant forall k :: 0 <= k <= j ==> a[k] <= a[j];\n        invariant multiset(a[..]) == multiset(old(a[..]));\n        {\n            if (a[j] > a[j+1]) {\n                a[j], a[j+1] := a[j+1], a[j];\n            }\n            j := j + 1;\n        }\n        i := i - 1;\n    }\n}"
},
{
    "dafny": "method F() returns(x:int)\n  ensures x == 6\n{\n  x := 5;\n  x := (var y := 1; y + x);\n}\nmethod Main()\n{\n  var x := F();\n  print x;\n}"
},
{
    "dafny": "method ifelse(x: int) returns (result : int)\nrequires x >= 0\n{\n  if(x == 0){\n    result :=1 ;\n  }\n  else{\n    result :=2 ;\n  }\n  assert result > 0;\n  return result;\n}\nmethod Main(){\n  var z1 :=0;\n  assert z1 == 0;\n  var result1 := ifelse(z1);\n  print result1;\n  print \"\\n\";\n  var z2 :=1;\n  assert z2 >0 ;\n  var result2 := ifelse(z2);\n  print result2;\n}"
},
{
    "dafny": "module Seqs {\n  function last<T>(s:seq<T>) : T\n    requires |s| > 0;\n  {\n    s[|s|-1]\n  }\n  function all_but_last<T>(s:seq<T>) : seq<T>\n    requires |s| > 0;\n  {\n    s[..|s|-1]\n  }\n  function reverse<T>(s:seq<T>) : seq<T>\n    ensures |reverse(s)| == |s|\n  {\n    if s == [] then []\n    else reverse(s[1..]) + [s[0]]\n  }\n}"
},
{
    "dafny": "method mc91(n: nat) returns (b: nat)\n  requires n <= 101;\n  ensures b == 91; \n{\n  var m, c;\n  c := 1;\n  m := n;\n  while (c > 0)\n    invariant m <= 111;\n    invariant m > 100 && c == 1 ==> m == 101;\n    invariant c == 0 ==> m == 91;\n    decreases 21 * c + (400 - 2 * m);\n  {\n    if (m > 100) {\n      m := m - 10;\n      c := c - 1;\n    }\n    else {\n      m := m + 11;\n      c := c + 1;\n    }\n  }\n  return m;\n}"
},
{
    "dafny": "method Add(x: int, y: int) returns (r: int)\n  ensures r == x+y;\n{\n  r := x;\n  if (y < 0) {\n    var n := y;\n    while (n != 0)\n      invariant r == x+y-n && 0 <= -n;\n    {\n      r := r - 1;\n      n := n + 1;\n    }\n  } else {\n    var n := y;\n    while (n != 0)\n      invariant r == x+y-n && 0 <= n;\n    {\n      r := r + 1;\n      n := n - 1;\n    }\n  }\n}\nmethod Mul(x: int, y: int) returns (r: int)\n  ensures r == x*y;\n  decreases x < 0, x;\n{\n  if (x == 0) {\n    r := 0;\n  } else if (x < 0) {\n    r := Mul(-x, y);\n    r := -r;\n  } else {\n    r := Mul(x-1, y);\n    r := Add(r, y);\n  }\n}\nmethod Main() {\n  var a: int;\n  var b: int;\n  a := 3;\n  b := 5;\n  var add := Add(a, b);\n  var mul := Mul(a,b);\n  print \"Add: \", add;\n  print \" Mul: \", mul;\n}"
},
{
    "dafny": "module DivMod {\n  function {:opaque} DivSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then 0 else 1 + DivSub(a - b, b)\n  }\n  function {:opaque} ModSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then a else ModSub(a - b, b)\n  }\n  lemma DivModAdd1(a: int, b: int)\n    requires b != 0\n    ensures (a + b) % b == a % b\n    ensures (a + b) / b == a / b + 1\n  {\n    var c := (a + b) / b - (a / b) - 1;\n    assert c * b + (a + b) % b - a % b == 0;\n  }\n  lemma DivModSub1(a: int, b: int)\n    requires b != 0\n    ensures (a - b) % b == a % b\n    ensures (a - b) / b == a / b - 1\n  {\n    var c := (a - b) / b - (a / b) + 1;\n    assert c * b + (a - b) % b - a % b == 0;\n  }\n  lemma ModEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a % b == ModSub(a, b)\n  {\n    reveal ModSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a / b == DivSub(a, b)\n  {\n    reveal DivSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivModSpec'(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures ModSub(a, b) == r\n    ensures DivSub(a, b) == q\n  {\n    reveal ModSub();\n    reveal DivSub();\n    if q > 0 {\n      DivModSpec'(a - b, b, q - 1, r);\n    }\n  }\n  lemma DivModSpec(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures a % b == r\n    ensures a / b == q\n  {\n    ModEq(a, b);\n    DivEq(a, b);\n    DivModSpec'(a, b, q, r);\n  }\n  lemma DivMul(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a * b / b == a\n  {\n    DivModSpec(a * b, b, a, 0);\n  }\n  lemma DivModMulAdd(a: int, b: int, c: int)\n    requires 0 <= a && 0 <= c < b && 0 < b\n    ensures (a * b + c) / b == a\n    ensures (a * b + c) % b == c\n  {\n    DivModSpec(a * b + c, b, a, c);\n  }\n}"
},
{
    "dafny": "function min(x:nat, y:nat) : nat {\n  if (x < y) then x else y\n}\nmethod slow_min(a: nat, b:nat) returns (z:nat)\n  ensures z == min(a, b);\n{\n  var x := a;\n  var y := b;\n  z := 0;\n  while (x != 0 && y != 0)\n    invariant 0<= x <= a\n    invariant 0<= y <= b\n    invariant (a-x) == (b-y)\n    invariant z == (a-x) || z == (b -y)\n    decreases x\n    decreases y\n  {\n    x := x - 1;\n    y := y - 1;\n    z := z + 1;\n  }\n}"
},
{
    "dafny": "class Score{\n    var highest_score: int;\n    predicate Valid()\n        reads this;\n    {\n        highest_score >= 0\n    }\n    constructor()\n    modifies this;\n    ensures Valid();\n    ensures highest_score == 0;\n    {\n        highest_score := 0;\n    }\n    method NewScore(score:int)returns(b: bool, curr: int)\n    modifies this\n    requires score >=0;\n    ensures Valid();\n    ensures if score > old(highest_score) then (b == true && curr == score == highest_score) else(b==false && curr == highest_score == old(highest_score))\n    {\n        b := true;\n        curr:= highest_score;\n        if score > this.highest_score {\n            this.highest_score := score;\n            b := true;\n            curr := score;\n        }\n        else{\n            b:=false;\n            curr:=this.highest_score;\n        }\n        return b, curr;\n    }\n}\nmethod TestScore(){\n    var sc := new Score();\n    var b, curr := sc.NewScore(2);\n    assert b==true && curr == 2;\n    b, curr := sc.NewScore(0);\n    assert b==false && curr == 2;\n    b, curr := sc.NewScore(4);\n    assert b==true&&curr==4;\n    b, curr := sc.NewScore(4);\n    assert b==false&&curr==4;\n    b, curr := sc.NewScore(6);\n    assert b==true&&curr==6;\n}"
},
{
    "dafny": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); \n     label N:\n     a.value := 20;\n     label P:\n     assert old(a.value) == 11;\n     assert old(a).value == 12; \n     assert old@L(a.value) == 11;\n     assert old@L(a).value == 12; \n     assert old@M(a.value) == 12; \n     assert old@M(a).value == 12;\n     assert old@N(a.value) == 10; \n     assert old@N(a).value == 20; \n     assert old@P(a.value) == 20;\n     assert old@P(a).value == 20;\n  }\n}"
},
{
    "dafny": "datatype D = Nil | MM | D(x: int, tail: D)\nmethod M1() {\nvar D(a,b) := D(1, D(2, Nil)); \nassert a == 1;\nassert b == D(2,Nil);\nexpect a == 1;\nexpect b == D(2,Nil);\n}\nmethod M4() {\nvar D(c, Nil) := D(1, Nil); \nassert c == 1;\nassert Nil == Nil();\nexpect c == 1;\nexpect Nil == Nil();\n}\nmethod M6() {\nvar D(a,D(b,Nil)) := D(1, D(2, Nil)); \nassert a == 1;\nassert b == 2;\nexpect a == 1;\nexpect b == 2;\n}\nmethod Main() {\n  M1();\n  M4();\n  M6();\n  print \"Done\\n\";\n}"
},
{
    "dafny": "method Main() \n{\n    var s: seq := [1,2,3,4,5];\n    var i,j := 0,0;\n    while ((j + 2) < |s| )\n    invariant 0 <= i <= j;\n    invariant j < |s|;\n    {\n      j := j + 2;\n      i := i + 1;\n    }\n    assert 0 <= i <= j < |s|;\n     var returnVal := s[i];\n     print returnVal;\n}"
},
{
    "dafny": "module {:extern} MapRemove_s {\n  function {:opaque} MapRemove1<K,V>(m:map<K,V>, k:K) : (m':map<K,V>)\n    ensures forall j :: j in m && j != k ==> j in m'\n    ensures forall j :: j in m' ==> j in m && j != k\n    ensures forall j :: j in m' ==> m'[j] == m[j]\n    ensures |m'.Keys| <= |m.Keys|\n    ensures k in m ==> |m'| == |m| - 1\n    ensures k !in m ==> |m'| == |m|\n  {\n    var m' := map j | j in m && j != k :: m[j];\n    assert m'.Keys == m.Keys - {k};\n    m'\n  }\n  method {:extern \"MapRemove__s_Compile\", \"ComputeMapRemove1\"}\n      ComputeMapRemove1<K,V>(m: map<K,V>, k:K) \n  returns (m' : map<K,V>)\n  ensures m' == MapRemove1(m, k)\n}"
},
{
    "dafny": "method Allocate<T(0)>(n: int) returns (a: array<T>)\n    requires n >= 0\n    ensures a != null && a.Length == n && fresh(a)\n{\n    a := new T[n];\n}\nmethod Main()\n{\n    var a := Allocate<int>(10);\n    a[0] := 0;\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && pre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || pre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\npredicate isSubstringPred(sub:string, str:string)\n{\n  exists k | 0 <= k <= |str| - |sub| :: sub == str[k..][..|sub|]\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\tforall k | 0 <= k <= |str| - |sub| :: isNotPrefixPred(sub, str[k..])\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\texists a | 0 <= a <= |str1| - k && 0 <= k <= min(|str1|, |str2|) :: isSubstringPred(str1[a..][..k], str2)\n}\nfunction min(a:int, b:int): int\n{\n\tif a <= b then a else b\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\t(forall a | 0 <= a <= |str1| - k :: isNotSubstringPred(str1[a..][..k], str2)) || \n\tk < 0 || \n\tk > min(|str1|, |str2|)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==> haveNotCommonKSubstringPred(k,str1,str2)\n{}"
},
{
    "dafny": "method Main() {\n  print \"hello, Main\\n\"; \n  P(); \n  var iter0 := new NoPrintIter(3);\n  var iter1 := new PrintIter(3);\n  var _ := iter0.MoveNext();\n  var _ := iter1.MoveNext(); \n  var cl0 := new Cl.NoPrint();\n  var cl1 := new Cl.Print(); \n}\nmethod {:print} P() {\n  print \"method P here\\n\";\n  M();\n  var iter0 := new NoPrintIter(3);\n  var iter1 := new PrintIter(3);\n  print \"calling MoveNexts\\n\";\n  MoveNexts(iter0, iter1);\n  var cl := new Cl.NoPrint();\n  cl := new Cl.Print();\n  TestOverrides();\n}\nmethod MoveNexts(iter0: NoPrintIter, iter1: PrintIter)\n  requires iter0.Valid() && iter1.Valid()\n  requires iter0._modifies == iter0._new == iter0._reads == {}\n  requires iter1._modifies == iter1._new == iter1._reads == {}\n  modifies iter0, iter1\n{\n  var more0 := iter0.MoveNext();\n  var more1 := iter1.MoveNext(); \n}\nmethod M() {\n  var x := F(3);\n  print \"bye, from M\\n\"; \n}\nfunction F(x: int): int {\n  10\n} by method {\n  print \"function-by-method F\\n\"; \n  return 10;\n}\niterator NoPrintIter(a: int) yields (x: int)\n{\n  print \"Start of Iter 0\\n\"; \n  yield 3 + a;\n  print \"End of Iter 0\\n\"; \n}\niterator {:print} PrintIter(a: int) yields (x: int)\n{\n  print \"Start of Iter 1\\n\";\n  yield 3 + a;\n  print \"End of Iter 1\\n\";\n}\nclass Cl {\n  constructor NoPrint() {\n    print \"Cl.NoPrint ctor\\n\"; \n  }\n  constructor {:print} Print() {\n    print \"Cl.Print ctor\\n\";\n  }\n}\ntrait Trait {\n  method {:print} MayPrint()\n  method {:print} AlwaysPrints()\n}\nclass Overrides extends Trait {\n  method MayPrint() { \n    print \"Override X\"; \n  }\n  method {:print} AlwaysPrints() {\n    print \" Y\\n\";\n  }\n}\nmethod {:print} TestOverrides() {\n  var c: Overrides := new Overrides;\n  var t: Trait := c;\n  t.MayPrint();\n  t.AlwaysPrints();\n  c.MayPrint();\n  c.AlwaysPrints();\n  TestOverridesNoPrint(c, t);\n}\nmethod TestOverridesNoPrint(c: Overrides, t: Trait) {\n  t.MayPrint(); \n  t.AlwaysPrints(); \n  c.MayPrint();\n  c.AlwaysPrints(); \n}"
},
{
    "dafny": "method integerDiv(n: nat, d: nat) returns (r: nat, q: nat)\n    requires n >= 0 && d > 0\n    ensures 0 <= r < d && n == (q * d + r)\n{\n    q := 0;\n    r := n;\n    while (r >= d) \n        decreases r\n        invariant q * d + r == n; \n    {   \n        q := q + 1;\n        r := r - d;\n    }\n}"
},
{
    "dafny": "method Main()\n{\n    var s1:set<int> := {}; \n    var s2 := {1,2,3};\n    assert {1,1,2,2,2,3} == s2; \n    assert {1,2} == {2,1}; \n    assert {1,2} != {1}; \n    assert |s1| == 0; \n    assert |s2| == 3;\n    assert 1 in s2; \n    assert 0 !in s2; \n    var s3 := {1,2};\n    var s4 := {3,4};\n    assert s2 + s4 == {1,2,3,4}; \n    assert s2 * s3 == {1,2}; \n    assert s2 - s3 == {3}; \n    assert {1} <= {1, 2}; \n    assert {} < {1, 2}; \n    assert {1,2} >= {1}; \n    assert {1,2} > {}; \n    assert s3 !! s4; \n}"
},
{
    "dafny": "method F() returns ( r: int)\n    ensures r <= 0\n{\n    r := 0;\n}\nmethod Main() \n{\n    var x := F();\n    assert x <= 0;\n    x := x-1;\n    assert x <= -1;\n    print x;\n}\nmethod Mid( p: int, q: int) returns ( m: int )\n    requires p <= q;\n    ensures p<= m <= q;\n    ensures m-p <= q-m;\n    ensures 0 <= (q-m)-(m-p) <= 1;\n{\n    m := (p+q)/2;\n    assert m == p+(q-p)/2;\n}"
},
{
    "dafny": "method max(a:array<int>, numelems:int) returns(r:int)\n  requires numelems > 0;\n  requires a != null && a.Length >= numelems;\n  ensures forall j :: 0 <= j < numelems ==> r >= a[j];\n  ensures exists j :: 0 <= j < numelems && r == a[j];\n{\n  var i:int := 1;\n  r := a[0];\n  while(i<numelems)\n  invariant 1 <= i <= numelems;\n  invariant forall j :: 0 <= j < i ==> r >= a[j];\n  invariant exists j :: 0 <= j < i && r == a[j];\n  {\n    if (a[i] > r) {\n      r := a[i];\n    }\n    i:= i + 1;\n  }\n}"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} Dafny.Relations {\n  ghost predicate Injective<X(!new), Y>(f: X-->Y)\n    reads f.reads\n    requires forall x :: f.requires(x)\n  {\n    forall x1, x2 :: f(x1) == f(x2) ==> x1 == x2\n  }\n  ghost predicate Commutative<T(!new),U(!new)>(f: (T,T)->U)\n    reads f.reads\n    requires forall x,y :: f.requires(x,y) && f.requires(y,x)\n  {\n    forall x,y :: f(x,y) == f(y,x)\n  }\n  ghost predicate Associative<T(!new)>(f: (T,T)->T)\n    reads f.reads\n    requires forall x, y, z :: f.requires(x,y) && f.requires(y,z) && f.requires(x,z)\n  {\n    forall x, y, z: T :: f(x,f(y,z)) == f(f(x,y),z)\n  }\n  ghost predicate Reflexive<T(!new)>(R: (T, T) -> bool) {\n    forall x :: R(x, x)\n  }\n  ghost predicate Irreflexive<T(!new)>(R: (T, T) -> bool) {\n    forall x :: !R(x, x)\n  }\n  ghost predicate AntiSymmetric<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) && R(y, x) ==> x == y\n  }\n  ghost predicate Asymmetric<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) ==> !R(y, x)\n  }\n  ghost predicate Symmetric<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) <==> R(y, x)\n  }\n  ghost predicate Connected<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: x != y ==> R(x, y) || R(y, x)\n  }\n  ghost predicate StronglyConnected<T(!new)>(R: (T, T) -> bool) {\n    forall x, y :: R(x, y) || R(y, x)\n  }\n  ghost predicate Transitive<T(!new)>(R: (T, T) -> bool) {\n    forall x, y, z :: R(x, y) && R(y, z) ==> R(x, z)\n  }\n  ghost predicate TotalOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && AntiSymmetric(R)\n    && Transitive(R)\n    && StronglyConnected(R)\n  }\n  ghost predicate StrictTotalOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Irreflexive(R)\n    && AntiSymmetric(R)\n    && Transitive(R)\n    && Connected(R)\n  }\n  ghost predicate PreOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Transitive(R)\n  }\n  ghost predicate PartialOrdering<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Transitive(R)\n    && AntiSymmetric(R)\n  }\n  ghost predicate EquivalenceRelation<T(!new)>(R: (T, T) -> bool) {\n    && Reflexive(R)\n    && Symmetric(R)\n    && Transitive(R)\n  }\n  ghost predicate IsLeast<T>(R: (T, T) -> bool, min: T, s: set<T>) {\n    min in s && forall x | x in s :: R(min, x)\n  }\n  ghost predicate IsMinimal<T>(R: (T, T) -> bool, min: T, s: set<T>) {\n    min in s && forall x | x in s && R(x, min) :: R(min, x)\n  }\n  ghost predicate IsGreatest<T>(R: (T, T) -> bool, max: T, s: set<T>) {\n    max in s && forall x | x in s :: R(x, max)\n  }\n  ghost predicate IsMaximal<T>(R: (T, T) -> bool, max: T, s: set<T>) {\n    max in s && forall x | x in s && R(max, x) :: R(x, max)\n  }\n}"
},
{
    "dafny": "function abs(a:int):nat\n{\n    if a < 0 then -a else a\n}\nmethod aba(a:array<int>)returns (b:array<int>)\nensures a.Length == b.Length \nensures forall x :: 0<=x<b.Length ==> b[x] == abs(a[x])\n{\n    b := new int[a.Length];\n    var i:=0;\n    while(i < a.Length)\n    invariant 0<= i <= a.Length\n    invariant forall x :: 0<=x<i ==> b[x] == abs(a[x])\n    {\n        if(a[i] < 0){\n            b[i] := -a[i];\n        } else{\n            b[i] := a[i];\n        }\n        i := i + 1;\n    }\n}\nmethod Main()\n{\n  var a := new int[][1,-2,-2,1];\n  var b := aba(a);\n  assert b[..] == [1,2,2,1];\n}"
},
{
    "dafny": "method DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n{\n  a := 2 * x;\n  b := 2 * a;\n}\nmethod TestMethod(){\n  var test1A, test1B := DoubleQuadruple(5);\n  print(\"Test 1: DoubleQuadruple(5) = \", test1A, \", \", test1B, \"\\n\");\n  var test2A, test2B := DoubleQuadruple(0);\n  print(\"Test 2: DoubleQuadruple(0) = \", test2A, \", \", test2B, \"\\n\");\n  var test3A, test3B := DoubleQuadruple(-3);\n  print(\"Test 3:  DoubleQuadruple(-3) = \", test3A, \", \", test3B, \"\\n\");\n  var test4A, test4B := DoubleQuadruple(12);\n  print(\"Test 4:  DoubleQuadruple(12) = \", test4A, \", \", test4B, \"\\n\");\n  var test5A, test5B := DoubleQuadruple(19);\n  print(\"Test 5:  DoubleQuadruple(19) = \", test5A, \", \", test5B, \"\\n\");\n}\nmethod Main(){\n  TestMethod();\n}"
},
{
    "dafny": "method PTOQ<T>(r: set<T>) returns (ac: seq<T>)\n{\n  ac := [];\n  var iexr: set<T> := r;\n  while iexr != {}\n    invariant multiset(iexr) + multiset(ac) == multiset(r)\n  {\n    var e :| e in iexr;\n    iexr := iexr - {e};\n    ac := ac + [e];\n  }\n}"
},
{
    "dafny": "method lastIndexOf(items: array<int>, item: int) returns (r: int)\n  requires items != null\n  ensures r < items.Length\n  ensures r >= 0 ==> items[r] == item\n  ensures r >= 0 ==> forall x :: r < x < items.Length\n                     ==> items[x] != item\n  ensures r < 0 ==> forall x :: 0 <= x < items.Length\n                    ==> items[x] != item\n{\n    r := items.Length;\n    while r > 0\n      invariant 0 <= r <= items.Length\n      decreases r\n      invariant forall x :: r <= x < items.Length ==> items[x] != item\n    {\n        r := r - 1;\n        if items[r] == item { return; }\n    }\n    r := -1;\n}"
},
{
    "dafny": "method max(a: array<int>) returns (res: int)\n  requires a!= null;\n  ensures forall i: int :: 0 <= i < a.Length ==> a[i] <= res\n  ensures (a.Length > 0)==> (exists i: int :: 0 <= i < a.Length && a[i] == res)\n  {\n    if(a.Length == 0){\n      res := 0;\n    }\n    else{\n      res := a[0];\n      var i := 1;\n      while (i < a.Length)\n      invariant i <= a.Length\n      invariant (forall j: int :: 0 <= j < i ==>  a[j] <= res)\n      invariant (exists j: int :: 0 <= j < i && a[j] == res)\n      decreases (a.Length-i); \n      {\n        if(a[i] > res){\n          res := a[i];\n        }\n        i := i + 1;\n      }\n    }\n  }"
},
{
    "dafny": "class {:extern \"java.lang.String\"} JavaString {\n  ghost const value: string\n}\nmethod {:extern \"Util.Conversions\", \"ToJavaString\"} ToJavaString(s: string) returns (js: JavaString)\n  ensures js.value == s\nfunction {:extern \"dafny.DafnySequence\", \"asString\"} ToDafnyString(js: JavaString): string\n  ensures ToDafnyString(js) == js.value\nmethod {:extern \"dafny.ExternJavaString\", \"getStringFromFile\"} GetStringFromFile() returns (js: JavaString)\nmethod Main() {\n  var js := GetStringFromFile();\n  var s := ToDafnyString(js);\n  var previousStart := 0;\n  for i := 0 to |s|\n    invariant previousStart <= i\n  {\n    if s[i] == '/' {\n      print s[previousStart..i], \"\\n\";\n      previousStart := i + 1;\n    }\n  }\n  if previousStart != |s| {\n    print s[previousStart..], \"\\n\";\n  }\n}"
},
{
    "dafny": "class UntestedBlood {\n    var id: int;\n    var retrieval:int;\n    constructor (bloodid: int, rdate: int)\n    ensures id == bloodid && rdate == retrieval\n    modifies this`id, this`retrieval\n    {\n        id := bloodid;\n        retrieval := rdate;\n    }\n}"
},
{
    "dafny": "method sortedInsertion(a:array<int>, na:int, e:int) returns (z:array<int>, nz:int, pos:int)\n    requires 0 <= na < a.Length\n    requires sorted(a, na)\n    ensures 0 <= pos <= na && a[pos] == e\n    ensures sorted(a, na + 1)\n    ensures forall k :: 0 <= k < pos ==> a[k] == old(a[k])\n    ensures forall k :: pos < k < na ==> a[k] == old(a[k-1])\n    modifies a\n{\n    var i := na;\n    if na > 0\n    { a[na] := a[na-1];}\n    while 0 < i && e < a[i-1]\n        decreases i\n        invariant 0 <= i <= na\n        invariant sorted(a, na+1)\n        invariant forall k :: i < k < na + 1 ==> e <= a[k]\n        invariant forall k :: 0 <= k < i ==> a[k] == old(a[k])\n        invariant forall k :: i < k < na ==> a[k] == old(a[k-1])\n    {\n        a[i] := a[i-1];\n        i := i - 1;\n    }\n    a[i] := e;\n    return a, na + 1, i;\n}\nfunction sortedRange(a:array<char>, l:int, h:int):bool\n    requires 0 <= l <= h <= a.Length\n    reads a\n{ forall i, j:: (l <= i < j < h) ==> a[i] <= a[j] }\nfunction sorted(a:array<int>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ forall i, j:: (0 <= i < j < n) ==> a[i] <= a[j] }\nmethod orderedInsert(a:array<int>, n:int, v:int)\n  requires 0 <= n < a.Length\n  requires sorted(a, n)\n  modifies a \n  ensures sorted(a, n+1)"
},
{
    "dafny": "datatype Blood = Blood(typeOf:char,date:int)\nmethod FindOldest (a:array<Blood>) returns (minimum:Blood)\nrequires a != null;\nrequires a.Length > 0;\nensures forall i :: 0 <= i < a.Length ==> minimum.date <= a[i].date;\nensures multiset(a[..]) == multiset(old(a[..]))\n{\n    var minimumDate : int := a[0].date;\n    var minimumType : char := a[0].typeOf;\n    var i : int := 1;\n    while (i < a.Length)\n    invariant (i <= a.Length)\n    invariant (forall j :: 0 <= j < i ==> minimumDate <= a[j].date) \n        && (exists j :: 0 <= j < i && minimumDate == a[j].date)\n    {\n        if (a[i].date <= minimumDate){\n            minimumDate := a[i].date;\n            minimumType := a[i].typeOf;\n        }\n        i := i + 1;\n    }\n    minimum := Blood(minimumType,minimumDate);    \n    return minimum;\n}\nmethod FindType (a:array<Blood>,typeOf:char) returns (newA:array<Blood>)\nrequires a != null;\nrequires a.Length > 1;\nensures multiset(a[..]) == multiset(old(a[..]))\n{\n    newA := new Blood[a.Length];\n    var i : int := 1;\n    var count : int := 0;\n    while (i < a.Length)\n    invariant (i <= a.Length)\n    invariant (count <= i)\n    {\n        if a[i].typeOf == typeOf{\n            newA[count] := a[i];\n            count := count + 1;\n        }\n        i := i + 1;\n    }\n    SortArray(newA);\n    return newA;\n}\npredicate Sorted(a: array<Blood>, low:int, high:int)\nrequires a != null;\nrequires 0<=low<=high<=a.Length;\nreads a;\n{ forall j,k:: low<=j<k<high ==> a[j].date<=a[k].date }\nmethod SortArray(a:array<Blood>) \nrequires a != null;\nrequires a.Length > 1;\nensures forall i :: 0 <= i < (a.Length-1) ==> a[i].date <= a[i+1].date;\nensures multiset(a[..]) == multiset(old(a[..]));\nmodifies a;\n{\n    var up := 1;\n    while (up < a.Length)\n    invariant 1 <= up <= a.Length;\n    invariant Sorted(a,0,up);\n    invariant multiset(a[..]) == multiset(old(a[..]));\n    {\n        var down := up;\n        while (down >= 1 && a[down-1].date > a[down].date)\n        invariant 0 <= down <= up;\n        invariant forall i,j :: (0<=i<j<=up && j!=down) ==> a[i].date<=a[j].date;\n        invariant multiset(a[..]) == multiset(old(a[..]))\n        {\n            a[down-1], a[down] := a[down], a[down-1];\n            down := down - 1;\n        }\n        up := up + 1;\n    }\n}\nmethod Main() {\n    var ar : array<Blood> := new Blood[3];\n    ar[0] := Blood('A', 7);\n    ar[1] := Blood('B', 3);\n    ar[2] := Blood('A', 2);\n}"
},
{
    "dafny": "method LinearSearch0<T>(a: array<T>, P:T -> bool) returns (n: int)\n    ensures 0 <= n <= a.Length\n    ensures n == a.Length || P(a[n])\n{\n    n := 0;\n    while n != a.Length\n        invariant 0 <= n <= a.Length\n        decreases if n <= a.Length then a.Length - n else n - a.Length\n    {\n        if P(a[n]) {\n            return;\n        }\n        n := n + 1;\n    }\n}\nmethod LinearSearch1<T>(a: array<T>, P:T -> bool) returns (n: int)\n    ensures 0 <= n <= a.Length\n    ensures n == a.Length || P(a[n])\n    ensures forall i :: 0 <= i < n ==> !P(a[i])\n{\n    n := 0;\n    while n != a.Length\n        invariant 0 <= n <= a.Length\n        invariant forall i :: 0 <= i < n ==> !P(a[i])\n    {\n        if P(a[n]) {\n            return;\n        }\n        n := n + 1;\n    }\n}\nmethod LinearSearch3<T>(a: array<T>, P:T -> bool) returns (n: int)\n    requires exists i :: 0 <= i < a.Length && P(a[i])\n    ensures 0 <= n < a.Length && P(a[n])\n{\n    n := 0;\n    while true\n        invariant 0 <= n < a.Length\n        invariant exists i :: n <= i < a.Length && P(a[i])\n        decreases a.Length - n\n    {\n        if P(a[n]) {\n            return;\n        }\n        n := n + 1;\n    }\n}\nmethod min(a: array<int>) returns (m: int)\n    requires a.Length > 0 \n    ensures exists i :: 0 <= i < a.Length && m == a[i]\n    ensures forall i :: 0 <= i < a.Length ==> m <= a[i]\n{\n    var n := 0;\n    m := a[0];\n    while n != a.Length\n        invariant 0 <= n <= a.Length\n        invariant forall i :: 0 <= i < n ==> m <= a[i]\n        invariant exists i :: 0 <= i < a.Length && m == a[i]\n    {\n        if a[n] < m {\n            m := a[n];\n        }\n        n := n + 1;\n    }\n}"
},
{
    "dafny": "method A(x: nat, y: nat)\n    decreases x + y, 1\n{\n    if y > 2 {B(x + 2, y - 2);}\n}\nmethod B(x: nat, y: nat) \n    decreases x + y, 0\n{\n    if x > 2 {A(x - 2,y + 1);}\n}"
},
{
    "dafny": "predicate sorted(a: array<int>)\n   requires a != null;\n   reads a;\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted_slice(a: array<int>, l:int, h:int)\n  requires a != null;\n  reads a;\n{\n  forall j, k :: l <= j < k <= h && 0 <= j && k < a.Length ==> a[j] <= a[k]\n}\nmethod bubble(a: array<int>)\n  requires a != null;\n  modifies a;\n  ensures sorted(a);\n{\n  var i, n, s;\n  n := a.Length;\n  s := a.Length > 0;\n  while (s)\n    invariant sorted_slice(a, n, a.Length - 1);\n    invariant forall j, k :: 0 <= j < n && n <= k < a.Length ==> a[j] <= a[k];\n    invariant !s ==> sorted_slice(a, 0, n);\n    invariant n > 0 || !s;\n    decreases n;\n  {\n    s := false;\n    i := 1;\n    while (i <= n - 1)\n      invariant n <= 1 ==> !s;\n      invariant 1 <= i && i <= n;\n      invariant sorted_slice(a, n, a.Length - 1);\n      invariant forall j, k :: 0 <= j < n && n <= k < a.Length ==> a[j] <= a[k];\n      invariant forall j :: 0 <= j <= i - 1 ==> a[j] <= a[i - 1]; \n      invariant !s ==> sorted_slice(a, 0, i - 1);\n    {\n      if (a[i - 1] > a[i]) {\n         a[i - 1], a[i] := a[i], a[i - 1];\n\t       s := true;\n      }\n      i := i + 1;\n    }\n    n := n - 1;\n  }\n}"
},
{
    "dafny": "ghost predicate Extends<K, V>(m1: map<K, V>, m2: map<K, V>) {\n    forall k :: k in m2 ==> k in m1 && m1[k] == m2[k]\n}\nghost predicate UndefOn<K(!new), V>(m: map<K, V>, p: K -> bool) {\n    forall k :: p(k) ==> k !in m\n}\nghost predicate Disjoint<K(!new)>(p1: K -> bool, p2: K -> bool) {\n    forall k :: !(p1(k) && p2(k))\n}\nghost predicate Subset<K(!new)>(p1: K -> bool, p2: K -> bool) {\n    forall k :: p1(k) ==> p2(k)\n}\nghost predicate OnlyDiffer<K(!new), V>(m1: map<K, V>, p: K -> bool, m2: map<K, V>) {\n    forall k :: p(k) || (k !in m1 && k !in m2) || (k in m1 && k in m2 && m1[k] == m2[k])\n}\nfunction Diff<K>(p1: K -> bool, p2: K -> bool): K -> bool {\n    k => p1(k) && !p2(k)\n}\nlemma flattenStmt_correct_aux_lemma6<K(!new), V>(\n    initialH: map<K, V>, initialL: map<K, V>, \n    fvngs: K -> bool, emv: K -> bool, av: V, vv : V,\n    v: K, v0 : K, \n    prefinalL: map<K, V>, finalL: map<K, V>, \n    fvn: K -> bool, fvngs': K -> bool, mvs0: K -> bool, mvs: K -> bool\n)\n    requires Extends(initialL, initialH)\n    requires UndefOn(initialH, fvngs)\n    requires Disjoint(emv, fvngs)\n    requires v in prefinalL && prefinalL[v] == av\n    requires v0 in finalL && finalL[v0] == vv\n    requires Subset(fvngs', fvn)\n    requires Subset(fvn, fvngs)\n    requires OnlyDiffer(prefinalL, mvs0, finalL)\n    requires OnlyDiffer(initialL, mvs, prefinalL)\n    requires mvs0(v0)\n    requires mvs(v)\n    requires Subset(mvs0, Diff(fvn, fvngs'))\n    requires Subset(mvs, Diff(fvngs, fvn))\n    ensures Extends(finalL, initialH)\n{}"
},
{
    "dafny": "method pqst<b(==)>(ghij: array<b>, lmno: b) returns (rstu: bool)\n{\n  var uvwx := 0;\n  rstu := false;\n  var yzab := 0;\n  while uvwx < ghij.Length\n    invariant 0 <= uvwx <= ghij.Length\n    invariant multiset(ghij[..uvwx])[lmno] == yzab\n    invariant rstu <==> (yzab == 1)\n  {\n    if (ghij[uvwx] == lmno)\n    { yzab := yzab + 1; }\n    if (yzab == 1)\n    { rstu := true; }\n    else\n    { rstu := false; }\n    uvwx := uvwx + 1;\n  }\n  assert ghij[..ghij.Length] == ghij[..];\n}"
},
{
    "dafny": "module Util {\n    method printMatrix(a: array2<nat>) \n    {\n        var v := 0;\n        while (v < a.Length0)\n        decreases a.Length0 - v\n        {\n            var y := 0;\n            print \"\\n\";\n            while (y < a.Length1)\n            decreases a.Length1 - y\n            {\n                print a[v, y];\n                print \"\\t\";\n                y := y + 1;\n            } \n            v := v + 1;\n        } \n        print \"\\n\";\n    }\n    method printArray<T>(a: array<T>) \n    {\n        var v := 0;\n        while (v < a.Length)\n        decreases a.Length - v\n        {\n            print a[v];\n            print \"\\t\";\n            v := v + 1;\n        } \n        print \"\\n\";\n    }\n}"
},
{
    "dafny": "method Main() {\n\tvar q := [4,8,6,3];\n\tvar p := Product(q);\n\tprint \"the product of odd-indexed elements of [4,8,6,3] is \";\n\tprint p;\n\tassert p == 8 * 3;\n\tprint \"\\ndone.\";\n}\nfunction OddIndexedProduct(q: seq<int>) : int\n{\n\tRecursiveOddIndexedProduct(q, 0)\n}\nfunction RecursiveOddIndexedProduct(q: seq<int>, i: nat) : int\n\trequires i <= |q|;\n\tdecreases |q|-i;\n{\n\tif i == |q| then 1\n\telse if i % 2 == 1 then q[i] * RecursiveOddIndexedProduct(q, i+1)\n\telse RecursiveOddIndexedProduct(q, i+1)\n}\nmethod Product'(q: seq<int>) returns (p: int)\n  ensures p == OddIndexedProduct(q)\n{\n\tvar i:nat;\n\tp,i := 1,0;\n\twhile i != |q|\n\tinvariant 0 <= i <= |q| && p == OddIndexedProduct(q[..i])\n\t{\n\t\tassert 0 <= i < |q| && p == OddIndexedProduct(q[..i]);\n\t\tif i % 2 ==1\n\t\t{\n\t\t\tassert 0 <= i < |q| && p == OddIndexedProduct(q[..i]);\n\t\t\tassert i%2 == 1;\n\t\t\tL1(i,p,q,q[i]);\n\t\t\tassert 0 <= i+1 <= |q| && p*q[i] == OddIndexedProduct(q[..i+1]);\n\t\t\tp,i := p*q[i], i+1;\n\t\t\tassert 0 <= i <= |q| && p == OddIndexedProduct(q[..i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert 0 <= i < |q| && p == OddIndexedProduct(q[..i]);\n\t\t\tassert i%2 != 1;\n\t\t\tL2(i,p,q,q[i]);\n\t\t\tassert 0 <= i+1 <= |q| && p == OddIndexedProduct(q[..i+1]);\n\t\t\ti := i+1;\n\t\t\tassert 0 <= i <= |q| && p == OddIndexedProduct(q[..i]);\n\t\t}\n\t\tassert 0 <= i <= |q| && p == OddIndexedProduct(q[..i]);\n\t}\n\tassert i == |q|;\n\tassert q == q[..|q|];\n\tassert p == OddIndexedProduct(q[..i]);\n\tassert p == OddIndexedProduct(q);\n}\nlemma L1(i:nat, p:int,q:seq<int>,p':int)\n\trequires 0 <= i < |q| && p == OddIndexedProduct(q[..i])\n\trequires i%2 == 1\n\trequires p' == q[i]\n\tensures 0 <= i+1 <= |q| && p*q[i] == OddIndexedProduct(q[..i+1])\n{\n\tcalc {\n\t\tOddIndexedProduct(q[..i+1]);\n\t== { assert q[..i]+[q[i]] == q[..i+1]; }\n\t\tOddIndexedProduct(q[..i]+[q[i]]);\n\t== { L2a(q,i); }\n\t\tOddIndexedProduct(q[..i])*q[i];\n\t==\n\t\tp*q[i];\n\t}\n}\nlemma L2a(q:seq<int>, i: nat)\n\trequires i % 2 == 1\n\trequires 0 <= i < |q|\n\tensures OddIndexedProduct(q[..i]+[q[i]]) == OddIndexedProduct(q[..i])*q[i]\nlemma L2(i:nat, p:int,q:seq<int>,p':int)\n\trequires 0 <= i < |q| && p == OddIndexedProduct(q[..i])\n\trequires i%2 != 1\n\trequires p' == q[i]\n\tensures 0 <= i+1 <= |q| && p == OddIndexedProduct(q[..i+1])\nmethod Product(q: seq<int>) returns (p: int)\n  ensures p == OddIndexedProduct(q)\n{\n\tvar i:nat;\n\tp,i := 1,|q|;\n\twhile i != 0\n\tinvariant 0 <= i <= |q| && p == RecursiveOddIndexedProduct(q, i)\n\t{\n\t\ti := i - 1;\n\t\tif i % 2 == 1\n\t\t{\n\t\t\tp := p * q[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t}\n\t\tassert 0 <= i <= |q| && p == RecursiveOddIndexedProduct(q, i);\n\t}\n\tassert p == OddIndexedProduct(q);\n}"
},
{
    "dafny": "function nonGhostPredicate(x: int): bool {\n  x % 2 == 0\n}\ndatatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | nonGhostPredicate(c.x) witness Cell(0)\nfunction doubleEvenCell(c: EvenCell): int\n{\n  if c.x % 2 == 1 then 1/0 else c.x * 2\n}\nmethod Main() {\n  var x: set<Cell> := { Cell(1), Cell(2), Cell(3), Cell(4) };\n  var y := set c: EvenCell | c in x;\n  var b := forall c :: c in y ==> doubleEvenCell(c) > 0;\n  var b2 := forall c: EvenCell :: c in x ==> c.x % 2 == 0;\n  var b3 := exists c: EvenCell :: c in x && c.x == 3;\n  assert b;\n  assert b2;\n  assert !b3;\n  print b && b2 && !b3;\n}"
},
{
    "dafny": "predicate isMax(s: array<int>, lo:int)\n    reads s\n{\n    (0 <= lo < s.Length) && (forall i :: (0 <= i < s.Length) ==> s[i] <= s[lo])\n}\nmethod findMax(s: array<int>) returns (lo:int, hi:int)\n    requires s.Length >= 0\n    ensures true\n{\n    lo := 0;\n    hi := s.Length - 1;\n    while lo < hi\n        invariant lo >= 0 && hi < s.Length\n        decreases hi - lo\n    {\n        if (s[lo] <= s[hi]) {\n            lo := lo + 1;\n        } else {\n            hi := hi - 1;\n        }\n    }\n}\npredicate isPal(s: array<int>)\n    reads s\n{\n    forall i :: (0 <= i < s.Length) ==> s[i] <= s[s.Length - i - 1]\n}\nmethod checkPalindrome(s: array<int>) returns (res:int)\n    requires s.Length >= 0\n    ensures true\n{\n    res := 1;\n    var i := 0;\n    var j := s.Length - 1;\n    while (i < j) && (res == 1)\n        invariant i >= 0 && j < s.Length\n        decreases j - i\n    {\n        if (s[i] != s[j]) {\n            res := 0;\n        } else { }\n        i := i + 1;\n        j := j - 1;\n    }\n}"
},
{
    "dafny": "method Main()\n{\n    var ms1: multiset<int> := multiset{};\n    var ms2 := multiset{1,1,1,2,3};\n    assert |ms1| == 0;\n    assert |ms2| == 5;\n    assert ms2[1] == 3;\n    assert 1 in ms2;\n    assert 1 !in ms1;\n    assert ms1 == multiset{};\n    assert multiset{1,2,3,1,1} == ms2;\n    assert ms1 < ms2;\n    assert multiset{1,2,1} <= ms2;\n    assert multiset{1,1,1,2} + multiset{1,2} == multiset{1,1,1,1,2,2};\n    assert multiset{1,1,1,2} * multiset{1,2} == multiset{1,2};\n    assert multiset{1,1,1,2} - multiset{1,2} == multiset{1,1};\n    assert multiset{1,1} !! multiset{2,3,3};\n    var ms3 := multiset{1,1,1,2,2,3};\n    assert ms3[2:=0] == multiset{1,1,1,3};\n}"
},
{
    "dafny": "method abcd(efgh:array<int>, ijkl:array<int>) returns (mnop:array<int>)\n{\n  mnop := new int[efgh.Length+ijkl.Length];\n  var qrst:= 0;\n  while (qrst < mnop.Length)\n    invariant 0 <= qrst <= mnop.Length\n    invariant if qrst<efgh.Length then mnop[..qrst]==efgh[..qrst] else mnop[..qrst]==efgh[..]+ijkl[..(qrst-efgh.Length)]\n  {\n    mnop[qrst] := if qrst<efgh.Length then efgh[qrst] else ijkl[qrst-efgh.Length];\n    qrst:=qrst+1;\n  }\n}"
},
{
    "dafny": "predicate Sorted(a: array<int>)\nreads a\n{\n    forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}\nmethod DoSomething(a: array<int>)\nrequires a.Length > 0\nmodifies a\n{\n    a[0] := 1;\n}"
},
{
    "dafny": "method allDigits(s: string) returns (result: bool)\n  ensures  result <==> (forall i :: 0 <= i < |s| ==> s[i] in \"0123456789\")\n{\n  result:=true ;\n  for i := 0 to |s|\n    invariant result <==> (forall ii :: 0 <= ii < i ==> s[ii] in \"0123456789\")\n  {\n    if ! (s[i] in \"0123456789\"){\n      return false;\n    }\n  }\n}"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} Wrappers {\n  datatype Option<+T> = None | Some(value: T) {\n    function ToResult(): Result<T, string> {\n      match this\n      case Some(v) => Success(v)\n      case None() => Failure(\"Option is None\")\n    }\n    function ToResult'<R>(error: R): Result<T, R> {\n      match this\n      case Some(v) => Success(v)\n      case None() => Failure(error)\n    }\n    function UnwrapOr(default: T): T {\n      match this\n      case Some(v) => v\n      case None() => default\n    }\n    predicate IsFailure() {\n      None?\n    }\n    function PropagateFailure<U>(): Option<U>\n      requires None?\n    {\n      None\n    }\n    function Extract(): T\n      requires Some?\n    {\n      value\n    }\n  }\n  datatype Result<+T, +R> = | Success(value: T) | Failure(error: R) {\n    function ToOption(): Option<T>\n    {\n      match this\n      case Success(s) => Some(s)\n      case Failure(e) => None()\n    }\n    function UnwrapOr(default: T): T\n    {\n      match this\n      case Success(s) => s\n      case Failure(e) => default\n    }\n    predicate IsFailure() {\n      Failure?\n    }\n    function PropagateFailure<U>(): Result<U, R>\n      requires Failure?\n    {\n      Failure(this.error)\n    }\n    function MapFailure<NewR>(reWrap: R -> NewR): Result<T, NewR>\n    {\n      match this\n      case Success(s) => Success(s)\n      case Failure(e) => Failure(reWrap(e))\n    }\n    function Extract(): T\n      requires Success?\n    {\n      value\n    }\n  }\n  datatype Outcome<E> = Pass | Fail(error: E)\n  {\n    predicate IsFailure() {\n      Fail?\n    }\n    function PropagateFailure<U>(): Result<U, E>\n      requires Fail?\n    {\n      Failure(this.error)\n    }\n  }\n  function Need<E>(condition: bool, error: E): (result: Outcome<E>)\n  {\n    if condition then Pass else Fail(error)\n  }\n}"
},
{
    "dafny": "method appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n{\n\tc := new int[a.Length + b.Length];\n\tvar i := 0;\n\twhile i < a.Length\n\tinvariant 0 <= i <= a.Length\n\tinvariant forall j :: 0 <= j < i ==> c[j] == a[j]\n\t{\n\t\tc[i] := a[i];\n\t\ti := i + 1;\n\t}\n\twhile i < b.Length + a.Length\n\tinvariant a.Length <= i <= b.Length + a.Length\n\tinvariant forall j :: 0 <= j < a.Length ==> a[j] == c[j]\n\tinvariant forall j :: a.Length <= j < i ==> c[j] == b[j - a.Length]\n\t{\n\t\tc[i] := b[i - a.Length];\n\t\ti := i + 1;\n\t}\n}"
},
{
    "dafny": "ghost function Sum(a: seq<int>, s: int, t: int): int\n  requires 0 <= s <= t <= |a|\n{\n  if s == t then 0 else Sum(a, s, t-1) + a[t-1]\n}\nmethod MaxSegSum(a: seq<int>) returns (k: int, m: int)\n  ensures 0 <= k <= m <= |a|\n  ensures forall p,q :: 0 <= p <= q <= |a| ==> Sum(a, p, q) <= Sum(a, k, m)\n{\n  k, m := 0, 0;\n  var s := 0;  \n  var n := 0;\n  var c, t := 0, 0;  \n  while n < |a|\n    invariant 0 <= c <= n <= |a| && t == Sum(a, c, n)\n    invariant forall b :: 0 <= b <= n ==> Sum(a, b, n) <= Sum(a, c, n)\n    invariant 0 <= k <= m <= n && s == Sum(a, k, m)\n    invariant forall p,q :: 0 <= p <= q <= n ==> Sum(a, p, q) <= Sum(a, k, m)\n  {\n    t, n := t + a[n], n + 1;\n    if t < 0 {\n      c, t := n, 0;\n    } else if s < t {\n      k, m, s := c, n, t;\n    }\n  }\n}"
},
{
    "dafny": "class Queue<T> {\n  var q : seq<T>; \n  constructor ()\n\t{\n    q := [];\n\t}\n  method Enqueue(elem: T)\n  modifies this;\n  ensures q == old(q) + [elem];\n  ensures q[|q|-1] == elem;\n  {\n    q := q + [elem];\n  }\n  method Dequeue() returns (r: T)\n  modifies this;\n  requires q != [];\n  ensures q == old(q)[0..|old(q)|-1];\n  ensures r == old(q)[|old(q)|-1];\n  {    \n    r := q[|q|-1];\n    q := q[0..|q|-1];\n  } \n  method Peek() returns (r: T)\n  requires q != [];\n  ensures q == old(q)\n  ensures r == old(q)[|old(q)|-1];\n  {    \n    r := q[|q|-1];\n  } \n}\nmethod Main() \n{\n      var s := new Queue<int>();\n      var input1 := 1;\n      var input2 := 1;\n      s.Enqueue(input1);\n      s.Enqueue(input2);\n      var test1 := s.Dequeue();\n      var test2 := s.Dequeue();\n      assert input1 == test1;\n      assert input2 == test2;\n}"
},
{
    "dafny": "class Node { }\nghost predicate Q(x: Node)\nghost predicate P(x: Node)\nmethod AuxMethod(y: Node)\n  modifies y\nmethod MainMethod(y: Node)\n  modifies y\n{\n  AuxMethod(y);  \n  forall x | Q(x)\n    ensures P(x)\n  {\n    assume false;\n  }\n  assert forall x :: Q(x) ==> P(x);\n}"
},
{
    "dafny": "class Stack<T> {\n  var stack : seq<T>; \n  constructor ()\n\t{\n    stack := [];\n\t}\n  method Push(elem: T)\n  modifies this;\n  ensures stack == [elem] + old(stack)\n  ensures stack[0] == elem\n  {\n    stack := [elem] + stack;\n  }\n  method Pop() returns (r: T)\n  modifies this;\n  requires stack != [];\n  ensures stack == old(stack)[1..]\n  ensures r == old(stack)[0]\n  {    \n    r := stack[0];\n    stack := stack[1..];\n  } \n  method Peek() returns (r: T)\n  requires stack != [];\n  ensures stack == old(stack)\n  ensures r == stack[0]\n  {    \n    return stack[0];\n  } \n}"
},
{
    "dafny": "method F() {\n   var s1 : set<int> := {}; \n   var s2 := {1, 2, 3}; \n   assert s2 == {1,1,2,3,3,3,3}; \n   var s3, s4 := {1,2}, {1,4};\n   assert s2 + s4 == {1,2,3,4}; \n   assert s2 * s3 == {1,2} && s2 * s4 == {1}; \n   assert s2 - s3 == {3}; \n   assert {1} <= {1, 2} && {1, 2} <= {1, 2}; \n   assert {} < {1, 2} && !({1} < {1}); \n   assert {1, 2} == {1, 2} && {1, 3} != {1, 2}; \n   assert 5 in {1,3,4,5};\n   assert 1 in {1,3,4,5};\n   assert 2 !in {1,3,4,5};\n   assert forall x :: x !in s1;\n}"
},
{
    "dafny": "method stock(a: array<int>) returns (max: int)\n\trequires a != null;\n\trequires forall i :: 0 <= i < a.Length ==> a[i] <= 1000;\n\tensures forall k, j :: 0 <= k < j < a.Length ==> max >= a[j] - a[k];\n{\n\tmax := 0;\n\tif(a.Length < 2){\n\t\treturn max;\n\t}\n\tvar lowPrice := a[0];\n\tvar i := 0;\n\twhile( i < a.Length)\n\t\tinvariant i <= a.Length;\n\t\tinvariant max >= 0;\n\t\tinvariant forall j :: 0 <= j < i ==> lowPrice <= a[j];\n\t\tinvariant forall k,j :: 0 <= k < j < i ==> max >= a[j] - a[k];\n\t\tdecreases a.Length - i;\n\t{\n\t\tif(a[i] < lowPrice){\n\t\t\tlowPrice := a[i];\n\t\t}\n\t\telse if(a[i] - lowPrice > max){\n\t\t\tmax := a[i] - lowPrice;\n\t\t}\n\t\ti := i + 1;\n\t}\n\treturn max;\n}"
},
{
    "dafny": "method Main()\n{\n  mapTest();\n  imapTest();\n}\nmethod mapTest() {\n  print \"map test \\n\";\n  var m := map[4 := 5, 6 := 7];\n  assert (set x | x in m) == m.Keys;\n  assert (set x | x in m :: m[x]) == m.Values;\n  print m.Keys, \"\\n\";\n  print m.Values, \"\\n\";\n  assert (4,5) in m.Items;\n  print m.Items, \"\\n\";\n}\nmethod imapTest() {\n  print \"imap test \\n\";\n  var m := imap[4 := 5, 6 := 7];\n  assert (iset x | x in m) == m.Keys;\n  assert (iset x | x in m :: m[x]) == m.Values;\n  print m.Keys, \"\\n\";\n  print m.Values, \"\\n\";\n  assert (4,5) in m.Items;\n  print m.Items, \"\\n\";\n}"
},
{
    "dafny": "function Sum(\n  ghost remaining: nat,\n  n: nat\n): (p: nat -> nat)\n  decreases remaining\n  requires remaining == n\n{\n  (pos: nat) =>\n    var x: nat := if n == 0 then 0 else Sum(remaining - 1, n - 1)(pos+1) + pos;\n    x\n}\nmethod Main() {\n  print Sum(5, 5)(10);\n}"
},
{
    "dafny": "method mod16counter(cur: nat) returns (next: nat, ch: char)\n    requires 0 <= cur < 16;\n    ensures  next == (cur + 1) % 16;\n    ensures ((cur == 00) ==> ch == '1') && ((cur == 01) ==> ch == '2') &&\n            ((cur == 02) ==> ch == '3') && ((cur == 03) ==> ch == '4') &&\n            ((cur == 04) ==> ch == '5') && ((cur == 05) ==> ch == '6') &&\n            ((cur == 06) ==> ch == '7') && ((cur == 07) ==> ch == '8') &&\n            ((cur == 08) ==> ch == '9') && ((cur == 09) ==> ch == 'A') &&\n            ((cur == 10) ==> ch == 'B') && ((cur == 11) ==> ch == 'C') &&\n            ((cur == 12) ==> ch == 'D') && ((cur == 13) ==> ch == 'E') &&\n            ((cur == 14) ==> ch == 'F') && ((cur == 15) ==> ch == '0');\n{\n    var hexchars := ['0', '1', '2', '3', '4', '5', '6', '7',\n                     '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'];\n    next := (cur + 1) % 16;\n    ch := hexchars[next];\n}\nmethod check_mod16counter()\n{\n    var next;\n    var ch;\n    next, ch := mod16counter(0);\n    assert(next == 1 && ch == '1');\n    next, ch := mod16counter(6);\n    assert(next == 7 && ch == '7');\n\tnext, ch := mod16counter(9);\n\tassert(next == 10 && ch == 'A');\n\tnext, ch := mod16counter(14);\n\tassert(next == 15  && ch == 'F');\n\tnext, ch := mod16counter(15);\n\tassert(next == 0 && ch == '0');\n}"
},
{
    "dafny": "function fib(n : nat ) : nat\n  decreases n\n{\n    if n < 2 then n else fib(n - 2) + fib(n - 1)\n}\nmethod computeFib (n : nat) returns (x : nat)\n    ensures x == fib(n)\n{\n    var i := 0;\n    x := 0;\n    var y := 1;\n    while  i < n \n        decreases n - i\n        invariant 0 <= i <= n\n        invariant x == fib(i)\n        invariant y == fib(i+1)\n    {\n        x, y := y, x + y; \n        i := i + 1;\n    }\n}\nmethod main() {\n    var x0 := computeFib(0); \n    var x1 := computeFib(1); \n    var x2 := computeFib(2); \n    var x3 := computeFib(3); \n    var x4 := computeFib(4); \n    var x5 := computeFib(5); \n    assert x0 == 0;\n    assert x1 == 1;\n    assert x2 == 1;\n    assert x3 == 2;\n    assert x4 == 3;\n    assert x5 == 5;\n}"
},
{
    "dafny": "method CalDiv() returns (x:int, y:int)\n  ensures x==191/7\n  ensures y==191%7\n{\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n  {\n    x := x+1;\n    y:=191-7*x;\n  }\n}"
},
{
    "dafny": "trait S {\n  ghost var obs: set<O>\n  ghost function upCast(o: object): object {o}\n  ghost predicate i0() reads this, obs { forall o: O | o in obs :: o.s == this && upCast(o) != this }\n  ghost predicate i() reads * { i0() && forall o: O | o in obs :: o.i() }\n  twostate predicate i2() reads * { forall o: O | o in old(obs) :: o in obs && o.i2() }\n  twostate predicate legal0() reads * { forall o: O | o in old(obs) :: unchanged(o) || (o.i2() && o.i()) }\n  twostate predicate legal1() reads * { forall o: O | o in obs && o !in old(obs) :: o.i() }\n  twostate predicate legal() reads * { old(i()) && i0() && old(obs) <= obs && legal0() && legal1() }\n  twostate lemma lci() requires legal() ensures i() && i2() {\n    forall o: O | o in old(obs) && o.admPre() ensures o.i2() && o.i() { o.adm(); }\n  }\n}\ntrait O {\n  ghost const s: S\n  ghost predicate i0() reads * { this in s.obs && s.i0() }\n  ghost method join()\n    requires s.i0() && s.upCast(this) != s\n    modifies s \n    ensures i0() && s.obs == old(s.obs) + { this }\n  {\n    s.obs := s.obs + { this }; \n  }\n  twostate predicate admPre() reads * { i0() && old(i0() && s.i()) && unchanged(this) && s.legal() }\n  ghost predicate gi() reads * { i0() && s.i() }\n  twostate predicate gi2() requires old(gi()) reads * { i0() && s.i2() }\n  ghost predicate i() reads *\n  twostate predicate i2() reads *\n  twostate lemma adm() requires admPre() ensures i2() && i()\n}\nclass Inner extends O {\n  var data: int\n  ghost predicate i() reads * {\n    && i0()\n  }\n  twostate predicate i2() reads * {\n    && old(data) <= data\n  }\n  twostate lemma adm() requires admPre() {}\n  constructor (ghost s: S, initial_data: int)\n    requires s.i()\n    modifies s\n    ensures s.i()\n  {\n    this.s := s;\n    data := initial_data;\n    new;\n    join();\n    s.lci();\n  }\n}\nclass Outer extends O {\n  var inner: Inner\n  ghost predicate i() reads * {\n    && i0()\n    && s == inner.s\n    && inner.i()\n  }\n  twostate predicate i2() reads * {\n    && inner == old(inner)\n    && inner.i2()\n  }\n  twostate lemma adm() requires admPre() ensures i2() && i() {\n  }\n  constructor (ghost s: S, inner: Inner)\n    requires s.i() && s == inner.s && inner.i()\n    modifies s\n    ensures s.i()\n  {   \n    this.s := s;\n    this.inner := inner;\n    new;\n    join();\n    s.lci();\n  }\n}"
},
{
    "dafny": "datatype Player = P1 | P2\n{\n  function Other(): Player {\n    if this == P1 then P2 else P1\n  }\n}\ndatatype Variables = Variables(piles: seq<nat>, turn: Player)\nghost predicate Init(v: Variables) {\n  && |v.piles| == 3\n  && v.turn.P1? \n}\ndatatype Step =\n  | TurnStep(take: nat, p: nat)\n  | NoOpStep()\nghost predicate Turn(v: Variables, v': Variables, step: Step)\n  requires step.TurnStep?\n{\n  var p := step.p;\n  var take := step.take;\n  && p < |v.piles|\n  && take <= v.piles[p]\n  && v' == v.(piles := v.piles[p := v.piles[p] - take]).(turn := v.turn.Other())\n}\nghost predicate NextStep(v: Variables,  v': Variables, step: Step) {\n  match step {\n    case TurnStep(_, _) => Turn(v, v', step)\n    case NoOpStep() => v' == v \n  }\n}\nlemma NextStepDeterministicGivenStep(v: Variables, v': Variables, v'': Variables, step: Step)\n  requires NextStep(v, v', step)\n  requires NextStep(v, v'', step)\n  ensures v' == v''\n{\n}\nghost predicate Next(v: Variables,  v': Variables) {\n  exists step :: NextStep(v, v', step)\n}\nlemma ExampleBehavior() returns (b: seq<Variables>)\n  ensures |b| >= 3 \n  ensures Init(b[0])\n  ensures forall i:nat | i + 1 < |b| :: Next(b[i], b[i+1])\n{\n  var state0 := Variables(piles := [3, 5, 7], turn := P1);\n  b := [\n    state0,\n    Variables(piles := [3, 1, 7], turn := P2),\n    Variables(piles := [3, 1, 0], turn := P1)\n  ];\n  assert NextStep(b[0], b[1], TurnStep(take := 4, p := 1));\n  assert NextStep(b[1], b[2], TurnStep(take := 7, p := 2));\n}"
},
{
    "dafny": "method Main()\n{\n    var a := new int[3];\n    a[0] := 1;\n    a[1] := 0;\n    a[2] := 1;\n    var sequencia := a[..];\n    assert sequencia == [1,0,1];\n    var multiconjunto := multiset(sequencia);\n    assert multiconjunto == multiset{0,1,1};\n    assert multiset(a[..])[1] == 2;\n}"
},
{
    "dafny": "function F(n: nat): nat { if n <= 2 then n else F(n-1) + F(n-3)}\nmethod calcF(n: nat) returns (res: nat)  \n ensures res == F(n) \n{\n    assert 0 <= 0 <= n && 0 == F(0) && 1 == F(0+1) && 2 == F(0+2); \n    var a, b, c := 0, 1, 2;\n    assert 0 <= 0 <= n && a == F(0) && b == F(0+1) && c == F(0+2); \n    var i := 0;\n    assert 0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2); \n    while i < n \n    decreases n - i \n    invariant 0 <= i <= n \n    invariant a == F(i) && b == F(i+1) && c == F(i+2)\n    {\n    ghost var V0 := n - i;\n    assert 0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2) && i < n && n - i == V0; \n    assert  0 <= i + 1 <= n && b == F(i + 1) && c == F(i + 1+1) && a+ c == F(i + 1 + 2) && 0 <= n - (i + 1)< V0;  \n    assert (0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2) && i < n && n - i == V0) ==> (0 <= i + 1 <= n && b == F(i + 1) && c == F(i + 1+1) && a+ c == F(i + 1 + 2) && 0 <= n - (i + 1)< V0);\n    a, b, c := b, c, a + c;   \n    assert  0 <= i + 1<= n && a == F(i + 1) && b == F(i + 1+1) && c == F(i + 1 + 2) && 0 <= n - (i + 1)< V0;   \n    i := i + 1;\n    assert  0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2) && 0 <= n - i < V0; \n    }\n    assert 0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2) && i >= n; \n    assert a == F(n);\n    assert (0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2) && i >= n) ==> (a== F(n)); \n    res := a;\n    assert res == F(n); \n}"
},
{
    "dafny": "method assign1()\t\t\n{  var x := *;      \n  assume x == -4;\t\t\t      \n     x := x*x+x+x+1;\t\t\t  \n  assert x < 10;\t\t\t      \n}\nmethod assign2()\t\t\n{  var x := *;      \n  assume -4 <= x < 2;\t\t\n    x := x*x+x+x+1;\t\t\t\n  assert x < 10;\t\t\t\n}\nmethod assign3()\t\t\n{  var x,y := *,*;  \n  assume -3 <= x < 2  && -1 < y <= 5;\t   \n    x := x + y;\t\t\t\t                   \n\t  y := x*y+1;\t\t\t                     \n  assert x < 10;\t\t\t                   \n}\n method assign4()\t\t\n{  var x,y,z := *,*,*;  \n  assume x == 17;\t\t\t  \n\t  if (x > y)\t\t\t    \n\t\t  { z := x; }\t      \n\t  else \n      { z := y; }\t       \n  assert z >= x && z >= y;\t\n\tassert z == x || z == y;\t\n}\nmethod assign5(a:int)\t\t\n{  var x,y := *,*;      \nassume y > 0 && x == a;\n  x := x+y;\n  if (x < y) {\n    x := x+1 ; \n    y := y+1;\n  } else {\n    y := x-y;\n  }\n  x := x+1;\nassert x > a+1;\n}"
},
{
    "dafny": "method Find(blood: array<int>, key: int) returns (index: int)\nrequires blood != null\nensures 0 <= index ==> index < blood.Length && blood[index] == key\nensures index < 0 ==> forall k :: 0 <= k < blood.Length ==> blood[k] != key\n{\n   index := 0;\n   while index < blood.Length\n      invariant 0 <= index <= blood.Length\n      invariant forall k :: 0 <= k < index ==> blood[k] != key\n   {\n      if blood[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}"
},
{
    "dafny": "method FindMax (a:array<int>)  returns (max : int)\nrequires a != null;\nrequires a.Length > 1; \nensures forall k:: 0 <= k < a.Length ==> a[k] <= max; \n{\n  max := a[0];\n  var i := 0;\n  while (i < a.Length)\n  invariant 0 <= i <= a.Length;\n  decreases a.Length - i;\n  invariant forall k:: 0 <= k < i ==> a[k] <= max;\n  {\n    if (a[i] > max) { max := a[i];} \n    i := i + 1;\n  }\n  return max;\n}"
},
{
    "dafny": "predicate isSortedRanged(a: array<int>, x1: nat, x2: nat) \n    reads a\n    requires 0 <= x1 <= x2 <= a.Length\n{\n    forall i, j :: x1 <= i < j < x2 ==> a[i] <= a[j]\n}\npredicate isSorted(a: array<int>)\n    reads a\n{\n    isSortedRanged(a, 0, a.Length)\n}\nmethod insertionSort(a: array<int>)\n    modifies a \n    ensures isSorted(a) \n    ensures multiset(a[..]) == multiset(old(a[..])) \n{\n    var i := 0;\n    while i < a.Length \n        decreases a.Length - i\n        invariant multiset(a[..]) == multiset(old(a[..]))\n        invariant 0 <= i <= a.Length\n        invariant isSortedRanged(a, 0, i)\n    {\n        var j := i;\n        while j > 0 && a[j-1] > a[j] \n            decreases j \n            invariant multiset(a[..]) == multiset(old(a[..]))\n            invariant 0 <= j <= i\n            invariant forall l, r :: (0 <= l < r <= i && j != r) ==> a[l] <= a[r]\n        {\n            a[j-1], a[j] := a[j], a[j-1];\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n}\nmethod Main() {\n    var a := new int[5];\n    a[0], a[1], a[2], a[3], a[4] := 9, 4, 6, 3, 8;\n    insertionSort(a);\n    assert isSorted(a);\n}"
},
{
    "dafny": "function abs(x: int): int\n{\n    if x < 0 then -x else x\n}\nmethod Testing_abs()\n{\n    var v := abs(3);\n    assert v == 3;\n}\nfunction max(a: int, b: int): int\n{\n    if a > b then a else b\n}\nmethod Testing_max() {\n    assert max(3, 4) == 4;\n    assert max(-1, -4) == -1;\n}\nmethod Abs(x: int) returns (y: int)\n    ensures abs(x) == y\n{\n    if x < 0 {\n        return -x;\n    } else {\n        return x;\n    }\n}\nghost function Double(val:int) : int\n{\n    2 * val\n}\nmethod TestDouble(val: int) returns (val2:int)\n    ensures val2 == Double(val)\n{\n    val2 := 2 * val;\n}"
},
{
    "dafny": "method swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && \n                            m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures a.Length > 1 ==> (forall k :: 0 <= k < a.Length - 1 ==> (a[k] && a[k+1]) || (!a[k] && a[k+1]) || (!a[k] && !a[k+1]))\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var i := 0;\n  var j := a.Length - 1;\n  while (i <= j)\n   invariant 0 <= i <= j + 1 <= a.Length\n   invariant forall m :: 0 <= m < i ==> !a[m]\n   invariant forall n :: j < n < a.Length ==> a[n]\n   invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    if (!a[i]) {\n      i := i+1;\n    } else if (a[j]) {\n      j := j-1;\n    } else {\n      swap(a, i, j);\n      i := i+1;\n      j := j-1;\n    }\n  }\n}"
},
{
    "dafny": "﻿static function Power2(exp: int) : int\n    requires exp >= 0;\n    ensures Power2(exp) > 0;\n{\n    if (exp==0) then\n        1\n    else\n        2*Power2(exp-1)\n}\nstatic lemma Lemma_Power2Adds(e1:nat, e2:nat)\n\tensures Power2(e1 + e2) == Power2(e1) * Power2(e2);\n{\n\tif e2 == 0 {\n\t\tassert Power2(e2) == 1;\t\n\t} else {\n\t\tvar e2min1 := e2 - 1;\n\t\tcalc {\n\t\t\tPower2(e1 + e2);\n\t\t\tPower2(e1 + e2 - 1) * 2;\n\t\t\tPower2(e1 + e2min1) * 2;\n\t\t\t{ Lemma_Power2Adds(e1, e2min1); }\n\t\t\tPower2(e1) * Power2(e2min1) * 2;\n\t\t\tPower2(e1) * Power2(e2-1) * 2;\n\t\t\tcalc {\n\t\t\t\tPower2(e2);\n\t\t\t\tPower2(e2-1) * 2;\n\t\t\t}\n\t\t\tPower2(e1) * Power2(e2);\n\t\t}\n\t\tassert Power2(e1 + e2) == Power2(e1) * Power2(e2);\n\t}\n}"
},
{
    "dafny": "method Triple(x: int) returns (r: int)\n  ensures r == 3 * x\n{\n  var y := 2 * x;\n  r := x + y;\n  ghost var a, b := DoubleQuadruple(x);\n  assert a <= r <= b || b <= r <= a;\n}\nghost method DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n{\n  a := 2 * x;\n  b := 2 * a;\n}"
},
{
    "dafny": "method stoogeSort(a: array<int>, left: int, right: int)\n  requires a != null;\n  requires 0 <= left <= right < a.Length;\n  modifies a;\n  decreases right - left;\n\tensures a[left] <= old(a[left])\n\tensures forall i :: 0 <= i < left || right < i < a.Length ==> a[i] == old(a[i])\n\tensures forall i :: left <= i <= right ==> exists j :: left <= j <= right && a[i] == old(a[j])\n\tensures forall i, j :: left <= i < j <= right ==> a[i] <= a[j]\n{\n  if (a[left] > a[right])\n  {\n    var tmp := a[left];\n    a[left] := a[right];\n    a[right] := tmp;\n  }\n  if (left + 1 >= right)\n  {\n    return;\n\t}\n  stoogeSort(a, left, right - 1);\n  stoogeSort(a, left + 1, right);\n  stoogeSort(a, left, right - 1);\n}"
},
{
    "dafny": "function somatorio(a: array?<int>, n:int) : int\n  requires a != null;\n  requires n >= 0 && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then\n    0\n  else\n    somatorio(a, n-1) + a[n-1]\n}\nmethod somatorioArray(a: array?<int>) returns (result: int)\n  requires a != null;\n  ensures result == somatorio(a, a.Length);\n{\n  result := 0;\n  var i := 0;\n  while i < a.Length\n    invariant i >= 0 && i <= a.Length;\n    invariant result == somatorio(a, i);\n    decreases a.Length - i;\n  {\n    result := result + a[i];\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n{\n    p := 1;\n    var i := 0;\n    while i != n\n        invariant 0 <= i <= n && p == Power(i)\n    {\n        i := i + 1;\n        p := p * 2;\n    }\n}"
},
{
    "dafny": "type T = int\nmethod binarySearch(a: array<T>, x: T) returns(index: int)\n    requires a.Length > 0\n    requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j] \n    ensures 0 <= index <= a.Length\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    ensures index > 0 ==> a[index-1] <= x \n    ensures index < a.Length ==> a[index] >= x \n{\n    var low, high := 0, a.Length;\n    while low < high\n        decreases high - low\n        invariant 0 <= low <= high <= a.Length\n        invariant low > 0 ==> a[low-1] <= x\n        invariant high < a.Length ==> a[high] >= x\n    {\n        var mid := low + (high - low) / 2;\n        if{\n            case a[mid] < x => low := mid + 1;\n            case a[mid] > x => high := mid;\n            case a[mid] == x => return mid;\n        }\n    }\n    return low;\n}\nmethod testBinarySearch(){\n   var a := new int[2] [1,3];\n   var id0 := binarySearch(a, 0);\n   assert id0 == 0;\n   var id1 := binarySearch(a, 1);\n   assert id1 in {0,1};\n   var id2 := binarySearch(a, 2);\n   assert id2 == 1;\n   var id3 := binarySearch(a, 3);\n   assert id3 in {1,2};\n   var id4 := binarySearch(a,4);\n   assert id4 == 2;\n}"
},
{
    "dafny": "datatype Result<T> = Success(value: T) | Failure(error: string)\n{\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): Result<U>\n    requires Failure?\n  {\n    Failure(this.error)\n  }\n  function Extract(): T\n    requires Success?\n  {\n    value\n  }\n}\nclass ClassA<T> {\n  const s: seq<T>\n  constructor (s: seq<T>) {\n    this.s := s;\n  }\n  method Read() returns (res: Result<seq<T>>)\n    ensures res.Success? ==> 1 <= |res.value|\n  {\n    if 1 <= |s| {\n      if * {\n        return Success(s);\n      }\n    }\n    return Failure(\"failing\");\n  }\n  method ReadX<U(==)>(x: U, y: U) returns (res: Result<seq<U>>)\n    ensures res.Success? ==> 1 <= |res.value|\n  {\n    if x != y {\n      return Success([x, y]);\n    }\n    return Failure(\"failing\");\n  }\n}\nmethod M0() returns (res: Result<int>) {\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var numbers: seq<int> :- a.Read();  \n  return Success(numbers[0]);\n}\nmethod M1() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var numbers :- a.Read();  \n  return Success(numbers[0]);\n}\nmethod P0() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var result: Result<seq<int>> := a.Read();\n  if result.IsFailure() {\n    res := result.PropagateFailure();\n    return;\n  }\n  var numbers := result.Extract();\n  return Success(numbers[0]);\n}\nmethod P1() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var result := a.Read();\n  if result.IsFailure() {\n    res := result.PropagateFailure();\n    return;\n  }\n  var numbers := result.Extract();\n  return Success(numbers[0]);\n}\nmethod N0() returns (res: Result<int>) {\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var numbers: seq<int> :- a.ReadX(50, 50);  \n  return Success(numbers[0]);\n}\nmethod N1() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var numbers :- a.ReadX(50, 50);  \n  return Success(numbers[0]);\n}\nmethod Q0() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var result: Result<seq<int>> := a.ReadX(50, 50);\n  if result.IsFailure() {\n    res := result.PropagateFailure();\n    return;\n  }\n  var numbers := result.Extract();\n  return Success(numbers[0]);\n}\nmethod Q1() returns (res: Result<int>)\n{\n  var a: ClassA<int> := new ClassA([57, 58, 59]);\n  var result := a.ReadX(50, 50);\n  if result.IsFailure() {\n    res := result.PropagateFailure();\n    return;\n  }\n  var numbers := result.Extract();\n  return Success(numbers[0]);\n}"
},
{
    "dafny": "method BinarySearch(a: array<int>, value: int) returns (index: int)\n  requires a != null && a.Length > 0;\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j];\n  ensures -1 <= index < a.Length;\n  ensures 0 <= index < a.Length ==> a[index] == value;\n  ensures index == -1 ==> forall k :: 0 <= k < a.Length ==> a[k] != value;\n{\n  var low, high := 0, a.Length;\n  while low < high\n    invariant 0 <= low <= high <= a.Length;\n    invariant forall k :: 0 <= k < a.Length && !(low <= k < high) ==> a[k] != value;\n  {\n    var mid:int := (low + high) / 2;\n    if a[mid] < value\n    {\n      low := mid + 1;\n    }\n    else if value < a[mid]\n    {\n      high := mid;\n    }\n    else\n    {\n      return mid;\n    }\n  }\n  return -1;\n}"
},
{
    "dafny": "method BubbleSort(a:array<int>)\n  requires a != null;\n  ensures forall k:: forall l:: 0 <= k < l < a.Length ==> a[k] <= a[l]; \n  modifies a;\n{\n  var i:int := a.Length - 1;\n  while(i > 0)\n    invariant -1 <= i <= a.Length - 1;\n    invariant a.Length == 0 <==>  i == -1;\n    invariant forall k:: forall l:: i <= k < l < a.Length ==> a[k] <= a[l];\n    invariant forall k:: forall l:: 0 <= k <= i && i+1 <= l <= a.Length - 1 ==>  a[k] <= a[l]; \n  {\n    var j:int := 0;\n    while (j < i)\n      invariant 1 <= i <= a.Length -1 && 0 <= j <= i;\n      invariant forall k:: forall l:: i <= k < l < a.Length ==>  a[k] <= a[l];\n      invariant forall k:: forall l:: 0 <= k <= i && i+1 <= l <= a.Length - 1 ==>  a[k] <= a[l];\n      invariant forall k:: 0 <= k < j ==>  a[k] <= a[j];\n    {\n      if (a[j] > a[j + 1]) {\n        var t:int := a[j];\n        a[j] := a[j + 1];\n        a[j + 1] := t;\n      }\n      j := j + 1;\n    }\n    i := i - 1;\n  }\n}"
},
{
    "dafny": "method double(x:int) returns (y:int)\nrequires x >= 2;\nensures y >= x*2;\n{\n\ty := x+x;\n}\nmethod fib(x:int) returns (y:int)\nrequires x>=1;\nensures y>=x;\n{\n\tif(x==1 || x==2){\n\t\ty:=x;\n\t}else{\n\t\tvar a:=fib(x-1);\n\t\tvar b:=fib(x-2);\n\t\ty:=a+b;\n\t}\n}\nmethod mul(x:int, y:int) returns (s:int)\nrequires x>=0;\nensures s == x*y;\n{\n\ts := 0;\n\tvar c := 0;\n\twhile(c != x)\n\tinvariant s==c*y && c<=x;\n\tdecreases x-c;\n\t{\n\t\tc := c+1;\n\t\ts := s+y;\n\t}\n}"
},
{
    "dafny": "method Max(a: int, b:int) returns (c: int)\n    ensures c >= a && c>= b\n    ensures b >= a ==> c == b\n    ensures a >= b ==> c == a\n    ensures (c == b || c == a)\n{\n    if (a < b)\n        { c := b; }\n    else\n        { c := a; }\n    assert a <= c && b <= c;\n}   \nmethod Testing()\n{\n    var v := Max(2, 3);\n    assert v == 3;\n}"
},
{
    "dafny": "datatype Blood = Blood(1:char,2:int)\nclass F\n{\n    static method findMinimumQuantity (a:array<Blood>) returns (minimum:Blood)\n    requires a != null;\n    requires a.Length >= 0;\n    ensures forall i :: 0 <= i < a.Length ==> minimum.2 <= a[i].2;\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    {\n        if (a.Length == 0) {minimum := Blood('N',0);}\n        else{\n            var minimumDate : int := a[0].2;\n            var i : int := 1;\n            while (i < a.Length)\n            invariant (i <= a.Length)\n            invariant (forall j :: 0 <= j < i ==> minimumDate <= a[j].2) \n                && (exists j :: 0 <= j < i && minimumDate == a[j].2)\n            {\n                if (a[i].2 <= minimumDate){\n                    minimumDate := a[i].2;\n                }\n                i := i + 1;\n            }\n            minimum := Blood('A',minimumDate);\n        }\n        return minimum;\n    }\n}\nmethod Main() {\n    var ar : array<Blood> := new Blood[3];\n    ar[0] := Blood('A', 7);\n    ar[1] := Blood('B', 3);\n    ar[2] := Blood('A', 2);\n}"
},
{
    "dafny": "class Score{\n    var highest_score: int;\n    predicate Valid()\n      reads this;\n    {highest_score >= 0}\n    constructor()\n      modifies this;\n      ensures Valid();\n      ensures highest_score == 0;\n    {\n        this.highest_score := 0;\n    }\n    method NewScore(score: int) returns (isChanged: bool, current: int)\n      modifies this;\n      requires score >= 0 && Valid();\n      ensures Valid();\n      ensures ((score > old(highest_score) ==> (isChanged == true && current == score == highest_score))&&(score <= old(highest_score) ==> (isChanged == false && current == highest_score == old(highest_score))))\n    {\n        isChanged:=true;\n        current:=this.highest_score;\n        if(score > this.highest_score){\n            this.highest_score := score;\n            isChanged := true;\n            current := score;\n        }\n        else{\n            isChanged := false;\n            current := this.highest_score;\n        }\n        return isChanged, current;\n    }\n}\nmethod TestScore()\n{\n    var score:= new Score();\n    var s1 := 0;\n    assert s1 == 0;\n    var isChanged, current := score.NewScore(s1);\n    assert isChanged == false && current == 0;\n    var s2 := 2;\n    assert s2 == 2;\n    var isChanged1,current1 := score.NewScore(s2);\n    assert isChanged1 == true && current1 == 2;\n    assert s1 == 0;\n    var isChanged2,current2 := score.NewScore(s1);\n    assert isChanged2 == false && current2 == 2;\n    var s3 := 4;\n    assert s3 == 4;\n    var isChanged3,current3 := score.NewScore(s3);\n    assert isChanged3 == true && current3 == 4;\n    var isChanged4,current4 := score.NewScore(s3);\n    assert isChanged4 == false && current4 == 4;\n    var s4 := 6;\n    var isChanged5,current5 := score.NewScore(s4);\n    assert isChanged5 == true && current5 == 6;\n    assert score.highest_score == 6;\n}"
},
{
    "dafny": "datatype T = T(n:int)\nghost function P(x: int) : int { x - 1}\nghost function ToInt(t:T) : int\n ensures ToInt(t) == t.n as int\n {\n    t.n as int\n }\nmethod Test(x:int)\n {\n    assume exists p:int :: exists t:T :: ToInt(t) > 0;\n    assert exists p:int :: exists t:T :: ToInt(t) > 0;\n }"
},
{
    "dafny": "method CalcProduct(m: nat, n: nat) returns (res: nat)\n  ensures res == m*n;\n{ \n  var m1: nat := m;\n  res := 0;\n  assert res == (m-m1)*n;\n  m1, res := *, *;\n  assume res == (m-m1)*n;\n  if (m1!=0) \n  {   \n    var n1: nat := n;\n    assert (res == (m-m1)*n + (n-n1));\n    res, n1 := *, *;\n    assume res == (m-m1)*n + (n-n1);\n    if (n1 != 0)\n    {\n      ghost var old_n1 := n1;\n      res := res+1;\n      n1 := n1-1; \n      assert (res == (m-m1)*n + (n-n1));\n      assert n1 < old_n1;\n      assert n1 >= 0;\n      assume (false);\n    }  \n    m1 := m1-1;\n    assert res == (m-m1)*n;\n    assume false;\n  }\n}"
},
{
    "dafny": "method Main() {\n  Sequences();\n  Arrays();\n  print \"that's all, folks!\\n\";\n}\nmethod Sequences() {\n  var a1 := [42];\n  var a2 := [42];\n  assert a1 == a2;\n  expect a1 == a2;\n}\nmethod Arrays() {\n  var a1 := new int[] [42];\n  var a2 := new int[] [42];\n  assert a1 != a2;\n  expect a1 != a2;\n}"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} Dafny.ModInternalsNonlinear\n{\n  lemma LemmaModOfZeroIsZero(m:int)\n    requires 0 < m\n    ensures 0 % m == 0\n  {\n  }\n  lemma LemmaFundamentalDivMod(x:int, d:int)\n    requires d != 0\n    ensures x == d * (x / d) + (x % d)\n  {\n  }\n  lemma Lemma0ModAnything()\n    ensures forall m: int {:trigger 0 % m} :: m > 0 ==> 0 % m == 0\n  {\n  }\n  lemma LemmaSmallMod(x:nat, m:nat)\n    requires x < m\n    requires 0 < m\n    ensures x % m == x\n  {\n  }\n  lemma LemmaModRange(x:int, m:int)\n    requires m > 0\n    ensures 0 <= x % m < m\n  {\n  }\n}"
},
{
    "dafny": "method M(P: (int -> int) -> bool, g: int -> int)\n  requires P.requires(g)\n  requires P(g) {\n  assume forall f: int -> int :: P.requires(f);\n  assume forall f: int -> int :: P(f) ==> f.requires(10) && f(10) == 0;\n  assert forall f: int -> int ::\n    (forall x :: f.requires(x) && g.requires(x) ==> f(x) == g(x)) ==>\n    f.requires(10) ==>\n    f(10) == 0;\n}"
},
{
    "dafny": "method divided_diff(n:int, m: int,q:array?<int>,r:array?<int>) \nrequires q!=null && q.Length>0\n   requires r!=null && r.Length>0\n   requires forall i,j::0<=i<q.Length&&0<=j<q.Length==>q[i]!=q[j]\n   requires n == m * q[0] + r[0]\n   ensures   0 <= r[0]  &&  r[0] < m\n   ensures   n == m * q[0] + r[0]\n   modifies r\n   modifies q\n{\n      r[0] := r[0] - m;\n      q[0] := q[0] + 1;\n}\nmethod divided_diff1(n:int, m: int,q:array?<int>,r:array?<int>) \nrequires q!=null && q.Length>0\n   requires r!=null && r.Length>0\n   requires forall i,j::0<=i<q.Length&&0<=j<q.Length==>q[i]!=q[j]\n   requires 0 <= r[0];\n   ensures   0 <= r[0]  &&  r[0] < m\n   ensures   n == m * q[0] + r[0]\n   modifies r\n   modifies q\n{\n      r[0] := r[0] - m;\n      q[0] := q[0] + 1;\n}"
},
{
    "dafny": "lemma lem(A : set<int>, B:set<int>, x :int)\n    requires x in A;\n\trequires A == B;\n\tensures x in B;\n\t{\n\t}\n  lemma example(A : set<int>, B:set<int>, x :int)\n    requires x in A;\n\trequires A * B == {};\n\tensures x !in B\n  {\n     if x in B {\n\t\tassert  x in A * B;\n\t\tlem(A*B,{},x);\n\t\tassert x in {};\n\t\tassert false;\n\t  }\n  }\n  lemma set_inter_empty_contr(A : set<int>, B:set<int>, x :int)\n    requires x in A;\n\trequires A * B == {};\n\tensures x !in B\n  {\n     if x in B {\n\t\tassert  x in A * B;\n\t\tlem(A*B,{},x);\n\t\tassert x in {};\n\t\tassert false;\n\t  }\n  }"
},
{
    "dafny": "newtype {:nativeType \"uint\"} u32 =\n  x: int | 0 <= x < 0x100000000\nfunction pow2(n: nat): int\n{\n  if n == 0 then 1 else 2 * pow2(n - 1)\n}\nlemma {:fuel pow2,31,32} {:induction false} pow2Bounds(n: nat)\n    requires n < 32\n    ensures 0 <= pow2(n) < 0x100000000\n{\n}\nfunction pow2u32(n: u32): u32\n    requires n < 32\n{\n    pow2Bounds(n as nat);\n    pow2(n as nat) as u32\n}"
},
{
    "dafny": "method Main()\n{\n    var vazia: seq<int> := [];\n    var s:seq<int> := [1, 2, 3, 4, 5];\n    var itens: array<int>;\n    itens := new int[3];\n    itens[0] := 1;\n    itens[1] := 2;\n    itens[2] := 3;\n    assert [1,2] == itens[..2];\n    assert [1,2,3,4,5] == s[..];\n    assert |s| == 5;\n    assert s[0] == 1;\n    assert s[1..3] == [2, 3];\n    assert s[1..] == [2,3,4,5];\n    assert s[..3] == [1,2,3];\n    assert [1,2,2,3,4] == [1,2] + [2,3,4] ;\n    assert 1 in s;\n    assert 0 !in s;\n    assert [1,2] + [3,4] == [1,2,3,4];\n    assert vazia < s; \n    assert [1,2] < s;\n    assert [1,2,3,4,5] <= s;\n    assert s[2:=0] == [1,2,0,4,5]; \n    assert s[2:=s[2]*2] == [1,2,6,4,5];\n}"
},
{
    "dafny": "predicate divides(f:nat, i:nat)\n  requires 1<=f\n{\n  i % f == 0\n}\npredicate IsPrime(i:nat)\n{\n  && 1<i\n  && ( forall f :: 1 < f < i ==> !divides(f, i) )\n}\nmethod test_prime(i:nat) returns (result:bool)\n  requires 1<i\n  ensures result == IsPrime(i)\n{\n  var f := 2;\n  while (f < i)\n    invariant forall g :: 1 < g < f ==> !divides(g, i)\n  {\n    if i % f == 0 {\n      assert divides(f, i);\n      return false;\n    }\n    f := f + 1;\n  }\n  return true;\n}\nmethod Main()\n{\n  var a := test_prime(3);\n  assert a;\n  var b := test_prime(4);\n  assert divides(2, 4);\n  assert !b;\n  var c := test_prime(5);\n  assert c;\n}"
},
{
    "dafny": "function fib(n: nat): nat\n{\n    if n == 0 then 0 else\n    if n == 1 then 1 else\n        fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n    ensures b == fib(n)\n{\n    var i: int := 0;\n    var a := 1;\n        b := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant b == fib(i)\n        invariant i >= 1 ==> a == fib(i - 1)\n        invariant i < 1 ==> a == 1\n    {\n        a, b := b, a + b;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "predicate elementosDistintos(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| ==> forall j :: 0 <= j < |s| && j != i ==> s[i] != s[j]\n}\nclass Conjunto{\n    var c : seq<nat>\n    constructor()\n    ensures |c| == 0\n    ensures elementosDistintos(c);\n    {\n        c := [];\n    }\n    method size()  returns (s:nat)\n    ensures s == |c|\n    {\n        s := |c|;\n    }\n    method contains(v : nat) returns (b:bool)\n    ensures b <==> v in c\n    {\n        b := v in c;\n    }\n    method add(v : nat) returns (b:bool)\n    modifies this\n    ensures v in c\n    ensures old(v !in c) ==> b\n    ensures old(v in c) ==> !b\n    ensures forall e :: e in c && e != v ==> e in c\n    ensures old(v !in c) && b ==> v in c\n    ensures b ==> old(|c|) + 1 == |c|\n    ensures !b ==> old(|c|) == |c|\n    ensures forall e :: (old(!( e in c)) && (e != v) ==> e !in c)\n    ensures old(|c|) == |c| ==> (b == false)\n    {\n        b := true;\n        var x := contains(v);\n        if(x){\n            b:=false;\n        }else{\n            c := c + [v];\n            b := true;\n        }\n    }\n    method inter(b : Conjunto) returns (d: Conjunto)\n    ensures forall e :: e in d.c <==> (e in c && e in b.c)\n    ensures elementosDistintos(d.c)\n    {\n        d := new Conjunto();\n        var aux := 0;\n        var x : bool;\n        d.c := [];\n        while (aux < |c|)\n        invariant aux <= |c|\n        invariant forall e :: e in c[..aux] && e in b.c ==> e in d.c \n        invariant forall e :: e in d.c ==> (e in c && e in b.c)\n        invariant forall i, j :: 0 <= i < |d.c|  && 0 <= j < |d.c| && i != j ==> d.c[i] != d.c[j]\n        decreases |c| - aux\n        {\n            x := c[aux] in b.c && c[aux] !in d.c;\n            if (x) {\n                d.c := d.c +  [c[aux]];\n            }\n            aux := aux + 1;\n        }\n    }\n  method union(b : Conjunto) returns (d: Conjunto)\n    ensures forall e :: (e in c || e in b.c) <==> e in d.c\n    ensures |d.c| <= |c + b.c|\n    {\n        d := new Conjunto();\n        d.c := c;\n        var aux := 0;\n        var x : bool;\n        while (aux < |b.c|)\n        invariant aux <= |b.c|\n        invariant forall e :: e in c ==> e in d.c\n        invariant forall e :: e in b.c[..aux] ==> e in d.c\n        invariant forall e :: e in d.c ==> (e in c || e in b.c)\n        invariant |d.c| <= |c + b.c[..aux]|\n        decreases |b.c| - aux\n        {\n            x := b.c[aux] !in d.c;\n            if (x) {\n                d.c := d.c + [b.c[aux]];\n            }\n            aux := aux + 1;\n        }\n    }\n    method diff(b : Conjunto) returns (d: Conjunto)\n    ensures forall e :: (e in c && e !in b.c) <==> e in d.c\n    ensures elementosDistintos(d.c)\n    {\n        d := new Conjunto();\n        d.c := [];\n        var aux := 0;\n        var x : bool;\n        while (aux < |c|)\n        invariant aux <= |c|\n        invariant forall e :: e in c[..aux] && e !in b.c <==> (e in d.c)\n        invariant forall i, j :: 0 <= i < |d.c|  && 0 <= j < |d.c| && i != j ==> d.c[i] != d.c[j]\n        decreases |c| - aux\n        {\n            x := c[aux] !in b.c && c[aux] !in d.c;\n            if (x) {\n                d.c := d.c + [c[aux]];\n            }\n            aux := aux + 1;\n        }\n    }\n}\nmethod testeAdd()\n{\n    var ins : bool;\n    var tam : nat;\n    var s := new Conjunto();\n    tam := s.size();\n    assert tam == 0;\n    assert 1 !in s.c;\n    ins := s.add(1);\n    assert ins;\n    assert 1 in s.c;\n    ins := s.add(1);\n    assert !ins;\n    ins := s.add(2);\n    assert ins;\n    assert 3 !in s.c;\n    ins := s.add(3);\n    assert ins;\n    assert 1128374623412341234 !in s.c;\n    ins := s.add(1128374623412341234);\n    assert ins;\n}\nmethod testeSize()\n{\n    var con : bool;\n    var ins : bool;\n    var tam : nat;\n    var c := new Conjunto();\n    tam := c.size();\n    assert tam == 0;\n    ins := c.add(1);\n    tam := c.size();\n    assert tam == 1;\n    ins := c.add(100);\n    tam := c.size();\n    assert tam == 2;\n}\nmethod testeContains()\n{\n    var con : bool;\n    var ins : bool;\n    var tam : nat;\n    var c := new Conjunto();\n    assert 1 !in c.c;\n    con := c.contains(1);\n    assert !con;\n    ins := c.add(1);\n    assert 1 in c.c;\n    con := c.contains(1);\n    assert con;\n}\nmethod Main(){\n    testeAdd();\n    testeSize();\n    testeContains();\n    var s := new Conjunto();\n    var ins := s.add(1);  assert ins;\n    ins := s.add(1);      assert !ins;\n    ins := s.add(2);      assert ins;\n    ins := s.add(3);      assert ins;\n    ins := s.add(5);      assert ins;\n    ins := s.add(8);      assert ins;\n    ins := s.add(13);     assert ins;\n    var tam := s.size();\n    assert tam == 6;\n    var p := new Conjunto();\n    ins := p.add(2);        assert ins;\n    ins := p.add(4);        assert ins;\n    ins := p.add(6);        assert ins;\n    ins := p.add(8);        assert ins;\n    ins := p.add(10);       assert ins;\n    ins := p.add(12);       assert ins;\n    ins := p.add(12);        assert !ins;\n    tam := s.size();\n    assert tam == 6;\n    print(\"s == \");\n    print(s.c); print(\"\\n\");\n    print(\"p == \"); \n    print(p.c); print(\"\\n\"); \n    var con := s.contains(1);\n    print (\"1 esta em s ? \");\n    print(con); print(\"\\n\");\n    con := p.contains(1);\n    print (\"1 esta em p ? \");\n    print(con); print(\"\\n\");\n    var intrr := s.inter(p);\n    print (\"s interseccao com p == \");\n    print(intrr.c); \n    print(\"\\n\");\n    var diff := s.diff(p);\n    print (\"s - p == \"); \n    print (diff.c);\n    print(\"\\n\");\n    diff := p.diff(s);\n    print (\"p - s == \"); \n    print (diff.c);\n    print(\"\\n\");\n    var u := s.union(p);\n    print(\"s uniao p == \");\n    print(u.c);\n}"
},
{
    "dafny": "method TwoSum(nums: seq<int>, target: int) returns (res: seq<int>)\n  requires |nums| >= 2\n  requires exists i, j :: 0 <= i < j < |nums| && nums[i] + nums[j] == target\n  requires forall i, j, k, l :: 0 <= i < j < |nums| && nums[i] + nums[j] == target &&\n                                0 <= k < l < |nums| && nums[k] + nums[l] == target ==>\n                                i == k && j == l\n  ensures |res| == 2\n  ensures 0 <= res[0] < |nums|\n  ensures 0 <= res[1] < |nums|\n  ensures nums[res[0]] + nums[res[1]] == target\n{\n  var m: map<int, int> := map[];\n  var i := 0;\n  while i < |nums|\n    invariant 0 <= i <= |nums|\n    invariant forall j | 0 <= j < i :: nums[j] in m\n    invariant forall k | k in m :: 0 <= m[k] < i && k == nums[m[k]]\n    invariant i > 1 ==> forall j, k | 0 <= j < k < i :: nums[j] + nums[k] != target\n    invariant exists k | i <= k < |nums| ::\n                         exists j | 0 <= j < |nums| && k != j ::\n                                    nums[k] + nums[j] == target\n  {\n    var val := target - nums[i];\n    if val in m {\n      var j := m[val];\n      return [j, i];\n    }\n    m := m[nums[i] := i];\n    i := i + 1;\n  }\n}\nmethod Testing() {\n  var nums1 := [2, 7, 11, 15];\n  var target1 := 9;\n  assert nums1[0] + nums1[1] == target1;\n  var res1 := TwoSum(nums1, target1);\n  assert nums1[res1[0]] + nums1[res1[1]] == target1;\n  print \"res1: \", res1, \"\\n\";\n  var nums2 := [3,2,4];\n  var target2 := 6;\n  assert nums2[1] + nums2[2] == target2;\n  var res2 := TwoSum(nums2, target2);\n  assert nums2[res2[0]] + nums2[res2[1]] == target2;\n  print \"res2: \", res2, \"\\n\";\n  var nums3 := [3,3];\n  var target3 := 6;\n  assert nums3[0] + nums3[1] == target3;\n  var res3 := TwoSum(nums3, target3);\n  assert nums3[res3[0]] + nums3[res3[1]] == target3;\n  print \"res3: \", res3, \"\\n\";\n}\nmethod Main() {\n  Testing();\n}"
},
{
    "dafny": "predicate isClean(a: array<int>, key: int) \n    reads a \n{\n    if a == null then a == null else\n    forall i ::0<= i < a.Length ==> a[i] != key\n}\nmethod IsClean(a: array<int>, key: int) returns (clean: bool)\nensures clean <==> isClean(a, key)\n{\n    clean:=true;\n    if a == null {return;}\n    var i:int := 0;\n    while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant clean == forall j :: 0<= j < i ==> a[j]!=key\n    decreases a.Length - i;\n    {\n        if a[i] == key \n        {\n            clean := false;\n            break;\n        }\n        i := i+1;\n    }\n}\nmethod Main()\n{\n    var arr :=new int[5];\n    arr[0], arr[1], arr[2], arr[3], arr[4] := 1,2,2,2,3;\n    var res:= IsClean(arr, 1);\n    assert arr[0]==1;\n    assert arr[1]==2;\n    assert arr[2]==2;\n    assert arr[3]==2;\n    assert arr[4]==3;\n    assert !res;\n    print res;\n    print \"\\n\";\n    res:= IsClean(arr, 2);\n    assert !res;\n    print res;\n    print \"\\n\";\n    res:= IsClean(arr, 3);\n    assert !res;\n    print res;\n    print \"\\n\";\n    res:= IsClean(arr, 4);\n    assert res;\n    print res;\n    print \"\\n\";\n    var arr1 :=new int[1];\n    arr1[0] := 1;\n    res := IsClean(arr1, 1);\n    assert arr1[0] == 1;\n    assert !res;\n    print res;\n    print \"\\n\";\n    res := IsClean(arr1, 2);\n    assert res;\n    print res;\n    print \"\\n\";\n    var arr2 :=new int[0];\n    res := IsClean(arr2, 1);\n    assert res;\n    print res;\n    print \"\\n\";\n}"
},
{
    "dafny": "predicate IsLessThanSuccesor(i:int)\n{\n  i < i + 1\n}\nlemma LemmaWithoutTriggerOnForallStatement()\n{\n  forall i\n    ensures IsLessThanSuccesor(i);\n  {\n  }\n}"
},
{
    "dafny": "method QuotRem(n: int, m: int)  returns (r: int, q: int) \n\trequires n >= 0 && m > 0;\n\tensures n == m ==> q == 1;\n\tensures n == (q * m) + r;\n{\n\tr := n;\n\tq := 0;\n\twhile(r >= m)\n\t\tinvariant n == m && r < n ==> q == 1;\n\t\tinvariant n == (q * m) + r; \n\t{\n\t\tr := r - m;\n\t\tq := q + 1;\n\t}\n}"
},
{
    "dafny": "predicate inplace(a : array<int>, l : int, m : int, h : int)\n  requires 0 <= l <= m <= h <= a.Length;\n  reads a;\n{\n  forall i,j :: l <= i < m <= j < h ==> a[i] < a[j]\n}\nmethod Swap(a : array<int>, k : int, k' : int)\n  requires a.Length > 0;\n  requires 0 <= k  < a.Length;\n  requires 0 <= k' < a.Length;\n  modifies a;\n  ensures a[k] == old(a[k']);\n  ensures a[k'] == old(a[k]);\n  ensures forall i :: (0 <= i < a.Length) && (i !in {k, k'}) ==> a[i] == old(a[i])\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  a[k], a[k'] := a[k'], a[k];\n}\nmethod Partition(A : array<int>, s : int, l : int, X : int) returns (m : int, n : int)\n  requires A.Length > 0;\n  requires 0 <= s <= l <= A.Length;\n  requires 0 <  s <= l <= A.Length ==> inplace(A, 0, s, A.Length);\n  requires 0 <= s <= l <  A.Length ==> inplace(A, 0, l, A.Length);\n  modifies A;\n  ensures 0 <= s <= m <= n <= l <= A.Length\n  ensures forall i :: s <= i < m ==> A[i] < X;\n  ensures forall i :: m <= i < n ==> A[i] == X;\n  ensures forall i :: n <= i < l ==> A[i] > X;\n  ensures s > 0        ==> forall i :: 0 <= i < s        ==> A[i] == old(A[i]);\n  ensures l < A.Length ==> forall i :: l <= i < A.Length ==> A[i] == old(A[i]);\n  ensures multiset(A[..]) == multiset(old(A[..]));\n  ensures 0 <  s <= l <= A.Length ==> inplace(A, 0, s, A.Length);\n  ensures 0 <= s <= l <  A.Length ==> inplace(A, 0, l, A.Length);\n{\n  var k := s;\n  m, n := s, l;\n  while k < n\n    invariant 0 <= s <= m <= k <= n <= l <= A.Length;\n    invariant forall i :: s <= i < m ==> A[i] < X;\n    invariant forall i :: m <= i < k ==> A[i] == X;\n    invariant forall i :: n <= i < l ==> A[i] > X;\n    invariant s > 0        ==> forall i :: 0 <= i < s        ==> A[i] == old(A[i]);\n    invariant l < A.Length ==> forall i :: l <= i < A.Length ==> A[i] == old(A[i]);\n    invariant multiset(A[..]) == multiset(old(A[..]));\n    invariant 0 < s <= l <= A.Length ==> inplace(A, 0, s, A.Length);\n    invariant 0 <= s <= l < A.Length ==> inplace(A, 0, l, A.Length);\n    decreases n - k;\n  {\n    if A[k] < X {\n      Swap(A, m, k);\n      m := m + 1;\n      k := k + 1;\n    } else if A[k] == X {\n      k := k + 1;\n    } else if A[k] > X {\n      Swap(A, n-1, k);\n      n := n - 1;\n    }\n  }\n}"
},
{
    "dafny": "method Multiply(a: nat, b: nat) returns (total: nat)\n  requires a >= 0 && b >= 0\n  ensures total == a * b\n{\n  total := 0;\n  var i := 0;\n  while i < a\n    invariant total == b * i\n    invariant i <= a\n    decreases a - i\n  {\n    total := total + b;\n    i := i + 1;\n  }\n}\nmethod Main() {\n    var result := Multiply(3, 2);\n}"
},
{
    "dafny": "method indexOf(a:array<int>, n:int, elem:int) returns (idx:int)\nrequires n>= 0 && n <= a.Length\nensures idx >= -1 && idx < n\nensures idx >= 0 ==> a[idx] == elem\nensures idx >= 0 ==> forall j :: 0 <= j < idx ==> a[j] != elem\nensures idx < 0 ==> forall j :: 0 <= j < n ==> a[j] != elem\n{\n    var i:int := 0;\n    while(i < n)\n    decreases n - i\n    invariant i >= 0 && i <= n\n    invariant forall j :: 0 <= j < i ==> a[j] != elem\n    {\n        if(a[i] == elem){\n            return i ;\n        }\n        i := i + 1;\n    }\n    return -1;\n}\nmethod max(a:array<int>, n:int) returns (elem:int, idx:int)\nrequires n > 0 && n < a.Length\nensures forall i :: 0 <= i < n ==> elem >= a[i]\nensures idx >=0 && idx < n\nensures a[idx] == elem\n{\n    var max:int := a[0];\n    var maxIdx:int := 0;\n    var i:int := 1;\n    while(i < n)\n    decreases n - i\n    invariant i >= 0 && i <= n\n    invariant forall j :: 0 <= j < i ==> a[j] <= max\n    invariant maxIdx >= 0 && maxIdx < i\n    invariant a[maxIdx] == max\n    {\n        if(a[i] > max){\n            max := a[i];\n            maxIdx :=i;\n        }\n        i := i + 1;\n    }\n    return max, maxIdx;\n}\nmethod min(a:array<int>, n:int) returns (elem:int, idx:int)\nrequires n > 0 && n <=a.Length\nensures forall i :: 0 <= i < n ==> elem <= a[i]\nensures idx >=0 && idx < n\nensures a[idx] == elem\n{\n    var min:int := a[0];\n    var minIdx:int := 0;\n    var i:int := 1;\n    while(i < n)\n    decreases n - i\n    invariant i >= 0 && i <= n\n    invariant forall j :: 0 <= j < i ==> a[j] >= min\n    invariant minIdx >= 0 && minIdx < i\n    invariant a[minIdx] == min\n    {\n        if(a[i] < min){\n            min := a[i];\n            minIdx := i;\n        }\n        i := i + 1;\n    }\n    return min, minIdx;\n}\nmethod fillK(a:array<int>, n:int, k:int, count:int) returns (b:bool)\nrequires 0 <= n <= a.Length\nrequires count > 0 && count <= n\nensures n == 0 ==> b\nensures b <==> forall j :: 0 <= j < count ==> a[j] == k\n{\n    var i:int := 0;\n    while(i < count)\n    decreases count - i\n    invariant i >= 0 && i <= count\n    invariant forall j :: 0 <= j < i ==> k == a[j]\n    {\n        if(a[i] != k){\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\nfunction subString(a:array<char>, b:array<char>, offset:int, length:int) : bool\nrequires offset >= 0 && offset < a.Length - b.Length\nrequires length <= b.Length\nreads a,b\n{\n    forall i :: 0 <= i < length ==> a[offset + i] == b[i]\n}\nmethod isSubString(a:array<char>, b:array<char>, offset:int) returns (result:bool)\nrequires offset >= 0 && offset < a.Length - b.Length\nensures result <==> subString(a, b, offset, b.Length)\n{\n    var i:int := 0;\n    while(i < b.Length)\n    decreases b.Length - i\n    invariant 0 <= i <= b.Length\n    invariant subString(a, b, offset, i)\n    {\n        if(a[offset + i] != b[i]){\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\nmethod containsSubString(a:array<char>, b:array<char>) returns (pos:int)\nrequires b.Length <= a.Length\nensures pos >= -1 && pos < a.Length - b.Length\nensures pos >= 0 ==> subString(a, b, pos, b.Length)\nensures pos == -1 ==> forall i :: 0 <= i < a.Length - b.Length ==> !subString(a,b, i, b.Length)\n{\n    var i:int := 0;\n    while(i < a.Length - b.Length)\n    decreases a.Length - b.Length - i\n    invariant i >= 0 && i <= (a.Length-b.Length)\n    invariant forall j :: 0 <= j < i ==> !subString(a, b, j, b.Length)\n    {\n        var temp:bool := isSubString(a,b,i);\n        if(temp){\n            return i;\n        }\n        i := i + 1;\n    }\n    return -1;\n}\nmethod resize(a:array<int>) returns (b:array<int>)\nmethod reverse(a:array<int>, n:int) returns (r:array<int>)\nrequires 0 <= n <= a.Length\nensures r.Length == a.Length\nensures forall j :: (0 <= j < n) ==> r[j] == a[n-1-j]\nensures forall j :: (n <= j < r.Length) ==> r[j] == a[j]\n{\n    r := new int[a.Length];\n    var i := 0;\n    while (i < n)\n        decreases n-i\n        invariant 0 <= i <= n\n        invariant forall j :: (0<= j < i) ==> r[j] == a[n-1-j]\n    {\n        r[i] := a[n-1-i];\n        i := i + 1;\n    }\n    while (i < a.Length)\n    decreases a.Length - i\n    invariant n <= i <= a.Length\n    invariant forall j :: (0<= j < n) ==> r[j] == a[n-1-j];\n    invariant forall j :: (n <= j < i) ==> r[j] == a[j];\n    {\n        r[i] := a[i];\n        i := i + 1;\n    }\n}\nmethod push(a:array<int>, na:int, elem:int) returns (b:array<int>, nb:int)\nmethod pop(a:array<int>, n:int) returns (na:array<int>, nn:int, elem:int)"
},
{
    "dafny": "method SwapBitvectors(X: bv8, Y: bv8) returns(x: bv8, y: bv8)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n  x := x ^ y;\n  y := x ^ y;\n  x := x ^ y;\n}\nmethod TestSwapBitvectors(){\n  var x, y := SwapBitvectors(3, 5);\n  print(\"Test 1: Swap(3,5) = \", x, y, \"\\n\");\n  x, y := SwapBitvectors(-1, 0);\n  print(\"Test 2: Swap(-1,0) = \",x, y, \"\\n\");\n  x, y := SwapBitvectors(0, 0);\n  print(\"Test 3: Swap(0,0) = \",x, y,  \"\\n\");\n  x, y := SwapBitvectors(100, -100);\n  print(\"Test 4: Swap(100,-100) = \", x, y,  \"\\n\");\n  x, y := SwapBitvectors(189, 21);\n  print(\"Test 5: Swap(189, 21) = \", x, y,  \"\\n\");\n}\nmethod Main(){\n  TestSwapBitvectors();\n}"
},
{
    "dafny": "method Odd(x: int) returns (r: int)\nensures r % 2 != 0;\n{\n  if (x % 2 != 0)\n  {\n    return x;\n  }\n  else\n  {\n    return x+1;\n  }\n}\nmethod Main() {\n  var a := Odd(4);\n  var b := Odd(3);\n  print a,\"\\n\";\n  print b; \n}"
},
{
    "dafny": "predicate sorted(a:array<int>, left:int, right:int)\n\trequires 0 <= left <= right <= a.Length\n\treads a\n{\n\tforall j,k | left <= j < k < right :: (a[j] <= a[k])\n}\nmethod quicksort(a: array<int>, left: int, right: int)\n\tdecreases right - left\n\trequires a.Length > 0\n\trequires 0 <= left <= right <= a.Length\n\trequires (forall i | left <= i < right :: a[i] < a[right]) <== (0 <= left <= right < a.Length)\n\trequires (forall i | left <= i < right :: a[left - 1] <= a[i]) <== (0 < left <= right <= a.Length)\n\tensures forall i | (0 <= i < left || right <= i < a.Length) :: (old(a[i]) == a[i])\n\tensures (forall i | left <= i < right :: a[i] < a[right]) <== (0 <= left <= right < a.Length)\n\tensures (forall i | left <= i < right :: a[left - 1] <= a[i]) <== (0 < left <= right <= a.Length)\n\tensures sorted(a, left, right);\n\tmodifies a\n{\n\tif(left < right-1)\n\t{\n\t\tvar p := partition(a, left, right);\n\t\tquicksort(a, left, p);\n\t\tquicksort(a, p+1, right);\n\t}\n}\nmethod partition(a: array<int>, left: int, right: int) returns (p: int)\n\trequires a.Length > 0\n\trequires 0 <= left < right <= a.Length\n\trequires (forall i | left <= i < right :: (a[i] < a[right])) <== (0 <= left <= right < a.Length)\n\trequires (forall i | left <= i < right :: (a[left-1] <= a[i])) <== (0 < left <= right <= a.Length)\n\tensures 0 <= left <= p < right <= a.Length\n\tensures forall i | (left <= i < p) :: (a[i] < a[p])\n\tensures forall i | (p < i < right) :: (a[p] <= a[i])\n\tensures forall i | (0 <= i < left || right <= i < a.Length) :: (old(a[i]) == a[i])\n\tensures (forall i | left <= i < right :: (a[i] < a[right])) <== (0 <= left <= right < a.Length)\n\tensures (forall i | left <= i < right :: (a[left-1] <= a[i])) <== (0 < left <= right <= a.Length)\n\tmodifies a\n{\n\tp := left;\n\tvar k := left+1;\n\twhile(k < right)\n\tdecreases right - k\n\tinvariant left <= p < k <= right\n\tinvariant forall i | left <= i < p :: a[i] < a[p]\n\tinvariant forall i | p < i < k :: a[p] <= a[i]\n\tinvariant forall i | (0 <= i < left || right <= i < a.Length) :: (old(a[i]) == a[i])\n\tinvariant (forall i | left <= i < right :: a[i] < a[right]) <== (0 <= left <= right < a.Length)\n\tinvariant (forall i :: left <= i < right ==> a[left-1] <= a[i]) <== (0 < left <= right <= a.Length)\n\t{\n\t\tif(a[k] < a[p])\n\t\t{\n\t\t\tvar j := k-1;\n\t\t\tvar tmp := a[k];\n\t\t\ta[k] := a[j];\n\t\t\twhile(j > p)\n\t\t\tdecreases j - p\n\t\t\tinvariant a[p] > tmp\n\t\t\tinvariant forall i | left <= i < p :: (a[i] < a[p])\n\t\t\tinvariant forall i | p < i < k + 1 :: (a[p] <= a[i])\n\t\t\tinvariant forall i | (0 <= i < left || right <= i < a.Length) :: (old(a[i]) == a[i])\n\t\t\tinvariant (forall i :: left <= i < right ==> a[i] < a[right]) <== (0 <= left <= right < a.Length)\n\t\t\tinvariant (forall i :: left <= i < right ==> a[left-1] <= a[i]) <== (0 < left <= right <= a.Length)\n\t\t\t{\n\t\t\t\ta[j+1] := a[j];\n\t\t\t\tj := j-1;\n\t\t\t}\n\t\t\ta[p+1] := a[p];\n\t\t\tp := p+1;\n\t\t\ta[p-1] := tmp;\n\t\t}\n\t\tk := k+1;\n\t}\n}\nmethod test()\n{\n\tvar a:array<int>:= new int[][5,4,3,2,1];\n\tassert a[0] == 5;\n\tassert a[1] == 4; \n\tassert a[2] == 3; \n\tassert a[3] == 2; \n\tassert a[4] == 1; \n\tquicksort(a,0,a.Length);\n\tassert sorted(a,0,a.Length);\n}"
},
{
    "dafny": "newtype {:nativeType \"int\"} i32 = x | -0x8000_0000 <= x < 0x8000_0000\nnewtype {:nativeType \"uint\"} u32 = x | 0 <= x < 0x1_0000_0000\nnewtype {:nativeType \"ulong\"} u64 = x | 0 <= x < 0x1_0000_0000_0000_0000\nnewtype {:nativeType \"int\"} ArrayIndex = x | 0 <= x < 0x7FF0_0000\nnewtype {:nativeType \"int\"} ArrayLength = x | 0 <= x < 0x7FF0_0001\nclass NativeIntConstants {\n    static const MaxArrayLengthInt := 0x7FF0_0000;\n    static const MaxArrayIndexInt := 0x7FEF_FFFF;\n    static const MaxArrayIndex: ArrayIndex := MaxArrayIndexInt as ArrayIndex;\n    static const MaxArrayLength: ArrayLength := MaxArrayLengthInt as ArrayLength;\n    ghost method checks() {\n        assert MaxArrayIndexInt + 1 == MaxArrayLengthInt;\n    }\n}"
},
{
    "dafny": "module GiveT {\n  type T = int\n}\nmodule Base {\n  function f(x : T):int { 0 }\n}\nmodule Refined refines Base {\n  type T = int \n}\nmodule ImportBase {\n}\nmodule RefineImportBase refines ImportBase {\n}\nmodule GiveT2 {\n  type T = bool\n}\nmodule Refined2 refines GiveT {\n  function f(x: T): int \n}\nmodule GiveF{\n  function {:opaque} f(): bool { true }\n}\nmodule BaseF{\n  lemma Test()\n    ensures f() == true\n  { reveal_f(); }\n}\nmodule RefinedF refines BaseF {\n  function f(): bool { false } \n  lemma False()\n    ensures false\n  { reveal_f(); Test(); }\n}"
},
{
    "dafny": "const A: int\nconst B: int\nghost function Fib(n: nat): int {\n  if n == 0 then A\n  else if n == 1 then B\n  else Fib(n - 2) + Fib(n - 1)\n}\nghost function Sum(n: nat, f: nat -> int): int {\n  f(n) + if n == 0 then 0 else Sum(n - 1, f)\n}\nlemma Eleven()\n  ensures Sum(9, Fib) == 11 * Fib(6)\n{\n}\nlemma FibSum(n: nat)\n  ensures Sum(n, Fib) == Fib(n + 2) - Fib(1) \n{\n}\nlemma {:induction false} FibSumManual(n: nat)\n  ensures Sum(n, Fib) == Fib(n + 2) - Fib(1) \n{\n  if n == 0 {\n  } else {\n    calc {\n      Sum(n, Fib);\n    ==  \n      Fib(n) + Sum(n - 1, Fib);\n    ==  { FibSumManual(n - 1); }\n      Fib(n) + Fib(n - 1 + 2) - Fib(1);\n    ==\n      Fib(n) + Fib(n + 1) - Fib(1);\n    ==  \n      Fib(n + 2) - Fib(1);\n    }\n    assert Sum(n, Fib) == Fib(n + 2) - Fib(1); \n    assert Sum(n, Fib) == Fib(n + 2) - Fib(1); \n    assert Sum(n, Fib) == Sum(n, Fib);\n  }\n  assert Sum(n, Fib) == Fib(n + 2) - Fib(1); \n}"
},
{
    "dafny": "method SwapArithmetic(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n  x := y - x;\n  y := y - x;\n  x := y + x;\n}\nmethod TestSwapArithmetic(){\n  var x, y := SwapArithmetic(3, 5);\n  print(\"Test 1: Swap(3,5) = \", x, y, \"\\n\");\n  x, y := SwapArithmetic(-1, 0);\n  print(\"Test 2: Swap(-1,0) = \",x, y, \"\\n\");\n  x, y := SwapArithmetic(0, 0);\n  print(\"Test 3: Swap(0,0) = \",x, y,  \"\\n\");\n  x, y := SwapArithmetic(100, -100);\n  print(\"Test 4: Swap(100,-100) = \", x, y,  \"\\n\");\n  x, y := SwapArithmetic(123456789, 987654321);\n  print(\"Test 5: Swap(123456789,987654321) = \", x, y,  \"\\n\");\n}\nmethod Main(){\n  TestSwapArithmetic();\n}"
},
{
    "dafny": "method mystery(a: nat) returns (q:nat, r:nat)\nensures  a == q*3 + r\nensures 0 <= r < 3\n{\n    q, r := 0, a + 1;\n    while r >= 4\n    invariant 0 < r <= a+1\n    invariant a == q*3 + r-1 \n    decreases r\n    {\n        assert a == q*3 + r-1; \n        assert a == q*3 + (r-r%4) + r%4-1;\n        assert a == q*3 + ((r-r%4)*4 + r%4*4)/4-1;\n        assert a == q*3 + ((r-r%4)*3 + r - r%4 + r%4*4)/4-1;\n        assert a == q*3 + (r/4*4*3 + r - r%4 + r%4*4)/4-1;\n        assert a == q*3 + (r/4*3*4 + r/4*4 +r%4*4)/4-1;\n        assert a == q*3 + r/4*3 + r/4+r%4-1;\n        assert a == (q+r/4)*3 + r/4+r%4-1;\n        q := q + r/4;\n        assert a == q*3 + r/4+r%4-1;\n        r := r/4 + r%4; \n        assert a == q*3 + r - 1;\n    }\n    assert a == q*3 + r - 1;\n    r := r - 1;\n    assert a == q*3 + r;\n}"
},
{
    "dafny": "datatype Colour = Red | White | Blue\npredicate Below(c1: Colour, c2: Colour)\n{\n    c1 == Red || c1 == c2 || c2 == Blue\n}\nmethod DutchFlag(a: array<Colour>)\n    modifies a\n    ensures forall k :: 0 <= k < a.Length-1 ==> Below(a[k], a[k+1])\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    var r, w, b := 0, 0, a.Length;\n    while w != b\n        invariant 0 <= r <= w <= b <= a.Length\n        invariant forall k :: 0 <= k < r ==> a[k] == Red\n        invariant forall k :: r <= k < w ==> a[k] == White\n        invariant forall k :: b <= k < a.Length ==> a[k] == Blue\n        invariant multiset(a[..]) == multiset(old(a[..]))\n        decreases b - w\n    {\n        match a[w]\n            case Red => \n                a[r], a[w] := a[w], a[r];\n                r := r + 1;\n                w := w + 1;\n            case White =>\n                w := w + 1;\n            case Blue =>\n                a[b-1], a[w] := a[w], a[b-1];\n                b := b - 1;\n    }\n}"
},
{
    "dafny": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures n==a.Length ==> forall i::0<=i<a.Length ==> e!=a[i]\n{\n  n :=0;\n  while n!=a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i<n ==> e!=a[i]\n  {\n    if e==a[n]{\n      return;\n    }\n    n:=n+1;\n  }\n}\nmethod TestLinearSearch(){\n  var a:=new int[5] [1, 2, 3, 4, 5];\n  var test := LinearSearch(a, 3);\n  print(\"Test 1: LinearSearch(...) = \", test, \"\\n\");\n  a:=new int[] [10, 15, 20, 25, 30, 35, 40];\n  test := LinearSearch(a, 30);\n  print(\"Test 2: LinearSearch(...) = \", test, \"\\n\");\n  a:=new int[] [0];\n  test := LinearSearch(a, 0);\n  print(\"Test 3: LinearSearch(...) = \", test, \"\\n\");\n  a:=new int[] [-10, -20, -30];\n  test := LinearSearch(a, -20);\n  print(\"Test 4: LinearSearch(...) = \", test, \"\\n\");\n  a:=new int[] [321, 123, 456, 654];\n  test := LinearSearch(a, 5);\n  print(\"Test 5: LinearSearch(...) = \", test, \"\\n\");\n}\nmethod Main(){\n  TestLinearSearch();\n}"
},
{
    "dafny": "function fib(n : nat ) : nat\n  decreases n\n{\n    if n < 2 then n else fib(n - 2) + fib(n - 1)\n}\nmethod computeFib (n : nat) returns (x : nat)\n    requires n > 0 \n    ensures x == fib(n)\n{\n    var i := 0;\n    x := 0;\n    var y := 1;\n    while  i < n \n        invariant 0 <= i <= n && x == fib(i) && y == fib(i+1) \n        decreases n - i\n    {\n        x, y := y, x + y; \n        i := i + 1;\n    }\n}\nmethod testComputeFib() {\n    var f := computeFib(3);\n    assert f == 2;\n}"
},
{
    "dafny": "method only_once<T(==)>(a: array<T>, key: T) returns (b:bool)\n  ensures (multiset(a[..])[key] ==1 ) <==> b\n{\n  var i := 0;\n  b := false;\n  var keyCount := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant multiset(a[..i])[key] == keyCount\n    invariant b <==> (keyCount == 1)\n  {\n    if (a[i] == key)\n    {\n      keyCount := keyCount + 1;\n    }\n    if (keyCount == 1)\n    { b := true; }\n    else\n    { b := false; }\n    i := i + 1;\n  }\n  assert a[..a.Length] == a[..];\n}"
},
{
    "dafny": "module {:extern \"System\"} {:compile false} {:options \"-functionSyntax:4\"} System {\n  class {:extern \"Text.StringBuilder\"} {:compile false} CsStringBuilder {\n    ghost var built: CsString\n    constructor {:extern} ()\n    method {:extern \"Append\"} Append(s: CsString)\n      modifies this\n      ensures built == String.Concat(old(built), s)\n    method {:extern @\"ToString().ToString\"} ToString() returns (r: CsString)\n      ensures r == built\n  }\n  type {:extern \"String\"} CsString(!new,==) {\n    ghost predicate {:extern} Contains(needle: CsString)\n    lemma {:axiom} ContainsTransitive(other: CsString, needle: CsString)\n      requires Contains(other) && other.Contains(needle)\n      ensures Contains(needle)\n  }\n  lemma ContainsTransitive()\n    ensures forall s1: CsString, s2: CsString, s3: CsString\n              | s1.Contains(s2) && s2.Contains(s3) :: s1.Contains(s3)\n  {\n    forall s1: CsString, s2: CsString, s3: CsString\n      | s1.Contains(s2) && s2.Contains(s3)\n    {\n      s1.ContainsTransitive(s2, s3);\n    }\n  }\n  class {:extern \"String\"} {:compile false} String {\n    static function Concat(s1: CsString, s2: CsString): (r: CsString)\n      ensures r.Contains(s1)\n      ensures r.Contains(s2)\n  }\n}"
},
{
    "dafny": "function square(n: int): int\n{\n    n * n\n}\nmethod sqrt(n : nat) returns (r: int)\n  ensures r * r <= n\n  ensures forall i :: 0 <= i < r ==> square(i) < r * r\n{\n    var i := 0; \n    r := 0;\n    while i * i <= n\n      invariant r * r <= n\n      invariant forall k :: 0 <= k < r ==> square(k) < r * r \n      decreases n - i\n    {\n      r := i;\n      i := i + 1;\n    }\n    return r;\n}"
},
{
    "dafny": "datatype State = State(m:map<int, bool>)\nlemma Test(s:State)\n  requires 42 in s.m\n  ensures s.(m := s.m[42 := s.m[42]]) == s\n{\n  var s' := s.(m := s.m[42 := s.m[42]]);\n  assert s'.m == s.m;\n}\ndatatype MyDt = MakeA(x: int, bool) | MakeB(s: multiset<int>, t: State)\nlemma AnotherTest(a: MyDt, b: MyDt, c: bool)\n  requires a.MakeB? && b.MakeB?\n  requires a.s == multiset(a.t.m.Keys) && |b.s| == 0\n  requires a.t.m == map[] && |b.t.m| == 0\n{\n  assert a == b;\n}\ndatatype GenDt<X,Y> = Left(X) | Middle(X,int,Y) | Right(y: Y)\nmethod ChangeGen(g: GenDt)\n{\n  match g\n  case Left(_) =>\n  case Middle(_,_,_) =>\n  case Right(u) =>\n    var h := g.(y := u);\n    assert g == h;\n}\ndatatype Recursive<X> = Red | Green(next: Recursive, m: set)\nlemma RecLem(r: Recursive) returns (s: Recursive)\n  ensures r == s\n{\n  match r\n  case Red =>\n    s := Red;\n  case Green(next, m) =>\n    var n := RecLem(next);\n    s := Green(n, m + m);\n}"
},
{
    "dafny": "method flip (a: array<int>, num: int)\n  requires 0 <= num < a.Length;\n  modifies a;\n  ensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k]);\n  ensures forall k :: num < k < a.Length ==> a[k] == old(a[k]);\n  ensures multiset(old(a[..])) == multiset(a[..]);\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\n    invariant num == i + j;\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[num-k]);\n    invariant forall k :: i <= k <= j ==> a[k] == old(a[k]);\n    invariant forall k :: j < k <= num ==> a[k] == old(a[num-k]);\n    invariant forall k :: num < k < a.Length ==> a[k] == old(a[k]);\n    invariant multiset(old(a[..])) == multiset(a[..]);\n    decreases j - i;\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}"
},
{
    "dafny": "ghost predicate P(s:seq<int>)\n    requires 10 < |s|\n{\n    (forall i:int {:trigger s[i]} :: forall j:int {:trigger s[j]} ::\n        0 <= i < j < 5 ==> s[i + j] == s[i] == s[j])\n}\nghost predicate P0(s:seq<int>)\n    requires 10 < |s|\n{\n    (forall i:int :: forall j:int  ::\n        0 <= i < j < 5 ==> s[i + j] == s[i] == s[j])\n}\nghost predicate P1(s:seq<int>)\n    requires 10 < |s|\n{\n    (forall i:int, j: int {:trigger s[i], s[j]} ::\n        0 <= i < j < 5 ==> s[i + j] == s[i]+s[j])\n}\nghost predicate P2(s:seq<int>)\n    requires 10 < |s|\n{\n    (forall i:int, j: int ::\n        0 <= i < j < 5 ==> s[i + j] == s[i]+s[j])\n}"
},
{
    "dafny": "datatype NatOutcome =\n| Success(value: nat)\n| Failure(error: string)\n{\n  predicate IsFailure() {\n    this.Failure?\n  }\n  function PropagateFailure(): NatOutcome\n    requires IsFailure()\n  {\n    this\n  }\n  function Extract(): nat\n    requires !IsFailure()\n  {\n    this.value\n  }\n  function P(): nat\n    ensures this.P() < 20  \n  {\n    if Success? then 12 else 14\n  }\n  function R(): nat\n  {\n    var x :| 0 <= x < this.P() + 1 && x < 1;  \n    x\n  }\n}\nmethod Main() {\n  var n := Success(55);\n  assert !n.IsFailure();\n  var v := n.Extract();\n  print n, \" \", n.IsFailure(), \" \", v, \"\\n\";  \n  print n.P(), \" \", n.R(), \"\\n\";  \n  n := Failure(\"it could be worse\");\n  assert n.IsFailure();\n  var p := n.PropagateFailure();\n  print n, \" \", n.IsFailure(), \" \", p, \"\\n\";  \n  print n.P(), \" \", n.R(), \"\\n\";  \n}"
},
{
    "dafny": "datatype Tree = Empty | Branch(val: int, left: Tree, right: Tree)\nfunction Size(t:Tree): int \n{\n  match t\n  case Empty => 0\n  case Branch(_, t1, t2) => 1 + Size(t1) + Size(t2)\n}\nfunction isEmpty(t:Tree): bool\n{\n    match t\n    case Empty => true\n    case Branch(_, _, _) => false\n}\nfunction Valid(t:Tree): (b: bool)\n{\n    match t\n    case Empty => true\n    case Branch(v, t1, t2) => Forall_lt(t1, v) && Forall_gt(t2, v) && Valid(t1) && Valid(t2)\n}\nfunction Exists_eq(t:Tree, v:int): (b: bool)\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) => x == v || Exists_eq(t1, v) || Exists_eq(t2, v)\n}\nfunction Exists_neq(t:Tree, v:int): bool\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) => x != v || Exists_neq(t1, v) || Exists_neq(t2, v)\n}\nfunction Exists_lt(t:Tree, v:int): bool\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) => x < v || Exists_lt(t1, v) || Exists_lt(t2, v)\n}\nfunction Exists_le(t:Tree, v:int): bool\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) => x <= v || Exists_le(t1, v) || Exists_le(t2, v)\n}\nfunction Exists_gt(t:Tree, v:int): bool\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) => x > v || Exists_gt(t1, v) || Exists_gt(t2, v)\n}\nfunction Exists_ge(t:Tree, v:int): bool\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) => x >= v || Exists_ge(t1, v) || Exists_ge(t2, v)\n}\nfunction Forall_eq(t:Tree, v:int): bool\n{\n    match t\n    case Empty => true\n    case Branch(x, t1, t2) => x == v && Forall_eq(t1, v) && Forall_eq(t2, v)\n}\nfunction Forall_neq(t:Tree, v:int): (b: bool)\n{\n    match t\n    case Empty => true\n    case Branch(x, t1, t2) => x != v && Forall_neq(t1, v) && Forall_neq(t2, v)\n}\nfunction Forall_lt(t:Tree, v:int): (b: bool)\n    ensures forall x :: b && x >= v ==> Forall_neq(t, x)\n{\n    match t\n    case Empty => true\n    case Branch(x, t1, t2) => x < v && Forall_lt(t1, v) && Forall_lt(t2, v)\n}\nfunction Forall_le(t:Tree, v:int): bool\n{\n    match t\n    case Empty => true\n    case Branch(x, t1, t2) => x <= v && Forall_le(t1, v) && Forall_le(t2, v)\n}\nfunction Forall_gt(t:Tree, v:int): (b: bool)\n    ensures forall x :: b && x <= v ==> Forall_neq(t, x)\n{\n    match t\n    case Empty => true\n    case Branch(x, t1, t2) => x > v && Forall_gt(t1, v) && Forall_gt(t2, v)\n}\nfunction Forall_ge(t:Tree, v:int): bool\n{\n    match t\n    case Empty => true\n    case Branch(x, t1, t2) => x >= v && Forall_ge(t1, v) && Forall_ge(t2, v)\n}\nfunction Find(t:Tree, v:int): (b: bool)\n    requires Valid(t)\n    ensures !b || Exists_eq(t, v)\n    ensures b || Forall_neq(t, v)\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) =>\n        if (x == v) then true \n        else if (v < x) then Find(t1, v) else Find(t2, v)\n}"
},
{
    "dafny": "abstract module Interface {\n    function addSome(n: nat): nat\n        ensures addSome(n) > n\n}\nabstract module Mod {\n    method m() {\n        assert 6 <= A.addSome(5);\n        print \"Test\\n\";\n    }\n}\nmodule Implementation refines Interface {\n    function addSome(n: nat): nat\n        ensures addSome(n) == n + 1\n    {\n        n + 1\n    }\n}\nmodule Mod2 refines Mod {\n}\nmethod Main() {\n    Mod2.m();\n}"
},
{
    "dafny": "method Max(a:array<nat>)returns(m:int)\nensures a.Length > 0 ==> forall k :: 0<=k<a.Length ==> m >= a[k]\nensures a.Length == 0 ==> m == -1\nensures a.Length > 0 ==> m in a[..] \n{\n    if(a.Length == 0){\n        return -1;\n    }\n    assert a.Length > 0;\n    var i := 0;\n    m := a[0];\n    assert m in a[..]; \n    while(i < a.Length)\n    invariant 0<=i<=a.Length\n    invariant forall k :: 0<=k<i ==> m >= a[k]\n    invariant m in a[..] \n    {\n        if(a[i] >= m){\n            m:= a[i];\n        }\n        i := i+1;\n    }\n    assert m in a[..]; \n}\nmethod Checker()\n{\n    var a := new nat[][1,2,3,50,5,51];\n    var n := Max(a);\n    assert n == 51;\n}"
},
{
    "dafny": "module bubblesort{ \npredicate sorted(a: array?<int>, l: int, u: int)\n  reads a\n  requires a != null\n  {\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]\n  }\npredicate partitioned(a: array?<int>, i: int)\n  reads a\n  requires a != null\n  {\n    forall k, k' :: 0 <= k <= i < k' < a.Length ==> a[k] <= a[k']\n  }\nmethod BubbleSort(a: array<int>)\n\tmodifies a\n\t  requires a != null\n\t  ensures sorted(a, 0, a.Length-1){\n\tvar i := a.Length - 1;\n\twhile i > 0 \n\t\tinvariant i < 0 ==> a.Length == 0 \n\t\t  invariant sorted(a, i, a.Length-1)\n\t\t  invariant partitioned(a, i){\n\t\tvar j := 0;\n\t\twhile j < i \n\t\t\tinvariant 0 < i < a.Length && 0 <= j <= i\n\t\t\t  invariant sorted(a, i, a.Length-1)\n\t\t\t  invariant partitioned(a, i)\n\t\t\t  invariant forall k :: 0 <= k <= j ==> a[k] <= a[j]{\n\t\t\tif a[j] > a[j+1] {\n\t\t\t\ta[j], a[j+1] := a[j+1], a[j];\n\t\t\t}\n\t\t\tj := j + 1;\n\t\t}\n\t\ti := i - 1;\n\t}\n}\n}"
},
{
    "dafny": "method BigFoot(step: nat)               \nrequires 0 < step;\n{\n  var indx := 0;                       \n  while indx <= 42                     \n    invariant indx <= 42 + step;\n    decreases (42 - indx); \n  {\n    indx := indx + step;               \n  }\n  assert indx > 42; \n}"
},
{
    "dafny": "module max{ \nmethod Maximum(values: array<int>)returns (max:int)\n\trequires values.Length > 0\n\tensures exists i :: 0 <= i < values.Length && values[i] == max\n\tensures forall i | 0 <= i < values.Length :: values[i] <= max{\n\tmax := values[0];\n\tvar idx := 0;\n\twhile idx < values.Length \n\t\tinvariant exists i :: 0 <= i < values.Length && values[i] == max\n\t\tinvariant idx <= values.Length\n\t\tinvariant forall j | 0 <= j < idx :: values[j] <= max{\n\t\tif values[idx] > max {\n\t\t\tmax := values[idx];\n\t\t}\n\t\tidx := idx + 1;\n\t}\n\treturn;\n}\n}"
},
{
    "dafny": "datatype Foo = Foo(x: nat)\n{\n  const good?: bool := 0 < x < 5\n}\nmethod Main()\n{\n  var x := Foo(2);\n  assert x.good?;\n  print x, \" \", x.good?, \"\\n\";\n  var y := Foo(5);\n  assert !y.good?;\n  print y, \" \", y.good?, \"\\n\";\n}"
},
{
    "dafny": "method toMultiset(s: string) returns (mset: multiset<char>)\n    ensures multiset(s) == mset\n{\n    mset := multiset{};\n    for i := 0 to |s| \n        invariant mset == multiset(s[0..i])\n    {\n        assert s == s[0..i] + [s[i]] + s[(i+1)..];\n        mset := mset + multiset{s[i]};\n    }\n    assert s == s[0..|s|];\n    return mset;\n}\nmethod msetEqual(s: multiset<char>, t: multiset<char>) returns (equal: bool)\n    ensures s == t <==> equal\n{\n    ghost var sremoved: multiset<char> := multiset{};\n    var scopy := s;\n    while scopy != multiset{} \n        invariant s - sremoved == scopy\n        invariant sremoved !! scopy\n        invariant sremoved <= s\n        invariant forall x :: x in sremoved ==> x in s && x in t && t[x] == s[x]\n    {\n        var x :| x in scopy;\n        if !(x in t && s[x] == t[x]) {\n           return false; \n        }\n        var removed := multiset{};\n        sremoved := sremoved + removed[x := s[x]];\n        scopy := scopy - removed[x := s[x]];\n    }\n    ghost var tremoved: multiset<char> := multiset{};\n    var tcopy := t;\n    while tcopy != multiset{} \n        invariant t - tremoved == tcopy\n        invariant tremoved !! tcopy\n        invariant tremoved <= t\n        invariant forall x :: x in tremoved ==> x in s && x in t && t[x] == s[x]\n    {\n        var x :| x in tcopy;\n        if !(x in t && s[x] == t[x]) {\n           return false; \n        }\n        var removed := multiset{};\n        tremoved := tremoved + removed[x := s[x]];\n        tcopy := tcopy - removed[x := s[x]];\n    }\n    return true;\n}\nmethod isAnagram(s: string, t: string) returns (equal: bool)\n    ensures (multiset(s) == multiset(t)) == equal\n{\n    var smset := toMultiset(s);\n    var tmset := toMultiset(t);\n    equal := msetEqual(smset, tmset);\n}"
},
{
    "dafny": "function f(x: int): int\nfunction ff(x: int): int\nlemma {:axiom} ff_eq()\n  ensures forall x {:trigger ff(x)} :: ff(x) == f(f(x))\nlemma {:axiom} ff_eq2()\n  ensures forall x {:trigger f(f(x))} :: ff(x) == f(f(x))\nlemma {:axiom} ff_eq_bad()\n  ensures forall x {:trigger {f(x)}} :: ff(x) == f(f(x))\nlemma use_ff(x: int)\n{\n  ff_eq();\n  assert f(ff(x)) == ff(f(x));\n}\nlemma use_ff2(x: int)\n{\n  ff_eq2();\n  assert f(f(x)) == ff(x);\n  assert f(ff(x)) == ff(f(x));\n}"
},
{
    "dafny": "function sorted(a:array<int>, n:int) : bool \nreads a\nrequires 0 <= n <= a.Length\n{\n    forall i, j :: 0 <= j <= i < n ==> a[i] >= a[j]\n}\nmethod binaryIndex(a:array<int>, n:int, e:int) returns (z:int)\nrequires 0 <= n < a.Length\nrequires sorted(a, n)\nensures sorted(a, n)\nensures -(n + 1) <= z <= n\nensures z >= 0 ==> a[z] == e;\nensures z >= 0 ==> forall i :: 0 <= i < z ==> a[i] <= e\nensures z >= 0 ==> forall i :: z <= i < n ==> a[i] >= e\nensures z < 0 ==> forall i :: 0 <= i < -z-1 ==> a[i] < e\nensures z < 0 ==> forall i :: -z-1 <= i < n ==> a[i] > e\n{\n    var l:int := 0;\n    var r:int := n - 1;\n    while (l <= r)\n    decreases r - l\n    invariant 0 <= l <= n\n    invariant -1 <= r < n\n    invariant forall i :: 0 <= i < l ==> a[i] < e\n    invariant forall i :: r < i < n ==> a[i] > e\n    {\n        var m:int := l + (r - l) / 2;\n        assert l <= m <= r;\n        if (a[m] < e) {\n            l := m + 1;\n        } else if (a[m] > e){\n            r := m - 1;\n        } else {\n            return m;\n        }\n    }\n    assert l >= 0;\n    return -(l + 1);\n}"
},
{
    "dafny": "method Main() {\n  TestM(0, 0);\n  TestM(-2, 2);\n  TestM(-2, 3);\n  TestM(10, 20);\n  TestP(0, 0);\n  TestP(28, 28);\n  TestP(28, 30);\n  TestP(255, 255); \n  TestP(0, 255);\n  TestQ(-128, -128);\n  TestQ(-128, -127);\n  TestQ(126, 127);\n  TestQ(127, 127);\n  Mul(0, 2);\n  Mul(2, 0);\n  Mul(1, 1);\n  Mul(6, 5);\n  Add(0, 3);\n  Add(3, 0);\n  Add(4, 0);\n  Add(0, 0);\n  Add(19, 14);\n}\nmethod TestM(lo: int, hi: int)\n  requires lo <= hi\n{\n  var s, t := M0(lo, hi);\n  var u, v := M1(lo, hi);\n  print s, \" \", t, \" \", u, \" \", v, \"\\n\";\n}\nmethod TestP(lo: byte, hi: byte)\n  requires lo <= hi\n{\n  var s, t := P(lo, hi);\n  print s, \" \", t, \"\\n\";\n}\nmethod TestQ(lo: i8, hi: i8)\n  requires lo <= hi\n{\n  var s, t := Q(lo, hi);\n  print s, \" \", t, \"\\n\";\n}\nmethod M0(lo: int, hi: int) returns (s: int, t: int)\n  requires lo <= hi\n{\n  s, t := 0, 0;\n  for i := lo to hi {\n    s := s + i;\n  }\n  for i := hi downto lo {\n    t := t + i;\n  }\n}\nmethod M1(lo: int, hi: int) returns (s: int, t: int)\n  requires lo <= hi\n{\n  s, t := 0, 0;\n  for i := lo to *\n    invariant i <= hi\n    decreases hi - i\n  {\n    if i == hi {\n      break;\n    }\n    s := s + i;\n  }\n  if lo < hi {\n    for i := hi downto *\n      invariant lo <= i\n      decreases i - lo\n    {\n      if i == lo - 1 {\n        break;\n      }\n      t := t + i;\n    }\n  }\n}\nnewtype byte = x | 0 <= x < 256\nmethod P(lo: byte, hi: byte) returns (s: int, t: int)\n  requires lo <= hi\n{\n  s, t := 0, 0;\n  for i := lo to hi {\n    s := s + i as int;\n  }\n  for i := hi downto lo {\n    t := t + i as int;\n  }\n}\nnewtype i8 = x | -128 <= x < 128\nmethod Q(lo: i8, hi: i8) returns (s: int, t: int)\n  requires lo <= hi\n{\n  s, t := 0, 0;\n  for i := lo to hi {\n    s := s + i as int;\n  }\n  for i := hi downto lo {\n    t := t + i as int;\n  }\n}\nmethod Mul(a: nat, b: nat) {\n  var c := 0;\n  var aa := a;\n  for _ := 0 to aa {\n    var bb := b;\n    for _ := bb downto 0 {\n      c, bb, aa := c + 1, bb + 3, aa + 2;\n    }\n    aa := aa + 5;\n  }\n  print a, \" * \", b, \" == \", c, \"\\n\";\n}\nmethod Add(a: nat, b: nat) {\n  var s := 0;\n  label Outer0:\n  label Outer1:\n  for _ := 0 to 7 {\n    for i := 0 to *\n      invariant i <= a\n      decreases a - i\n    {\n      if i == a {\n        if i % 2 == 0 {\n          break Outer0;\n        } else {\n          break Outer1;\n        }\n      }\n      if a < i {\n        break; \n      }\n      s := s + 1;\n    }\n    s := 77; \n  }\n  for _ := 2 to 3 {\n    label Inner:\n    for i: int := b downto *\n      invariant 0 <= i\n      decreases i\n    {\n      if i < 0 {\n        break Inner;\n      }\n      s := s + 1;\n    }\n  }\n  print a, \" + \", b, \" == \", s, \"\\n\";\n}"
},
{
    "dafny": "class CircularMemory\n{\n  var cells : array<int>;\n  var read_position : int;\n  var write_position : int;\n  var isFlipped : bool;\n  constructor Init(cap : int)\n  ensures cap >=0\n  ensures Valid()\n  requires cap >0\n  {\n    cells := new int[cap];\n    read_position, write_position := 0, 0;\n    isFlipped := false;\n  }\n  predicate Valid()\n    reads this\n  {\n    0 <= write_position < cells.Length &&\n    0 <= read_position < cells.Length\n  }\n  predicate isEmpty()\n    reads this\n  {\n  write_position == read_position\n  }\n  predicate isFull()\n    reads this\n  {\n  write_position ==read_position-1 \n  }\n method Read() returns (isSuccess : bool, content : int)\n    modifies this\n    requires Valid();\n    ensures  Valid();\n    ensures  isSuccess ==> content == old(cells[read_position]);\n    ensures !isSuccess ==> content==0 && read_position == old(read_position);\n  {\n    if(write_position==read_position){\n       isSuccess := false;\n        content := 0;\n    }\n    else{\n        isSuccess :=true;\n        content := cells[read_position];\n      if(isFlipped)\n        {\n            if(read_position == cells.Length-1){\n                read_position:=0;\n                isFlipped:=false;\n            }\n            else\n             {\n             read_position := read_position+1;\n            }\n        }\n    else\n    {\n      if(read_position <cells.Length-1){\n        read_position := read_position +1;\n      }\n      }\n    }\n  }\n  method Write(input : int) returns (isSuccess : bool)\n    modifies cells, this`write_position, this`isFlipped;\n    requires Valid()\n    ensures  Valid()\n    ensures  isSuccess ==> cells[old(write_position)]==input;\n    ensures !isSuccess ==> write_position == old(write_position)\n  {\n    if(read_position-1 == write_position)\n    {\n        isSuccess := false;\n    } \n    else{\n      if(isFlipped)\n       {\n             if(write_position >= read_position){\n              isSuccess := false;\n           } \n            else\n            {\n              cells[write_position]:= input;\n              write_position:=write_position+1;\n                isSuccess := true;\n            }\n        }\n      else \n        {\n          if(write_position < read_position){\n          isSuccess := false;\n        }else{\n            isSuccess:=true;\n            cells[write_position]:= input;\n          if(write_position==cells.Length-1){\n            write_position:=0;\n            isFlipped:=true;          \n          }\n          else{\n   write_position:=write_position +1;\n          }\n        }\n      }\n    }\n  }\n}"
},
{
    "dafny": "method LinearSearch(A:array<int>, key:int) returns (index:int)\n  ensures 0 <= index ==> index < A.Length && A[index] == key\n  ensures index < 0 ==> key !in A[..]\n{\n  var N := A.Length;\n  var i := 0;\n  while i < N\n    invariant 0 <= i <= N\n    invariant forall k :: 0 <= k < i ==> A[k] != key\n    decreases N - i\n  {\n    if A[i] == key\n    {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}"
},
{
    "dafny": "method Main(){\n  var a := new int[5];\n  a[0], a[1], a[2], a[3], a[4] := 0,2,5,10,20;\n  var value := 20;\n  var length := a.Length;\n  var index := BinarySearch(a, value,0, length);\n  print \"The value \",value, \" was found at index \",index,\"\\n\";\n}\npredicate sorted(a: array<int>)\n   reads a\n{\n   forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\nmethod BinarySearch(a: array<int>, value: int, x: int, y: int) returns (index: int)\n   requires a.Length >= 0 && sorted(a)\n   requires 0 <= x <= y <= a.Length\n   requires forall i :: 0 <= i < a.Length && !(x <= i < y) ==> a[i] != value\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n  var low, high := x, y;\n   while low < high\n      invariant 0 <= low <= high <= a.Length\n      invariant forall i ::\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (high + low) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n    ensures y == abs(x)\n{\n    if x < 0 {\n        y := -x;\n    } else {\n        y := x;\n    }\n}\nfunction abs(x: int): int\n{\n    if x < 0 then -x else x\n}\nmethod Testing()\n{\n    assert abs(3) == 3;\n}"
},
{
    "dafny": "method Main() {\n  TestTraits();\n  TestSiblings();\n  TestException();\n  MoreTests.Test();\n  Conveyance.Test();\n  Regression.Test();\n}\ndatatype Dt<+U> = Dt(u: U)\ntrait Tr {\n  var y: int\n}\nclass Cl extends Tr {\n  constructor () {\n    y := 15;\n  }\n}\nmethod Print(e: Dt<Cl>) {\n  print e.u.y, \"\\n\";\n}\nmethod CreateDtForTrait(e: Dt<Cl>) returns (d: Dt<Tr>)\n  ensures d.u == e.u\n{\n  d := e; \n}\nmethod TestTraits() {\n  var cl := new Cl();\n  var e: Dt<Cl> := Dt(cl);\n  var d: Dt<Tr> := CreateDtForTrait(e);\n  cl.y := cl.y + 1;\n  var f: Dt<Cl> := d; \n  Print(f); \n  Print(e); \n}\ntype Even = x | x % 2 == 0\nmethod TestSiblings() {\n  var a: Dt<int> := Dt(10);\n  var b: Dt<nat> := a;\n  var c: Dt<Even> := a;\n  b := Dt(11);\n  c := Dt(12);\n  a := b;\n  a := c;\n  b := Dt(20);\n  c := b;\n  c := Dt(30);\n  b := c;\n  print a, \" \", b, \" \", c, \"\\n\"; \n}\ndatatype Result<+T, +R> = | Success(value: T) | Failure(error: R)\ntrait Exception {}\nclass MyClassException extends Exception { }\nclass MyClass {\n  const error: Exception\n  constructor () {\n    error := new MyClassException;\n  }\n  function Foo(u: int): Result<int, Exception> {\n    if u < 8 then\n      Success(8)\n    else\n      Failure(error)\n  }\n}\nmethod TestException() {\n  var c := new MyClass();\n  print c.Foo(2), \" \", c.Foo(22), \"\\n\"; \n}\nmodule MoreTests {\n  type Even = x | x % 2 == 0\n  datatype Dt<T> = Make(T)\n  datatype DtCovariant<+T> = MakeCovariant(T)\n  trait Z { }\n  trait X extends Z { }\n  trait Y extends Z { }\n  class C extends X, Y { }\n  method Test() {\n    var c := new C;\n    var s: set<int> := {100};\n    var t: set<nat> := s;\n    var u: set<Even> := s;\n    t := u;\n    u := t;\n    s := u;\n    s := t;\n    print s, \" \", t, \" \", u, \"\\n\"; \n    var S: set<Z> := {c};\n    var T: set<X> := S;\n    var U: set<Y> := S;\n    T := U;\n    U := T;\n    S := U;\n    S := T;\n    print S, \" \", T, \" \", U, \"\\n\"; \n    var k: Dt<int> := Make(100);\n    var m: Dt<nat> := k;\n    var n: Dt<Even> := k;\n    m := n;\n    n := m;\n    k := m;\n    k := n;\n    print k, \" \", m, \" \", n, \"\\n\"; \n    var K: DtCovariant<Z> := MakeCovariant(c);\n    var M: DtCovariant<X> := K;\n    var N: DtCovariant<Y> := K;\n    M := var u: DtCovariant<Z> := N; u; \n    N := var u: DtCovariant<Z> := M; u; \n    print K, \" \", M, \" \", N, \"\\n\"; \n  }\n}\nmodule Conveyance {\n  trait Vehicle {\n  }\n  class Car extends Vehicle {\n    constructor() {}\n  }\n  trait Error {\n  }\n  class FlatTireError extends Error {\n    constructor() {}\n  }\n  datatype NonVariantResult<T, E> = NVSuccess(value: T) | NVFailure(error: E)\n  datatype CovariantResult<+T, +E> = CVSuccess(value: T) | CVFailure(error: E)\n  method Test() {\n    var myCar: Car := new Car();\n    var error: Error := new FlatTireError();\n    var cvSuccess: CovariantResult<Vehicle, Error> := CVSuccess(myCar);\n    var cvFailure: CovariantResult<Vehicle, Error> := CVFailure(error);\n    var nvSuccess: NonVariantResult<Vehicle, Error> := NVSuccess(myCar);\n    var nvFailure: NonVariantResult<Vehicle, Error> := NVFailure(error);\n    var nvCarSuccess: NonVariantResult<Car, Error> := NVSuccess(myCar);\n    var cvCarSuccess: CovariantResult<Car, Error> := CVSuccess(myCar);\n    var cvVehicleSuccess: CovariantResult<Vehicle, Error> := cvCarSuccess;\n    print nvCarSuccess, \" \", cvCarSuccess, \"\\n\"; \n  }\n}\nmodule Regression {\n  module M {\n    codatatype Stream<T> = Next(shead: T, stail: Stream)\n  }\n  function CoUp(n: int, b: bool): M.Stream<int>\n  {\n    if b then\n      CoUp(n, false)  \n    else\n      M.Next(n, CoUp(n+1, true))  \n  }\n  method Test(){\n    print CoUp(0, false), \"\\n\";\n  }\n}"
},
{
    "dafny": "method FP() returns (r: FStatus)\n{\n  {\n    var r: int;  \n    :- FTry();  \n  }\n}\nmethod MP() returns (r: MStatus)\n{\n  {\n    var r: int;  \n    :- MTry();  \n  }\n}\nmethod FQ() returns (r: FResult<int>)\n  ensures r == FResult.Failure(5)\n{\n  {\n    var r: int;  \n    var x :- FCompute();  \n  }\n}\nmethod MQ() returns (r: MResult<int>)\n  ensures r == MResult.Failure(5)\n{\n  {\n    var r: int;  \n    var x :- MCompute();  \n  }\n}\nmethod FS() returns (r: FStatus)\n  ensures r == FStatus.Error(5)\n{\n  {\n    var r: FStatus;  \n    :- FTry();  \n  }\n}\nmethod MS() returns (r: MStatus)\n  ensures r == MStatus.Error(5)\n{\n  {\n    var r: MStatus;  \n    :- MTry();  \n  }\n}\nmethod FR() returns (r: FResult<int>)\n  ensures r == FResult.Failure(5)\n{\n  {\n    var r: FResult<int>;  \n    var x :- FCompute();  \n  }\n}\nmethod MR() returns (r: MResult<int>)\n  ensures r == MResult.Failure(5)\n{\n  {\n    var r: MResult<int>;  \n    var x :- MCompute();  \n  }\n}\nmethod FTry() returns (status: FStatus)\n  ensures status == FStatus.Error(5)\nmethod MTry() returns (status: MStatus)\n  ensures status == MStatus.Error(5)\ndatatype FStatus = Okay | Error(code: int) {\n  predicate IsFailure() {\n    Error?\n  }\n  function PropagateFailure(): FStatus\n    requires Error?\n  {\n    this\n  }\n}\ndatatype MStatus = Okay | Error(code: int) {\n  predicate IsFailure() {\n    Error?\n  }\n  function PropagateFailure(): MStatus\n    requires Error?\n  {\n    this\n  }\n}\nmethod FCompute() returns (result: FResult<int>)\n  ensures result == FResult.Failure(5)\nmethod MCompute() returns (result: MResult<int>)\n  ensures result == MResult.Failure(5)\ndatatype FResult<X> = Success(x: X) | Failure(code: int) {\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): FResult<U>\n    requires Failure?\n  {\n    FResult.Failure(code)\n  }\n  function Extract(): X\n    requires Success?\n  {\n    x\n  }\n}\ndatatype MResult<X> = Success(x: X) | Failure(code: int) {\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): MResult<U>\n    requires Failure?\n  {\n    MResult.Failure(code)\n  }\n  function Extract(): X\n    requires Success?\n  {\n    x\n  }\n}"
},
{
    "dafny": "method Max(a: int, b: int) returns (c: int)\n  ensures a >= b ==> c == a\n  ensures b >= a ==> c == b\n{\n if a > b {\n   return a;\n } else {\n   return b;\n }\n}\nmethod MaxTest() {\n var low := 1;\n var high := 10;\n var v := Max(low, high);\n assert v == high;  \n}\nfunction max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod maxTest() {\n  assert max(1, 10) == 10;\n}"
},
{
    "dafny": "function power(x: real, n: nat) : real\n  decreases n\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\nmethod powerIter(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n)\n{\n    p := 1.0;\n    var i := 0;\n    while i < n\n      decreases n - i\n      invariant 0 <= i <= n && p == power(x, i)\n    {\n        p := p * x;\n        i := i + 1;\n    }\n}\nmethod powerOpt(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n);\n  decreases n;\n{\n    if n == 0 {\n        return 1.0;\n    }\n    else if n == 1 {\n        return x;\n    }\n    else if n % 2 == 0 {\n        distributiveProperty(x,  n/2, n/2); \n        var temp := powerOpt(x, n/2);\n        return temp * temp;\n    }\n    else {\n        distributiveProperty(x, (n-1)/2, (n-1)/2); \n        var temp := powerOpt(x, (n-1)/2);\n        return temp * temp * x;\n    } \n}\nlemma {:induction false} distributiveProperty(x: real, a: nat, b: nat) \n  ensures power(x, a) * power(x, b)  == power(x, a + b) \n{\n    if a == 0 {\n        calc == {\n            power(x, a) * power(x, b);\n            power(x, 0) * power(x, b); \n            1.0 * power(x, b); \n            power(x, b); \n            power(x, a + b); \n        }\n    }\n    else {\n        distributiveProperty(x, a-1, b); \n        calc == {\n            power(x, a) * power(x, b);\n            (x * power(x, a-1)) * power(x, b); \n            x * (power(x, a-1) * power(x, b)); \n            x * power(x, a + b - 1); \n            power(x, 1 + (a - 1 + b));\n            power(x, a + b); \n        }\n    }\n}\nmethod testPower() {\n    var p1 := powerIter(2.0, 5);\n    var p2 := powerOpt(2.0, 5);\n    assert p1 == 32.0;\n    assert p2 == 32.0;\n}"
},
{
    "dafny": "method find (a : array <int>, key : int) returns ( index : int )\n    ensures 0 <= index <= a.Length;\n    ensures index < a.Length ==> a[index] == key;\n{\n    index := 0;\n    assert 0 <= index <= a.Length; \n    while index < a.Length && a[index] != key \n        invariant 0 <= index <= a.Length;\n        invariant forall i:: 0 <= i < index ==> a[i] != key;\n        decreases a.Length - index;\n    {\n        ghost var Vzero := a.Length - index;\n        assert index < a.Length && 0 <= index <= a.Length && a.Length - index == Vzero; \n        index := index + 1;\n        assert 0 <= index <= a.Length && 0 <= a.Length - index < Vzero; \n    }\n    assert index < a.Length ==> a[index] == key; \n}"
},
{
    "dafny": "predicate sorted(a:array<int>, min:int, max:int)\n requires 0<= min <= max <= a.Length\n reads a\n {\n      forall j, k :: min <= j < k < max ==> a[j] <= a[k]\n}\nmethod FindMin(a: array<int>, from: int) returns (min: int)\nrequires a.Length >= 1\nrequires  0 <= from < a.Length\nensures  from <= min < a.Length\nensures forall k :: from <= k < a.Length ==> a[k] >= a[min]\n{\n    var i := from;\n    min := from;\n    while i < a.Length\n\t   decreases a.Length - i;\n       invariant from <= i <= a.Length\n       invariant from <= min < a.Length\n       invariant forall k :: from <= k < i ==> a[k] >= a[min]\n    {\n        if a[i] <= a[min] {min := i;}      \n        i := i+1;\n     }\n   return min;\n}\nmethod SelectionSort ( a: array<int> ) \nrequires  a.Length >=1\nmodifies a\nensures sorted(a, 0, a.Length)\n{ \n\t   var min, current :=  0, 0;\n\t   while (current < a.Length) \n\t   invariant 0 <= current <= a.Length\n\t   invariant sorted(a, 0, current)\n\t   invariant forall k, l :: 0 <= k < current <= l < a.Length ==> a[k] <= a[l];\n\t   {\n\t     min := FindMin (a, current);\n\t     a[min], a[current] := a[current], a[min];\n\t     current := current +1;\n\t   }\n}"
},
{
    "dafny": "method isPalindrome(s: array<char>) returns (result: bool)\n    requires 1<= s.Length <= 200000\n    ensures result <==> (forall i:: 0 <= i < s.Length / 2 ==> s[i] == s[s.Length - 1 - i])\n{\n    var length := s.Length;\n    var i := 0;\n    while i < length / 2 \n        invariant 0 <= i <= length\n        invariant forall j:: 0 <= j < i ==> s[j] == s[length - 1 - j]\n    {\n        if s[i] != s[length - 1 - i]\n        {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}"
},
{
    "dafny": "method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n{\n  xs := [];\n  var left: set<T> := s;\n  while left != {}\n    invariant multiset(left) + multiset(xs) == multiset(s)\n  {\n    var x :| x in left;\n    left := left - {x};\n    xs := xs + [x];\n  }\n}"
},
{
    "dafny": "class SavingsAccount {\n  var checking:int\n  var savings:int\n  constructor() {\n    checking := 0;\n    savings := 0;\n  }\n  method deposit(amount:int)\n    requires amount > 0\n    ensures checking == old(checking) + amount\n    modifies this`checking\n  {\n    checking := checking + amount;\n  }\n  method withdraw(amount:int)\n    requires amount > 0 \n    requires hasBalance(amount)\n    ensures checking == old(checking) - amount\n    modifies this`checking\n  {\n    checking := checking - amount;\n  }\n   method save(amount:int) \n    requires amount > 0\n    requires hasDebt()\n    modifies this`savings\n  {\n    savings := savings + amount;\n  }\n  method rescue(amount:int) \n    requires amount > 0\n    ensures savings == old(savings) - amount\n    modifies this`savings\n  {\n    savings := savings - amount;\n  }\n  function hasBalance(amount:int) : bool\n    reads this\n  {\n    savings / 2 >= checking + amount\n  }\n  function hasDebt(): bool\n    reads this\n  {\n    checking >= 0\n  }\n  method Main() {\n  }\n}"
},
{
    "dafny": "function Fib(n: nat): nat\n{\n    if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\nmethod ComputeFib(n: nat) returns (x: nat)\n    ensures x == Fib(n)\n{\n    var i:= 0;\n    x := 0;\n    var y := 1;\n    while i < n \n    invariant 0 <= i <= n\n    invariant x == Fib(i) && y == Fib(i+1)\n    {\n        x, y := y, x+y;\n        i := i + 1;\n    }\n}\nfunction Sum(n:nat): nat\n{\n    if n == 0 then 0 else n + Sum(n-1)\n}"
},
{
    "dafny": "function partialSum( a:seq<array<int>>, n:int ) : int\n  requires 0 <= n <= |a|;\n  requires forall k :: 0 <= k < |a| ==> a[k] != null && a[k].Length == 5;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else partialSum(a, n-1) + a[n-1][4]\n}\nmethod sum_volume( a:seq<array<int>> ) returns (sum: int)\n  requires forall k :: 0 <= k < |a| ==> a[k] != null && a[k].Length == 5;\n  ensures sum == partialSum(a, |a|);\n{\n  var i := 0;\n  sum := 0;\n  while (i < |a|)\n    invariant 0 <= i <= |a|;\n    invariant sum == partialSum(a, i);\n    decreases |a| - i;\n  {\n    sum := sum + a[i][4];\n    i := i + 1;\n  }\n}\nmethod filter(a:seq<array<int>>, attribute: int, value: int) returns (filtered: seq<array<int>>)\n  requires a != [] && |a| > 0;\n  requires forall k :: 0 <= k < |a| ==> a[k] != null && a[k].Length == 5;\n  requires 0 <= attribute < 5;\n  ensures forall k: int :: (0 <= k < |a| ==> ((a[k][attribute] == value) ==> a[k] in filtered));\n  ensures forall k: int :: (0 <= k < |filtered| ==> (filtered[k] != null && filtered[k].Length == 5));\n  ensures forall k: int :: (0 <= k < |filtered| ==> filtered[k] in multiset(a[..]));\n{\n  var i : int := 0;\n  filtered := [];\n  while (i < |a|)\n    invariant 0 <= i <= |a|;\n    invariant forall k: int :: (0 <= k < i ==> ((a[k][attribute] == value) ==> a[k] in filtered));\n    invariant forall k: int :: (0 <= k < |filtered| ==> (filtered[k] != null && filtered[k].Length == 5));\n    invariant forall k: int :: (0 <= k < |filtered| ==> filtered[k] in multiset(a[..]));\n  {\n    if (a[i][attribute] == value) \n    { \n      filtered := filtered + [a[i]];\n    }\n    i := i + 1;\n  }\n}\nmethod count_volume(deposits: seq<array<int>>, value: int) returns (volume: int)\n  requires deposits != [] && |deposits| > 0;\n  requires forall k :: 0 <= k < |deposits| ==> deposits[k] != null && deposits[k].Length == 5;\n{\n  var filtered: seq<array<int>> := filter(deposits,1,value);\n  volume := sum_volume(filtered);\n  return volume;\n}\nmethod Main() {\n  var a1: array<int> := new int[5];\n  a1[0], a1[1], a1[2], a1[3], a1[4] := 0, 0, 20, 30, 540;\n  var a2: array<int> := new int[5];\n  a2[0], a2[1], a2[2], a2[3], a2[4] := 1, 1, 23, 31, 241;\n  var a3: array<int> := new int[5];\n  a3[0], a3[1], a3[2], a3[3], a3[4] := 2, 2, 22, 32, 542;\n  var a4: array<int> := new int[5];\n  a4[0], a4[1], a4[2], a4[3], a4[4] := 3, 3, 23, 33, 343;\n  var a5: array<int> := new int[5];\n  a5[0], a5[1], a5[2], a5[3], a5[4] := 4, 0, 20, 30, 401;\n  var a6: array<int> := new int[5];\n  a6[0], a6[1], a6[2], a6[3], a6[4] := 5, 1, 23, 31, 512;\n  var a7: array<int> := new int[5];\n  a7[0], a7[1], a7[2], a7[3], a7[4] := 6, 2, 22, 32, 452;\n  var a8: array<int> := new int[5];\n  a8[0], a8[1], a8[2], a8[3], a8[4] := 7, 3, 23, 33, 423;\n  var deposits: seq<array<int>> := [];\n  deposits := deposits + [a1] + [a2] + [a3] + [a4];\n  deposits := deposits + [a5] + [a6] + [a7] + [a8];\n  var filtered: seq<array<int>> := filter(deposits,1,2);\n  var j : int := 0;\n  while (j < |filtered|) {\n    var k : int := 0;\n    while (k < filtered[j].Length) {\n      print filtered[j][k];\n      print ' ';\n      k := k + 1;\n    }\n    print '\\n';\n    j := j + 1;\n  }\n  var volume := sum_volume(filtered);\n  print \"\\nVolume: \",volume,'\\n';\n}"
},
{
    "dafny": "function Transform(x:int) : int\nlemma TransformProperties()\n    ensures forall x1, x2 {:trigger Transform(x1), Transform(x2)} :: Transform(x1) == Transform(x2) ==> x1 == x2;\nfunction {:opaque} Looper(input:seq<int>) : seq<int>\n    ensures |Looper(input)| == |input|;\n    ensures forall i :: 0 <= i < |input| ==> Looper(input)[i] == Transform(input[i])\n{\n    if |input| == 0 then []\n    else [Transform(input[0])] + Looper(input[1..])\n}\nlemma proof(s1:seq<int>, s2:seq<int>)\n    requires Looper(s1) == Looper(s2);\n    ensures forall i :: i in s1 <==> i in s2;\n{\n    reveal_Looper();\n    TransformProperties();\n}"
},
{
    "dafny": "method qXwZ(aBcD: seq<real>, eFgH: real) returns (iJkL: bool)\n{\n  iJkL := false;\n  var uVwX: int := 0;\n  while uVwX < |aBcD| && !iJkL\n    invariant 0 <= uVwX <= |aBcD|\n    invariant !iJkL\n    invariant forall mNpO: int, qRsT: int :: 0 <= mNpO < uVwX && 0 <= qRsT < mNpO ==> (if aBcD[mNpO] - aBcD[qRsT] < 0.0 then aBcD[qRsT] - aBcD[mNpO] else aBcD[mNpO] - aBcD[qRsT]) >= eFgH\n  {\n    var yZaB: int := 0;\n    while yZaB < uVwX && !iJkL\n      invariant 0 <= uVwX <= |aBcD|\n      invariant 0 <= yZaB <= uVwX\n      invariant !iJkL\n      invariant forall qRsT: int :: 0 <= qRsT < yZaB ==> (if aBcD[uVwX] - aBcD[qRsT] < 0.0 then aBcD[qRsT] - aBcD[uVwX] else aBcD[uVwX] - aBcD[qRsT]) >= eFgH\n    {\n      var cDeF := (if aBcD[yZaB] - aBcD[uVwX] < 0.0 then aBcD[uVwX] - aBcD[yZaB] else aBcD[yZaB] - aBcD[uVwX]);\n      if cDeF < eFgH  {\n        iJkL := true;\n        return;\n      }\n      yZaB := yZaB + 1;\n    }\n    uVwX := uVwX + 1;\n  }\n}"
},
{
    "dafny": "predicate sortedbad(s: string)\n{\n  forall i, j :: 0 <= i <= j < |s| && s[i] == 'b' && s[j] != 'b' ==> i < j &&\n  forall i, j :: 0 <= i <= j < |s| && s[i] != 'd' && s[j] == 'd' ==> i < j\n}\nmethod BadSort(a: string) returns (b: string)\nrequires forall i :: 0<=i<|a| ==> a[i] in {'b', 'a', 'd'}\nensures sortedbad(b)\nensures multiset(b[..]) == multiset(a[..])\n{\n  b := a;\n  var next:int := 0;\n  var aPointer:int := 0;\n  var dPointer:int := |b|;\n  while (next != dPointer)\n  decreases if next <= dPointer then dPointer - next else next - dPointer\n  invariant 0 <= aPointer <= next <= dPointer <= |b|\n  invariant forall i :: 0 <= i < aPointer ==> b[i] == 'b'\n  invariant forall i :: aPointer <= i < next ==> b[i] == 'a'\n  invariant forall i :: dPointer <= i < |b| ==> b[i] == 'd'\n  invariant forall i :: 0<=i<|b| ==> b[i] in {'b', 'a', 'd'}\n  invariant sortedbad(b)\n  invariant multiset(b[..]) == multiset(a[..])\n  {\n    if(b[next] == 'a'){\n      next := next + 1;\n    } \n    else if(b[next] == 'b'){\n      b := b[next := b[aPointer]][aPointer := b[next]];\n      next := next + 1;\n      aPointer := aPointer + 1;\n    }\n    else{\n      dPointer := dPointer - 1;\n      b := b[next := b[dPointer]][dPointer := b[next]];\n    } \n  } \n}"
},
{
    "dafny": "method GCD(x: int, y: int) returns (r: int)\n  requires 0 < x && 0 < y;\n  ensures (r>0) && (r<= x) && (r <= y);\n  {\n    var a: int := x;\n    var b: int := y;\n    while((a>0) && (b>0))\n    decreases a + b;\n    invariant x >= a >= 0 && y >= b >= 0;\n    invariant a == 0 ==> ( y >= b > 0 && x >= b);\n    invariant b == 0 ==> ( x >= a > 0 && y >= a);\n    {\n      if( a > b)\n      {\n        a := a - b;\n      }\n      else\n      {\n        b := b - a;\n      }\n    }\n    if (a > 0)\n    {\n      r := a;\n    }\n    else\n    {\n      r := b;\n    }\n  }"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} DivInternalsNonlinear {\n  lemma LemmaDivOf0(d:int)\n    requires d != 0\n    ensures 0 / d == 0\n  {\n  }\n  lemma LemmaDivBySelf(d:int)\n    requires d != 0\n    ensures d / d == 1\n  {\n  }\n  lemma LemmaSmallDiv()\n    ensures forall x, d {:trigger x / d} :: 0 <= x < d && d > 0 ==> x / d == 0\n  {\n  }\n  lemma LemmaRealDivGt(x:real, y:real)\n    requires x > y\n    requires x >= 0.0\n    requires y > 0.0\n    ensures  x / y > 1 as real\n  {\n  }\n}"
},
{
    "dafny": "module LogRep{\n  predicate sorted(Log: seq<int>)\n  {\n    forall i,j :: 0 <= i < j < |Log| ==> Log[i] <= Log[j]\n  }\n  method initLog() returns( list: seq<int>)\n  {\n    list := [];\n  }\n  method addLog(list: seq<int>, log: int) returns(newLog: seq<int>)\n    ensures newLog == list + [log]\n    ensures |newLog| == |list| + 1\n    ensures log in newLog\n  {\n    newLog := list + [log];\n  }\n  method Test()\n  {\n    var Log := initLog();\n    var entry1 := 0107;\n    var entry2 := 0108;\n    var entry3 := 0308;\n    Log := addLog(Log, entry1);\n    assert Log[|Log| - 1 ] == 0107;\n    Log := addLog(Log, entry2);\n    assert Log[|Log| - 1 ] == 0108;\n    assert Log[|Log| - 2 ] == 0107;\n    Log := addLog(Log, entry3);\n    assert Log[|Log| - 1 ] == 0308;\n    assert Log[|Log| - 2 ] == 0108;\n    assert Log[|Log| - 3 ] == 0107;\n  }\n}"
},
{
    "dafny": "module gcd{ \nfunction gcd(m: nat, n: nat) : nat\n  requires m >= 1;\n  requires n >= 1;\n{\n  if (m == n) then m\n  else if (m < n) then gcd(m, n-m)\n  else gcd(m-n, n)\n}\nlemma gcd_lemma(m: nat, n: nat)\n  requires m >= 1 && n >= 1;\n  ensures gcd(m,n) == gcd(n,m);\n{\n}\nmethod GcdCal(m: int, n: int)returns (res:int)\n\trequires m >= 1 && n >= 1;\n\t  ensures res == gcd(m, n);{\n\tvar m1, n1 := m, n;\n\tgcd_lemma(m, n);\n\twhile m1 != n1 \n\t\tinvariant m1 >= 1;\n\t\t  invariant n1 >= 1;\n\t\t  decreases m1+n1;\n\t\t  invariant gcd(m1, n1) == gcd(n, m){\n\t\tif m1 > n1 {\n\t\t\tm1 := m1 - n1;\n\t\t} else {\n\t\t\tn1 := n1 - m1;\n\t\t}\n\t}\n\treturn m1;\n}\n}"
},
{
    "dafny": "datatype List<T> = Nil | Cons(T, List)\nghost function length(list: List): nat  \n{\n  match list\n  case Nil => 0\n  case Cons(_, tl) => 1 + length(tl)\n}\nghost function In(x: int, list: List<int>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(y, tl) => (if x == y then 1 else 0) + In(x, tl)\n}\nghost predicate SortedRange(m: int, n: int, list: List<int>)\n  decreases list  \n{\n  match list\n  case Nil => m <= n\n  case Cons(hd, tl) => m <= hd <= n && SortedRange(hd, n, tl)\n}\nghost function append(n0: int, n1: int, n2: int, n3: int, i: List<int>, j: List<int>): List<int>\n  requires n0 <= n1 <= n2 <= n3\n  requires SortedRange(n0, n1, i) && SortedRange(n2, n3, j)\n  ensures SortedRange(n0, n3, append(n0, n1, n2, n3, i, j))\n  ensures forall x :: In(x, append(n0, n1, n2, n3, i, j)) == In(x, i) + In(x, j)\n  decreases i  \n{\n  match i\n  case Nil => j\n  case Cons(hd, tl) => Cons(hd, append(hd, n1, n2, n3, tl, j))\n}\nghost function partition(x: int, l: List<int>): (List<int>, List<int>)\n  ensures var (lo, hi) := partition(x, l);\n    (forall y :: In(y, lo) == if y <= x then In(y, l) else 0) &&\n    (forall y :: In(y, hi) == if x < y then In(y, l) else 0) &&\n    length(l) == length(lo) + length(hi)  \n{\n  match l\n  case Nil => (Nil, Nil)\n  case Cons(hd, tl) =>\n    var (lo, hi) := partition(x, tl);\n    if hd <= x then\n      (Cons(hd, lo), hi)\n    else\n      (lo, Cons(hd, hi))\n}\nghost function sort(min: int, max: int, i: List<int>): List<int>\n  requires min <= max\n  requires forall x :: In(x, i) != 0 ==> min <= x <= max\n  ensures SortedRange(min, max, sort(min, max, i))\n  ensures forall x :: In(x, i) == In(x, sort(min, max, i))\n  decreases length(i)  \n{\n  match i\n  case Nil => Nil\n  case Cons(hd, tl) =>\n    assert In(hd, i) != 0;  \n    var (lo, hi) := partition(hd, tl);\n    assert forall y :: In(y, lo) <= In(y, i);  \n    var i' := sort(min, hd, lo);\n    var j' := sort(hd, max, hi);\n    append(min, hd, hd, max, i', Cons(hd, j'))\n}"
},
{
    "dafny": "datatype Result<T> =\n  | Success(value: T)\n  | Failure(error: string)\ndatatype C = C1 | C2(x: int)\ntrait Foo\n{\n  method FooMethod1(r: Result<()>)\n    ensures\n      match r {\n        case Success(()) => true \n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(()) => x := 1;\n      case Failure(e) => x := 2;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n  method FooMethod2(r: Result<C>)\n    ensures\n      match r {\n        case Success(C1()) => true \n        case Success(C2(x)) => true \n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C1()) => x := 1;\n      case Success(C2(_)) => x := 2;\n      case Failure(e) => x := 3;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n  method FooMethod2q(r: Result<C>)\n    ensures\n      match r {\n        case Success(C1()) => true \n        case Success(C2(x)) => true \n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C1()) => x := 1;\n      case Success(C2(x)) => x := 2;  \n      case Failure(e) => x := 3;\n    }\n    assert x == 0 || x == 1 || x == 3;\n    expect x == 0 || x == 1 || x == 3;\n  }\n  method FooMethod2r(r: Result<C>)\n    ensures\n      match r {\n        case Success(C1()) => true \n        case Success(C2(x)) => true \n        case Failure(e) => true\n      }\n  {\n    var x: real := 0.0;\n    match r {\n      case Success(C1()) => x := 1.0;\n      case Success(C2(x)) => x := 2;  \n      case Failure(e) => x := 3.0;\n    }\n    assert x == 0.0 || x == 1.0 || x == 3.0;\n    expect x == 0.0 || x == 1.0 || x == 3.0;\n  }\n  method FooMethod3(r: Result<C>)\n    ensures\n      match r {\n        case Success(C1) => true \n        case Success(C2(x)) => true \n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C1) => x := 1;\n      case Success(C2(_)) => x := 2;  \n      case Failure(e) => x := 3;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n  method FooMethod4(r: Result<C>)\n    ensures\n      match r {\n        case Success(C2) => true \n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C2) => x := 1;\n      case Failure(e) => x := 2;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n  method FooMethod5(r: Result<string>)\n    ensures\n      match r {\n        case Success(C1) => true \n        case Failure(e) => true\n      }\n  {\n    var x: int := 0;\n    match r {\n      case Success(C1) => x := 1;\n      case Failure(e) => x := 2;\n    }\n    assert x > 0;\n    expect x == 1;\n  }\n}\nclass CL extends Foo {}\nmethod Main() {\n  var t := new CL;\n  m(t);\n}\nmethod m(t: Foo) {\n  t.FooMethod1(Result.Success(()));\n  t.FooMethod2(Result<C>.Success(C1));\n  t.FooMethod2q(Result<C>.Success(C1));\n  t.FooMethod2r(Result<C>.Success(C1));\n  t.FooMethod3(Result<C>.Success(C1));\n  t.FooMethod4(Result<C>.Success(C1));\n  t.FooMethod5(Result<string>.Success(\"\"));\n  print \"Done\\n\";\n}"
},
{
    "dafny": "module A {\n  ghost predicate F(x: int) { true }\n}\nmodule B {\n  lemma Test(x: int)\n    ensures I.F(x)\n  {\n  }\n  lemma TestWrapper()\n  {\n    forall x {\n      Test(x);\n    }\n  }\n}"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} Dafny.MulInternalsNonlinear\n{\n  lemma LemmaMulStrictlyPositive(x: int, y: int)\n    ensures (0 < x && 0 < y) ==> (0 < x * y)\n  {}\n  lemma LemmaMulNonzero(x: int, y: int)\n    ensures x * y != 0 <==> x != 0 && y != 0\n  {}\n  lemma LemmaMulIsAssociative(x: int, y: int, z: int)\n    ensures x * (y * z) == (x * y) * z\n  {}\n  lemma LemmaMulIsDistributiveAdd(x: int, y: int, z: int)\n    ensures x * (y + z) == x * y + x * z\n  {}\n  lemma LemmaMulOrdering(x: int, y: int)\n    requires x != 0\n    requires y != 0\n    requires 0 <= x * y\n    ensures x * y >= x && x * y >= y\n  {}\n  lemma LemmaMulStrictInequality(x: int, y: int, z: int)\n    requires x < y\n    requires z > 0\n    ensures  x * z < y * z\n  {}\n}"
},
{
    "dafny": "ghost function f(n: int): int {\n  if n < 0 then 0 else 3*f(n-5) + n\n}\nmethod problem5(n:nat) returns (x: int)\nensures x == f(n)\n{\n    var a := 1;\n    var b := 0;\n    var k := n;\n    while k >= 0\n    invariant f(n) == a*f(k) + b\n    invariant -5 <= k <= n\n    decreases k\n    {\n        assert f(n) == a*f(k) + b;\n        assert f(n) == a*(3*f(k-5)+k) + b;\n        assert f(n) == 3*a*f(k-5) + a*k + b;\n        b := a*k + b;\n        assert f(n) == 3*a*f(k-5) + b;\n        a := 3*a;\n        assert f(n) == a*f(k-5) + b;\n        k := k - 5;\n        assert f(n) == a*f(k) + b;\n    }\n    assert k < 0;\n    assert f(n) == a*f(k) + b;\n    assert f(n) == a*0 + b;\n    x := b;\n    assert x== f(n);\n}"
},
{
    "dafny": "function Fibonacci(n: nat): nat {\n  match n {\n    case 0 => 0\n    case 1 => 1\n    case _ => Fibonacci(n - 1) + Fibonacci(n - 2)\n  }\n}\nmethod FibonacciIterative(n: nat) returns (f: nat)\n  ensures f == Fibonacci(n)\n{\n  if n < 2 {\n    return n;\n  }\n  var prev := 1;\n  f := 1;\n  var i := 2;\n  while i < n\n    invariant i <= n\n    invariant prev == Fibonacci(i - 1)\n    invariant f == Fibonacci(i)\n  {\n    prev, f := f, f + prev;\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method g30(m: nat, n: nat) returns (PROD: nat)\n  ensures PROD == m * n\n{\n  var M: nat;\n  M := m;\n  PROD := 0;\n  while M > 0 \n    decreases M\n    invariant PROD == n * (m - M)\n  {\n    PROD := PROD + n;\n    M := M - 1;\n  }\n}"
},
{
    "dafny": "function fib(n : nat ) : nat\n  decreases n\n{\n    if n < 2 then n else fib(n - 2) + fib(n - 1)\n}\nmethod computeFib (n : nat) returns (x : nat)\nrequires n >= 0\nensures x == fib(n)\n{\n    var i := 0;\n    x := 0;\n    var y := 1;\n    while  i < n \n\tdecreases n-i\n\tinvariant 0 <= i <= n && x == fib(i) && y == fib(i+1)\n    {\n        x, y := y, x + y; \n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures forall i::0<=i < n ==> e!=a[i]\n{\n  n :=0;\n  while n!=a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i<n ==> e!=a[i]\n  {\n    if e==a[n]{\n      return;\n    }\n    n:=n+1;\n  }\n}"
},
{
    "dafny": "method Two(x: int) returns (y: int)\nensures y == x + 1\n{\n    assert true;\n    var a:= x+1;\n    assert (a - 1 == 0 ==> x == 0) && (x - 1!= 0 ==> a == x +1);\n    if(a - 1 == 0){\n        y:= 1;\n    } else {\n        y:= a;\n    }\n}"
},
{
    "dafny": "module M {\n  least predicate P(x: int)\n  {\n    x < 100\n  }\n  greatest predicate Q(x: int)\n  {\n    x < 100\n  }\n  lemma K(x: int)\n    requires P(x)\n  {\n  }\n  lemma K'(x: int)\n    requires P#[3](x)\n  {\n  }\n  lemma CoK(x: int)\n    requires x < 100\n    ensures Q(x)\n  {\n  }\n  lemma CoK'(x: int)\n    requires x < 100\n    ensures Q#[3](x)\n  {\n  }\n}\nmodule M' {\n  lemma H(x: int)\n    requires M.P(x)\n  {\n  }\n  lemma H'(x: int)\n     requires M.P#[3](x)\n  {\n  }\n  lemma CoH(x: int)\n    requires x < 100\n    ensures M.Q(x)\n  {\n  }\n  lemma CoH'(x: int)\n    requires x < 100\n    ensures M.Q#[3](x)\n  {\n  }\n  lemma L(x: int)\n    requires P(x)\n  {\n  }\n  lemma L'(x: int)\n    requires P#[3](x)\n  {\n  }\n  lemma CoL(x: int)\n    requires x < 100\n    ensures Q(x)\n  {\n  }\n  lemma CoL'(x: int)\n    requires x < 100\n    ensures Q#[3](x)\n  {\n  }\n  least lemma V(x: int)\n    requires P(x)\n  {\n  }\n  least lemma W(x: int)\n    requires M.P(x)\n  {\n  }\n  greatest lemma CoV(x: int)\n    requires x < 100\n    ensures Q(x)\n  {\n  }\n  greatest lemma CoW(x: int)\n    requires x < 100\n    ensures M.Q(x)\n  {\n  }\n}"
},
{
    "dafny": "class VampireSystem{\n    var blood:array<string>\n    predicate Valid()\n    reads this;\n    { blood != null}\n    constructor (i:array<string>)\n    requires i != null;\n    ensures Valid();\n    ensures blood == i;\n    ensures blood != null\n    modifies this;\n    { blood:= i; } \n    predicate DeliveredBlood(a: seq<string>)\n    {\n    forall k ::0 <= k < |a| ==> a[k] == \"-\"\n    }\n    method getDeliveredBlood() returns (result: seq<string>) \n    requires Valid(); ensures Valid();\n    ensures DeliveredBlood(result[..]);\n    ensures |result| == multiset(blood[..])[\"-\"];\n    { \n    var temp := new string[blood.Length];\n    var i := 0;\n    var j := 0;\n    while (i < blood.Length && j < temp.Length) \n    invariant 0 <= i <= blood.Length\n    invariant 0 <= j <= blood.Length\n    invariant DeliveredBlood(temp[..j])\n    invariant j == multiset(blood[..i])[\"-\"]\n    {\n      if (blood[i] == \"-\") {\n        temp[j] := blood[i];\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    assert blood[..] == blood[..blood.Length];\n    assert j == multiset(blood[..])[\"-\"];\n    result := temp[..j];\n    }\n    method updateBloodStatus(newdata:string, id:int)\n    requires blood != null\n    requires Valid()\n    requires 0 <= id < blood.Length\n    ensures Valid()\n    modifies this.blood;\n    ensures (forall i: int :: ( i == id && 0 <= i < blood.Length) ==> blood[i] == newdata);\n    ensures (forall i: int :: (i != id && 0 <= i < blood.Length) ==> blood[i] == old(blood[i]));\n    {\n    var k: int := 0;\n    while (k < blood.Length)\n    decreases blood.Length - k\n    invariant Valid()\n    invariant 0 <= k < blood.Length\n    invariant id >= k;\n    invariant (forall i: int :: ( i == id && 0 <= i < k) ==> blood[i] == newdata);\n\t  invariant (forall i: int :: (i != id && 0 <= i < k) ==> blood[i] == old(blood[i]));\n    {\n    \tif (k == id)\n    \t{\n    \t\tblood[k] := newdata;\n    \t\treturn;\n    \t}\n    \tk := k + 1;\n    }\n    }\n    method updateInputDate(newdate:string, id:int)\n    requires blood != null\n    requires Valid()\n    requires 0 <= id < blood.Length\n    ensures Valid()\n    modifies this.blood;\n    ensures (forall i: int :: ( i == id && 0 <= i < blood.Length) ==> blood[i] == newdate);\n    ensures (forall i: int :: (i != id && 0 <= i < blood.Length) ==> blood[i] == old(blood[i]));\n    {\n    var k: int := 0;\n    while (k < blood.Length)\n    decreases blood.Length - k\n    invariant Valid()\n    invariant 0 <= k < blood.Length\n    invariant id >= k;\n    invariant (forall i: int :: ( i == id && 0 <= i < k) ==> blood[i] == newdate);\n\t  invariant (forall i: int :: (i != id && 0 <= i < k) ==> blood[i] == old(blood[i]));\n    {\n    \tif (k == id)\n    \t{\n    \t\tblood[k] := newdate;\n    \t\treturn;\n    \t}\n    \tk := k + 1;\n    }\n    }\n    method updateDeliveredStatus(id :int,newdata:string)\n    requires blood != null\n    requires Valid()\n    requires 0 <= id < blood.Length\n    ensures Valid()\n    modifies this.blood;\n    ensures (forall i: int :: ( i == id && 0 <= i < blood.Length) ==> blood[i] == newdata);\n    ensures (forall i: int :: (i != id && 0 <= i < blood.Length) ==> blood[i] == old(blood[i]));\n    {\n    var k: int := 0;\n    while (k < blood.Length)\n    decreases blood.Length - k\n    invariant Valid()\n    invariant 0 <= k < blood.Length\n    invariant id >= k;\n    invariant (forall i: int :: ( i == id && 0 <= i < k) ==> blood[i] == newdata);\n\t  invariant (forall i: int :: (i != id && 0 <= i < k) ==> blood[i] == old(blood[i]));\n    {\n    \tif (k == id)\n    \t{\n    \t\tblood[k] := newdata;\n    \t\treturn;\n    \t}\n    \tk := k + 1;\n    }\n    }\n    method getRequest() returns (r:array<string>)\n    requires Valid();\n    ensures Valid();\n    ensures fresh(r);\n    ensures r != null;\n    ensures r.Length == 5;\n    ensures r[0]== \"blood C\";\n    ensures r[1]== \"blood A\";\n    ensures r[2]== \"blood B\";\n    ensures r[3]== \"blood B\";\n    ensures r[4]== \"blood O\";\n    {\n        r := new string[5]; \n        r[0]:= \"blood C\";r[1]:= \"blood A\";\n        r[2] := \"blood B\";r[3]:=\"blood B\";r[4]:=\"blood O\";  \n    }\n}\nmethod Main()\n{    \n    var a : array<string> := new string[2];\n    a[0]:= \"B\";a[1]:=\"A\";\n    var v := new VampireSystem(a);\n    var answer := v.getDeliveredBlood();\n    assert |answer| == multiset(a[..])[\"-\"];\n    assert v.DeliveredBlood(answer);\n    var e:array<string> := new string[6];\n    e[0]:=\"tested\"; e[1]:= \"not-tested\";\n    e[2]:=\"tested\";e[3]:= \"tested\"; \n    e[4]:= \"not-tested\"; e[5] := \"tested\";\n    var system := new VampireSystem(e);\n    system.updateBloodStatus(\"not-tested\",2);\n    assert system.blood[2] == \"not-tested\";\n    assert system.blood[0] == \"tested\";\n    assert system.blood[1] == \"not-tested\";\n    assert system.blood[3] == \"tested\";\n    assert system.blood[4] == \"not-tested\";\n    assert system.blood[5] == \"tested\";\n    system.updateBloodStatus(\"not-tested\",2);\n    assert system.blood[2] == \"not-tested\";\n    assert system.blood[0] == \"tested\";\n    assert system.blood[1] == \"not-tested\";\n    assert system.blood[3] == \"tested\";\n    assert system.blood[4] == \"not-tested\";\n    assert system.blood[5] == \"tested\";\n    system.updateBloodStatus(\"added\",2);\n    assert system.blood[2] == \"added\";\n    assert system.blood[0] == \"tested\";\n    assert system.blood[1] == \"not-tested\";\n    assert system.blood[3] == \"tested\";\n    assert system.blood[4] == \"not-tested\";\n    assert system.blood[5] == \"tested\";\n    system.updateBloodStatus(\"tested\",4);\n    assert system.blood[2] == \"added\";\n    assert system.blood[0] == \"tested\";\n    assert system.blood[1] == \"not-tested\";\n    assert system.blood[3] == \"tested\";\n    assert system.blood[4] == \"tested\";\n    assert system.blood[5] == \"tested\";\n\t  var e2 : array<string> := new string[6];\n    e2[0]:=\"\"; e2[1]:= \"2019-08-12\"; \n    e2[2]:=\"\";e2[3]:= \"2019-08-02\"; \n    e2[4]:= \"2019-08-10\"; e2[5] := \"\";\n    system := new VampireSystem(e2);\n    system.updateInputDate(\"2019-10-11\",5);\n    assert system.blood[0] == \"\";\n    assert system.blood[1] == \"2019-08-12\";\n    assert system.blood[2] == \"\";\n    assert system.blood[3] == \"2019-08-02\";\n    assert system.blood[4] == \"2019-08-10\";\n    assert system.blood[5] == \"2019-10-11\";\n    var e3 : array<string> := new string[6];\n    e3[0]:=\"\"; e3[1]:= \"no\"; \n    e3[2]:=\"\";e3[3]:= \"\"; \n    e3[4]:= \"yes\"; e3[5] := \"no\";\n    system := new VampireSystem(e3);\n    system.updateDeliveredStatus(2,\"yes\");\n    assert system.blood[2] == \"yes\";\n    assert system.blood[0] == \"\";\n    assert system.blood[1] == \"no\";\n    assert system.blood[3] == \"\";\n    assert system.blood[4] == \"yes\";\n    assert system.blood[5] == \"no\";\n    var r := v.getRequest();     \n    assert r.Length == 5;\n    assert r != null;\n    assert r[0] == \"blood C\";\n    assert r[1] == \"blood A\";\n    assert r[2] == \"blood B\";\n    assert r[3] == \"blood B\";\n    assert r[4] == \"blood O\";\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n    requires x < 0\n    ensures 0 <= y\n{\n    return -x;\n}\nmethod AbsEx3(x: int) returns (y: int)\n    requires x == -1\n    ensures y >= 0 && (y == x || y == -x)\n{\n    y := x + 2;\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n    requires 0 < y\n    ensures less < x < more\n{\n    more := x + y;\n    less := x - y;\n}\nmethod Max(a: int, b: int) returns (c: int)\n    requires a >= 0 && b >= 0\n    ensures c == a || c == b\n{\n    if a > b {\n        return a;\n    } else {\n        return b;\n    }\n}\nmethod TestingAbs()\n{\n    var num := -3;\n    var v := Abs(num);\n    print v;\n    assert 0 <= v;\n}\nmethod TestingMax()\n{\n    var a, b := 5, 4;\n    var c;\n    c := Max(a, b);\n    assert c > 1;\n}\nmethod TestingAbsEx3()\n{\n    var num := -1;\n    var v := AbsEx3(num);\n    assert 0 <= v;\n}\nmethod Main()\n{\n    TestingAbsEx3();\n}"
},
{
    "dafny": "function count (a: seq<int>, key: int): nat \n{  \n\tmultiset(a)[key] \n}\npredicate valid (a: array<int>, res_len: int, key: int) \nreads a;\nrequires a.Length >= 0;\nrequires 0 <= res_len <= a.Length;\n{\n\tres_len <= 0 || \n\t(forall i :: (0 <= i < res_len) ==> a[i] == key)\n}\nmethod LinearSearch (a: array<int>, key: int) returns (res: array<int>, res_len: int) \nrequires a.Length >= 0;\nensures 0 <= res_len <= a.Length <= res.Length;\nensures valid (res, res_len, key);\nensures res_len == 0 <==> key !in a[..];\nensures res_len == count (a[..], key) && res_len == count (res[..res_len], key); \n{\n\tres := new int[a.Length];\n\tres_len := 0;\t\n\tvar i := 0;\n\twhile (i < a.Length) \n\tinvariant 0 <= res_len <= i <= a.Length <= res.Length;\n\tinvariant valid (res, res_len, key);\n\tinvariant res_len == 0 <==> key !in a[..i];\n\tinvariant res_len == count (a[..i], key) && res_len == count (res[..res_len], key); \n\t{\n\t\tif (a[i] == key) {\n\t\t\tres[res_len] := a[i];\n\t\t\tres_len := res_len + 1;\t\n\t\t}\t\n\t\ti := i + 1;\n\t}\n  assert (a[..i] == a[..]);\n}\nmethod Main () \n{\n\tvar a := new int[][1,2,2,3,3,3,4,4,4,4];\n\tvar a_res : array<int>;\n\tvar a_res_len : int;\n\ta_res, a_res_len := LinearSearch (a, 1);\n\tassert (valid(a_res, a_res_len, 1));\n\tassert (a_res_len == count(a[..], 1));\n\ta_res, a_res_len := LinearSearch (a, 2);\n\tassert (valid(a_res, a_res_len, 2));\n\tassert (a_res_len == count(a[..], 2));\n\ta_res, a_res_len := LinearSearch (a, 3);\n\tassert (valid(a_res, a_res_len, 3));\n\tassert (a_res_len == count(a[..], 3));\n\ta_res, a_res_len := LinearSearch (a, 4);\n\tassert (valid(a_res, a_res_len, 4));\n\tassert (a_res_len == count(a[..], 4));\n\ta_res, a_res_len := LinearSearch (a, 0);\n\tassert (valid(a_res, a_res_len, 0));\n\tassert (a_res_len == count(a[..], 0));\n\ta_res, a_res_len := LinearSearch (a, 5);\n\tassert (valid(a_res, a_res_len, 5));\n\tassert (a_res_len == count(a[..], 5));\n\tvar b := new int[][4,1,2,4,3,3,4,2,3,4];\n\tvar b_res : array<int>;\n\tvar b_res_len : int;\n\tb_res, b_res_len := LinearSearch (b, 1);\n\tassert (valid(b_res, b_res_len, 1));\n\tassert (b_res_len == count(b[..], 1));\n\tb_res, b_res_len := LinearSearch (b, 2);\n\tassert (valid(b_res, b_res_len, 2));\n\tassert (b_res_len == count(b[..], 2));\n\tb_res, b_res_len := LinearSearch (b, 3);\n\tassert (valid(b_res, b_res_len, 3));\n\tassert (b_res_len == count(b[..], 3));\n\tb_res, b_res_len := LinearSearch (b, 4);\n\tassert (valid(b_res, b_res_len, 4));\n\tassert (b_res_len == count(b[..], 4));\n\tb_res, b_res_len := LinearSearch (b, 0);\n\tassert (valid(b_res, b_res_len, 0));\n\tassert (b_res_len == count(b[..], 0));\n\tb_res, b_res_len := LinearSearch (b, 5);\n\tassert (valid(b_res, b_res_len, 5));\n\tassert (b_res_len == count(b[..], 5));\n}"
},
{
    "dafny": "method append(a:array<int>, b:int) returns (c:array<int>)\n  ensures  a[..] + [b] == c[..]\n{\n  c := new int[a.Length+1];\n  var i:= 0;\n  while (i < a.Length)\n    invariant 0 <= i <= a.Length\n    invariant forall ii::0<=ii<i ==> c[ii]==a[ii]\n  {\n    c[i] := a[i];\n    i:=i+1;\n  }\n  c[a.Length]:=b;\n}"
},
{
    "dafny": "ghost function Count<T>(s: set<T>): int\n{\n  if s == {} then 0 else\n    var x :| x in s;  \n    1 + Count(s - {x})\n}\nmethod Copy<T>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var r := s;\n  while r != {}\n    invariant s == r + t\n    decreases r\n  {\n    var x :| x in r;\n    r, t := r - {x}, t + {x};\n  }\n}\nmethod CopyFaster<T>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var r := s;\n  while r != {}\n    invariant s == r + t\n    decreases r\n  {\n    var p :| p != {} && p <= r;  \n    r, t := r - p, t + p;\n  }\n}\nmethod CopyFastest<T>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := s;  \n}\niterator Iter<T(0)>(s: set<T>) yields (x: T)\n  yield ensures x in s && x !in xs[..|xs|-1]\n  ensures s == set z | z in xs\n{\n  var r := s;\n  while r != {}\n    invariant forall z :: z in xs ==> z !in r  \n    invariant s == r + set z | z in xs\n  {\n    var y :| y in r;\n    r, x := r - {y}, y;\n    yield;\n    assert y == xs[|xs|-1];  \n  }\n}\nmethod UseIterToCopy<T(0)>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var m := new Iter(s);\n  while true\n    invariant m.Valid() && fresh(m._new)\n    invariant t == set z | z in m.xs\n    decreases s - t\n  {\n    var more := m.MoveNext();\n    if !more { break; }\n    t := t + {m.x};\n  }\n}"
},
{
    "dafny": "function sumn(n : int) : int \n     { n * (n + 1) / 2}\nmethod sum(n : int) returns (s : int)\nrequires n > 0; \nensures s == sumn(n) ; \n{\n   var i := 0;\n   s := 0;\n   while i < n\n   invariant 0 <= i <= n;\n   decreases n - i;\n   invariant s == sumn(i);\n   {\n      i := i + 1;\n      s := s + i;\n   }\n}"
},
{
    "dafny": "predicate inDifference(original: multiset<int>, curr: multiset<int>, key: int)\n{\n  key in original-curr\n}\nmethod narrowDown(bags: array<int>, start: int, end: int) returns (selected: seq<int>)\nrequires start <= end\nensures forall x:: 0<=x<|selected| ==> start<=selected[x]<=end\n{\n    var i := 0;\n    selected := [];\n    while i < bags.Length\n    invariant 0<=i<=bags.Length\n    invariant forall x:: 0<=x<|selected| ==> start<=selected[x]<=end\n    {\n        if start<=bags[i]<=end{\n            selected := selected + [bags[i]];\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method FindMax(a: array<int>) returns (i: int)\n    requires a.Length > 0\n    ensures 0 <= i < a.Length\n    ensures forall j :: 0 <= j < a.Length ==> a[i] >= a[j]\n{\n    i := 0;\n    var index: int := 1;\n    while index < a.Length\n        decreases a.Length - index\n        invariant 0 <= i < a.Length\n        invariant 1 <= index <= a.Length\n        invariant forall k :: 0 <= k < index ==> a[i] >= a[k]\n    {\n        if a[index] > a[i] {\n            i := index;\n        }\n        index := index + 1;\n    }\n    return i;\n}"
},
{
    "dafny": "class A {\n  var value: int\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\n    assert old(i) == 6; \n    assert old(j) == 18; \n    assert old@L(j) == 18; \n    assert old(value) == 42;\n    assert old@L(value) == 43;\n    assert old@M(value) == 44 && this.value == 44;\n  }\n}"
},
{
    "dafny": "method remove(items: array<int>, index: nat) returns (r: array<int>)\n  requires items != null && index < items.Length\n  requires items.Length > 0\n  ensures r != null && r.Length == items.Length - 1\n  ensures forall k: nat :: k < index ==> r[k] == items[k]\n  ensures forall k :: index <= k < r.Length ==> r[k] == items[k + 1]\n{\n    var newlen := items.Length - 1;\n    r := new int[newlen];\n    var i: nat := 0;\n    while i < index\n      invariant i <= index\n      decreases index - i\n      invariant r.Length == newlen\n      invariant forall k: nat :: k < i\n                ==> (k < index ==> r[k] == items[k])\n    {\n        r[i] := items[i];\n        i := i + 1;\n    }\n    assert i == index;\n    while i < newlen\n      invariant index <= i <= newlen\n      decreases newlen - i\n      invariant r.Length == newlen\n      invariant forall k: nat :: k < index ==> r[k] == items[k]\n      invariant forall k :: index <= k < i ==> r[k] == items[k + 1]\n    {\n        r[i] := items[i + 1];\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method isPrefix(pre: string, str: string) returns (res: bool){\n  if(|pre| == 0){\n    return true;\n  }\n  if (|pre| > |str|){\n    return false;\n  }\n  var i: nat := 0;\n  var n:= |pre|;\n  while(i < n)\n    decreases n - i\n    invariant 0 <= i <= n\n  {\n    if(pre[i] != str[i]){\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\nmethod isSubstring(sub: string, str: string) returns (res: bool){\n  if(|sub| == 0){\n    return true;\n  }\n  if(|str| < |sub|){\n    return false;\n  }\n  var i: nat := 0;\n  var substr: string;\n  var isPref : bool;\n  var len: int := |str| - |sub|;\n  while (i < len)\n    decreases len - i\n    invariant 0 <= i <= len\n  {\n    substr := str[i..];\n    isPref := isPrefix(sub, substr);\n    if(isPref){\n      return true;\n    }\n    i := i + 1; \n  }\n  return false;\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2:string) returns (res: bool){\n  if (k == 0){\n    return true;\n  }\n  if (k > |str1| || k > |str2|){\n    return false;\n  }\n  var i: nat := 0;\n  while(i < |str1| - k)\n    decreases |str1| - k - i \n    invariant 0 <= i <= |str1| - k\n  {\n    var substr : string := str1[i..i+k-1];\n    var isSubStr : bool := isSubstring(substr, str2);\n    if(isSubStr){\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat){\n  var short : string := str1;\n  var long : string := str2;\n  if(|str1| > |str2|){\n    short := str2;\n    long := str1;\n  }\n  var k : nat := 0;\n  var haveCommonSubstring : bool := true;\n  while(k < |short|)\n    decreases |short| - k\n    invariant 0 <= k <= |short|\n  {\n    haveCommonSubstring := haveCommonKSubstring(k, short, long);\n    if(!haveCommonSubstring){\n      break;\n    }\n    k := k + 1;\n  }\n  return k;\n}"
},
{
    "dafny": "method max(a:array<int>) returns(max:int)\n requires a!=null;\n ensures (forall j :int :: (j >= 0 && j < a.Length ==> max >= a[j]));\n ensures (a.Length > 0)==>(exists j : int :: j>=0 && j < a.Length && max==a[j]);\n{\n if (a.Length == 0)  { max := 0;} \n else {\n max:=a[0];\n var i:int :=1;\n while(i < a.Length)\n invariant (i<=a.Length) && (forall j:int :: j>=0 && j<i ==> max >= a[j])\n         && (exists j:int :: j>=0 && j<i && max==a[j]);\n decreases (a.Length-i); \n {\n if(a[i] > max){max := a[i];}\n i := i + 1;\n }\n }\n}"
},
{
    "dafny": "method if_else_test (i: int) returns (out: int)\nrequires true;\nensures (out==100 && i>0) || (out==200 && i<= 0)\n{\n    if(i > 0)\n    {\n        out:= 100;\n    }\n    else\n    {\n        out:= 200;\n    }\n}"
},
{
    "dafny": "trait ADT {\n  ghost function ReprFamily(n: nat): set<object>\n    decreases n\n    ensures n > 0 ==> ReprFamily(n) >= ReprFamily(n-1)\n    reads this, if n == 0 then {} else ReprFamily(n-1)\n}\nclass P extends ADT {\n  ghost function ReprFamily(n: nat): set<object>\n    decreases n\n    ensures n > 0 ==> ReprFamily(n) >= ReprFamily(n-1)\n    reads this, if n == 0 then {} else ReprFamily(n-1)\n  { {} }\n}"
},
{
    "dafny": "class Contador\n{\n    var valor: int;\n    method Inc()\n    modifies this\n    ensures valor == old(valor) + 1\n    {\n        valor := valor + 1;\n    }\n    method Decr()\n    modifies `valor\n    ensures valor == old(valor) - 1\n    {\n        valor := valor - 1;\n    }\n    method GetValor() returns (v: int)\n    ensures v == valor\n    ensures valor == old(valor)\n    {\n        return valor;\n    }\n    constructor()\n    ensures valor == 0\n    {\n        valor := 0;\n    }\n}\nmethod Main()\n{\n    var c := new Contador();\n    var v := c.GetValor();\n    assert v == 0;\n    c.Inc();\n    c.Inc();\n    v:= c.GetValor();\n    assert v == 2;\n    c.Decr();\n    v := c.GetValor();\n    assert v == 1;\n}"
},
{
    "dafny": "method max(x: int, y: int) returns (max: int)\n   requires true;\n  ensures (x>y && max==x) || (x<=y && max==y);\n{   \n    if(x > y){\n         assert (true && x > y);\n          assert (x > y && x == x) || (x <=y && x == y);\n      max := x;\n           assert (x > y && max == x) || (x <=y && max == y);\n    }else{\n         assert (true && !(x > y));\n          assert (x > y && y == x) || (x <=y && y == y);\n      max := y;\n           assert (x > y && max == x) || (x <=y && max == y);\n    }\n}"
},
{
    "dafny": "method append( items: array<int>, item: int ) returns (r: array<int>)\n  requires items != null && items.Length > 0\n  ensures r != null && r.Length == items.Length + 1\n  ensures forall k: int :: 0 <= k < items.Length ==> r[k] == items[k]\n{\n    r := new int[items.Length + 1];\n    var i: nat := 0;\n    while i < items.Length\n      invariant r.Length == items.Length + 1\n      invariant i <= items.Length\n      invariant forall k: int :: 0 <= k < i ==> r[k] == items[k]\n    {\n        r[i] := items[i];\n        i := i + 1;\n    }\n    r[i] := item;\n}"
},
{
    "dafny": "method Main() {\n  print \"Hello\\n\";\n  var x, y := Library.LibClass.CallMeInt(30);\n  var z := Library.LibClass.CallMeNative(44, true);\n  print x, \" \", y, \" \", z, \"\\n\";\n  Library.AllDafny.M();\n  Library.Mixed.M();\n  Library.Mixed.P();\n  Library.AllExtern.P();\n  assert Library.AllDafny.Seven() == Library.Mixed.Seven() == Library.AllExtern.Seven();\n}\nmodule {:extern \"Library\"} Library {\n  newtype MyInt = x | -100 <= x < 0x8000_0000\n  class {:extern \"LibClass\"} LibClass {\n    static method {:extern} CallMeInt(x: int) returns (y: int, z: int)\n    static method {:extern} CallMeNative(x: MyInt, b: bool) returns (y: MyInt)\n  }\n  class AllDafny {\n    static function Seven(): int { 7 }\n    static method M() { print \"AllDafny.M\\n\"; }\n  }\n  class {:extern} Mixed {\n    static function Seven(): int { 7 }\n    static method M() { print \"Mixed.M\\n\"; }\n    static method {:extern} P()\n  }\n  class {:extern} AllExtern {\n    static function Seven(): int { 7 }\n    static method {:extern} P()\n  }\n}"
},
{
    "dafny": "function IsEven(a : int) : bool\n    requires a >= 0\n{\n    if a == 0 then      true \n    else if a == 1 then false \n    else                IsEven(a - 2)\n}\nlemma EvenSquare(a : int)\nrequires a >= 0\nensures IsEven(a) ==> IsEven(a * a)\n{\n    if a >= 2 && IsEven(a) {\n        EvenSquare(a - 2);\n        assert a * a == (a - 2) * (a - 2) + 4 * a - 4;\n        EvenDouble(2 * a - 2);\n        EvenPlus((a - 2) * (a - 2), 4 * a - 4);\n    }\n}\nlemma EvenDouble(a: int)\n    requires a >= 0\n    ensures IsEven(a + a)\n{\n    if a >= 2 {\n        EvenDouble(a - 2);\n    }\n}\nlemma {:induction x} EvenPlus(x: int, y: int)\n    requires x >= 0\n    requires y >= 0\n    requires IsEven(x)\n    requires IsEven(y)\n    ensures IsEven(x + y)\n{\n    if x >= 2 {\n        EvenPlus(x - 2, y);\n    }\n}"
},
{
    "dafny": "predicate sorted(a:array<int>, min:int, max:int)\nrequires a != null;\nrequires 0 <= min <= max <= a.Length;\nreads a;\n{\n    forall j, k :: min <= j < k < max ==> a[j] <= a[k]\n}\nmethod insertSort(a : array<int>)\nrequires a != null && a.Length >= 1;\nensures sorted(a, 0, a.Length);\nmodifies a;\n{\n    var i := 1;\n    while (i < a.Length)\n    invariant 1 <= i <= a.Length;\n    invariant sorted(a, 0, i);\n    decreases a.Length - i;\n    {\n        var j := i;\n        var value := a[i];\n        a[i] := a[i - 1];\n        while (j > 0 && a[j - 1] > value)\n        invariant sorted(a, 0, i + 1);\n        invariant forall k :: j - 1 < k < i ==> a[k] > value;\n        decreases j;\n        {\n            a[j] := a[j - 1];\n            j := j - 1;\n        }\n    a[j] := value;\n    i := i + 1;\n    }\n}"
},
{
    "dafny": "method below_zero(operations: seq<int>) returns (s:array<int>, result:bool)\n  ensures s.Length == |operations| + 1\n  ensures s[0]==0\n  ensures forall i :: 0 <= i < s.Length-1 ==> s[i+1]==s[i]+operations[i]\n  ensures result == true ==> (exists i :: 1 <= i <= |operations| && s[i] < 0)\n  ensures result == false ==> forall i :: 0 <= i < s.Length ==> s[i] >= 0\n{\n  result := false;\n  s := new int[|operations| + 1];\n  var i := 0;\n  s[i] := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant s[0]==0\n    invariant s.Length == |operations| + 1\n    invariant forall x :: 0 <= x < i-1 ==> s[x+1]==s[x]+operations[x]\n  {\n    if i>0{\n        s[i] := s[i - 1] + operations[i - 1];\n    }\n    i := i + 1;\n  }\n  i:=0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> s[x] >= 0\n  {\n    if s[i] < 0 {\n      result := true;\n      return;\n    }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "module Sequence {\n    datatype T<A> = Nil | Cons(head: T, tail: T<T>)\n    function Length<A>(s: T<A>): int\n    {\n        match s\n            case Nil => 0\n            case Cons(_, s) => 1 + Length(s)\n    }\n    lemma lemma_LengthGe0<A>(s: T<A>)\n        ensures 0 <= Length(s)\n    {\n        match s \n            case Nil => \n            case Cons(_, s) => lemma_LengthGe0(s);\n    }\n}"
},
{
    "dafny": "type T = int \npredicate sorted(a: array<T>, n: nat) \n    requires n <= a.Length\n    reads a\n{\n    forall i,j :: 0 <= i < j < n ==> a[i] <= a[j]\n}\nmethod binarySearch(a: array<T>, x: T) returns (index: int) \n    requires sorted(a, a.Length)\n    ensures sorted(a, a.Length)\n    ensures 0 <= index <= a.Length\n    ensures index > 0 ==> a[index-1] <= x\n    ensures index < a.Length ==> a[index] >= x\n{\n    var low, high := 0, a.Length;\n    while low < high \n        decreases high-low\n        invariant 0 <= low <= high <= a.Length\n        invariant low > 0 ==> a[low-1] <= x\n        invariant high < a.Length ==> a[high] >= x\n    {\n        var mid := low + (high - low) / 2;\n        if {\n            case a[mid] < x => low := mid + 1;\n            case a[mid] > x => high := mid;\n            case a[mid] == x => return mid;\n        }\n    }\n    return low;\n}\nmethod testBinarySearch() {\n    var a := new int[2] [1, 3];\n    var id0 := binarySearch(a, 0);\n    assert id0 == 0;\n    var id1 := binarySearch(a, 1);\n    assert id1 in {0, 1};\n    var id2 := binarySearch(a, 2);\n    assert id2 == 1;\n    var id3 := binarySearch(a, 3);\n    assert id3 in {1, 2};\n    var id4 := binarySearch(a, 4);\n    assert id4 == 2;\n}"
},
{
    "dafny": "module Libraries__Math {\nlemma lemma_div(m:nat, k:nat) \n    requires m >= k;\n    requires k >= 1;\n    ensures m/k >= 1;\n{\n    if m == k {\n        assert m / k == 1;\n    }\n}\n}"
},
{
    "dafny": "predicate Clean(a: array<int>, key: int) \n    reads a \n{\n    forall k ::0<= k < a.Length ==> a[k] != key\n}\nmethod IsClean(a: array<int>, key: int) returns (clean: bool) \n    ensures clean <==> Clean(a,key)\n{\n    clean := true ;\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant clean == forall j :: 0<= j < i ==> a[j] != key\n        decreases a.Length - i \n    {\n        if (a[i] == key){\n            clean := false;\n            break;\n        }\n        i := i +1;\n    }\n}\n    method Test(){\n        var a:= new int[5][1,2,2,2,3];\n        assert a[0] == 1;\n        assert a[1] == 2;\n        assert a[2] == 2;\n        assert a[3] == 2;\n        assert a[4] == 3;\n        var b:=  IsClean(a, 5);\n        assert b==true;\n        b:= IsClean(a, 2);\n        assert !b;\n        b:= IsClean(a, 3);\n        assert !b;\n        b:= IsClean(a, 4);\n        assert b;\n        var c:= new int[1][1];\n        assert c[0]== 1;\n        b:= IsClean(c,1);\n        assert !b;\n        b:= IsClean(c,2);\n        assert b;\n        var d:= new int[0][];\n        b:= IsClean(d,1);\n        assert b;\n    }"
},
{
    "dafny": "const digits := [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\nfunction IntToString(i: int): string   \n  decreases i < 0, if i<0 then -i else i\n{\n  if i < 0 then (\"-\" + IntToString(-i))\n  else if i < 10 then digits[i]  \n  else if i < 100 then (digits[i/10] + digits[i%10])\n  else (IntToString(i/10) + digits[i%10])  \n}\nmethod Main() {\n  print IntToString(4), \"\\n\";\n  print IntToString(42), \"\\n\";\n  print IntToString(422), \"\\n\";\n}"
},
{
    "dafny": "predicate isMax(s: string, lo: nat)\n{\n    0 <= lo < |s| && forall i | 0 <= i < |s| :: s[i] <= s[lo]\n}\nmethod findMax(s: string) returns (lo: nat)\n    requires 0 < |s|\n    ensures isMax(s, lo)\n{\n    lo := 0;\n    var hi: nat := |s| - 1;\n    ghost var max := if s[lo] >= s[hi] then lo else hi;\n    while lo < hi\n        decreases hi - lo\n        invariant 0 <= lo <= hi < |s|\n        invariant lo == max || hi == max\n        invariant forall i | 0 <= i < (lo + 1) || hi <= i < |s| :: s[i] <= s[max]\n    {\n        if s[lo] <= s[hi]\n        {\n            lo := lo + 1;\n            max := hi;\n            if s[lo] >= s[max] {\n                max := lo;\n            }\n        } else {\n            hi := hi - 1;\n            max := lo;\n            if s[hi] >= s[max] {\n                max := hi;\n            }\n        }\n    }\n}"
},
{
    "dafny": "method Multiply2(n:int) returns (r:int)\n requires 0 <= n;\n ensures r == 2*n;\n{\n  r := 0;\n  var i:int := 0;\n  while (i < n)\n   invariant (0 <= i <= n);\n   invariant (r == 2*i);\n  {\n    r := r + 2;\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "class PingProtocol\n{\n  method PingSeq( Ps : set<nat>\n                )\n  {\n    var X  := map i | i in Ps :: 0;\n    var Val := *;\n    var WL := Ps;\n    while WL != {}\n      invariant forall p :: p in Ps <==> p in X;\n      invariant forall p :: p in Ps && p !in WL ==> X[p] == Val;\n      decreases |WL|\n    {\n      var p := *;\n      assume (p in WL && p in Ps);\n      X := X[p := Val];\n      WL := WL - {p};\n    }\n    assert (forall p :: p in Ps ==> X[p] == Val);\n  }\n}"
},
{
    "dafny": "predicate P(x: int, y: int)\npredicate Q(x: int)\npredicate R(x: int)\nmethod M() {\n  assert forall x, y :: true || P(x, y) || Q(y) || R(x);\n  assert forall x, y :: true || Q(y) || P(x, y) || R(x);\n  assert forall x, y :: true || Q(y) || R(x) || P(x, y);\n}\npredicate PP(x: int, y: int, z: int)\npredicate QQ(x: int, y: int)\npredicate RR(x: int, y: int)\npredicate SS(x: int, y: int)\nmethod MM() {\n  assert forall x, y, z, u, v, w :: true || PP(x, y, z) || QQ(x, u) || RR(y, v) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || PP(x, y, z) || RR(y, v) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || RR(y, v) || PP(x, y, z) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || RR(y, v) || SS(z, w) || PP(x, y, z);\n}"
},
{
    "dafny": "method AbsIt(s: array<int>) modifies s;\nensures forall x :: 0 <= x < s.Length ==> old(s[x]) < 0 ==> s[x] == -old(s[x])\nensures forall x :: 0 <= x < s.Length ==> old(s[x]) >= 0 ==> s[x] == old(s[x])\n{\n    var i:int := 0;\n    while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall k :: 0 <= k < i ==> old(s[k]) < 0  ==> s[k] == -old(s[k])\n    invariant forall k :: 0 <= k < i ==> old(s[k]) >= 0 ==> s[k] == old(s[k])  \n    invariant forall k:: i <= k < s.Length ==> old(s[k]) == s[k]              \n    {\n        if (s[i] < 0) {\n            s[i] := -s[i];\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method abs (x: int) returns (y : int)\n    ensures  0 <= y; \n{\n    if (x < 0) {\n        return -x;\n    } else {\n        return x;\n    }\n}\nmethod max (x: int, y: int) returns (m : int)\nrequires true\nensures m == y || m == x\nensures m >= x && m >= y\n{\n    var r : int;\n    if ( x < y ) {\n        r := y  ;\n    } else {\n        r := x;\n    }\n    m := r;\n    return m;\n}\nmethod ex1 (n: int) returns (i : int)\n    requires n >= 0\n    ensures i == n\n{\n    i := 0;\n    while (i < n)\n        invariant i <= n;\n        decreases n - i;   \n    {\n        i := i + 1;\n        assert( i <= n);\n    } \n}\nmethod find (a: seq<int>, key: int) returns (index : int)\nrequires true\nensures key !in a ==> index == -1 \nensures key in a ==> 0 <= index < |a| \nensures key in a ==> 0 <= index < |a| && a[index] == key\n{\n    index := 0;\n    while (index < |a|) \n        decreases |a| - index\n        invariant 0 <= index <= |a| ;\n        invariant key !in a[..index];\n        {\n            if ( a[index] == key ) { \n                assert( index < |a|);\n                return index ;\n            }\n            index := index + 1;\n        }\n    index := -1;\n}\nmethod isPalindrome(a: seq<char>) returns (b: bool) \n    ensures b <==> (forall j:: 0 <= j < |a| / 2 ==> a[j] == a[|a| - 1 - j] )\n{\n    var i := 0;\n    while i < |a| / 2 \n        invariant 0 <= i <= |a|\n        invariant forall j:: 0 <= j < i ==> a[j] == a[|a| - 1 - j]\n    {\n        if a[i] != a[|a| - 1 - i] {\n            return false;\n        } else {\n            i := i + 1;\n        }\n    }\n    return true;\n}\nfunction isPalindrome1(a: seq<char>): bool \n    ensures isPalindrome1(a) <==> (forall j:: 0 <= j < |a| / 2 ==> a[j] == a[|a| - 1 - j] )\n    decreases |a|\n{\n    if |a| <= 1 then \n        true\n    else \n        assert(|a| >= 2);\n        a[0] == a[|a| - 1] && isPalindrome1(a[1..|a| - 1])\n}\npredicate sorted (a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\nmethod unique(a: seq<int>) returns (b: seq<int>) \n    requires sorted(a)\n    ensures forall j, k::0 <= j < k < |b|  ==> b[j] < b[k]\n    ensures forall j :: j in a <==> j in b\n{\n    if |a| == 0 {\n        b := [] ;\n    } else \n    {\n        var last := a[0];\n        b := [a[0]];\n        var index := 1;\n        while (index < |a|)\n            decreases |a| - index\n            invariant index <= |a|;\n            invariant |b| >= 1;\n            invariant b[|b| - 1] == last;\n            invariant forall j, k::0 <= j < k < |b|  ==> b[j] < b[k];\n            invariant last in a[..index];   \n            invariant forall j :: j in a[..index] <==> j in b\n        {\n            if ( a[index] != last ) { \n                b := b + [a[index]];\n                last := a[index];\n            }\n            index := index + 1;\n        }\n    }\n}\nmethod Main() {\n    var r := find([], 1);   \n    print r, \"\\n\";\n    r := find([0,3,5,7], 5);  \n    print r, \"\\n\";\n    var s1 := ['a'];\n    var r1 := isPalindrome(s1);\n    print \"is [\", s1, \"]\", \" a isPalindrome? \", r1, \" \\n\";\n    s1 := [];\n    r1 := isPalindrome(s1);\n    print \"is [\", s1, \"]\", \" a isPalindrome? \", r1, \" \\n\";\n    s1 := ['a', 'b'];\n    r1 := isPalindrome(s1);\n    print \"is [\", s1, \"]\", \" a isPalindrome? \", r1, \" \\n\";\n    s1 := ['a', 'b', 'a'];\n    r1 := isPalindrome(s1);\n    print \"is [\", s1, \"]\", \" a isPalindrome? \", r1, \" \\n\";\n    var i := [0,1,3,3,5,5,7];\n    var s := unique(i);\n    print \"unique applied to \", i, \" is \", s, \"\\n\";\n}"
},
{
    "dafny": "predicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n{\n  var m: map<int, int> := map[];\n  var i := 0;\n  while i < nums.Length\n    invariant i <= nums.Length\n    invariant forall k :: k in m ==> 0 <= m[k] < i\n    invariant forall k :: k in m ==> nums[m[k]] + k == target\n    invariant InMap(nums[..i], m, target)\n    invariant forall u, v :: 0 <= u < v < i ==> nums[u] + nums[v] != target\n  {\n    if nums[i] in m {\n      return (m[nums[i]], i);\n    }\n    m := m[target - nums[i] := i];\n    i := i + 1;\n  }\n  return (-1, -1);\n}"
},
{
    "dafny": "method find(a : array<int>, key : int) returns (index : int)\n  requires a != null;\n  ensures 0 <= index <= a.Length;\n  ensures index < a.Length ==> a[index] == key;\n{\n  index := 0;\n  while (index < a.Length && a[index] != key)\n  invariant 0 <= index <= a.Length\n  invariant forall k :: 0 <= k < index ==> a[k] != key\n  {\n    index := index + 1;\n  }\n}"
},
{
    "dafny": "method Min(a:int, b:int, c:int) returns (m:int)\n ensures (m >= 0);\n ensures m in [a,b,c,-a,-b,-c];\n ensures (m <= a) || (m<=-a);\n ensures (m <= b) || (m<=-b);\n ensures (m <= c) || (m<=-c);\n{\n  var ap:int, bp:int, cp:int;\n  if (a >= 0) {ap := a;} else {ap := -a;}\n  if (b >= 0) {bp := b;} else {bp := -b;}\n  if (c >= 0) {cp := c;} else {cp := -c;}\n  assert ((ap >= 0) && (bp >= 0) && (cp >= 0)); \n  m := -1;\n  if ((ap <= bp) && (ap <= cp)) {m := ap;}\n  if ((bp <= ap) && (bp <= cp)) {m := bp;}\n  if ((cp <= ap) && (cp <= bp)) {m := cp;}\n  assert (m != -1); \n}"
},
{
    "dafny": "predicate divisible(n1 : int, n2 : int)\nrequires n1 >= 0 && n2 > 0 \nensures divisible(n1,n2) == (n1 % n2 == 0)\nmethod TestDivisible()\n{\n\tassert divisible(5,1);\n\tassert divisible(25,5);\n\tassert divisible(1000,1000);\n}\npredicate VectorDivisible (s : seq<int>, n : int)\nrequires n > 0\nrequires forall i:: 0<=i<|s| ==> s[i]>=0\nensures VectorDivisible(s,n) == (forall k :: 0<=k<|s| ==> divisible(s[k],n))\nmethod TestDivisibles() \n{\n\tassert VectorDivisible([99],3);\n\tassert VectorDivisible([5,100,10,25],5);\n\tvar s : seq<int>;\n\ts := [];\n\tassert VectorDivisible(s,3);\n\tassert VectorDivisible([0,0,0],4);\n}\npredicate CrecienteM1(s: seq<int>)\nensures CrecienteM1(s) == (forall i:: 0<=i<(|s|-1) ==> s[i]<s[i+1])\npredicate Capicua(s: seq<int>)\nensures Capicua(s) == forall i ::0<=i<|s| ==> s[i] == s[|s|- i - 1 ]\npredicate Decreciente(s:seq<int>)\nensures Decreciente(s) == forall i :: 0<=i<|s|-1 ==> s[i] > s[i+1]\npredicate Montana (s : seq<int>) \nensures Montana(s) == (|s| == 1) \nensures Montana(s) == (|s| % 2 == 0 && Capicua(s) && CrecienteM1(s[..(|s|/2)]) && Decreciente(s[(|s|/2)..]))\nensures Montana(s) == (|s| % 2 != 0 && Capicua(s) && CrecienteM1(s[..((|s|/2)-1)]) && Decreciente(s[((|s|/2)+1)..])) \nmethod TestMontana() \n{\n\tassert Montana([2]);\n\tassert Montana([2,2]);\n\tassert Montana([-2,3,4,3,-2]);\n\tassert Montana([-2,3,3,-2]);\n\tassert Montana([5,6]); \n\tvar s : seq<int>;\n\ts := [];\n\tassert Montana(s);\n\tassert Montana([0,0,0,0]); \n\tassert Montana([0,0,0]); \n\tassert Montana([3,-4,-4,3]);  \n}"
},
{
    "dafny": "method MergeSort(a1:array<int>) returns (a:array<int>)\n  requires a1 != null && a1.Length > 0;\n  ensures a != null;\n  ensures forall k:: forall l:: 0 <= k < l < a.Length ==> a[k] <= a[l];\n{\n  a := ms(a1, 0, a1.Length-1);\n  return;\n}\nmethod ms(a1:array<int>, l:int, u:int) returns (a:array<int>)\n  requires a1 != null;\n  requires 0 <= l <= u < a1.Length;\n  ensures a != null && a.Length == a1.Length;\n  ensures forall elem1:: forall elem2:: l <= elem1 <= elem2 <= u ==> a[elem1] <= a[elem2];\n  decreases u - l;\n  decreases u;\n{\n  a := new int[a1.Length];\n  assume forall k:: 0 <= k < a1.Length ==> a[k] == a1[k];\n  if (l >= u)\n  {\n    return;\n  }\n  else\n  {\n    var m:int := (l + u) / 2;\n    a := ms(a, l, m);\n    a := ms(a, m+1, u);\n    a := merge(a, l, m, u);\n    return;\n  }\n}\nmethod merge(a1:array<int>, l:int, m:int, u:int) returns (a:array<int>)\n  requires a1 != null;\n  requires 0 <= l <= m < u < a1.Length;\n  ensures a != null && a.Length == a1.Length;\n  ensures forall elem1:: forall elem2:: l <= elem1 <= elem2 <= u ==> a[elem1] <= a[elem2];\n{\n  a := new int[a1.Length];\n  assume forall k:: 0 <= k < a1.Length ==> a[k] == a1[k];\n  var buf := new int[u-l+1];\n  var i:int := l;\n  var j:int := m + 1;\n  var k:int := 0;\n  while (k < u-l+1)\n\tinvariant m + 1 <= j <= a.Length;\n\tinvariant l <= i <= m + 1;\n\tinvariant k == i - l + j - m - 1;\n\tinvariant i > m ==> j < a.Length || k > u-l;\n\tdecreases u-l-k;\n  {\n    if (i > m)\n    {\n      buf[k] := a[j];\n      j := j + 1;\n    }\n    else if (j > u)\n    {\n      buf[k] := a[i];\n      i := i + 1;\n    }\n    else if (a[i] <= a[j])\n    {\n      buf[k] := a[i];\n      i := i + 1;\n    }\n    else\n    {\n      buf[k] := a[j];\n      j := j + 1;\n    }\n    k := k + 1;\n  }\n  assume k == buf.Length;\n  assume forall elem1:: forall elem2:: 0 <= elem1 <= elem2 < k ==> buf[elem1] <= buf[elem2];\n  k := 0;\n  while (k < u-l+1)\n\tinvariant 0 <= k <= u - l + 1 == buf.Length;\n\tinvariant forall elem1:: l <= elem1 < k + l ==> a[elem1] == buf[elem1 - l]; \n\tinvariant forall elem1:: forall elem2:: 0 <= elem1 <= elem2 < buf.Length ==> buf[elem1] <= buf[elem2];\n\tinvariant forall elem1:: forall elem2:: 0 <= elem1 <= elem2 < k ==> buf[elem1] <= buf[elem2]; \n\tinvariant forall elem1:: forall elem2:: l <= elem1 <= elem2 < k + l ==> a[elem1] <= a[elem2];\n\tdecreases u-l-k;\n  {\n    a[l + k] := buf[k];\n    k := k + 1;\n  }\n}"
},
{
    "dafny": "ghost function f(n: int): int {\n  if n <= 0 then 1 else n + f(n-1)*f(n-2)\n}\nghost function fSum(n: nat): int {\n  if n <= 0 then 0 else f(n-1) + fSum(n-1)\n}\nmethod problem6(n:nat) returns (a: int)\nensures a == fSum(n)\n{\n  a := 0;\n  var k := 0;\n  var x := 1;\n  var y := 2;\n  while k < n\n  invariant 0 <= k <= n && x == f(k) && y == f(k+1) && a == fSum(k)\n  decreases n-k\n  {\n    assert x == f(k) && y == f(k+1) && a == fSum(k);\n    k := k + 1;\n    assert x == f(k-1) && y == f(k) && a == fSum(k-1);\n    assert x == f(k-1) && y == f(k) && a == fSum(k) - f(k-1);\n    a := a + x;\n    assert x == f(k-1) && y == f(k) && a == fSum(k) - f(k-1) + f(k-1);\n    assert x == f(k-1) && y == f(k) && a == fSum(k);\n    x, y := y, k+1 + x*y;    \n    assert x == f(k) && y == k+1+f(k-1)*f(k) && a == fSum(k);\n    assert x == f(k) && y == k+1+f(k+1-2)*f(k+1-1) && a == fSum(k);\n    assert x == f(k) && y == f(k+1) && a == fSum(k);\n  }\n  assert a == fSum(k);\n}"
},
{
    "dafny": "module Sets {\n  lemma {:opaque} ProperSubsetImpliesSmallerCardinality<T>(a: set<T>, b: set<T>)\n    requires a < b\n    ensures |a| < |b|\n  {\n    assert |b| == |a| + |b-a|;\n  }\n  lemma {:opaque} SetInclusionImpliesSmallerCardinality<T>(a: set<T>, b: set<T>)\n    requires a <= b\n    ensures |a| <= |b|\n  {\n    assert b == a + (b - a);\n  }\n  lemma {:opaque} SetInclusionImpliesStrictlySmallerCardinality<T>(a: set<T>, b: set<T>)\n    requires a < b\n    ensures |a| < |b|\n  {\n    assert b == a + (b - a);\n  }\n  lemma {:opaque} SetInclusionAndEqualCardinalityImpliesSetEquality<T>(a: set<T>, b: set<T>)\n    requires a <= b\n    requires |a| == |b|\n    ensures a == b\n  {\n    assert b == a + (b - a);\n  }\n  function SetRange(n: int) : set<int>\n  {\n    set i | 0 <= i < n\n  }\n  lemma CardinalitySetRange(n: int)\n  requires n >= 0\n  ensures |SetRange(n)| == n\n  {\n    if n == 0 {\n    } else {\n      CardinalitySetRange(n-1);\n      assert SetRange(n)\n          == SetRange(n-1) + {n-1};\n    }\n  }\n}"
},
{
    "dafny": "ghost predicate P(x: int, y: int)\nghost predicate Q(x: int)\nghost predicate R(x: int)\nmethod M() {\n  assert forall x, y :: true || P(x, y) || Q(y) || R(x);\n  assert forall x, y :: true || Q(y) || P(x, y) || R(x);\n  assert forall x, y :: true || Q(y) || R(x) || P(x, y);\n}\nghost predicate PP(x: int, y: int, z: int)\nghost predicate QQ(x: int, y: int)\nghost predicate RR(x: int, y: int)\nghost predicate SS(x: int, y: int)\nmethod MM() {\n  assert forall x, y, z, u, v, w :: true || PP(x, y, z) || QQ(x, u) || RR(y, v) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || PP(x, y, z) || RR(y, v) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || RR(y, v) || PP(x, y, z) || SS(z, w);\n  assert forall x, y, z, u, v, w :: true || QQ(x, u) || RR(y, v) || SS(z, w) || PP(x, y, z);\n}"
},
{
    "dafny": "method insertionSort(a: array<int>) \n    modifies a\n    ensures isSorted(a, 0, a.Length)\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    var i := 0;\n    while i < a.Length \n        decreases a.Length - i \n        invariant 0 <= i <= a.Length\n        invariant isSorted(a, 0, i)\n        invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n        var j := i;\n        while j > 0 && a[j-1] > a[j] \n            decreases j\n            invariant 0 <= j <= i \n            invariant multiset(a[..]) == multiset(old(a[..]))\n            invariant forall l, r :: 0 <= l < r <= i && r != j ==> a[l] <= a[r]\n        {\n            a[j-1], a[j] := a[j], a[j-1];\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n}\npredicate isSorted(a: array<int>, from: nat, to: nat)\n  reads a\n  requires 0 <= from <= to <= a.Length\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j]\n}\nmethod testInsertionSort() {\n  var a := new int[] [ 9, 4, 3, 6, 8];\n  assert a[..] == [9, 4, 3, 6, 8];\n  insertionSort(a);\n  assert a[..] == [3, 4, 6, 8, 9];\n}"
},
{
    "dafny": "function f(x: int): int\nlemma {:axiom} f_positive(x: int)\n  requires x >= 0\n  ensures f(x) >= 0\nlemma f_2_pos()\n  ensures f(2) >= 0\n{\n  f_positive(2);\n}\nlemma f_1_1_pos()\n  ensures f(1 + 1) >= 0\n{\n  f_2_pos();\n  assert 1 + 1 == 2;\n}"
},
{
    "dafny": "datatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | c.x % 2 == 0 witness Cell(0)\nfunction doubleEvenCell(c: EvenCell): int\n{\n  if c.x % 2 == 1 then 1/0 else c.x * 2\n}\nmethod Main() {\n  var x: set<Cell> := { Cell(1), Cell(2), Cell(3), Cell(4) };\n  var y := set c: EvenCell | c in x;\n  var b := forall c :: c in y ==> doubleEvenCell(c) > 0;\n  assert b;\n  print b;\n}"
},
{
    "dafny": "module Optional {\n    datatype Option<T> = Some(v: T) | None {\n        function Unwrap() : T\n        requires this.Some? {\n            this.v\n        }\n        function UnwrapOr(default: T) : T {\n            match this\n            case Some(v) => v\n            case none => default\n        }\n    }\n}"
},
{
    "dafny": "method GenericMax<A>(cmp: (A, A) -> bool, a: array<A>) returns (max: A)\n  requires a != null && a.Length > 0\n  requires forall x, y :: cmp.requires(x, y)\n  requires forall x, y :: cmp(x, y) || cmp(y, x);\n  requires forall x, y, z :: cmp(x, y) && cmp(y, z) ==> cmp(x, z);\n  ensures forall x :: 0 <= x < a.Length ==>\n    cmp(a[x], max)\n{\n  max := a[0];\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall x :: 0 <= x < i ==> cmp(a[x], max)\n  {\n    if !cmp(a[i], max) {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "predicate sorted(s: seq<int>) {\n\tforall i, j :: 0 <= i <= j < |s| ==> s[i] <= s[j]\n}\npredicate member(s: seq<int>, n: int) {\n\texists i :: 0 <= i <|s| && s[i] == n\n}\n function log2(size:int) : (result:int)\n    requires 1 <= size\n    ensures 0 <= result\n {\n     if (size == 1) then 0\n     else 1 + log2(size/2)\n }\nmethod binsearch(s: seq<int>, n: int) returns (found:bool, steps: int)\n\trequires sorted(s)\n    requires 1 <= |s|\n\tensures !found ==> !member(s, n)\t\t\t\t\t\t\t\t\t\t\n\tensures found ==> member(s, n)\n{\n    steps := 0;\n    assert steps <= log2(|s|);\n\tvar lo := 0;\n\tvar hi := |s| - 1;\n\tvar mid := 0;\n    var size := |s|;\n    var maxAttempts := log2(size);\n\tfound := false;\n\twhile(lo <= hi && !found)\n\t\tdecreases hi-lo + (if found then 0 else 1)\t\t\t\t\t\t\t\n        decreases size\n\t\tinvariant 0 <= lo <= |s| && -1 <= hi < |s| \n\t\tinvariant !member(s[..lo],n)\t\t\t\t\t\t\t\t\t\t\n\t\tinvariant !member(s[hi+1..],n)\n\t\tinvariant found ==> member(s, n)\t\t\t\t\t\t\n\t{\n\t\tmid := (hi + lo)/2;\n\t\tif (s[mid] == n) { \n\t\t\tfound := true;\n\t\t} else if (s[mid] < n) {\n\t\t\tlo := mid + 1;\n\t\t} else {\n\t\t\thi := mid - 1;\n\t\t}\n        steps := steps + 1;\n\t}\n}\nmethod binsearchInd(s: seq<int>, n:int) returns (ind:int)\n\trequires sorted(s)\n\tensures ind < 0 ==> !member(s, n)\t\t\t\t\t\t\t\t\t\t\n\tensures 0 <= ind ==> (ind < |s| && s[ind] == n)\t\t\t\t\t\t\t\n{\n\tif |s| == 0 { return -1; }\n\tvar lo := 0;\n\tvar hi := |s| - 1;\n\tvar mid := 0;\n\tind := -1;\n\twhile(lo <= hi && ind < 0)\n\t\tdecreases hi-lo + (if 0 <= ind then 0 else 1);\t\t\t\t\t\t\n\t\tinvariant 0 <= lo <= |s| && -1 <= hi < |s| && 0 <= mid < |s|\t\t\n\t\tinvariant !member(s[..lo],n)\t\t\t\t\t\t\t\t\t\t\n\t\tinvariant !member(s[hi+1..],n)\t\t\t\t\t\t\t\t\t\t\n\t\tinvariant -1 <= ind < |s|\t\t\t\t\t\t\t\t\t\t\t\n\t\tinvariant 0 <= ind ==> s[ind] == n\t\t\t\t\t\t\t\t\t\n\t{\n\t\tmid := lo + (hi - lo)/2;\n\t\tif (s[mid] == n) { \n\t\t\tind := mid;\n\t\t} else if (s[mid] < n) {\n\t\t\tlo := mid + 1;\n\t\t} else {\n\t\t\thi := mid - 1;\n\t\t}\n\t}\n}"
},
{
    "dafny": "method x(n: nat, m: nat) returns (prod: nat)\n    ensures prod == n * m;    \n{\n    var i : nat:= n;\n    var a: nat := 0;\n    while (i > 0)\n        invariant a + i * m == m * n;\n    {\n        a := a + m;\n        i := i - 1;\n    }\n    prod := a;\n    return;\n}\nmethod Main()\n{\n    var s1 := { 1, 2, 3 };\n    var s2 := set n | 0 <= n <= 999_999;\n    var c1 := | s2 |;\n    var ps1 := set s | s <= s1;\n    var ri := set ss1, ss2 | ss1 in ps1 && ss2 in ps1 && ss1 <= ss2 :: (ss1,ss2);\n}"
},
{
    "dafny": "method occurences(items: array<int>,item: nat) returns (r: nat)\n  requires items != null\n  ensures r > 0  ==> exists k: nat :: k < items.Length && items[k] == item\n  ensures r == 0 ==> forall k: nat :: k < items.Length ==> items[k] != item\n{\n  var i: nat := 0;\n  var count: nat := 0;\n  while i < items.Length\n    invariant i <= items.Length\n    invariant count > 0  ==> exists k: nat :: k < i && items[k] == item\n    invariant count == 0 ==> forall k: nat :: k < i ==> items[k] != item\n  {\n    if items[i] == item\n      { count := count + 1; }\n    i := i + 1;\n  }\n  return count;\n}"
},
{
    "dafny": "abstract module VectorCommitmentScheme {\n    type Message(==,!new)\n    type Commitment(==,!new)\n    type Opening(!new)\n    function Commit(vec: seq<Message>) : Commitment\n    requires |vec| > 0\n    function Open(vec: seq<Message>, i: nat) : Opening\n    requires i < |vec|\n    predicate Verify(c: Commitment, o: Opening, i: nat, m: Message)\n    lemma Completeness(vec: seq<Message>, c: Commitment, o: Opening, i: nat)\n    requires i < |vec|\n    requires Commit(vec) == c\n    requires Open(vec,i) == o\n    ensures Verify(c,o,i,vec[i])\n}"
},
{
    "dafny": "predicate permutacao (a:seq<int>, b:seq<int>)\n{\n    multiset(a) == multiset(b)\n}\npredicate ordenadoEntre(a:array<int>, e:int, d:int)\nrequires 0 <= e <= d <= a.Length\nreads a\n{\n    forall i,j ::e <= i <= j < d ==> a[i] <= a[j]\n}\npredicate ordenado(a:array<int>)\nreads a\n{\n    ordenadoEntre(a,0,a.Length)\n}\nmethod bubbleSort(a:array<int>)\nensures ordenado(a)\nensures permutacao(a[..], old(a[..]))\nmodifies a\n{\n    if a.Length > 1\n    {\n        var i := 1;\n        while i < a.Length\n        invariant 1 <= i <= a.Length\n        invariant ordenadoEntre(a,0,i)\n        invariant permutacao(a[..], old(a[..]))\n        {\n            bubbleStep(a,i);\n            i := i + 1;\n        }\n    }\n}\nmethod bubbleStep(a: array<int>, i: int)\nrequires 0 <= i < a.Length\nrequires ordenadoEntre(a,0,i)\nensures ordenadoEntre(a,0,i+1)\nensures permutacao(a[..], old(a[..]))\nmodifies a\n{\n    var j := i;\n    while j>0 && a[j-1] > a[j]\n    invariant 0 <= j <= i\n    invariant ordenadoEntre(a,0,j) && ordenadoEntre(a,j,i+1)\n    invariant 1 < j + 1 <= i ==> a[j-1] <= a[j+1]\n    invariant permutacao(a[..], old(a[..]))\n    {\n        a[j-1], a[j] := a[j], a[j-1];\n        j := j - 1;\n    }\n}"
},
{
    "dafny": "function R(n: nat): nat \n    decreases n\n{\n    if n == 0 then 0 else if R(n-1) > n then R(n-1) - n else R(n-1) + n\n}\nmethod calcR(n: nat) returns (r: nat)\n    ensures r == R(n) \n{\n    r := 0;\n    var i := 0;\n    while i < n \n        decreases n - i\n        invariant 0 <= i <= n && r == R(i)\n    {\n      assert i < n && 0 <= i <= n && r == R(i); \n      assert (r > i + 1 && 0 <= i + 1 <= n && r - i - 1 == R(i + 1)) || (r <= i + 1 && 0 <= i + 1 <= n && r + i + 1 == R(i + 1)); \n        i := i + 1;\n      assert (r > i && 0 <= i <= n && r - i == R(i)) || (r <= i && 0 <= i <= n && r + i == R(i)); \n        if r > i {\n            r := r - i;\n        } \n        else {\n            r := r + i;\n        }\n      assert 0 <= i <= n && r == R(i); \n    }\n}"
},
{
    "dafny": "class Node_q\n{\n    var next: Node_q?;\n    var value: int;\n    constructor()\n    ensures this.next == null\n    {\n        this.next := null;\n    }\n}\nmethod Main()\n{\n    var n1 := new Node_q();\n    var n2 := new Node_q();\n    var n3 := new Node_q();\n    n1.value := 1;\n    n1.next := n2;\n    n2.value := 2;\n    n2.next := n3;\n    n3.value := 3;\n    n3.next := null;\n    var expr := n1.next.next;\n    var anotherNode := new Node_q();\n    anotherNode.value := 44;\n    anotherNode.next := null;\n    assert expr != null;\n}"
},
{
    "dafny": "method max(a:array<int>) returns(max:int)\n    requires a != null;\n    ensures forall j :: j >= 0 && j < a.Length ==> max >= a[j]; \n    ensures a.Length > 0 ==> exists j :: j >= 0 && j < a.Length && max == a[j]; \n{\n    if (a.Length == 0)  { \n        max := 0;\n        return;\n    }\n    max := a[0];\n    var i := 1;\n    while i < a.Length\n        invariant i <= a.Length \n        invariant forall j :: 0 <= j < i ==> max >= a[j] \n        invariant exists j :: 0 <= j < i && max==a[j]    \n    {\n        if a[i] > max\n        {\n            max := a[i];\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method ZYXW() returns (ABCD:int, EFGH:int)\n{\n  ABCD, EFGH := 0, 191;\n  while 7 <= EFGH\n    invariant 0 <= EFGH && 7 * ABCD + EFGH == 191\n  {\n    ABCD := ABCD+1;\n    EFGH:=191-7*ABCD;\n  }\n}"
},
{
    "dafny": "method breakParagraphs(n: nat, b: bool, r: nat)\n  requires r > 0\n{\n   var R1 := 0;\n   var R2 := 0;\n   var i := 0;\n   var m := 0;\n   while i < n\n      invariant m <= n; \n      invariant R1+m <= i; \n   {\n      i := i + r;\n      if (i < n) {\n          if (b) {\n            m := m + r;\n          } else {\n            R1 := R1 + m;\n            assert R1 <= n; \n            m := 0;\n          }\n      }\n   }\n   assert 0<= m <= n; \n   R2 := R2 + m;\n   assert R2 <= n; \n}"
},
{
    "dafny": "method M0(t: map<int, int>, k: int)\n  requires k in t\n{\n  if * {\n    assert |t| == |t - {k}| + 1;\n  } else if * {\n    assume t.Items == {(1, 2), (3, 4)};\n    assert |t| == 2;\n  } else {\n    assume t.Values == {2, 3, 4};\n    assert |t| >= 2;\n  }\n}\nmethod M0'(t: map<int, int>, k: int)\n  requires k in t\n{\n  if * {\n    var _ := |(t - {k}).Keys|;\n    assert |t| == |t - {k}| + 1;\n  } else if * {\n    assume t.Items == {(1, 2), (3, 4)};\n    var _ := |t.Items|;\n    assert |t| == 2;\n  } else {\n    assume t.Values == {2, 3, 4};\n    assert |t.Values| >= 2;\n  }\n}"
},
{
    "dafny": "method flip (a: array<int>, num: int)\nrequires num >= 0 && num<= a.Length-1;\nmodifies a;\nensures forall i:: 0 <= i <=num==> a[i] == old(a[num-i]) && a[num-i]==old(a[i]);\nensures forall i:: num<i<=a.Length-1 ==> a[i] == old(a[i])\n{ \n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\n  invariant 0<=i<=num;\n  invariant 0<=j<=num;\n  invariant i+j==num;\n  invariant forall z :: i<=z<=j==>a[z]==old(a[z]);\n  invariant forall z :: 0 <= z < i || j < z <= num ==> a[num-z] == old(a[z]) && a[z] == old(a[num-z]);\n  invariant forall z:: num<z<=a.Length-1 ==> a[z] == old(a[z])\n  decreases j;\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}"
},
{
    "dafny": "lemma d()\n{\n  var a: int := 0x0000_0000_0000_BEEF;\n  var testbv: bv16 := a as bv16;\n  var testval: int := testbv as int;\n  assert testval == a; \n}\nlemma e()\n{\n  var a: int := 0x0000_0000_0000_00EF;\n  var testbv: bv8 := a as bv8;\n  var testval: int := testbv as int;\n  assert testval == a; \n}"
},
{
    "dafny": "function pow(x: int, n: nat): int {\n  if (n == 0) then\n    1\n   else\n    x * pow(x, n - 1)\n}\nlemma powexplemma(x: int, n: nat)\n  ensures pow(x, n) * pow(x, n) == pow(x, n + n)\n{\n  if (n > 0) {\n    powexplemma(x, n-1);\n  }\n}\nlemma powbaselemma(x: int, n: nat)\n  ensures pow(x, n) * pow(x, n) == pow(x * x, n)\n{\n  if (n > 0) {\n    powbaselemma(x, n-1);\n  }\n}\nmethod rpow(x: int, n: nat) returns (res: int)\n  ensures res == pow(x, n)\n{\n  var xx: int := x;\n  var nn: nat := n;\n  var rr: int := 1;\n  while nn > 0\n    decreases nn\n    invariant pow(x,n) == rr * pow(xx, nn)\n  {\n    if (nn % 2 == 1) {\n      rr := xx * rr;\n    }\n    nn := nn / 2;\n    if (nn > 0) {\n      var x0: int := xx;\n      xx := xx * xx;\n      calc {\n            pow(xx, nn);\n         == pow(x0 * x0, nn);\n         == { powbaselemma(x0, nn); }\n            pow(x0, nn) * pow(x0, nn);\n         == { powexplemma(x0, nn); }\n            pow(x0, nn + nn);\n      }\n    }\n  }\n  return rr;\n}"
},
{
    "dafny": "method product(m: int, n: int) returns(result: int)\n  requires n >= 0\n  ensures result == m*n\n  {\n    var x := m;\n    var y := n;\n    result := 0;\n    while(y != 0)\n      invariant x*y+result == m*n\n      invariant y >= 0\n      decreases y\n      {\n      if(y%2 == 0){\n        double_and_halve(x, y/2);\n        x := x + x;\n        y := y/2;\n      }\n      else{\n        result := result + x;\n        y := y - 1;\n      }\n    }\n    return result;\n  }\nfunction prod(m: int, n: int): int\n  {\n    m*n\n  }\nlemma double_and_halve(m:int, n:int)\n  requires n >= 0\n  ensures prod(m, 2 * n) == prod(m + m, n);\n  {\n    if (n != 0)\n    {\n      double_and_halve(m, n - 1);\n    }\n  }"
},
{
    "dafny": "method swap (v : array<int>, i : int, j : int) \nrequires 0 <= i < v.Length && 0 <= j < v.Length\nensures old(v[i])==v[j] && old(v[j])==v[i]\nmodifies v\n{\n\tvar aux := v[i];\n\tv[i] := v[j];\n\tv[j] := aux;\n}\npredicate par (n : int)\n{n%2 == 0}\nmethod verificaPar (v : array<int>) returns (b : bool)\nrequires v.Length > 0\nensures b == forall w :: 0 <= w < v.Length ==> par(v[w])\n{\n\tvar i := 0;\n\twhile (i < v.Length && v[i]%2 == 0) \n\tinvariant 0 <= i <= v.Length\n\tinvariant forall w :: 0 <= w < i ==> par(v[w])\n\t{\n\t\ti := i + 1;\n\t}\n\tb := i == v.Length;\n}\nmethod maximo (v : array<int>) returns (m : int)\nrequires v.Length > 0\nensures forall w:: 0<=w<v.Length ==> m >= v[w]\nensures exists k :: 0<=k<v.Length && v[k]==m\n{\n\tvar i := 1;\n\tm := v[0];\n\twhile (i < v.Length) \n\tinvariant 0 <= i <= v.Length\n\tinvariant forall k :: 0 <= k < i ==> m >= v[k]\n\tinvariant m in v[..i]\n\tdecreases v.Length - i\n\t{\n\t\tif (m < v[i]) {m := v[i];}\n\t\ti := i+1;\n\t}\n}"
},
{
    "dafny": "method Skippy(limit: nat)\n{\n    var skip := 7;\n    var index := 0;\n    while index<=limit\n        invariant index % 7 == 0 && 0 <= index <= (limit/7 + 1) * 7;\n        decreases  limit - index\n    { index := index+skip; }\n    assert index % 7 == 0 && index == (limit/7 + 1) * 7 ;\n}"
},
{
    "dafny": "class CircularBuffer{\n  var buffer : array?< int >;\n  var capacity : int ;\n  var size : int ;\n  var start : int ;\n  predicate Valid()\n  reads this , this .buffer;\n  {\n    buffer != null &&\n    capacity > 0 && buffer.Length == capacity &&\n    0 <= start < buffer.Length &&\n    0 <= size <= capacity\n  }\n  constructor(cap: int , startInd : int )\n  requires cap > 0 && 0 <= startInd < cap;\n  ensures fresh (buffer);\n  ensures Valid();\n  ensures start == startInd;\n  ensures forall i :: 0 <= i < buffer.Length ==> buffer[i] == 0;\n  {\n    size := 0;\n    capacity := cap;\n    start := startInd;\n    buffer := new int [cap](_ => 0);\n  }\n  method Add(elem : int )\n  modifies this, this.buffer ;\n  requires Valid() ;\n  requires size < capacity ;\n  ensures Valid() ;\n  ensures size == old (size)+1;\n  ensures exists i :: 0 <= i < buffer.Length && buffer[i] == elem;\n  {\n    var i := start+size;\n    buffer[i%capacity] := elem;\n    size := size+1;\n  }\n}"
},
{
    "dafny": "method Study(n: nat, h: nat)\n    decreases n , h\n{\n    if h != 0 {\n        Study(n, h - 1);\n    } else if n == 0 {\n    } else {\n        var hours := RequiredStudyTime(n - 1);\n        Study(n - 1, hours);\n    }\n}\nmethod RequiredStudyTime(c: nat) returns (hours: nat)\n    ensures hours <= 200"
},
{
    "dafny": "ghost method M()\n{\n   ghost var s := iset{2};\n   if(2 in s)\n   {\n   }\n   else\n   { assert false; }\n   if(3 !in s)\n   {\n   }\n   else\n   { assert false; }\n   if(s == iset{2})\n   {\n   }\n   else\n   { assert false; }\n}\nghost method m1() {\n var s1:iset<int> := iset{}; \n var s2 := iset{1, 2, 3}; \n assert s2 == iset{1,1,2,3,3,3,3}; \n var s3, s4 := iset{1,2}, iset{1,4};\n assert s2 + s4 == iset{1,2,3,4}; \n assert s2 * s3 == iset{1,2} && s2 * s4 == iset{1}; \n assert s2 - s3 == iset{3}; \n assert (iset x | x in s2 :: x+1) == iset{2,3,4}; \n assert 17 in (iset x: int | true :: x); \n assert (imap x: int | true :: x+1)[14] == 15;\n}"
},
{
    "dafny": "method ComputeFact(n : nat) returns (res : nat)\n  requires n > 0;\n  ensures res == fact(n);\n {\n  res := 1;\n  var i := 2;\n  while (i <= n)\n  decreases (n-i)\n  invariant 2 <= i <= n+1\n  invariant res == fact(i-1)\n  {\n    res := res * i;\n    i := i + 1;\n  }\n }\n function fact(m : nat) : nat {\n    if m <= 1 then 1 else m * fact(m - 1)\n }"
},
{
    "dafny": "method A(a: int) returns (x: int)\n{\n    if * {\n    assert true;\n    } else if * {\n    assert true;\n    } else {\n    assert true;\n    }\n    if\n    case true =>  x := 1;\n    case true =>  x := 2;\n    case true =>  x := 3;\n}\nmethod Main()\n{\n    var a := A(1);\n    print a;\n}"
},
{
    "dafny": "predicate sorted(a: array<int>)\n   requires a != null;\n   reads a;\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\npredicate sorted_slice(a: array<int>, l:int, h:int)\n  requires a != null;\n  reads a;\n{\n  forall j, k :: l <= j < k <= h && 0 <= j && k < a.Length ==> a[j] <= a[k]\n}\npredicate permutation(a: seq<int>, a0: seq<int>, perm: seq<int>)\n{\n  (|perm| == |a| && |perm| == |a0|)\n  && (forall k :: 0 <= k && k < |perm| ==> 0 <= perm[k] && perm[k] < |perm|)\n  && (forall k, t :: 0 <= k && k < t && t < |perm| ==> perm[k] != perm[t])\n  && (forall k :: 0 <= k && k < |perm| ==> a[k] == a0[perm[k]])\n}\nmethod id_perm(a: array<int>) returns (ghost perm: seq<int>)\n  requires a != null;\n  ensures permutation(a[..], old(a[..]), perm);\n{\n  var n := a.Length;\n  var i := 0;\n  perm := [];\n  while (i < n)\n    invariant i <= n;\n    invariant |perm| == i;\n    invariant forall k :: 0 <= k && k < i ==> perm[k] == k;\n  {\n    perm := perm + [i];\n    i := i + 1;\n  }\n}\nmethod push(a: array<int>, n: int, ghost a0: seq<int>, ghost perm: seq<int>) returns (s: bool, ghost p: seq<int>)\n  requires a != null;\n  requires 0 < n <= a.Length;\n  requires sorted_slice(a, n, a.Length - 1);\n  requires forall j, k :: 0 <= j < n && n <= k < a.Length ==> a[j] <= a[k];\n  requires permutation(a[..], a0, perm);\n  modifies a;\n  ensures n <= 1 ==> !s;\n  ensures permutation(a[..], a0, p);\n  ensures sorted_slice(a, n - 1, a.Length - 1);\n  ensures forall j, k :: 0 <= j < n - 1 && n - 1 <= k < a.Length ==> a[j] <= a[k];\n  ensures !s ==> sorted_slice(a, 0, n - 1);\n{\n  var i := 1;\n  s := false;\n  p := perm;\n  while (i <= n - 1)\n    invariant 1 <= i && i <= n;\n    invariant permutation(a[..], a0, p);\n    invariant n <= 1 ==> !s;\n    invariant sorted_slice(a, n, a.Length - 1);\n    invariant forall j, k :: 0 <= j < n && n <= k < a.Length ==> a[j] <= a[k];\n    invariant forall j :: 0 <= j <= i - 1 ==> a[j] <= a[i - 1]; \n    invariant !s ==> sorted_slice(a, 0, i - 1);\n    {\n      if (a[i - 1] > a[i]) {\n        ghost var t := p[i];\n        p := p[i := p[i - 1]];\n        p := p[i - 1 := t];\n        a[i - 1], a[i] := a[i], a[i - 1];\n        s := true;\n      }\n      i := i + 1;\n    }\n}\nmethod bubble(a: array<int>) returns (ghost perm: seq<int>)\n  requires a != null;\n  modifies a;\n  ensures sorted(a);\n  ensures permutation(a[..], old(a[..]), perm);\n{\n  var n: nat;\n  var s;\n  perm := id_perm(a);\n  n := a.Length;\n  s := a.Length > 0;\n  while (s)\n    invariant permutation(a[..], old(a[..]), perm);\n    invariant sorted_slice(a, n, a.Length - 1);\n    invariant forall j, k :: 0 <= j < n && n <= k < a.Length ==> a[j] <= a[k];\n    invariant !s ==> sorted_slice(a, 0, n);\n    invariant n > 0 || !s;\n    decreases n;\n  {\n    s, perm := push(a, n, old(a[..]), perm);\n    n := n - 1;\n  }\n}"
},
{
    "dafny": "method Main() {\n    var s := [1, 2, 3, 4, 5];\n    assert s[|s| -1] == 5;\n    assert s[|s|-1..|s|] == [5];\n    assert s[1..] == [2, 3, 4, 5];\n    assert s[..|s|-1] == [1, 2, 3, 4];\n    assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..];\n}\npredicate sorted(a: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |a| ==> a[i] < a[j]\n}"
},
{
    "dafny": "method Search( s: seq<int>, x: int ) returns ( k: int )\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n{\n    var p := 0;\n    var q := |s|;\n    if p == q\n    {\n        return p;\n    }\n    while p != q \n        decreases q-p;\n        invariant 0 <= p <= q <= |s|;\n        invariant forall r | 0 <= r < p :: s[r] <= x;\n        invariant forall r | q <= r < |s| :: s[r] >= x;\n    {\n        var m := p + (q-p)/2;\n        if s[m] == x\n        {\n            return m;\n        }\n        if s[m] < x\n        {\n            p := m+1;\n        }\n        else\n        {\n            q := m;\n        }\n    }\n    return p;\n}\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == m;\n    ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n{\n    r := [];\n    var rest := m;\n    while rest != multiset{}\n        decreases rest;\n        invariant m == multiset(r)+rest;\n        invariant forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n    {\n        var x :| x in rest;\n        rest := rest - multiset{x};\n        var k := Search(r, x);\n        r := r[..k] + [x] + r[k..];\n    }\n    return r;\n}"
},
{
    "dafny": "method Reverse(a:array<int>, n:int) returns (b:array<int>)\n    requires 0 <= n <= a.Length\n    ensures b.Length == a.Length\n    ensures forall j :: (0<= j < n) ==> b[j] == a[n-1-j]\n    ensures forall j :: (n<= j < b.Length) ==> b[j] == a[j]\n{\n    b := new int[a.Length];\n    var i := 0;\n    while i < n\n        decreases n-i\n        invariant 0 <= i <= n\n        invariant forall j :: (0<= j < i) ==> b[j] == a[n-1-j]\n    {\n        b[i] := a[n-1-i];\n        i := i + 1;\n    }\n    assert forall j :: (0<= j < n) ==> b[j] == a[n-1-j];\n    while i < a.Length\n        decreases a.Length - i\n        invariant n <= i <= a.Length\n        invariant forall j :: (0<= j < n) ==> b[j] == a[n-1-j];\n        invariant forall j :: (n <= j < i) ==> b[j] == a[j];\n    {\n        b[i] := a[i];\n        i := i + 1;\n    }\n    assert i == a.Length;\n}\nfunction isequalfromN(a:array<char>, offset:int, b:array<char>, n:int):bool\n    reads a,b\n    requires 0 <= n <= b.Length\n    requires 0 <= offset <= a.Length - n\n{\n    forall j :: 0 <= j < n ==> b[j] == a[offset+j]\n}\nmethod Equal(a:array<char>, offset:int, b:array<char>) returns (r:bool)\n    requires 0 <= offset <= a.Length - b.Length\n    ensures r <==> isequalfromN(a,offset, b, b.Length)\n{\n    var i := 0;\n    r := true;\n    while i < b.Length\n        decreases b.Length - i\n        invariant 0 <= i <= b.Length\n        invariant r <==> isequalfromN(a,offset, b, i)\n    {\n        if a[offset+i] != b[i]\n        {\n            r := false; \n            break;\n        }\n        i := i + 1;\n    }\n}\nmethod IndexOf(a:array<char>, b:array<char>) returns (pos:int)\n    requires b.Length <= a.Length \n    ensures 0 <= pos ==> pos < a.Length-b.Length && isequalfromN(a,pos,b, b.Length)\n    ensures pos == -1 ==> forall j :: 0 <= j < a.Length-b.Length ==> !isequalfromN(a,j,b,b.Length)\n{\n    var i := 0;\n    var n := a.Length - b.Length;\n    while i < n\n        decreases n - i\n        invariant 0 <= i <= n\n        invariant forall j :: 0 <= j < i ==> !isequalfromN(a,j,b,b.Length)\n    {\n        var r := Equal(a,i,b);\n        if r \n        { return i; }\n        i := i + 1;\n    }\n    return -1;\n}"
},
{
    "dafny": "function NumHosts() : nat\n  ensures NumHosts() > 0\nnewtype HostId = b: int | 0 <= b < NumHosts()\nfunction AllHosts() : set<HostId> {\n  set h:HostId | true     \n}\ndatatype Option<V> = None | Some(value:V)\ndatatype NetAction<M> = NetAction(rcv:Option<M>, send:set<M>)\ndatatype NetState<M> = NetState(messagesEverSent:set<M>)\npredicate NetInit(s:NetState) {\n  s.messagesEverSent == {}\n}\npredicate NetNext(s:NetState, s':NetState, a:NetAction) {\n  && (a.rcv.Some? ==> a.rcv.value in s.messagesEverSent)\n  && s'.messagesEverSent == s.messagesEverSent + a.send\n}"
},
{
    "dafny": "method SquareRoot(N: nat) returns (r: nat)\n  ensures r * r <= N < (r + 1) * (r + 1)\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= N\n    invariant r * r <= N\n  {\n    r := r + 1;\n  }\n}\nmethod MoreEfficientSquareRoot(N: nat) returns (r: nat)\n  ensures r * r <= N < (r + 1) * (r + 1)\n{\n  r := 0;\n  var s := 1;\n  while s <= N\n    invariant r * r <= N\n    invariant s == (r + 1) * (r + 1)\n  {\n    s := s + 2*r + 3;\n    r := r + 1;\n  }\n}"
},
{
    "dafny": "function fib(n: nat): nat\n{\n  if n < 2 then\n    n\n  else  \n    fib(n-1)+fib(n-2)\n}\nfunction F(n: nat, k: nat, m1: nat, m2: nat): nat\n  requires n >= k;\n  decreases n - k;\n{\n  if n == k then\n    m1+m2\n  else\n    F(n, k + 1, m1 + m2, m1)\n}\nfunction G(n: nat): nat\n{\n    if n<2 then n\n\telse  F(n,2,1,0)\n}\nghost method Lemma(n: nat)\n       ensures fib(n) == G(n); \n{  if n<2  \n     { } \n   else \n     { AuxLemma(n,2,1,0); }\n}\nghost method AuxLemma(n:nat,k:nat,m1:nat,m2:nat)\n\trequires 2<=k<=n && m1==fib(k-1) && m2==fib(k-2);\n\tensures fib(n)==F(n,k,m1,m2);\n\tdecreases n-k;\n{ \n  if n==k \n     { }  \n  else \n     {  AuxLemma(n,k+1,m1+m2,m1);   }\n}"
},
{
    "dafny": "datatype state = I| T| C| E\n  type client=nat\ntype boolean=bool\nclass TopC{\nvar\nx : boolean,\nn : array<state>;\nconstructor (){\n}\n}\nmethod n_Tryinv__2_0(top:TopC,i:nat,N0:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires  p__Inv4<N0\nrequires i==p__Inv4\nrequires   (top.n[i] == I)\nensures   (!((top.n[p__Inv4] == C) && (top.x == true)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := T;\n}\nmethod n_Tryinv__2_1(top:TopC,i:nat,N0:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires  p__Inv4<N0\nrequires i!=p__Inv4\nrequires (!((top.n[p__Inv4] == C) && (top.x == true)))\nrequires   (top.n[i] == I)\nensures   (!((top.n[p__Inv4] == C) && (top.x == true)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := T;\n}\nmethod n_Critinv__2_0(top:TopC,i:nat,N0:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires  p__Inv4<N0\nrequires i==p__Inv4\nrequires   ((top.n[i] == T) && (top.x == true))\nensures   (!((top.n[p__Inv4] == C) && (top.x == true)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := C;\n  top.x := false;\n}\nmethod n_Critinv__2_1(top:TopC,i:nat,N0:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires  p__Inv4<N0\nrequires i!=p__Inv4\nrequires   ((top.n[i] == T) && (top.x == true))\nensures   (!((top.n[p__Inv4] == C) && (top.x == true)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := C;\n  top.x := false;\n}\nmethod n_Exitinv__2_0(top:TopC,i:nat,N0:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires  p__Inv4<N0\nrequires i==p__Inv4\nrequires   (top.n[i] == C)\nensures   (!((top.n[p__Inv4] == C) && (top.x == true)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := E;\n}\nmethod n_Exitinv__2_1(top:TopC,i:nat,N0:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires  p__Inv4<N0\nrequires i!=p__Inv4\nrequires (!((top.n[p__Inv4] == C) && (top.x == true)))\nrequires   (top.n[i] == C)\nensures   (!((top.n[p__Inv4] == C) && (top.x == true)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := E;\n}\nmethod n_Idleinv__2_0(top:TopC,i:nat,N0:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires  p__Inv4<N0\nrequires i==p__Inv4\nrequires   (top.n[i] == E)\nensures   (!((top.n[p__Inv4] == C) && (top.x == true)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := I;\n  top.x := true;\n}\nmethod n_Idleinv__2_1(top:TopC,i:nat,N0:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires  p__Inv4<N0\nrequires i!=p__Inv4\nrequires (!((top.n[p__Inv4] == C) && (top.n[i] == E)))\nrequires   (top.n[i] == E)\nensures   (!((top.n[p__Inv4] == C) && (top.x == true)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := I;\n  top.x := true;\n}"
},
{
    "dafny": "method Main()\n{\n    var i;\n    var a := new int[][1, 3, 4, 6, 7, 8];\n    assert a[..] == [1, 3, 4, 6, 7, 8];\n    i := BinarySearch(a, 0);\n    assert i == -1;\n    i := BinarySearch(a, 1);\n    assert i ==  0;\n    i := BinarySearch(a, 2);\n    assert i == -1;\n    i := BinarySearch(a, 3);\n    assert i ==  1;\n    i := BinarySearch(a, 4);\n    assert i ==  2;\n    i := BinarySearch(a, 5);\n    assert i == -1;\n    i := BinarySearch(a, 6);\n    assert i ==  3;\n    i := BinarySearch(a, 7);\n    assert i ==  4;\n    i := BinarySearch(a, 8);\n    assert i ==  5;\n    i := BinarySearch(a, 9);\n    assert i == -1;\n    var b := new int[][5];\n    assert b[..] == [5];\n    i := BinarySearch(b, 1);\n    assert i == -1;\n    i := BinarySearch(b, 5);\n    assert i ==  0;\n    i := BinarySearch(b, 9);\n    assert i == -1;\n    var c := new int[][];\n    assert c[..] == [];\n    i := BinarySearch(c, 5);\n    assert i == -1;\n}\nmethod BinarySearch(a: array<int>, key: int) returns (i: int)\n    requires Sorted(a);\n    ensures  key !in a[..] ==> i == -1;\n    ensures  key  in a[..] ==> 0 <= i < a.Length && a[i] == key;\n{\n    var l := 0;\n    var r := a.Length - 1;\n    while l <= r\n        decreases r - l;\n        invariant 0 <= l <= r + 1 <= a.Length;\n        invariant forall i | 0 <= i < l :: a[i] != key;\n        invariant forall i | r < i < a.Length :: a[i] != key;\n    {\n        var m := (l + r) / 2;\n        if key == a[m] {\n            return m;\n        } else if key < a[m] {\n            r := m - 1;\n        } else {\n            l := m + 1;\n        }\n    }\n    return -1;\n}\npredicate Sorted(a: array<int>)\n    reads a;\n{\n    forall i, j | 0 <= i < j < a.Length :: a[i] <= a[j]\n}"
},
{
    "dafny": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0;\n    while i<v.Length && v[i]>=0\n        decreases v.Length - i \n        invariant 0<=i<=v.Length\n        invariant positive(v[..i])\n    {\n        i:=i+1;\n    }\n    b := i==v.Length;\n}\nmethod mpositive3(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositive4(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositivertl(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=v.Length-1;\n    while(i>=0 && v[i]>=0)\n        decreases i\n        invariant -1 <= i < v.Length\n        invariant positive(v[i+1..])\n    {\n        i:=i-1;\n    }\n    b:= i==-1;\n}"
},
{
    "dafny": "function RowColumnProduct(m1: array2<int>, m2: array2<int>, row: nat, column: nat): int\n    reads m1\n    reads m2\n    requires m1 != null && m2 != null && m1.Length1 == m2.Length0\n    requires row < m1.Length0 && column < m2.Length1\n{\n    RowColumnProductFrom(m1, m2, row, column, 0)\n}\nfunction RowColumnProductFrom(m1: array2<int>, m2: array2<int>, row: nat, column: nat, k: nat): int\n    reads m1\n    reads m2\n    requires m1 != null && m2 != null && k <= m1.Length1 == m2.Length0\n    requires row < m1.Length0 && column < m2.Length1\n    decreases m1.Length1 - k\n{\n    if k == m1.Length1 then\n        0\n    else\n        m1[row,k]*m2[k,column] + RowColumnProductFrom(m1, m2, row, column, k+1)\n}\nmethod multiply(m1: array2<int>, m2: array2<int>) returns (m3: array2<int>)\n    requires m1 != null && m2 != null\n    requires m1.Length1 == m2.Length0\n    ensures m3 != null && m3.Length0 == m1.Length0 && m3.Length1 == m2.Length1\n    ensures forall i, j | 0 <= i < m3.Length0 && 0 <= j < m3.Length1 ::\n        m3[i, j] == RowColumnProduct(m1, m2, i, j)\n{\n    m3 := new int[m1.Length0, m2.Length1];\n    var i := 0;\n    while i < m1.Length0\n        invariant 0 <= i <= m1.Length0\n        invariant forall i', j' | 0 <= i' < i && 0 <= j' < m2.Length1 ::\n            m3[i',j'] == RowColumnProduct(m1, m2, i', j')\n    {\n        var j := 0;\n        while j < m2.Length1\n            invariant 0 <= j <= m2.Length1\n            invariant forall i', j' | 0 <= i' < i && 0 <= j' < m2.Length1 ::\n                m3[i',j'] == RowColumnProduct(m1, m2, i', j')\n            invariant forall j' | 0 <= j' < j ::\n                m3[i,j'] == RowColumnProduct(m1, m2, i, j')\n        {\n            var k :=0;\n            m3[i, j] := 0;\n            while k < m1.Length1\n                invariant 0 <= k <= m1.Length1\n                invariant forall i', j' | 0 <= i' < i && 0 <= j' < m2.Length1 ::\n                    m3[i',j'] == RowColumnProduct(m1, m2, i', j')\n                invariant forall j' | 0 <= j' < j ::\n                    m3[i,j'] == RowColumnProduct(m1, m2, i, j')\n                invariant RowColumnProduct(m1, m2, i, j) ==\n                    m3[i,j] + RowColumnProductFrom(m1, m2, i, j, k)\n            {\n                m3[i,j] := m3[i,j] + m1[i,k] * m2[k,j];\n                k := k+1; \n            }\n            j := j+1;\n        }\n        i := i+1;\n    }\n}"
},
{
    "dafny": "datatype natr = Zero | Succ(natr)\nfunction add(x: natr, y: natr): natr\n{\n  match x\n  case Zero => y\n  case Succ(x') => Succ(add(x', y))\n}\nlemma prop_add_Zero(x: natr)\n  ensures add(x, Zero) == x;\n{ }\nlemma prop_add_Succ(x: natr, y: natr)\n  ensures Succ(add(x, y)) == add(x,Succ(y));\n{ }\nlemma prop_add_comm(x: natr, y: natr)\n  ensures add(x, y) == add(y, x)\n{\n  match x {\n    case Zero => \n      calc {\n        add(Zero, y);\n        ==\n        y;\n        == { prop_add_Zero(y); }\n        add(y, Zero);\n    }\n    case Succ(x') =>\n      calc {\n        add(x,y);\n        ==\n        { assert x == Succ(x'); }\n        add(Succ(x'), y);\n        ==\n        Succ(add(x', y));\n        =={ prop_add_comm(x', y); }\n        Succ(add(y, x'));\n        == \n        add(y, Succ(x'));\n      }\n  }\n}"
},
{
    "dafny": "function fat(n:nat) : nat {\n    if n == 0\n    then 1\n    else n * fat(n-1)\n}\nmethod Fat(n:nat) returns (f:nat)\nensures f == fat(n)\n{\n    var i := n;\n    f := 1;\n    while i > 0\n    invariant f * fat(i) == fat(n)\n    {\n        f := f*i;\n        i := i-1;\n    }\n}\nmethod Mdc (a:nat, b:nat) returns (m:nat)\nrequires a > 0 && b > 0\nensures m > 0\nensures a % m == 0 && b % m == 0\nensures forall p | 0 < p :: a % p == 0 && b % p == 0 ==> p <= m\n{ m := 1;\n  var i:=2;\n  while i <= a && i <= b\n  invariant forall p | 0 < p < i :: a % p == 0 && b % p == 0 ==> p <= m\n  invariant a % m == 0 && b % m == 0\n  {\n      if a % i == 0 && b % i == 0 {\n          m := i;\n      }\n      i := i+1;\n  }\n}\nmethod MinSeq(a:seq<int>) returns (m:int) \nrequires a != []\nensures forall v | v in a :: m <= v\nensures m in a\n{\n  m := a[0];\n  var i:=1;\n  while i < |a|\n  invariant i <= |a|\n  invariant forall k | 0 <= k < i :: m <= a[k]\n  invariant m in a\n  {\n      if a[i] < m {\n          m := a[i];\n      }\n      i := i+1;\n  }\n}\nmethod MinArr(a:array<int>) returns (m:int) \nrequires a.Length > 0\nensures forall v | v in a[..] :: m <= v\nensures m in a[..]\n{\n    m := a[0];\n    var i := 1;\n    while i < a.Length\n    invariant i <= a.Length\n    invariant m in a[..]\n    invariant forall k | 0 <= k < i :: m <= a[k]\n    {\n        if a[i] < m {\n            m := a[i];\n        }\n        i := i+1;\n    }\n}\nmethod SomaUm(s:seq<int>) returns (r:seq<int>)\nensures |s| == |r|\nensures forall k | 0 <= k < |s| :: r[k] == s[k] + 1\n{\n  r:=[];\n  var i := 0;\n  while i < |s|\n  invariant i <= |s|\n  invariant |r| == i\n  invariant forall k | 0 <= k < i :: r[k] == s[k] + 1\n  { \n    r := r + [s[i]+1];\n    i := i+1;\n  }\n}\nmethod SomaUmArr(a:array<int>)\nmodifies a\nensures forall k | 0 <= k < a.Length :: a[k] == old(a[k]) + 1\n{\n  var i := 0;\n  while i < a.Length\n  invariant i <= a.Length\n  invariant forall k | 0 <= k < i :: a[k] == old(a[k]) + 1\n  invariant a[i..] == old(a[i..])\n  { \n    a[i] := a[i] + 1;\n    i := i+1;\n  }\n}\nmethod Swap(i:nat, j:nat, a:array<int>)\nmodifies a\nrequires i < a.Length && j < a.Length\nensures a[i] == old(a[j]) && a[j] == old(a[i])\nensures forall k | 0 <= k < a.Length && k != i && k != j :: a[k] == old(a[k])\n{\n    a[i], a[j] := a[j], a[i];\n}"
},
{
    "dafny": "lemma exp_even (x:real, n:nat)\n  requires n % 2 == 0;\n  ensures (exp (x, n) == exp (x*x, n/2));\n{\n  assume (false);\n}\nlemma exp_odd(x:real, n:nat)\n  requires n % 2 == 1;\n  ensures (exp (x, n) == exp (x*x, (n-1)/2)*x);\n{\n  assume (false);\n}\nfunction exp (x: real, n:nat): real\n{\n  if (x == 0.0) then 0.0\n  else if (n == 0) then 1.0\n  else x * exp(x, n-1)\n}\nmethod exp_by_sqr (x0: real, n0: nat) returns (r: real)\n  requires x0 >= 0.0;\n  ensures r == exp (x0, n0);\n{\n  if (x0 == 0.0) { return 0.0; }\n  if (n0 == 0) { return 1.0; }\n  var x, n, y  := x0, n0, 1.0;\n  while (n > 1)\n    invariant 1 <= n <= n0;\n    invariant exp (x0, n0) == exp (x, n) * y;\n  {\n    if (n % 2 == 0)\n    {\n      exp_even(x, n);\n      x := x * x;\n      n := n / 2;\n    }\n    else\n    {\n      exp_odd(x,n);\n      y := x * y;\n      x := x * x;\n      n := (n-1)/2;\n    }\n  }\n  return x * y;\n}"
},
{
    "dafny": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  requires exists i::0<=i<a.Length && a[i]==e\n  ensures 0<=n<a.Length && a[n]==e\n  ensures forall k :: 0 <= k < n ==> a[k]!=e\n{\n  n :=0;\n  while n!=a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i<n ==> e!=a[i]\n  {\n    if e==a[n]{\n      return;\n    }\n    n:=n+1;\n  }\n}"
},
{
    "dafny": "predicate isSorted(a: array<int>)\n  reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\nmethod binarySearch(a: array<int>, x: int) \n    returns (index: int)\n    requires isSorted(a)\n    ensures -1 <= index < a.Length\n    ensures index == -1 ==> x !in a[..]\n    ensures index >= 0  ==> a[index] == x\n{   \n    var low, high := 0, a.Length;\n    while low < high \n        decreases high - low\n        invariant 0 <= low <= high <= a.Length\n        invariant x !in a[..low]\n        invariant x !in a[high..]\n    {\n        var mid := low + (high - low) / 2;\n        if \n        {\n            case a[mid]  < x => low := mid + 1;\n            case a[mid]  > x => high := mid;\n            case a[mid] == x => return mid;\n        }\n    }\n    return -1;\n}\nmethod Main() {\n    var a := new int[5];\n    a[0], a[1], a[2], a[3], a[4] := 1, 5, 10, 12, 15;\n    var x0 := binarySearch(a, 4);\n    var x1 := binarySearch(a, 5);\n    assert x0 == -1;\n}"
},
{
    "dafny": "datatype Cell = Cell(x: int)\ntype CompilableNaturalCell = cn: Cell | cn.x >= 0 witness Cell(0)\ntype CompilableOrdinalCell = coc: CompilableNaturalCell | coc.x != 0 witness Cell(1)\npredicate compiledOrdinalCellIsOneOrMore(c: CompilableOrdinalCell)\n{\n  (if c.x <= 0 then 1/0 else c.x) > 1\n}\nfunction returnsOneIfCompilableOrdinalCell(c: CompilableOrdinalCell): int\n{\n  if c.x <= 0 then 1/0 else 1\n}\nfunction {:opaque} getOriginalSet(): set<Cell> {\n  { Cell(-1), Cell(0), Cell(1), Cell(2) }\n}\npredicate isSetOfCompilableOrdinalCells(s: set<CompilableOrdinalCell>) {\n  forall c :: c in s ==> returnsOneIfCompilableOrdinalCell(c) == 1\n}\nmethod Main() {\n  var x: set<Cell> := getOriginalSet();\n  var b := true;\n  b := b && isSetOfCompilableOrdinalCells(set co: CompilableOrdinalCell | co in x && compiledOrdinalCellIsOneOrMore(co) :: co);\n  assert b;\n  print if b then \"ok\" else \"error\";\n}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n{\n  index := 0;\n  while index < a.Length\n    invariant 0<=index<=a.Length\n    invariant (forall i::0 <= i < index==>a[i] != key)\n  {\n    if a[index] == key { return; }\n    index := index + 1;\n  }\n  if index >= a.Length  {\n    index := -1;\n  }\n}\nmethod TestMethod(){\n  var a1:= new int[5] [1, 2, 3, 4, 5];\n  var test1 := Find(a1, 3);\n  print(\"Test 1: Find(...) = \", test1, \"\\n\");\n  var a2:= new int[5] [5, 4, 3, 2, 1];\n  var test2 := Find(a2, 1);\n  print(\"Test 2: Find(...) = \", test2, \"\\n\");\n  var a3:= new int[5] [-2, -4, -6, -8, -10];\n  var test3 := Find(a3, -8);\n  print(\"Test 3: Find(...) = \", test3, \"\\n\");\n  var a4:= new int[5] [0, 10, 20, 30, 40];\n  var test4 := Find(a4, 60);\n  print(\"Test 4: Find(...) = \", test4, \"\\n\");\n  var a5:= new int[0] [];\n  var test5 := Find(a5, 10);\n  print(\"Test 5: Find(...) = \", test5, \"\\n\");\n}\nmethod Main(){\n  TestMethod();\n}"
},
{
    "dafny": "function count(items: seq<int>, item: int): nat\n  decreases |items|\n{\n  if |items| == 0 then 0 else\n    (if items[|items|-1] == item then 1 else 0)\n        + count( items[..|items|-1], item )\n}\nmethod occurences(items: array<int>, item: int) returns (num: nat)\n  requires items != null\n  ensures num <= items.Length\n  ensures num == count( items[..], item )\n{\n  var i: nat := 0;\n  num := 0;\n  while i < items.Length\n    invariant num <= i <= items.Length\n    invariant num == count( items[..i], item )\n  {\n    assert items[..i+1] == items[..i] + [items[i]];\n    if items[i] == item\n      { num := num + 1; }\n    i := i + 1;\n  }\n  assert items[..i] == items[..];\n}"
},
{
    "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    calc {\n      x;\n    <=  { assert x <= 0; }\n      0;\n    <  \n      1;\n    ==  \n      More(x);\n    }\n  } else {\n    calc {\n      true;\n    ==>  { Increasing(x - 2); }\n      x - 2 < More(x - 2);\n    ==  \n      x + 1 < More(x - 2) + 3;\n    ==  \n      x + 1 < More(x);\n    ==>  \n      x < More(x);\n    }\n  }\n}"
},
{
    "dafny": "method Product(m: nat, n: nat) returns (res: nat)\n  ensures res == m*n;\n{\n  var m1: nat := m;\n  res := 0;\n  while (m1!=0)\n    invariant m1 >= 0;\n    invariant res == (m - m1) * n;\n    decreases m1;\n  {\n    var n1: nat := n;\n    while (n1 != 0)\n      invariant n1 >= 0;\n      invariant res == (m - m1) * n + (n-n1);\n      decreases n1;\n    {\n      res := res+1;\n      n1 := n1-1;\n    }\n    m1 := m1-1;\n  }\n}\nmethod ProductGhost(m: nat, n: nat) returns (res: nat)\n  ensures res == m*n;\n{\n  var m1: nat := m;\n  res := 0;\n  while (m1!=0)\n    invariant m1 >= 0;\n    invariant res == (m - m1) * n;\n    decreases m1;\n  {\n    var n1: nat := n;\n    ghost var pre_res := res;\n    while (n1 != 0)\n      invariant n1 >= 0;\n      invariant res == pre_res + (n-n1);\n      decreases n1;\n    {\n      res := res+1;\n      n1 := n1-1;\n    }\n    m1 := m1-1;\n  }\n}\nmethod ProductThree(m: nat, n: nat, p: nat) returns (res: nat)\n  ensures res == m*n*p;\n{\n  var m1: nat := 0;\n  res := 0;\n  while (m1!=m)\n    invariant m1 <= m;\n    invariant res == m1*n*p;\n    decreases m - m1;\n  {\n    var n1: nat := 0;\n    ghost var res_l2 := res;\n    while (n1!=n)\n      invariant n1 <= n;\n      invariant res == res_l2 + n1*p;\n      decreases n - n1;\n    {\n      var p1: nat := 0;\n      ghost var res_l3 := res;\n      while (p1!=p)\n        invariant p1 <= p;\n        invariant res == res_l3 + p1;\n        decreases p - p1;\n      {\n        res := res+1;\n        p1 := p1+1;\n      }\n      n1 := n1+1;\n    }\n    m1:= m1+1;\n  }\n}"
},
{
    "dafny": "method Main()\n{\n  var f := F;\n  var f' := F';\n  var f'' := F'';\n  var c := InitArray(F);\n  var d := InitArray(F');\n  var e := InitArray(F'');\n  print c, d, e, \"\\n\";\n}\nfunction F(x: int): char  \n{ 'D' }\nfunction F'(x: int): char\n  requires true  \n{ 'D' }\nfunction F''(x: int): char\n  reads {}  \n{ 'D' }\nmethod InitArray<D>(f: int -> D) returns (a: D)\n{\n  return f(44);\n}"
},
{
    "dafny": "method Main()\n{\n    var a1: array<int> := new int[7];\n    a1[0], a1[1], a1[2], a1[3], a1[4], a1[5], a1[6] := 0, 10, 20, 30, 40, 50, 60;\n    var a2: array<int> := new int[7];\n    a2[0], a2[1], a2[2], a2[3], a2[4], a2[5], a2[6] := 1, 11, 23, 31, 41, 51, 61;\n    var a3: array<int> := new int[7];\n    a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6] := 2, 11, 22, 32, 42, 52, 62;\n    var donors: seq <array> := [];\n    donors := donors + [a1] + [a2] + [a3];\n    assert donors[0] == a1;\n    assert donors[1] == a2;\n    assert donors[2] == a3;\n    var s: seq<array<int>> := removeDonor(donors, 1);\n    var j : int := 0;\n    while (j < |s|) {\n        var k : int := 0;\n        while (k < s[j].Length) {\n            print s[j][k];\n            print ' ';\n            k := k + 1;\n        }\n        print '\\n';\n        j := j + 1;\n    }\n}\nmethod removeDonor(donors: seq <array<int>>, v: int) returns (updated : seq<array<int>>)\nrequires donors != []\nrequires |donors| > 0\nrequires forall r : int :: (0 <= r < |donors|  ==> donors[r] != null);\nrequires forall k : int :: (0 <= k < |donors|  ==> donors[k].Length == 7) \nrequires exists k : int :: 0 <= k < |donors|  && donors[k][0] == v \nensures forall k : int :: ( 0 <= k < |donors|   ==> ((donors[k][0] != v) ==> (donors[k] in updated)))\nensures forall k : int :: (0 <= k < |updated|  ==> (updated[k] != null));\n{\n    var i : int := 0;\n    updated := [];\n    while (i < |donors| )\n    decreases |donors|  - i\n    invariant 0 <= i <= |donors| \n    invariant forall j : int :: (0 <= j < i ==> (donors[j][0] != v) ==> (donors[j] in updated))\n    invariant forall j : int :: (0 <= j < |updated| ==> (updated[j] != null))\n    {\n       if(donors[i][0] != v){\n           updated := updated + [donors[i]];\n       }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method ArraySplit (a : array<int>) returns (b : array<int>, c : array<int>)\n  ensures fresh(b)\n  ensures fresh(c)\n  ensures a[..] == b[..] + c[..]\n  ensures a.Length == b.Length + c.Length\n  ensures a.Length > 1 ==> a.Length > b.Length\n  ensures a.Length > 1 ==> a.Length > c.Length\n{\n  var splitPoint : int := a.Length / 2;\n  b := new int[splitPoint];\n  c := new int[a.Length - splitPoint];\n  var i : int := 0;\n  while (i < splitPoint)\n    invariant 0 <= i <= splitPoint\n    invariant b[..i] == a[..i]\n  {\n    b[i] := a[i];\n    i := i + 1;\n  }\n  var j : int := 0;\n  while (i < a.Length)\n    invariant splitPoint <= i <= a.Length\n    invariant j == i - splitPoint\n    invariant c[..j] == a[splitPoint..i]\n    invariant b[..] + c[..j] == a[..i]\n  {\n    c[j] := a[i];\n    i := i + 1;\n    j := j + 1;\n  }\n}"
},
{
    "dafny": "function sorted(a:array<int>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ forall i, j:: (0 <= i < j < n) ==> a[i] <= a[j] }\nmethod binarySearch(a:array<int>, n:int, e:int) returns (z:int)\n  requires 0 < n <= a.Length\n  requires sorted(a,n)\n  ensures n > z >= 0 ==> a[z] == e\n  ensures z < 0 ==> forall k :: 0 <= k < n ==> a[k] != e \n{\n    var start := 0;\n    var end := n;\n    var mid := 0;\n    while(start < end)\n    decreases end-start;\n    invariant 0 <= start <= end <= n && 0 <= mid;\n    invariant forall j ::  0<= j < n && !(start <= j < end) ==> a[j] != e\n    {\n      mid := (start + end) / 2;     \n      if e > a[mid]{start := mid +1;}\n      else if e < a[mid]{end := mid;}\n      else{return mid;}\n    }\n    return -mid-1;\n}"
},
{
    "dafny": "function fib(n: nat): nat\ndecreases n\n{\n    if n<=1 then n else fib(n-1)+fib(n-2)\n}\nmethod fibfast(n: nat) returns (c: nat)\nrequires n>=1;\nensures c==fib(n);\n{\n    var p := 0;\n    c := 1;\n    var i := 1;\n    while(i<n)\n    invariant 1<=i<=n\n    invariant p == fib(i-1) && c == fib(i)\n    decreases (n-i)\n    {\n        var new2 := p + c;\n        p := c;\n        c := new2;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "datatype Option<T> = None | Some(value: T)\nmethod FindEntries(expenses: array<nat>) returns (result: Option<(nat, nat)>)\n    ensures\n    if result.Some?\n    then exists i, j :: 0 <= i < j < expenses.Length\n         && result.value.0 == expenses[i]\n         && result.value.1 == expenses[j]\n         && expenses[i] + expenses[j] == 2020\n    else !exists i, j :: 0 <= i < j < expenses.Length && expenses[i] + expenses[j] == 2020\n{\n    var seen := new bool[2021](i => false);\n    assert forall i :: 0 <= i < seen.Length ==> seen[i] == false;\n    var c := 0;\n    while c < expenses.Length\n        invariant 0 <= c <= expenses.Length\n        invariant forall v :: 0 <= v <= 2020 ==> (seen[v] <==> v in expenses[..c])\n        invariant !exists i, j :: 0 <= i < j < c && expenses[i] + expenses[j] == 2020\n    {\n        var val := expenses[c];\n        if 0 <= val <= 2020 {\n            var other := 2020 - val;\n            assert 0 <= other <= 2020;\n            if seen[other] {\n                assert other in expenses[..c];\n                return Option.Some((other, val));\n            }\n            seen[val] := true;\n        }\n        c := c + 1;\n    }\n    return None;\n}\nmethod ToArray<A>(s: seq<A>) returns (a: array<A>)\n    ensures a[..] == s\n{\n    a := new A[|s|](i requires 0 <= i < |s| => s[i]);\n}\nmethod Main() {\n    var expenses_data: seq<nat> := [\n        1833,\n        1949,\n        1745,\n        1863,\n        1422,\n        1980,\n        1695,\n        1233,\n        1407,\n        1971,\n        1486,\n        1922,\n        1802,\n        1689,\n        214,\n        1864,\n        1091,\n        1395,\n        1772,\n        1901,\n        1542,\n        1730,\n        1782,\n        1815,\n        1818,\n        1236,\n        1604,\n        1219,\n        1834,\n        1813,\n        1532,\n        1963,\n        2003,\n        1149,\n        1577,\n        1408,\n        1871,\n        1417,\n        1727,\n        1155,\n        1953,\n        1287,\n        1259,\n        1548,\n        1126,\n        1927,\n        1225,\n        1172,\n        11,\n        1301,\n        1869,\n        1808,\n        1238,\n        1989,\n        1027,\n        321,\n        1564,\n        636,\n        1847,\n        1877,\n        1716,\n        1275,\n        1738,\n        1054,\n        1966,\n        1019,\n        1256,\n        1940,\n        1821,\n        1914,\n        1556,\n        1389,\n        1020,\n        1293,\n        1935,\n        1804,\n        1945,\n        508,\n        1856,\n        1674,\n        1721,\n        1541,\n        1435,\n        1852,\n        1394,\n        2006,\n        1366,\n        1473,\n        1274,\n        623,\n        1701,\n        1842,\n        1954,\n        1999,\n        1195,\n        1246,\n        1967,\n        1153,\n        1851,\n        1294,\n        1152,\n        1812,\n        1732,\n        1030,\n        1956,\n        1132,\n        1948,\n        1865,\n        1835,\n        1231,\n        1975,\n        1759,\n        1843,\n        1379,\n        1657,\n        1267,\n        1062,\n        1850,\n        1817,\n        1543,\n        1805,\n        1252,\n        1974,\n        1161,\n        876,\n        1647,\n        1796,\n        1634,\n        1177,\n        1519,\n        1527,\n        1249,\n        1158,\n        2007,\n        1702,\n        1714,\n        1040,\n        1826,\n        1837,\n        1361,\n        1814,\n        1858,\n        1828,\n        1951,\n        1140,\n        1845,\n        1476,\n        1337,\n        1262,\n        1923,\n        1397,\n        1025,\n        1412,\n        1930,\n        1164,\n        1300,\n        1369,\n        1777,\n        1591,\n        1919,\n        1874,\n        1482,\n        2010,\n        1957,\n        1897,\n        1854,\n        1992,\n        1735,\n        1786,\n        1661,\n        1404,\n        1254,\n        1803,\n        1794,\n        1614,\n        1711,\n        1007,\n        1979,\n        1928,\n        1505,\n        2001,\n        1094,\n        2005,\n        1297,\n        1933,\n        1976,\n        1104,\n        1279,\n        1012,\n        1943,\n        1679,\n        1958,\n        1841,\n        1623,\n        1809,\n        1800,\n        919,\n        1620,\n        1936,\n        1209\n    ];\n    var expenses: array<nat> := ToArray(expenses_data);\n    var result := FindEntries(expenses);\n    match result {\n        case Some((x, y)) => { print x * y; }\n        case None => { print \"no solutions\\n\"; }\n    }\n}"
},
{
    "dafny": "predicate isIndex(i: int, s: string) { 0 <= i < |s| }\npredicate isPrefixF(pre: string, str: string) { |pre| <= |str| && pre == str[..|pre|] }\nmethod isPrefix(pre: string, str: string) returns (res: bool)\n    ensures res <==> isPrefixF(pre, str)\n{\n    if |str| < |pre|\n    || pre != str[..|pre|]\n    {\n        res := false;\n    }\n    else\n    {\n        res := true;\n    }\n    return res;\n}\npredicate isSubstringF(sub: string, str: string)\n{\n    |sub| == 0 ||\n    (|sub| <= |str| &&\n     (exists k | 0 <= k <= |str| - |sub|\n               :: isPrefixF(sub, str[k..])))\n}\nmethod isSubstring(sub: string, str: string) returns (res: bool)\n    ensures res <==> isSubstringF(sub, str)\n{\n    if |sub| == 0 { return true; }\n    if |sub| > |str| { return false; }\n    res := false;\n    var i := 0;\n    while i <= |str| - |sub|\n        decreases |str| - |sub| - i\n        invariant 0 <= i <= |str|\n        invariant !res <==> (forall a | 0 <= a < i :: !isPrefixF(sub, str[a..]))\n    {\n        res := isPrefix(sub, str[i..]);\n        if res { return true; } \n        i := i + 1;\n    }\n    return false;\n}\npredicate haveCommonKSubstringF(k: nat, str1: string, str2: string) {\n    k == 0 ||\n    (k <= |str1| &&\n     k <= |str2| &&\n     (exists a | 0 <= a <= |str1| - k :: isSubstringF(str1[a..][..k], str2)))\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found <==> haveCommonKSubstringF(k, str1, str2)\n{\n    if k == 0 { return true; }\n    if k > |str1| || k > |str2| { return false; }\n    found := false;\n    var i := 0;\n    while i + k <= |str1|\n        decreases |str1| - k - i\n        invariant 0 <= i <= |str1| - k + 1\n        invariant !found ==> forall a | 0 <= a < i :: !isSubstringF(str1[a..][..k], str2)\n    {\n        found := isSubstring(str1[i..][..k], str2);\n        if found { return true; }\n        i := i + 1;\n    }\n    return false;\n}\nfunction minF(a: int, b: int): int { if a < b then a else b }\nmethod min(a: int, b: int) returns (m: int)\n    ensures m == minF(a, b)\n{\n    if a < b { return a; } else { return b; }\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len: nat)\n    ensures (forall l | 0 <= l <= len :: haveCommonKSubstringF(l, str1, str2)) && (forall l | len < l :: !haveCommonKSubstringF(l, str1, str2))\n{\n    len := 0;\n    var shorter_len := min(|str1|, |str2|);\n    while len < shorter_len\n        decreases shorter_len - len\n        invariant forall l | 0 <= l <= len :: haveCommonKSubstringF(l, str1, str2)\n    {\n        var b: bool := haveCommonKSubstring(len + 1, str1, str2);\n        if !b\n        {\n            break;\n        }\n        len := len + 1;\n    }\n    return len;\n}\nmethod Main()\n{\n    print \"Running\\n\";\n    var r := maxCommonSubstringLength(\"ThisIsATest\", \"ThisIsNotATest\");\n    print r, \"\\n\";\n}"
},
{
    "dafny": "method Main() {\n  var a := new [][2, 3, -5, 2, 3];\n  var m, start := MinimumWindowMax(a, 1);\n  print \"Window size 1:  min window-max is \", m, \"\\n\";  \n  m, start := MinimumWindowMax(a, 2);\n  print \"Window size 2:  min window-max is \", m, \"\\n\";  \n  m, start := MinimumWindowMax(a, 3);\n  print \"Window size 3:  min window-max is \", m, \"\\n\";  \n  m, start := MinimumWindowMax(a, 5);\n  print \"Window size 5:  min window-max is \", m, \"\\n\";  \n}\nmethod MinimumWindowMax(a: array<int>, W: int) returns (m: int, start: int)\n  requires 1 <= W <= a.Length\n  ensures 0 <= start <= a.Length - W\n  ensures m == Max(a, start, W)\n  ensures forall s :: 0 <= s <= a.Length - W ==> m <= Max(a, s, W)\n{\n  var b := new int[a.Length];  \n  b[0] := 0;\n  var k, l := 0, 1;  \n  var n := 1;\n  while n < W\n    invariant 0 <= k < l <= n <= W\n    invariant StrictlyIncreasing(b, k, l, 0, n)\n    invariant RightmostMax(a, 0, b[k], n)\n    invariant forall u :: k < u < l ==> RightmostMax(a, b[u-1] + 1, b[u], n)\n    invariant b[l-1] == n-1\n    invariant l - k <= W  \n  {\n    while k <= l-1 && a[b[l-1]] <= a[n]\n      invariant k <= l <= n\n      invariant forall i :: (if k < l then b[l-1] + 1 else 0) <= i < n ==> a[i] <= a[n]\n    {\n      l := l - 1;\n    }\n    b[l], l := n, l + 1;\n    n := n + 1;\n  }\n  m := a[b[k]];\n  Maxes(a, 0, b[k], n);  \n  start := 0;\n  while n < a.Length\n    invariant 0 <= k < l <= n <= a.Length\n    invariant StrictlyIncreasing(b, k, l, n - W, n)\n    invariant RightmostMax(a, n - W, b[k], n)  \n    invariant forall u :: k < u < l ==> RightmostMax(a, b[u-1] + 1, b[u], n)\n    invariant b[l-1] == n-1\n    invariant 0 <= start <= a.Length - W\n    invariant m == Max(a, start, W)\n    invariant forall s :: 0 <= s <= n - W ==> m <= Max(a, s, W)\n    invariant l - k <= W  \n  {\n    while k <= l-1 && a[b[l-1]] <= a[n]\n      invariant k <= l <= n\n      invariant forall i :: (if k < l then b[l-1] + 1 else n - W) <= i < n ==> a[i] <= a[n]\n    {\n      l := l - 1;\n    }\n    b[l], l := n, l + 1;\n    if k < l-1 && b[k] == n - W {\n      k := k + 1;\n    }\n    Maxes(a, n - W + 1, b[k], n + 1);  \n    if a[b[k]] < m {\n      m, start := a[b[k]], n - W + 1;\n    }\n    n := n + 1;\n    Bound(b, k, l, n, W);  \n  }\n}\nghost function Max(a: array<int>, s: int, len: int): int\n  requires 0 <= s && 1 <= len && s + len <= a.Length\n  reads a\n{\n  if len == 1 then a[s] else\n    var m := Max(a, s, len - 1);\n    var y := a[s + len - 1];\n    if y < m then m else y\n}\nlemma MaxProperty(a: array<int>, s: int, len: int)\n  requires 0 <= s && 1 <= len && s + len <= a.Length\n  ensures forall i :: s <= i < s + len ==> a[i] <= Max(a, s, len)\n  ensures exists i :: s <= i < s + len && a[i] == Max(a, s, len)\n{\n  if len == 1 {\n    assert a[s] == Max(a, s, len);\n  } else {\n    MaxProperty(a, s, len - 1);\n  }\n}\nghost predicate RightmostMax(a: array<int>, lo: int, x: int, hi: int)\n  requires 0 <= lo <= x < hi <= a.Length\n  reads a\n{\n  (forall i :: lo <= i < x ==> a[i] <= a[x]) &&\n  (forall i :: x < i < hi ==> a[i] < a[x])\n}\nlemma Maxes(a: array<int>, lo: int, x: int, hi: int)\n  requires 0 <= lo <= x < hi <= a.Length\n  requires RightmostMax(a, lo, x, hi)\n  ensures a[x] == Max(a, lo, hi - lo)\n{\n  MaxProperty(a, lo, hi - lo);\n}\nghost predicate StrictlyIncreasing(b: array<int>, k: int, l: int, lo: int, hi: int)\n  requires 0 <= k <= l <= b.Length\n  reads b\n{\n  (forall i :: k <= i < l ==> lo <= b[i] < hi) &&  \n  (forall i,j :: k <= i < j < l ==> b[i] < b[j])  \n}\nlemma Bound(b: array<int>, k: int, l: int, n: int, W: nat)\n  requires 0 <= k <= l <= b.Length\n  requires forall i :: k <= i < l ==> n - W <= b[i] < n  \n  requires forall i,j :: k <= i < j < l ==> b[i] < b[j]  \n  ensures l - k <= W\n  decreases W\n{\n  if k < l {\n    assert n - W <= b[k] < n;\n    Bound(b, k+1, l, n, W-1);\n  }\n}"
},
{
    "dafny": "method M()\n{\n  N();\n  if (*)\n  {\n  }\n  else\n  {\n    assert (forall b: bool :: b || !b) || 0 != 0;\n  }\n  N();\n  assert (forall b: bool :: b || !b) || 3 != 3;\n  if (*)\n  {\n  }\n  else\n  {\n    assert (exists b: bool :: true) || 4 != 4;\n  }\n  assert (exists b: bool :: true) || 5 != 5;\n}\nmethod N()\n  ensures (forall b: bool :: b || !b) || 2 != 2;"
},
{
    "dafny": "function Fib(n: nat): nat\n  decreases n;\n{ if n < 2 then n else Fib(n-2) + Fib(n-1) }\nlemma FibLemma(n: nat)\n  ensures Fib(n) % 2 == 0 <==> n % 3 == 0;\n  decreases n;\n{\n  if (n < 2) {\n  } else {\n    FibLemma(n-2);\n    FibLemma(n-1);\n  }\n}\nlemma FibLemma_Alternative(n: nat)\n  ensures Fib(n) % 2 == 0 <==> n % 3 == 0;\n{\n  forall k | 0 <= k < n {\n    FibLemma_Alternative(k);\n  }\n}\nlemma FibLemma_All()\n  ensures forall n :: 0 <= n ==> (Fib(n) % 2 == 0 <==> n % 3 == 0);\n{\n  forall n | 0 <= n {\n    FibLemma(n);\n  }\n}\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\nfunction Append<T>(xs: List<T>, ys: List<T>): List<T>\n  decreases xs;\n{\n  match xs\n  case Nil => ys\n  case Cons(x, rest) => Cons(x, Append(rest, ys))\n}\nlemma {:induction false} AppendIsAssociative(xs: List, ys: List, zs: List)\n  ensures Append(Append(xs, ys), zs) == Append(xs, Append(ys, zs));\n  decreases xs;\n{\n  match (xs) {\n    case Nil =>\n    case Cons(x, rest) =>\n      AppendIsAssociative(rest, ys, zs);\n  }\n}\nlemma AppendIsAssociative_Auto(xs: List, ys: List, zs: List)\n  ensures Append(Append(xs, ys), zs) == Append(xs, Append(ys, zs));\n{\n}"
},
{
    "dafny": "method sumAndMax(N: int, a: array<int>) returns (sum: int, max: int)\n  requires 0 <= N && a != null && a.Length == N\n  ensures sum <= N * max\n{\n  sum := 0;\n  max := 0;\n  var i := 0;\n  while i < N\n    invariant i <= N && sum <= i * max\n  {\n    if max < a[i] {\n      max := a[i];\n    }\n    sum := sum + a[i];\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "module FOO {\n  datatype D = D(\n    f1: nat,\n    f2: nat\n  )\n  function f(d : D) : nat\n    ensures f(d) != 0\n  const D0 := D(0, 0)\n  const C1 :=  D0.(f2 := f(D0))\n  class E {\n    var a : D\n    constructor ()  {\n      a := C1;\n    }\n  }\n}"
},
{
    "dafny": "function sortedRange(a:array<char>, l:int, h:int):bool\n    requires 0 <= l <= h <= a.Length\n    reads a\n{ forall i, j:: (l <= i < j < h) ==> a[i] <= a[j] }\nfunction sorted(a:array<char>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ forall i, j:: (0 <= i < j < n) ==> a[i] <= a[j] }\nmethod orderedInsert(a:array<char>, v:char, n:int)\n    requires 0 <= n < a.Length\n    requires sorted(a, n)\n    ensures sorted(a, n+1)\n    modifies a \n{\n    if(n > 0)\n    {\n        a[n] := a[n-1];\n    }\n    var i := n;\n    while(i > 0 && v < a[i-1])\n        decreases i\n        invariant 0 <= i <= n+1\n        invariant sorted(a, n+1)\n        invariant forall k:: i < k < n+1 ==> v <= a[k]\n    {\n        a[i] := a[i-1];\n        i := i - 1;\n    }\n    a[i] := v;\n}"
},
{
    "dafny": "method flip (a: array<int>, num: int)\n  requires a.Length > 0;\n  requires 0 <= num < a.Length;\n  modifies a;\n  ensures multiset(old(a[..])) == multiset(a[..]);\n  ensures forall i :: 0 <= i <= num ==> a[i] == old(a[num - i]);\n  ensures forall i :: num < i < a.Length ==> a[i] == old(a[i]);\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\n    invariant i + j == num;\n    invariant 0 <= i <= num/2 + 1;\n    invariant num/2 - 1 <= j <= num;\n    invariant multiset(old(a[..])) == multiset(a[..]);\n    invariant forall k :: 0<= k <i ==> a[num-k] == old(a[k]);\n    invariant forall k :: i<= k <= j ==> a[k] == old(a[k]); \n    invariant forall k :: j< k <=num ==> a[num-k] == old(a[k]);\n    invariant forall k:: num < k < a.Length ==> a[k] == old(a[k]);\n    decreases num - i;\n    decreases j;\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}"
},
{
    "dafny": "function returnNat(c: nat): int\n{\n  if c < 0 then 1/0 else c\n}\nmethod Main() {\n  var x: set<int> := { -1, 2, -3, 4 };\n  var y := set c: nat | c in x;\n  var b := forall c :: c in y ==> returnNat(c) >= 0;\n  assert b;\n  print b;\n}"
},
{
    "dafny": "class Count{\n}\nfunction reduce_0_count(val1: int, val2: int, loop0: bool, count0: int) : int\n{\n\t(1+val1)\n}\nfunction doreduce_0(data: seq<int>, i: int, loop0: bool, count0: int) : int\n    requires 0 <= i <= |data|\n{\n    if i == 0 then 0\n    else (reduce_0_count(doreduce_0(data,i-1,loop0,count0),data[i-1],loop0,count0))\n}\npredicate loopInvariant (data: seq<int>, count: int, count0: int, i: int, i0: int, loop0: bool)\n{\n    0 <= i <= |data| &&\n\t(count == (doreduce_0(data,i,loop0,count0)))\n}\npredicate postCondition (data: seq<int>, count: int, count0: int, i: int, i0: int, loop0: bool)\n{\n    i == |data| &&\n\t(count == (doreduce_0(data,i,loop0,count0)))\n}\nmethod harness (data: seq<int>, count: int, i: int)\n{\n    var count0 := 0;\n\tvar loop0 := false;\n\tvar i0 := 0;\n    assert loopInvariant(data,count0,count0,i0,i0,loop0);\n\tif(loopInvariant(data,count,count0,i,i0,loop0) && (i<|data|))\n\t{\n\t\tassert loopInvariant(data,(count+1),count0,(i+1),i0,loop0);\n\t}\n\tif(loopInvariant(data,count,count0,i,i0,loop0) && !(i<|data|))\n\t{\n\t\tassert postCondition(data,count,0,i,0,loop0);\n\t}\n}"
},
{
    "dafny": "method Main()\n{\n    var a := new int[5]; \n    a[0] := 0;\n    a[1] := 1;\n    a[2] := 2;\n    a[3] := 3;\n    a[4] := 4;\n    var s := a[..]; \n    assert 5 !in a[..];\n}"
},
{
    "dafny": "method FindMaxIndex(a: array<int>) returns (index:nat)\nrequires a.Length > 0\nensures 0 <= index < a.Length\nensures forall k :: 0 <= k < a.Length ==> a[k] <= a[index]\n{\n    index := 0;\n    var i := 0;\n    while i < a.Length\n    decreases a.Length - i\n    invariant 0 <= i <= a.Length\n    invariant 0 <= index < a.Length\n    invariant forall j :: 0 <= j < i ==> a[j] <= a[index ]\n    {\n        if a[i] > a[index]\n        {\n            index := i;\n        }\n        i := i + 1;\n    }\n}\nmethod FindMaxValue(a :array<int>) returns (val: int)\nrequires a.Length > 0\nensures forall i :: 0 <= i < a.Length ==> a[i] <= val\nensures exists i :: 0 <= i < a.Length && a[i] == val\n{\n    val := a[0];\n    var i := 0;\n    while i < a.Length\n    decreases a.Length - i\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> a[j] <= val\n    invariant exists j :: 0 <= j < a.Length && a[j] == val\n    {\n        if a[i] > val\n        {\n            val := a[i];\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "predicate hasSubstring(token: seq<char>,str: seq<char>)\n{\n\t(exists i: nat :: i + |token| <= |str| && hasSubstringWithOffset(token,str,i))\n}\npredicate hasSubstringWithOffset(token: seq<char>, str: seq<char>, i: nat)\n{ \n\t(i + |token| <= |str|) && (token <= str[i..])\n}\npredicate loopInvariantOnEntry(token:string,str:string,i:int)\n{\n\texists n : int :: 0 <= n <= i && (n + |token| <= |str|) && hasSubstringWithOffset(token,str,n)  \n}\nmethod isSubstring(token: string, str: string) returns (r: bool)\n\trequires |str| > 0 && |token| > 0\n\trequires |token| <= |str|\n\tensures r <==> hasSubstring(token,str)\n{\n\tvar i := 0;\n\tr := (token <= str[i..]);\n\twhile(i <= (|str|-|token|) && !r)\n\t\tinvariant r <== loopInvariantOnEntry(token,str,i)\n\t\tinvariant r ==> (exists n : int :: (n >= 0) && (n + |token| <= |str|) && (token <= str[n..]))\n\t\tinvariant r ==> hasSubstringWithOffset(token,str,i)\n\t\tdecreases |str|-|token|-i\n\t{\n\t\tif (token <= str[(i+1)..])\n\t\t{\n\t\t\tr := true;\n\t\t}\n\t\ti := i+1;\n\t}\n}\nmethod Main() {\n\tvar token, str := \"World\",\"Hdwadaw World\";\n\tassert token[..] == \"World\";\n\tassert str[..] == \"Hdwadaw World\";\n\tvar found := isSubstring(token, str);\n\tassert (found == true) by\n\t{\n\t\tcalc {\n\t\t\ttoken <= str[8..]; \n\t\t\thasSubstringWithOffset(token,str,8);\n\t\t\thasSubstring(token,str);\n\t\t\tfound == true;\n\t\t}\n\t}\n}"
},
{
    "dafny": "predicate sorted_range(a: array<int>, l:nat, u:nat)\n  requires a != null;\n  requires 0 <= l <= u <= a.Length;\n  reads a;\n{\n  forall i, j :: l <= i < j < u ==> a[i] <= a[j]\n}\npredicate pivot(a:array<int>, pv:nat, l:nat, up:nat)\n  requires a != null;\n  requires 0 <= l <= pv <= up <= a.Length;\n  reads a;\n{\n  forall u , v :: l <= u < pv < v < up ==> a[u] <= a[v]\n}\nmethod bubbleSort (a: array<int>)\n  requires a != null && a.Length > 1;\n  ensures sorted_range(a, 0, a.Length);\n  ensures multiset(a[..]) == multiset(old(a[..]));\n  modifies a;\n{\n  var i:nat := 1;\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant sorted_range (a, 0, i);\n    invariant multiset(a[..]) == multiset(old(a[..]));\n  {\n    var j:nat := i;\n    while (j > 0)\n      invariant 0 <= j <= i;\n      invariant sorted_range (a, 0, j)\n      invariant sorted_range (a, j, i+1);\n      invariant pivot(a, j, 0, i+1);\n      invariant multiset(a[..]) == multiset(old(a[..]));\n    {\n      if (a[j-1] > a[j]) {\n        var temp:int := a[j-1];\n        a[j-1] := a[j];\n        a[j] := temp;\n      }\n      j := j - 1;\n    }\n    i := i+1;\n  }\n}"
},
{
    "dafny": "newtype uint32 = i:int | 0 <= i < 0x100000000\nmethod Test(name:string, b:bool) \n  requires b\n{\n  if b {\n    print name, \": This is expected\\n\";\n  } else {\n    print name, \": This is *** UNEXPECTED *** !!!!\\n\";\n  }\n}\ndatatype map_holder = map_holder(m:map<bool, bool>)\nmethod Basic() {\n  var f:map_holder;\n  var s:map<uint32,uint32> := map[1 := 0, 2 := 1, 3 := 2, 4 := 3];\n  var t:map<uint32,uint32> := map[1 := 0, 2 := 1, 3 := 2, 4 := 3];\n  Test(\"Identity\", s == s);\n  Test(\"ValuesIdentity\", s == t);\n  Test(\"KeyMembership\", 1 in s);\n  Test(\"Value1\", s[1] == 0);\n  Test(\"Value2\", t[2] == 1);\n  var u := s[1 := 42];\n  Test(\"Update Inequality\", s != u);\n  Test(\"Update Immutable 1\", s == s);\n  Test(\"Update Immutable 2\", s[1] == 0);\n  Test(\"Update Result\", u[1] == 42);\n  Test(\"Update Others\", u[2] == 1);\n  var s_keys := s.Keys;\n  var t_keys := t.Keys;\n  Test(\"Keys equal\", s_keys == t_keys);\n  Test(\"Keys membership 1\", 1 in s_keys);\n  Test(\"Keys membership 2\", 2 in s_keys);\n  Test(\"Keys membership 3\", 3 in s_keys);\n  Test(\"Keys membership 4\", 4 in s_keys);\n}\nmethod Main() {\n  Basic();\n}"
},
{
    "dafny": "function reverse<A>(s:seq<A>) : seq<A>\n{\n  if |s| == 0 then\n    []\n  else\n    reverse(s[1..]) + [s[0]]\n}\nmethod Swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < a.Length;\n  requires 0 <= j < a.Length;\n  modifies a;\n  ensures a[i] == old(a[j]);\n  ensures a[j] == old(a[i]);\n  ensures forall k :: 0 <= k < a.Length && k != i && k != j ==> a[k] == old(a[k]);\n  ensures multiset(a[..]) == old(multiset(a[..]));\n{\n  var tmp := a[i];\n  a[i] := a[j];\n  a[j] := tmp;\n}\nlemma reverse_eq<T>(s1:seq<T>, s2:seq<T>)\n  requires |s1| == |s2|;\n  requires forall i :: 0 <= i < |s1| ==> s1[i] == s2[|s2| - 1 - i];\n  ensures reverse(s1) == s2;\n{\n  if |s1| == 0 { } else {\n    reverse_eq(s1[1..], s2[..|s2|-1]);    \n  }\n}\nmethod Reverse<T>(a: array<T>)\n  modifies a;\n  ensures a[..] == reverse(old(a[..]));\n{\n  var i := 0;\n  while (i <= a.Length - 1 - i)\n    invariant 0 <= i <= a.Length - i + 1;\n    invariant forall k :: i <= k <= a.Length - 1 - i ==>\n      a[k] == old(a[k]);\n    invariant forall k :: 0 <= k < i ==>\n      a[a.Length - 1 - k] == old(a[k]) && a[k] == old(a[a.Length - 1 - k]);\n  {\n    Swap(a, i, a.Length - 1 - i);    \n    i := i + 1;\n  }\n  assert forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i]);\n  reverse_eq(old(a[..]), a[..]);\n}"
},
{
    "dafny": "predicate ItWasReal(r: real)\n{\n  r == 44.1985\n}\nmethod AssignSuchThat() returns (a: int, b: real)\n{\n  a :| a % 5 == 0 && a % 7 == 0;\n  assert ItWasReal(44.1985);\n  b :| ItWasReal(b);  \n}\nmethod LetSuchThat() returns (x: int, y: real)\n{\n  x := var a :| a % 5 == 0 && a % 7 == 0 && 0 <= a && a < 30; a;\n  assert ItWasReal(44.1985);\n  y := var b :| ItWasReal(b); b;  \n}"
},
{
    "dafny": "method A(x: nat, y: nat)\n    decreases x, y, 1\n{\n    B(x, y);\n}\nmethod B(x: nat, y: nat) \n    decreases x, y, 0\n{\n    if x > 0 && y > 0 {A(x - 1,y - 1);}\n}"
},
{
    "dafny": "method Partition(a: array<int>) returns (lo: int, hi: int)\n  modifies a\n  ensures 0 <= lo <= hi <= a.Length\n  ensures forall x | 0 <= x < lo :: a[x] < 0\n  ensures forall x | lo <= x < hi :: a[x] == 0\n  ensures forall x | hi <= x < a.Length :: a[x] > 0\n{\n  var i := 0;\n  var j := a.Length;\n  var k := a.Length;\n  while i < j\n    invariant 0 <= i <= j <= k <= a.Length\n    invariant forall x | 0 <= x < i :: a[x] < 0\n    invariant forall x | j <= x < k :: a[x] == 0\n    invariant forall x | k <= x < a.Length :: a[x] > 0\n  {\n    if a[i] < 0 {\n      i := i + 1;\n    } else if a[i] == 0 {\n      var current := a[i];\n      a[i] := a[j-1];\n      a[j-1] := current;\n      j := j - 1;\n    } else {\n      assert a[i] > 0;\n      var current := a[i];\n      a[i] := a[j-1];\n      a[j-1] := a[k-1];\n      a[k-1] := current;\n      j := j - 1;\n      k := k - 1;\n    }\n  }\n  return i, k;\n}"
},
{
    "dafny": "module DefaultModule {\n  class DefaultClass {\n    static ghost function BrokenFunction(): nat {\n      var y := 0;\n      assert true by {\n        if foobarquux: bool :| true {\n          assert true || foobarquux;\n        }\n      }\n      0\n    }\n  }\n}"
},
{
    "dafny": "module SetBijectivity {\n  lemma BijectivityImpliesEqualCardinality<A, B>(setA: set<A>, setB: set<B>, relation: iset<(A, B)>)\n    requires forall a :: a in setA ==> exists b :: b in setB && (a, b) in relation\n    requires forall a1, a2, b :: a1 in setA && a2 in setA && b in setB && (a1, b) in relation && (a2, b) in relation ==> a1 == a2\n    requires forall b :: b in setB ==> exists a :: a in setA && (a, b) in relation\n    requires forall a, b1, b2 :: b1 in setB && b2 in setB && a in setA && (a, b1) in relation && (a, b2) in relation ==> b1 == b2\n    ensures |setA| == |setB|\n  {\n    if |setA| == 0 {\n    } else {\n      var a :| a in setA;\n      var b :| b in setB && (a, b) in relation;\n      var setA' := setA - {a};\n      var setB' := setB - {b};\n      BijectivityImpliesEqualCardinality(setA', setB', relation);\n    }\n  }\n  lemma CrossProductCardinality<A, B>(setA: set<A>, setB: set<B>, cp: set<(A,B)>)\n  requires cp == (set a, b | a in setA && b in setB :: (a,b))\n  ensures |cp| == |setA| * |setB|;\n  {\n    if |setA| == 0 {\n      assert setA == {};\n      assert cp == {};\n    } else {\n      var x :| x in setA;\n      var setA' := setA - {x};\n      var cp' := (set a, b | a in setA' && b in setB :: (a,b));\n      var line := (set a, b | a == x && b in setB :: (a,b));\n      assert |line| == |setB| by {\n        var relation := iset p : ((A, B), B) | p.0.1 == p.1;\n        forall b | b in setB\n        ensures exists p :: p in line && (p, b) in relation\n        {\n          var p := (x, b);\n          assert p in line && (p, b) in relation;\n        }\n        BijectivityImpliesEqualCardinality(line, setB, relation);\n      }\n      CrossProductCardinality(setA', setB, cp');\n      assert cp == cp' + line;\n      assert cp' !! line;\n      assert |cp'| == |setA'| * |setB|;\n      assert |setA'| == |setA| - 1;\n      assert |cp|\n          == |cp' + line|\n          == |cp'| + |line|\n          == (|setA| - 1) * |setB| + |setB|\n          == |setA| * |setB|;\n    }\n  }\n}"
},
{
    "dafny": "function power(n:int, e:nat):int\n{\n   if (e==0) then 1 else n * power(n,e-1)\n}\nmethod Power1(n:int, e:nat) returns (p:int)\nensures p==power(n, e);\n{   var i:= 0;  \n    p:= 1;\n    while (i!=e)\n    invariant i<=e;\n    invariant p==power(n, i);\n    {\n       i := i+1;\n       p := p*n;  \n    }   \n}\nmethod Main() {\n  var a: int;\n  var b: nat;\n  a := 3;\n  b := 34234;\n  var c := Power1(a,b);\n  print \"Result: \", c;\n}"
},
{
    "dafny": "function Sum(s : seq<int>) : int ensures s == [] ==> Sum(s) == 0 ensures s != [] ==> Sum(s) == s[0] + Sum(s[1..])\n{ if s == [] then 0 else s[0] + Sum(s[1..])}\nmethod practicaAcum(v: array<int>)\nrequires v != null && v.Length > 0\nrequires v[v.Length - 1] == 0\nrequires forall i :: 0 <= i < v.Length ==> v[i] >= 0\nensures forall i,j :: 0 <= i < j < v.Length ==> v[i] == v[i] + Sum(v[j..])\nmodifies v\nensures v.Length == old(v.Length - 1)\nensures forall i :: 0 <= i < v.Length ==> v[i] in old(v[..])\nensures forall j :: 0 <= j < old(v.Length) ==> old(v[j]) in v[..]"
},
{
    "dafny": "method indexOf(a:array<int>, n:int, elem:int) returns (idx:int)\nmethod max(a:array<int>, n:int) returns (elem:int, idx:int)\nmethod min(a:array<int>, n:int) returns (elem:int, idx:int)\nrequires n > 0 && n <=a.Length \nmethod fillK(a:array<int>, n:int, k:int, count:int) returns (b:bool)\nmethod containsSubString(a:array<char>, b:array<char>) returns (pos:int)\nmethod resize(a:array<int>) returns (b:array<int>)\nmethod reverse(a:array<int>, n:int) returns (r:array<int>)\nmethod push(a:array<int>, na:int, elem:int) returns (b:array<int>, nb:int)\nmethod pop(a:array<int>, n:int) returns (na:array<int>, nn:int, elem:int)"
},
{
    "dafny": "method LinearSearch(a:array<int>, l:int, u:int, e:int) returns (r:bool)\n  requires a != null;\n  requires 0 <= l;\n  requires u < a.Length;\n  ensures r <==> exists k :: l <= k && k <= u && a[k] == e;\n{\n  var i := l;\n  r := false;\n  while (i <= u)\n    invariant !r <==> (forall k :: l <= k < i && k <= u ==> a[k] != e);\n  {\n    if (a[i] == e)\n    {\n      r := true;\n      return;\n    }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "module find{ \nmethod Find(a: array<int>, key: int)returns (index:int)\n\tensures 0 <= index ==> index < a.Length && a[index] == key\n\t  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key{\n\tindex := 0;\n\twhile index < a.Length \n\t\tinvariant 0 <= index <= a.Length\n\t\t  invariant forall k :: 0 <= k < index ==> a[k] != key{\n\t\tif a[index] == key {\n\t\t\treturn;\n\t\t}\n\t\tindex := index + 1;\n\t}\n\tindex := -1;\n\treturn;\n}\n}"
},
{
    "dafny": "method XCDE() returns (QWIK:int, UFOT:int)\n{\n  UFOT, QWIK := 0, 0;\n  while UFOT != 33\n    invariant QWIK == UFOT * (UFOT + 1) / 2\n  {\n    UFOT := UFOT + 1;\n    QWIK := QWIK + UFOT;\n  }\n}"
},
{
    "dafny": "function Stairs(n: nat): nat {\n  if n <= 1 then 1 else Stairs(n - 2) + Stairs(n - 1)\n}\nmethod ClimbStairs(n: nat) returns (r: nat)\n  ensures r == Stairs(n)\n{\n  var a, b := 1, 1;\n  var i := 1;\n  while i < n\n    invariant i <= n || i == 1\n    invariant a == Stairs(i - 1)\n    invariant b == Stairs(i)\n  {\n    a, b := b, a + b;\n    i := i + 1;\n  }\n  return b;\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n    requires x == -1\n    ensures 0 <= y\n    ensures 0 <= x ==> y == x\n    ensures x < 0 ==> y == -x\n{\n    y:= x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n    requires 2 * x == -1\n    ensures 0 <= y\n    ensures 0 <= x ==> y == x\n    ensures x < 0 ==> y == -x\n{\n    y:= x + 1;\n}"
},
{
    "dafny": "function SpecConverter(input: string): int {\n  1\n}\ntype StringWrapper {\n  ghost const base: string\n}\nmethod Converter(value: StringWrapper) returns (res: int)\n  ensures res == SpecConverter(value.base)\n{\n  res := 1;\n}"
},
{
    "dafny": "predicate sorted(l1: int, u1: int,a: array<int>)\n\trequires a != null &&  u1 < a.Length \n\treads a\n{\n\tforall i,j::  (0 <= i && l1 <= i <= j <= u1) ==> a[i] <= a[j]\n}\nmethod insertSort(a : array<int>)\n    requires a != null\n    modifies a\n    ensures sorted(0, a.Length - 1,a)\n{\n    var i := 1;\n    while (i < a.Length)\n        invariant (0 <= i - 1 < a.Length && sorted(0,i - 1,a)) || a.Length == 0\n        {\n            var j := i;\n            var value := a[i];\n            a[i] := a[i-1];\n            while (j > 0 && a[j-1] > value)\n                invariant forall m:: 0 <= j < m <= i <= a.Length ==> a[m] >= value \n                invariant sorted(0,i,a)\n            {\n                a[j] := a[j-1];\n                j := j - 1;\n            }\n            a[j] := value;\n            i := i + 1;\n        }\n}"
},
{
    "dafny": "module PostOffice {\n\tdatatype state = State(\n\t\tBoxCount: int,\n\t\tTime: int,\n\t\tCalledAt: int,\n\t\tCalled: bool\n\t)\n\tpredicate Valid(s:state)\n\t{\n\t\t(0 <= s.CalledAt < 1000 - 3) &&\n\t\t(0 <= s.Time < 1000) &&\n        (s.BoxCount >= 0) &&\n        (s.BoxCount > 20 ==> s.Called) &&\n        (s.BoxCount == 0 ==> !s.Called) &&\n\t\t(s.CalledAt <= s.Time)\n\t}\n\tmethod NewDay() returns (s:state)\n\t\tensures s.BoxCount == 0\n\t\tensures s.Time == 0\n\t\tensures s.CalledAt == 0\n\t\tensures s.Called == false\n\t\tensures Valid(s)\n\t{\n\t\ts := State(0, 0, 0, false);\n\t}\n\tmethod DropOff(s:state) returns (s':state)\n\t\trequires Valid(s)\n\t\trequires s.Time < 1000 - 3\n\t\tensures s'.BoxCount == s.BoxCount + 1\n\t\tensures if (s'.BoxCount > 20 && !s.Called) \n\t\t\tthen s'.Called && s'.CalledAt == s'.Time \n\t\t\telse s'.Called == s.Called && s'.CalledAt == s.CalledAt\n\t\tensures s'.Time == s.Time\n\t\tensures s'.BoxCount > 0\n\t\tensures Valid(s')\n\t{\n\t\ts' := s.(BoxCount := s.BoxCount + 1);\n\t\tif s'.BoxCount > 20 && !s'.Called {\n\t\t\ts' := s'.(Called := true, CalledAt := s'.Time);\n\t\t}\n\t}    \n\tmethod PickUp(s:state) returns (s':state)\n\t\trequires Valid(s)\n\t\tensures s'.BoxCount == 0\n\t\tensures s'.Called == false\n\t\tensures s'.Time == s.Time\n\t\tensures s'.CalledAt == s.CalledAt\n\t\tensures Valid(s')\n\t{\n\t\ts' := s.(BoxCount := 0, Called := false);\n\t}\n\tmethod TickMidday(drop:bool, pick:bool, s:state) returns (s':state)\n\t\trequires Valid(s)\n\t\trequires s.Time < 1000 - 3\n\t\tensures s.Called ==> s'.CalledAt == s.CalledAt\n\t\tensures s'.Time <= 1000 - 3\n\t\tensures s'.Time == s.Time + 1\n\t\tensures !pick && drop ==> s'.BoxCount == s.BoxCount + 1 \n\t\t\t\t&& (s'.BoxCount > 20 ==> s'.Called)\n\t\tensures !pick && !drop ==>  s'.BoxCount == s.BoxCount\n\t\tensures if pick \n\t\t\tthen s'.BoxCount == 0 && !s'.Called \n\t\t\telse s.Called ==> s'.Called\n\t\tensures s'.Called && !s.Called ==> s'.CalledAt == s.Time\n\t\tensures (s.Called ==> s.BoxCount > 0) ==> (s'.Called ==> s.BoxCount > 0)\n\t\tensures Valid(s')\n\t{\n\t\ts' := s;\n\t\tif drop {\n\t\t\ts' := DropOff(s');\n\t\t}\n\t\tif pick {\n\t\t\ts' := PickUp(s');\n\t\t}\n\t\ts' := s'.(Time := s'.Time + 1);\n\t}\n\tmethod TickEoD(pick:bool, s:state) returns (s':state)\n\t\trequires Valid(s)\n\t\trequires 1000 - 3 <= s.Time < 1000 - 1\n\t\trequires s.CalledAt < 1000 - 3\n\t\tensures 1000 - 3 < s'.Time <= 1000\n\t\tensures s'.Time == s.Time + 1\n\t\tensures s'.CalledAt == s.CalledAt\n\t\tensures if pick then s'.BoxCount == 0 else s'.BoxCount == s.BoxCount\n\t\tensures if pick then !s'.Called else s.Called == s'.Called\n\t\tensures Valid(s')\n\t{\n\t\ts' := s;\n\t\tif pick {\n\t\t\ts' := PickUp(s');\n\t\t}\n\t\ts' := s'.(Time := s'.Time + 1);\n\t}\n\tmethod WholeDay(dropoffs:seq<bool>)\n\t\trequires |dropoffs| == 1000 - 3\n\t{\n\t\tvar s := NewDay();\n\t\tvar pickups := [false, false];\n\t\twhile s.Time < 1000 - 1\n\t\t\tdecreases  1000 - 1 - s.Time\n\t\t\tinvariant Valid(s)\n\t\t\tinvariant s.Called ==> (0 < s.Time - s.CalledAt <= 2)\n\t\t\tinvariant |pickups| == 2\n\t\t\tinvariant old(|dropoffs|) == |dropoffs|\n\t\t\tinvariant 0 <= s.Time <= 1000 - 1\n\t\t\tinvariant s.Time > 1000 - 2 ==> s.BoxCount == 0\n\t\t\tinvariant s.Called ==> (s.Time - s.CalledAt <= 2)\n\t\t\tinvariant (s.Called && s.CalledAt == s.Time - 1) == pickups[1]\n\t\t\tinvariant (s.Called && s.CalledAt == s.Time - 2) ==> pickups[0]\n\t\t\tinvariant s.Called ==> true in pickups\n\t\t\tinvariant s.Called ==> s.BoxCount > 0\t\t\n\t\t\tinvariant pickups[0] ==> s.BoxCount > 0 && s.Called\n\t\t\tinvariant s.BoxCount > 0 && s.Time == 1000 - 3 ==> s.Called\n\t\t\tinvariant s.BoxCount > 0 && s.Time == 1000 - 3 ==> true in pickups\n\t\t\tinvariant s.BoxCount > 0 && s.Time == 1000 - 2 ==> true in pickups[..(|pickups|-1)]\n\t\t\tinvariant pickups[0] ==> !pickups[1]\n\t\t\tinvariant pickups[1] ==> !pickups[0]\n\t\t{\n\t\t\tvar stime_old := s.Time;\n\t\t\tvar pickups_old := pickups;\n\t\t\tvar scalledat_old := s.CalledAt;\n\t\t\tvar scalled_old := s.Called;\n\t\t\tvar sboxcount_old := s.BoxCount;\n\t\t\tif s.Time < 1000 - 3 {\n\t\t\t\ts := TickMidday(dropoffs[s.Time], pickups[0], s);\n\t\t\t} else {\n\t\t\t\ts := TickEoD(pickups[0], s);\n\t\t\t}\n\t\t\tif s.Time == 1000 - 3 {\n\t\t\t\tif s.BoxCount > 0 && !s.Called {\n\t\t\t\t\ts := s.(Called := true, CalledAt := s.Time - 1); \n\t\t\t\t}\n\t\t\t}\n\t\t\tpickups := pickups[1..] + [s.Called && s.CalledAt == s.Time - 1];\n\t\t\tassert s.Called ==> (s.Time - s.CalledAt == 1 || s.Time - s.CalledAt == 2);\n\t\t\tassert pickups_old[1] == pickups[0];\n\t\t\tassert stime_old == s.Time - 1;\n\t\t\tassert pickups_old[1] ==> !pickups_old[0];\n\t\t\tassert !pickups_old[0] ==> scalled_old ==> s.Called;\n\t\t\tassert scalled_old && scalledat_old == stime_old - 1 ==> s.Called;\n\t\t\tassert (scalled_old && scalledat_old == stime_old - 1) == pickups_old[1];\n\t\t\tassert scalled_old && scalledat_old == stime_old - 1 ==> scalled_old == s.Called;\t\t\t\n\t\t\tassert s.Called && s.Time - s.CalledAt == 2 ==> scalled_old;\n\t\t\tassert (s.Called && s.CalledAt == s.Time - 2) ==> (scalled_old && scalledat_old == stime_old - 1);\n\t\t\tassert (s.Called && s.CalledAt == s.Time - 2) ==> pickups[0];\n\t\t\tassert (s.Called && s.CalledAt == s.Time - 1) == pickups[1];\n\t\t\tassert s.Called ==> true in pickups;\n\t\t\tassert stime_old == 997 && sboxcount_old > 0 ==> scalled_old;\n\t\t\tassert s.Time == 998 && s.BoxCount > 0 ==> sboxcount_old > 0;\n\t\t\tassert s.Time == 998 && s.BoxCount > 0 ==> scalled_old;\n\t\t\tassert s.Time == 998 && s.BoxCount > 0 ==> (scalled_old && scalledat_old == stime_old - 1);\n\t\t\tassert s.Time == 998 && s.BoxCount > 0 ==> pickups_old[1];\n\t\t\tassert s.Time == 998 && s.BoxCount > 0 ==> pickups[0];\n\t\t}\n\t\tassert (s.Time == 1000 - 1);\n\t\tassert (s.BoxCount == 0);\n\t}\n}"
},
{
    "dafny": "method Min(x: int, y: int) returns (z: int)\n  ensures x <= y ==> z == x\n  ensures x > y ==> z == y\n{\n  if x <= y {\n    z := x;\n  } else {\n    z := y;\n  }\n}"
},
{
    "dafny": "method ArrayMap<A>(f: int -> A, a: array<A>)\n  requires a != null\n  requires forall j :: 0 <= j < a.Length ==> f.requires(j)\n  requires forall j :: 0 <= j < a.Length ==> a !in f.reads(j)\n  modifies a\n  ensures forall j :: 0 <= j < a.Length ==> a[j] == f(j)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length;\n    invariant forall j :: 0 <= j < i ==> a[j] == f(j)\n  {\n    a[i] := f(i);\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "function Fat(n: nat): nat\n{\n   if n == 0 then 1 else n * Fat(n-1)\n}\nmethod Fatorial(n:nat)  returns (r:nat)\n  ensures r == Fat(n)\n{\n    r := 1;\n    var i := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant r == Fat(i)\n    {\n        i := i + 1;\n        r := r * i;\n    }\n}"
},
{
    "dafny": "method BinarySearch(a:array<int>, key:int) returns (r:int)\n  requires forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= r ==> r < a.Length && a[r]==key\n  ensures r < 0 ==> forall i :: 0 <= i < a.Length ==> a[i] != key\n  {\n    var lo, hi := 0, a.Length;\n    while lo < hi \n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] != key\n    invariant forall i :: hi <= i < a.Length ==> a[i] != key\n    decreases hi - lo\n    {\n      var mid := lo+(hi-lo)/2;\n      if a[mid] > key {\n        hi := mid;\n      }\n      else if a[mid] < key {\n        lo := mid + 1; \n      }\n      else {\n        return mid;\n      }\n    }\n    return -1;\n  }\nmethod BinarySearch2(a:array<int>, key:int) returns (r:int) \n  requires forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= r <= a.Length\n  ensures r < a.Length ==> a[r] == key || forall i,j :: 0 <= i < r <= j < a.Length ==> a[i] < key < a[j]\n  ensures r == a.Length ==> forall i :: 0 <= i < r ==> a[i] < key\n  {\n    var lo, hi := 0, a.Length;\n    while lo < hi \n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] < key\n    invariant forall i :: hi <= i < a.Length ==> a[i] > key\n    decreases hi - lo\n    {\n      var mid := lo+(hi-lo)/2;\n      if a[mid] > key {\n        hi := mid;\n      }\n      else if a[mid] < key {\n        lo := mid + 1; \n      }\n      else {\n        return mid;\n      }\n    }\n    return lo;\n  }\n  method BinarySearch3(a:array<int>, key:int) returns (r:int) \n  requires forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= r <= a.Length\n  ensures r < a.Length ==> forall i,j :: 0 <= i < r <= j < a.Length ==> a[i] <= key < a[j]\n  ensures r == a.Length ==> forall i :: 0 <= i < r ==> a[i] <= key\n  {\n    var lo, hi := 0, a.Length;\n    while lo < hi \n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] <= key\n    invariant forall i :: hi <= i < a.Length ==> a[i] > key\n    decreases hi - lo\n    {\n      var mid := lo+(hi-lo)/2;\n      if a[mid] > key {\n        hi := mid;\n      }\n      else {\n        lo := mid + 1; \n      }\n    }\n    return lo;\n  }"
},
{
    "dafny": "method allDigits(s: string) returns (result: bool)\n{\n  result:=true ;\n  for i := 0 to |s|\n    invariant result <==> (forall ii :: 0 <= ii < i ==> s[ii] in \"0123456789\")\n  {\n    if ! (s[i] in \"0123456789\"){\n      return false;\n    }\n  }\n}"
},
{
    "dafny": "module correctMaxExample{\n    predicate maxSpec(a:int,b:int,c:int)\n    {\n        c >= a\n        && c >= b\n        && (c == b || c ==a)\n    }\n    lemma max(a:int,b:int) returns (c:int)\n        ensures maxSpec(a,b,c)\n    {\n        if(a > b){\n            c := a;\n        }else{\n            c := b;\n        }\n    }\n}"
},
{
    "dafny": "method isPrefix(pre: string, str: string) returns (res:bool)\nrequires |pre| > 0 && |str| > 0 && |str|>= |pre|\n{\n    var i : int := 0;\n    var count : int := 0;\n    while (i <  |pre|) decreases (|pre| - i)\n    {\n        if str[i] == pre[i] {\n            count := count +1;\n        }\n        i := i + 1;\n   }\n   res:= false;\n   if count == |pre| {\n       res := true;\n   }\n}"
},
{
    "dafny": "newtype uint64 = i:int | 0 <= i < 0x10000000000000000\nfunction bit(i: uint64) : bv64\n  requires i < 64\n  {\n    1 as bv64 << i\n  }\nmethod BasicOps(b0:bv64, b1:bv64) {\n  var r0:bv64 := b0 & b1;\n  var r1:bv64 := b0 | b1;\n  var r2:bv64 := b0 ^ b1;\n  var r3:bv64 := b0 ^ 0xffff_ffff_ffff_ffff;\n  var r4:bv64 := b0 << 4;\n  var r5 := r0 & r1 & r2 & r3 & r4;\n  print r5;\n}\nlemma {:axiom} as_int_as_bv64(a: bv64)\n  ensures (a as int) as bv64 == a\n  ensures (a as int) < 0x10000000000000000\nmethod Casts(u0:uint64)\n{\n  var r0:bv64 := u0 as bv64 << 1;\n  as_int_as_bv64(u0 as bv64 << 1);\n  var r1:uint64 := (u0 as bv64 << 1) as uint64;\n  print r0, r1;\n}\nmethod Main() {\n  BasicOps(72, 15);\n  Casts(42);\n  var b := bit(10);\n  print b, \"\\n\";\n}"
},
{
    "dafny": "trait Tr { }\nclass A extends Tr { }\nclass B extends Tr { }\nghost predicate SpecialA(a: A)\n{\n  false\n}\ntype Ap  = x : A | SpecialA(x) witness *\nfunction testSpecial(x: Tr): bool\n  requires x is A && SpecialA(x)\n{\n  1/0 == 0\n}\nfunction test(x: Tr): bool\n  requires x is A\n{\n  if x is B then 1/0 == 0 else true\n}\nmethod Main() {\n  var a := new A;\n  var b := new B;\n  var s: set<Tr> := {a, b};\n  var s2: set<Ap> := {};\n  var aa := forall a': A :: a' in s ==> test(a');\n  var si: set<int> := {2, 3, 4};\n  var ai:= forall i: nat :: i in si ==> i > 1;\n  assert aa;\n  print \"ok\";\n}"
},
{
    "dafny": "predicate sorted(a: array<int>, l1: int, u1: int)\n\trequires a != null \n\treads a\n{\n\tforall i,j::  (0 <= i && j < a.Length && l1 <= i <= j <= u1) ==> a[i] <= a[j]\n}\nmethod insertSort(a : array<int>)\n  requires a != null;\n  modifies a;\n  ensures sorted (a, 0, a.Length - 1)\n{\n    var i := 1;\n    while (i < a.Length)\n      invariant sorted(a, 0, i-1);\n    {\n        var j := i;\n        var value := a[i];\n        a[i] := a[i-1];\n        while (j > 0 && a[j-1] > value)\n          invariant sorted(a, 0, i)  \n                    && (forall k :: j + 1 <= k <= i ==> value <= a[k])\n        {\n            a[j] := a[j-1];\n            j := j - 1;\n        }\n\t\t\t\tassert j == 0 || value >= a[j-1]; \n        a[j] := value;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "predicate distintos(s: seq<int>) {\n\tforall u, w :: 0 <= u < w < |s| ==> s[u] != s[w]\n}\npredicate distintosA(a: array<int>) \n\treads a\n{\n\tforall u, w :: 0 <= u < w < a.Length ==> a[u] != a[w]\n}\nmethod TestDistintos() \n{\n  \tassert distintos([1,4,2,8]);\n\tassert distintos([6,3,1,9,2]);\n\tassert distintos([2]);\n\tvar s : seq<int>;\n\ts := [];\n\tassert distintos(s);\n\tvar v:array<int> := new int[4];\n\tv[0]:=6; v[1]:=7; v[2]:=8; v[3]:=-2;\n\tassert distintos(v[0..v.Length]);\n\tassert distintosA(v);\n}\npredicate contiguosDistintos(s: seq<int>) {\n\tforall u :: 0 <= u < |s|-1 ==> s[u] != s[u+1]\n}\nmethod TestContiguosDistintos() {\n   assert contiguosDistintos([1,4,2,8]);\n   assert contiguosDistintos([6,3,1,9,2]);\n   assert contiguosDistintos([2]);\n\tvar s:seq<int>;\n\ts:=[];\n\tassert contiguosDistintos(s);\n\tassert contiguosDistintos([3,4,3,6]);\n\tvar v:array<int> := new int[4];\n\tv[0]:=6; v[1]:=7; v[2]:=6; v[3]:=-2;\n\tassert contiguosDistintos(v[0..v.Length]);\n}\npredicate ordenado(s: seq<int>) {\n\tforall i:: 0 <= i < |s| - 1 ==> s[i] <= s[i+1]\n}\nmethod TestOrdenado() {\n assert ordenado([]);\n assert ordenado([5]);\n assert ordenado([1,6,8,9]);\n assert ordenado([3,10,10,28]);\n}\npredicate ordenadoEstricto(s: seq<int>) {\n\tforall i:: 0 <= i < |s| - 1 ==> s[i] < s[i+1]\n}\nmethod TestOrdenadoEstricto() {\n\tassert ordenadoEstricto([]);\n\tassert ordenadoEstricto([5]);\n\tassert ordenadoEstricto([1,6,8,9]);\n}\npredicate igual(s : seq<int>, x :int) {\n   exists u:int :: 0 <= u < |s| && s[u] == x \n}\nmethod TestIgual() \n{  \t\n\tvar s : seq<int>;\n    s := [1,7,0,5];\n    assert s[2]==0; \n  \tassert igual(s,0);\n\ts:=[];\n}\npredicate esPrimerCero(s : seq<int>, k : int)  \n\trequires 0 <= k <= |s|\n{\n    forall i:: 0 <= i < k ==> s[i] != 0 && (|s| == k || s[k] == 0)\n}\nmethod TestEsPrimerCero() \n{  \n\tvar s : seq<int>;\n   s := [1,7,0,5];\n   assert esPrimerCero(s,2);\n\ts:= [1,7,4,5];\n\tassert esPrimerCero(s,4);\n\ts:=[];\n\tassert esPrimerCero(s,0);\n\ts := [0,0,0,0];\n\ts := [0, 0, 0, 0];\n}\npredicate esPermutacion(s:seq<int>, t:seq<int>){\n\tmultiset(s)==multiset(t)\n}\nmethod TestEsPerm()\n{\n  assert esPermutacion([1,4,2,5], [5,2,4,1]);\n}"
},
{
    "dafny": "method Sum() returns (s:int, n:int)\n  ensures s == n * (n + 1) / 2\n  ensures n==33\n{\n  n, s := 0, 0;\n  while n != 33\n    invariant s == n * (n + 1) / 2\n  {\n    n := n + 1;\n    s := s + n;\n  }\n}"
},
{
    "dafny": "class Ref<A(0)> {\n  var val: A\n}\nmethod Nice(n: int) returns (k: int) {\n  var f : int -> int := x => x;\n  var i := new Ref<int>;\n  i.val := 0;\n  while i.val < n\n    invariant forall u :: f.requires(u)\n    invariant forall u :: f.reads(u) == {}\n    invariant forall u :: f(u) == u + i.val\n  {\n    i.val := i.val + 1;\n    f := x => f(x) + 1;\n  }\n  return f(0);\n}\nmethod OneShot(n: int) returns (k: int) {\n  var f : int -> int := x => x;\n  var i := 0;\n  while i < n\n    invariant forall u :: f.requires(u)\n    invariant forall u :: f(u) == u + i\n  {\n    i := i + 1;\n    f := x requires f.requires(x) reads f.reads(x) => f(x) + 1;\n  }\n  k := f(0);\n}\nmethod HeapQuant(n: int) returns (k: int) {\n  var f : int -> int := x => x;\n  var i := new Ref;\n  ghost var r := 0;\n  i.val := 0;\n  while i.val < n\n    invariant forall u :: f.requires(u)\n    invariant forall u :: f.reads(u) == {}\n    invariant r == i.val\n    invariant forall u :: f(u) == u + r\n  {\n    i.val, r := i.val + 1, r + 1;\n    f := x => f(x) + 1;\n  }\n  k := f(0);\n}\nmethod Main() {\n  var k0 := Nice(22);\n  var k1 := OneShot(22);\n  var k2 := HeapQuant(22);\n  print k0, \" \", k1, \" \", k2, \"\\n\";\n}"
},
{
    "dafny": "datatype TextProcessing =\n  | TeX    \n  | LaTeX\n  | Madoko\nghost predicate InfixStyle(x: int, y: int, t: TextProcessing)\n{\n  (t == TeX ==> x < y) &&\n  (t == LaTeX || t == TeX ==> x == 100 && y == 1000) &&\n  (t == Madoko ==> 0 <= x || 0 <= y)\n}\nghost predicate TLA_plus_Style(x: int, y: int, t: TextProcessing)\n{\n  && (t == TeX ==> x < y)\n  && (|| t == LaTeX\n      || t == TeX\n    ==>\n     && x == 100\n     && y == 1000\n     )\n  && (t == Madoko ==> || 0 <= x || 0 <= y)\n}\nlemma Same(x: int, y: int, t: TextProcessing)\n  ensures InfixStyle(x, y, t) == TLA_plus_Style(x, y, t)\n{\n}\ndatatype MyRecord = | MakeItHere(z: int)\nghost function UnitConjunct(y: int): bool\n{\n  && y == 5\n}\nghost function UnitDisjunct(y: int): bool\n{\n  || y == 5\n}\nlemma Units(y: int)\n  ensures UnitConjunct(y) == UnitDisjunct(y)\n{\n}\nghost function MyPredicate(y: int): bool\n{\n  || 5 + y == 0 <==> && 10 + y == 0\n}\nghost function MyPredicateClean(y: int): bool\n{\n  5 + y == 0 <==> 10 + y == 0\n}\nlemma MyPred(y: int)\n  ensures MyPredicate(y) == MyPredicateClean(y)\n{\n}\nlemma CheckMyPred_0(y: int)\n  requires MyPredicate(y)\n  ensures y != -5 && y != -10\n{\n}\nlemma CheckMyPred_1(y: int)\n  ensures MyPredicate(4)\n{\n}"
},
{
    "dafny": "method find(v:int, a:array<int>, numelems:int) returns(r:int)\n  requires numelems > 0;\n  requires a != null && a.Length >= numelems;\n  ensures (r == -1 && forall j :: 0 <= j < numelems ==> a[j] != v) ||  (0 <= r < numelems && a[r] == v);\n{\n  var i:int := 0;\n  r := -1;\n  while(i<numelems)\n  invariant 0 <= i <= numelems;\n  invariant (r == -1 && forall j :: 0 <= j < i ==> a[j] != v) ||  (0 <= r < i && a[r] == v);\n  {\n    if (a[i] == v) {\n      r := i;\n      break;\n    }\n    i:= i + 1;\n  }\n}"
},
{
    "dafny": "datatype BYTree = BlueLeaf\n                | YellowLeaf\n                | Node(left: BYTree, right: BYTree)\nfunction BlueCount(t: BYTree): nat {\n  if t.BlueLeaf? then 1\n  else if t.YellowLeaf? then 0\n  else BlueCount(t.left) + BlueCount(t.right)\n}\nmethod Test() {\n  assert BlueCount(BlueLeaf) == 1;\n  assert BlueCount(Node(YellowLeaf, BlueLeaf)) == 1;\n}"
},
{
    "dafny": "function sq(n: int) : int\n{\n    (n * n)\n}\nmethod check_sq()\n{\n    assert(sq(0) == 0);\n    assert(sq(0) == sq(0));\n    assert(sq(sq(0)) == sq(0));\n    assert(sq(1) == sq(sq(1)));\n    assert(sq(2) == 4);\n    assert(sq(-2) == sq(2));\n    assert(sq(sq(1)) == 1);\n    assert(sq(3) + sq(4) == sq(5));\n    assert(sq(-3) + sq(4) == sq(-5));\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && \n\tpre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || \n\tpre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n\tensures !res <==> isNotPrefixPred(pre,str)\n\tensures  res <==> isPrefixPred(pre,str)\n{\n\tif (|pre| > |str|) { return false; }\n\tvar i := 0;\n\tres := true;\n\twhile (i < |pre| && res)\n\t  invariant 0 <= i <= |pre| <= |str|\n\t  invariant res ==> pre[..i] == str[..i]\n\t  invariant !res ==> pre != str[..|pre|]\n\t  decreases |pre| - i - (if res then 0 else 1);\n\t{\n\t\tif (pre[i] != str[i]) { res := false; }\n\t\telse {\n\t\t i := i + 1; \n\t\t}\n\t}\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n\t(exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\t(forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n\tensures  res <==> isSubstringPred(sub, str)\n{\n\tif (|sub| > |str|) { return false; }\n\tvar i := 0;\n\tres := false;\n\twhile (i <= |str|-|sub| && !res) \n\t  decreases |str|-|sub| - i - (if res then 1 else 0);\n\t  invariant 0 <= i <= |str| - |sub| + 1\n\t  invariant res ==> exists j :: 0 <= j <= |str| &&  isPrefixPred(sub, str[j..])\n\t  invariant !res ==> forall j :: 0 <= j < i ==> isNotPrefixPred(sub, str[j..])\n  {\n\t\tres := isPrefix(sub, str[i..]);\n\t\tif (!res) {\ti := i + 1;\t}\n\t}\n}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\texists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\tforall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n\tensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n{\n\tif |str1| < k || |str2| < k { return false; } \n\tif k == 0\n\t{\n\t\tassert isPrefixPred(str1[0..0],str2[0..]);\n\t\treturn true; \n\t} \n\tfound := false;\n\tvar i := 0;\n\twhile (i <= |str1| - k && !found)\n\t  invariant 0 <= i <= |str1| - k + 1\n\t  invariant found ==> haveCommonKSubstringPred(k, str1, str2)\n\t  invariant !found ==> forall i1, j1 :: 0 <= i1 < i && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n\t  decreases |str1| - k - i - (if found then 1 else 0)\n\t{\n\t\tfound := isSubstring(str1[i..i+k], str2);\n\t\tif (!found) { i := i+1; }\n\t}\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n\trequires (|str1| <= |str2|)\n\tensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n\tensures haveCommonKSubstringPred(len,str1,str2)\n{\n\tlen := |str1|;\n\tvar found : bool := false;\n\twhile (0 < len && !found)\n\t  invariant 0 <= len <= |str1|\n\t  invariant found ==> haveCommonKSubstringPred(len,str1,str2)\n\t  invariant forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k, str1, str2)\n\t  decreases len - (if found then 1 else 0)\n\t{\n\t\tfound := haveCommonKSubstring(len, str1, str2);\n\t\tif !found {\tlen := len - 1; }\n\t}\n\tassert isPrefixPred(str1[0..0],str2[0..]);\n\treturn len;\n}"
},
{
    "dafny": "method Main() {\n  var s := { 1,9,3,7,5};\n  m(s);\n  mp(map[ 1:= 3, 3:= 5]);\n}\nmethod m(s: set<int>) {\n  var ss := s;\n  while ss != {}\n    decreases |ss|\n  {\n    var i: int :| i in ss;\n    ss := ss - {i};\n    print i, \"\\n\";\n  }\n}\nmethod mp(m: map<int,int>)\n{\n  var items := m.Items;\n  while items != {}\n    decreases |items|\n  {\n    var item :| item in items;\n    items := items - { item };\n    print item.0, \" \", item.1, \"\\n\";\n  }\n}\nmethod mpi(m: imap<int,int>)\n{\n  var items: iset<(int,int)> := m.Items;\n  var keys: iset<int> := m.Keys;\n  var vals: iset<int> := m.Values;\n}\nmethod mseq(s: seq<int>) {\n  var i: int := 0;\n  var sum: int := 0;\n  while i < |s|\n    decreases |s| - i\n  {\n    sum := sum + s[i];\n    i := i + 1;\n  }\n}\nmethod marr(s: array<int>) {\n  var i: int := 0;\n  var sum: int := 0;\n  while i < s.Length\n    decreases s.Length - i\n  {\n    sum := sum + s[i];\n    i := i + 1;\n  }\n  var rev := new int[s.Length];\n  forall i | 0 <= i < s.Length {\n    rev[i] := s[s.Length-i-1];\n  }\n}"
},
{
    "dafny": "method problem4(a: nat, b: nat)\n{\n  var i,j: int;\n  i,j := a,b;\n  while i > 0 && j > 0\n  decreases i + 2*j     \n  {\n    if i < j {\n      i,j := j,i;\n    } else {\n      i := i - 1;\n    }\n  }\n}"
},
{
    "dafny": "method Main()\n{\n    var ms0:multiset<int> := multiset{};\n    var ms1 := multiset{1,1,1,2};\n    var ms2 := multiset{1,1};\n    assert |ms1| == 4; \n    assert ms1[1] == 3; \n    assert 1 in ms1; \n    assert 0 !in ms1; \n    assert ms1 == multiset{1,2,1,1}; \n    assert ms1 != multiset{}; \n    assert ms1 !! multiset{3,3,4}; \n    assert multiset{1,2} <= ms1; \n    assert ms1 + ms2 == multiset{1,1,1,1,1,2}; \n    assert ms1 - ms2 == multiset{1,2}; \n    assert ms1 * ms2 == multiset{1,1}; \n    assert ms1[2:=0] == multiset{1,1,1}; \n}"
},
{
    "dafny": "codatatype Stream<T> = Cons(hd: T, tl: Stream)\nfunction zip(xs: Stream, ys: Stream): Stream\n  { Cons(xs.hd, Cons(ys.hd, zip(xs.tl, ys.tl))) }\nfunction even(xs: Stream): Stream\n  { Cons(xs.hd, even(xs.tl.tl)) }\nfunction odd(xs: Stream): Stream\n  { even(xs.tl) }\ncolemma EvenOddLemma(xs: Stream)\n  ensures zip(even(xs), odd(xs)) == xs;\n{ EvenOddLemma(xs.tl.tl); }\ncolemma EvenZipLemma(xs:Stream, ys:Stream)\n  ensures even(zip(xs, ys)) == xs;\n{  }\nfunction bzip(xs: Stream, ys: Stream, f:bool) : Stream\n  { if f then Cons(xs.hd, bzip(xs.tl, ys, !f))\n    else      Cons(ys.hd, bzip(xs, ys.tl, !f)) }\ncolemma BzipZipLemma(xs:Stream, ys:Stream)\n  ensures zip(xs, ys) == bzip(xs, ys, true);\n{ BzipZipLemma(xs.tl, ys.tl); }\nfunction constr(n:int): Stream<int>\n{\n  Cons(n, constr(n))\n}\nfunction blink(): Stream<int>\n{\n  Cons(0, Cons(1, blink()))\n}\ncolemma BzipBlinkLemma()\n  ensures zip(constr(0), constr(1)) == blink();\n{\n  BzipBlinkLemma();\n}\nfunction zip2(xs: Stream, ys: Stream): Stream\n{\n  Cons(xs.hd, zip2(ys, xs.tl))\n}\ncolemma Zip201Lemma()\n  ensures zip2(constr(0), constr(1)) == blink();\n{\n  Zip201Lemma();\n}\ncolemma ZipZip2Lemma(xs:Stream, ys:Stream)\n  ensures zip(xs, ys) == zip2(xs, ys);\n{\n  ZipZip2Lemma(xs.tl, ys.tl);\n}\nfunction bswitch(xs: Stream, f:bool) : Stream\n{\n  if f then Cons(xs.tl.hd, bswitch(Cons(xs.hd, xs.tl.tl), !f))\n  else      Cons(xs.hd,      bswitch(xs.tl, !f))\n}\ncolemma BswitchLemma(xs:Stream)\n  ensures zip(odd(xs), even(xs)) == bswitch(xs, true);\n{\n  BswitchLemma(xs.tl.tl);\n}\ncolemma Bswitch2Lemma(xs:Stream, ys:Stream)\n  ensures zip(xs, ys) == bswitch(zip(ys, xs), true);\n{\n  Bswitch2Lemma(xs.tl, ys.tl);\n}"
},
{
    "dafny": "method isPrefix(pre:string, str:string) returns(res:bool)\n    requires 0 < |pre| <= |str| \n{\n    var i := 0;\n    while (i < |pre|)\n        invariant 0 <= i <= |pre|                               \n        decreases |pre| - i                                     \n    {\n        if (str[i] != pre[i]) {\n            print str[i], \" != \", pre[i], \"\\n\";\n            return false;\n        }\n        else{\n            print str[i], \" == \", pre[i], \"\\n\";\n            i := i + 1;\n        }\n    }\n    return true;\n}\nmethod isSubstring(sub:string, str:string) returns(res:bool)\n    requires 0 < |sub| <= |str| \n{\n    var i := 0;\n    var n := (|str| - |sub|);\n    while(i < n+1)\n        invariant 0 <= i <= n+1     \n        decreases n - i             \n    {\n        print \"\\n\", sub, \", \", str[i..|str|], \"\\n\";\n        var result:= isPrefix(sub, str[i..|str|]);\n        if(result == true){\n            return true;\n        }\n        else{\n            i := i+1;\n        }\n    }\n    return false;\n}\nmethod haveCommonKSubstring(k:nat, str1:string, str2:string) returns(found:bool)\n    requires 0 < k <= |str1| &&  0 < k <= |str2| \n{\n    var i := 0;\n    var n := |str1|-k;\n    while(i < n)\n        decreases n - i \n    {\n        print \"\\n\", str1[i..i+k], \", \", str2, \"\\n\";\n        var result := isSubstring(str1[i..i+k], str2);\n        if(result == true){\n            return true;\n        }\n        else{\n            i:=i+1;\n        }\n    }\n    return false;\n}\nmethod maxCommonSubstringLength(str1:string, str2:string) returns(len:nat)\n    requires 0 < |str1| && 0 < |str1|\n{\n    var result:bool;\n    var i:= |str1|;\n    if(|str2| < |str1|){\n        i := |str2|;\n    }\n    while (i > 0)\n        decreases i - 0\n    {\n        print str1, \", \", str2, \" k = \", i, \"\\n\";\n        result := haveCommonKSubstring(i, str1, str2);\n        if(result == true){\n            return i;\n        }\n        else{\n            i := i - 1;\n        }\n    }\n    return 0;\n}\nmethod Main(){\n    var prefix:string := \"pre\";\n    var str_1:string := \"prehistoric\";\n    var result:bool;\n    var substring := \"and\";\n    var str_2 := \"operand\";\n    var string1 := \"operation\";\n    var string2 := \"irrational\";\n    var k:nat := 5;\n    var x := maxCommonSubstringLength(string1, string2);\n    print \"Result: \", x, \"\\n\";\n}"
},
{
    "dafny": "method Symmetric(a: array<int>) returns (flag: bool)\nensures flag == true ==> forall x :: 0 <= x < a.Length ==> a[x] == a[a.Length - x - 1]\nensures flag == false ==> exists x :: 0 <= x < a.Length && a[x] != a[a.Length - x - 1]\n{\n    if a.Length == 0 {\n        return true;\n    } \n    var i:int := 0;\n    while i < a.Length\n    invariant 0 <= i <= a.Length \n    invariant forall x :: 0 <= x < i ==> a[x] == a[a.Length - x - 1]\n    {\n        if a[i] != a[a.Length - i - 1] {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}"
},
{
    "dafny": "method Main() {\n  var xs := Nil;\n  var s := SmallestMissingNumber(xs);\n  assert s == 0;\n  print s, \" \";  \n  var a := Cons(2, Cons(0, Nil));\n  print SmallestMissingNumber(a), \" \";  \n  a := Cons(3, Cons(1, a));\n  print SmallestMissingNumber(a), \" \";  \n  a := Cons(7, Cons(4, Cons(6, a)));\n  print SmallestMissingNumber(a), \"\\n\";  \n}\ndatatype List<X> = Nil | Cons(head: X, tail: List<X>)\nfunction Length(xs: List): nat\n{\n  match xs\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\nfunction SmallestMissingNumber(xs: List<nat>): nat\n{\n  SMN(xs, 0, Length(xs))\n}\nfunction SMN(xs: List<nat>, n: nat, len: nat): nat\n  requires len == Length(xs)\n  decreases len\n{\n  if 2 <= len then\n    var (L, R) := Split(xs, n + len/2);\n    var llen := Length(L);\n    if llen < len/2 then\n      SMN(L, n, llen)\n    else\n      SMN(R, n + llen, len - llen)\n  else if xs.Cons? then\n    if xs.head == n then n + 1 else n\n  else\n    n\n}\nfunction SMN'(xs: List<nat>, n: nat, len: nat): nat\n  requires len == Length(xs)\n  decreases len\n{\n  if xs == Nil then\n    n\n  else\n    var half := (len + 1) / 2;\n    var (L, R) := Split(xs, n + half);\n    var llen := Length(L);\n    if llen < half then\n      SMN'(L, n, llen)\n    else\n      SMN'(R, n + llen, len - llen)\n}\nfunction SMN''(xs: List<nat>, n: nat, len: nat): nat\n  requires len == Length(xs)\n  decreases len\n{\n  if xs == Nil then\n    n\n  else\n    var half := len / 2 + 1;\n    var (L, R) := Split(xs, n + half);\n    var llen := Length(L);\n    if llen < half then\n      SMN''(L, n, llen)\n    else\n      SMN''(R, n + llen, len - llen)\n}\nfunction Split(xs: List<nat>, b: nat): (List<nat>, List<nat>)\n  ensures var r := Split(xs, b); Length(xs) == Length(r.0) + Length(r.1)\n{\n  match xs\n  case Nil => (Nil, Nil)\n  case Cons(x, tail) =>\n    var (L, R) := Split(tail, b);\n    if x < b then\n      (Cons(x, L), R)\n    else\n      (L, Cons(x, R))\n}\nlemma SmallestMissingNumber_Correct(xs: List<nat>)\n  requires NoDuplicates(xs)\n  ensures var s := SmallestMissingNumber(xs);\n    s !in Elements(xs) &&\n    forall x :: 0 <= x < s ==> x in Elements(xs)\n{\n  SMN_Correct(xs, 0, Length(xs));\n}\nghost function Elements(xs: List): set\n{\n  match xs\n  case Nil => {}\n  case Cons(x, tail) => {x} + Elements(tail)\n}\nghost predicate NoDuplicates(xs: List)\n{\n  match xs\n  case Nil => true\n  case Cons(x, tail) =>\n    x !in Elements(tail) && NoDuplicates(tail)\n}\nlemma Cardinality(A: set, B: set)\n  requires A <= B\n  ensures |A| <= |B|\n{\n  if A != {} {\n    var x :| x in A;\n    Cardinality(A - {x}, B - {x});\n  }\n}\nlemma SetEquality(A: set, B: set)\n  requires A <= B && |A| == |B|\n  ensures A == B\n{\n  if A == {} {\n  } else {\n    var x :| x in A;\n    SetEquality(A - {x}, B - {x});\n  }\n}\nlemma SMN_Correct(xs: List<nat>, n: nat, len: nat)\n  requires NoDuplicates(xs)\n  requires forall x :: x in Elements(xs) ==> n <= x\n  requires len == Length(xs)\n  ensures var s := SMN(xs, n, len);\n    n <= s <= n + len &&\n    s !in Elements(xs) &&\n    forall x :: n <= x < s ==> x in Elements(xs)\n  decreases len\n{\n  if 2 <= len {\n    var (L, R) := Split(xs, n + len/2);\n    Split_Correct(xs, n + len/2);\n    var llen := Length(L);\n    Elements_Property(L);  \n    var bound := IntRange(n, len/2);\n    Cardinality(Elements(L), bound);\n    if llen < len/2 {\n      SMN_Correct(L, n, llen);\n    } else {\n      var s := SMN(R, n + llen, len - llen);\n      SMN_Correct(R, n + llen, len - llen);\n      forall x | n <= x < s\n        ensures x in Elements(xs)\n      {\n        if x < n + llen {\n          SetEquality(Elements(L), bound);\n        }\n      }\n    }\n  }\n}\nlemma Split_Correct(xs: List<nat>, b: nat)\n  requires NoDuplicates(xs)\n  ensures var r := Split(xs, b);\n    Elements(r.0) == (set x | x in Elements(xs) && x < b) &&\n    Elements(r.1) == (set x | x in Elements(xs) && b <= x) &&\n    NoDuplicates(r.0) && NoDuplicates(r.1)\n{\n  match xs\n  case Nil =>\n  case Cons(_, tail) =>\n    Split_Correct(tail, b);\n}\nlemma Elements_Property(xs: List)\n  requires NoDuplicates(xs)\n  ensures |Elements(xs)| == Length(xs)\n{\n}\nghost function IntRange(lo: nat, len: nat): set<nat>\n  ensures |IntRange(lo, len)| == len\n{\n  var S := set x | lo <= x < lo + len;\n  assert len != 0 ==> S == IntRange(lo, len - 1) + {lo+len-1};\n  S\n}\nlemma {:vcs_split_on_every_assert} SMN'_Correct(xs: List<nat>, n: nat, len: nat)\n  requires NoDuplicates(xs)\n  requires forall x :: x in Elements(xs) ==> n <= x\n  requires len == Length(xs)\n  ensures var s := SMN'(xs, n, len);\n    n <= s <= n + len &&\n    s !in Elements(xs) &&\n    forall x :: n <= x < s ==> x in Elements(xs)\n  decreases len\n{\n  if xs == Nil {\n  } else {\n    var half := (len + 1) / 2;\n    var (L, R) := Split(xs, n + half);\n    Split_Correct(xs, n + half);\n    var llen := Length(L);\n    Elements_Property(L);  \n    var bound := IntRange(n, half);\n    Cardinality(Elements(L), bound);\n    if llen < half {\n      SMN'_Correct(L, n, llen);\n    } else {\n      var s := SMN'(R, n + llen, len - llen);\n      SMN'_Correct(R, n + llen, len - llen);\n      forall x | n <= x < s\n        ensures x in Elements(xs)\n      {\n        if x < n + llen {\n          SetEquality(Elements(L), bound);\n        }\n      }\n    }\n  }\n}\nlemma {:vcs_split_on_every_assert} SMN''_Correct(xs: List<nat>, n: nat, len: nat)\n  requires NoDuplicates(xs)\n  requires forall x :: x in Elements(xs) ==> n <= x\n  requires len == Length(xs)\n  ensures var s := SMN''(xs, n, len);\n    n <= s <= n + len &&\n    s !in Elements(xs) &&\n    forall x :: n <= x < s ==> x in Elements(xs)\n  decreases len\n{\n  if xs == Nil {\n  } else {\n    var half := len / 2 + 1;\n    var (L, R) := Split(xs, n + half);\n    Split_Correct(xs, n + half);\n    var llen := Length(L);\n    Elements_Property(L);  \n    var bound := IntRange(n, half);\n    Cardinality(Elements(L), bound);\n    if llen < half {\n      SMN''_Correct(L, n, llen);\n    } else {\n      var s := SMN''(R, n + llen, len - llen);\n      SMN''_Correct(R, n + llen, len - llen);\n      forall x | n <= x < s\n        ensures x in Elements(xs)\n      {\n        if x < n + llen {\n          SetEquality(Elements(L), bound);\n        }\n      }\n    }\n  }\n}"
},
{
    "dafny": "datatype Expp = Const(valeur:int) | Var(string) | Plus(Expp, Expp) |  Mult(Expp, Expp)\nfunction eval(e:Expp, store:map<string, int>):int\ndecreases e, store\n{\n\tmatch(e)\n\t\tcase Const(n) => n\n\t\tcase Var(s) => if(s in store) then store[s] else -1\n\t\tcase Plus(e1, e2) => eval(e1, store) + eval(e2, store)\n\t\tcase Mult(e1, e2) => eval(e1, store) * eval(e2, store)\n}\nfunction optimize(e:Expp):Expp\ndecreases e\n{\n\tmatch (e) \n\t  case Mult(e1, e2) => if e1==Const(0) then Const(0) \n\t                       else if e1==Const(1) then e2 \n\t\t\t\t\t\t   else if e2==Const(0) then Const(0)\n\t\t\t\t\t\t   else if e2==Const(1) then e1\n\t\t\t\t\t\t   else if e1.Const? && e2.Const? then Const(e1.valeur*e2.valeur)\n\t\t\t\t\t\t   else Mult(e1, e2)\n\t  case Plus(e1, e2) => if e1==Const(0) then e2\n\t                       else if e2==Const(0) then e1\n\t\t\t\t\t\t   else if e1.Const? && e2.Const? then Const(e1.valeur+e2.valeur)\n\t\t\t\t\t\t   else Plus(e1, e2)\n\t  case Const(n)     => Const(n)\n\t  case Var(s)       => Var(s)\n}\nmethod optimizeCorrect(e:Expp, s:map<string, int>)\n decreases e, s\nensures eval(e,s) == eval(optimize(e), s)\n{\n\tmatch (e) {\n\t\tcase Mult(e1, e2) => {\n\t\t\tif e1==Const(0) {\n\t\t\tassert eval(optimize(e), s)\n\t\t\t    == eval(optimize(Mult(e1, e2)), s)\n\t\t\t\t== eval(optimize(Mult(Const(0), e2)), s)\n\t\t\t\t== eval(Const(0), s)\n\t\t\t\t== 0\n\t\t\t\t== 0 * eval(e2, s)\n\t\t\t\t== eval(Const(0), s) * eval(e2, s)\n\t\t\t\t== eval(e1, s) * eval(e2, s)\n\t\t\t\t== eval(Mult(e1, e2), s)\n\t\t\t\t== eval(e, s);\n\t\t\t} else if e1==Const(1) {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(optimize(Mult(e1, e2)), s)\n\t\t\t\t\t== eval(optimize(Mult(Const(1), e2)), s)\n\t\t\t\t\t== eval(e2, s)\n\t\t\t\t\t== eval(e2, s) * 1\n\t\t\t\t\t== eval(e2, s) * eval(Const(1), s)\n\t\t\t\t\t== eval(e2, s) * eval(e1, s)\n\t\t\t\t\t== eval(e1, s) * eval(e2, s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t} else if e2==Const(0) {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(optimize(Mult(e1, e2)), s)\n\t\t\t\t\t== eval(optimize(Mult(e1, Const(0))), s)\n\t\t\t\t\t== eval(Const(0), s)\n\t\t\t\t\t== 0\n\t\t\t\t\t== 0 * eval(e1, s)\n\t\t\t\t\t== eval(Const(0), s) * eval(e1, s)\n\t\t\t\t\t== eval(e1, s) * eval(e2, s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t} else if e2==Const(1) {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(optimize(Mult(e1, e2)), s)\n\t\t\t\t\t== eval(optimize(Mult(e1, Const(1))), s)\n\t\t\t\t\t== eval(e1, s)\n\t\t\t\t\t== eval(e1, s) * 1\n\t\t\t\t\t== eval(e1, s) * eval(Const(1), s)\n\t\t\t\t\t== eval(e1, s) * eval(e2, s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t} else if e1.Const? && e2.Const? {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(Const(e1.valeur*e2.valeur), s)\n\t\t\t\t\t== e1.valeur * e2.valeur\n\t\t\t\t\t== eval(e1, s) * eval(e2, s)\n\t\t\t\t\t== eval(Mult(e1, e2), s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t} else {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(optimize(Mult(e1, e2)), s)\n\t\t\t\t\t== eval(Mult(e1, e2), s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t}\n\t\t}\n\t\tcase Plus(e1, e2) => {\n\t\t\tif e1==Const(0) {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(optimize(Plus(e1, e2)), s)\n\t\t\t\t\t== eval(optimize(Plus(Const(0), e2)), s)\n\t\t\t\t\t== eval(e2, s)\n\t\t\t\t\t== eval(e2, s) + 0\n\t\t\t\t\t== eval(e2, s) + eval(Const(0), s)\n\t\t\t\t\t== eval(e2, s) + eval(e1, s)\n\t\t\t\t\t== eval(e1, s) + eval(e2, s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t} else if e2==Const(0) {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(optimize(Plus(e1, e2)), s)\n\t\t\t\t\t== eval(optimize(Plus(e1, Const(0))), s)\n\t\t\t\t\t== eval(e1, s)\n\t\t\t\t\t== eval(e1, s) + 0\n\t\t\t\t\t== eval(e1, s) + eval(Const(0), s)\n\t\t\t\t\t== eval(e1, s) + eval(e2, s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t} else if e1.Const? && e2.Const? {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(Const(e1.valeur+e2.valeur), s)\n\t\t\t\t\t== e1.valeur + e2.valeur\n\t\t\t\t\t== eval(e1, s) + eval(e2, s)\n\t\t\t\t\t== eval(Plus(e1, e2), s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t} else {\n\t\t\t\tassert eval(optimize(e), s)\n\t\t\t\t    == eval(optimize(Plus(e1, e2)), s)\n\t\t\t\t\t== eval(Plus(e1, e2), s)\n\t\t\t\t\t== eval(e, s);\n\t\t\t}\n\t\t}\n\t\tcase Const(n) => {\n\t\t\tassert eval(optimize(e), s)\n\t\t\t    == eval(optimize(Const(n)), s)\n\t\t\t\t== eval(Const(n), s)\n\t\t\t\t== eval(e, s);\n\t\t}\n\t\tcase Var(a) => {\n\t\t\tassert eval(optimize(e), s)\n\t\t\t    == eval(optimize(Var(a)), s)\n\t\t\t\t== eval(Var(a), s)\n\t\t\t\t== eval(e, s);\n\t\t}\n\t}\n}\nmethod optimizeFeatures()\n{\n\tassert( optimize(Mult(Var(\"x\"), Const(0))) == Const(0) );\n\tassert( optimize(Mult(Var(\"x\"), Const(1))) == Var(\"x\") );\n\tassert( optimize(Mult(Const(0), Var(\"x\"))) == Const(0) );\n\tassert( optimize(Mult(Const(1), Var(\"x\"))) == Var(\"x\") );\n\tassert( optimize(Plus(Const(0), Var(\"x\"))) == Var(\"x\") );\n\tassert( optimize(Plus(Var(\"x\"), Const(0))) == Var(\"x\") );\n\tassert( optimize(Plus(Const(3), Const(4))) == Const(7) );\n\tassert( optimize(Mult(Const(3),Const(4))) == Const(12) );\n\tassert( optimize(Plus(Plus(Var(\"x\"), Var(\"y\")), Const(0))) == Plus(Var(\"x\"), Var(\"y\")) );\n}"
},
{
    "dafny": "method find(a: array<int>, key: int) returns(index: int)\n    requires a.Length > 0;\n    ensures 0 <= index <= a.Length;\n    ensures index < a.Length ==> a[index] == key;\n{\n    index := 0;\n    while index < a.Length && a[index] != key \n        decreases a.Length - index \n        invariant 0 <= index <= a.Length\n        invariant forall x :: 0 <= x < index ==> a[x] != key\n    {\n        index := index + 1;\n    }\n}"
},
{
    "dafny": "predicate sorted(a:array<int>, low:int, high:int) \n    requires 0 <= low <= high <= a.Length;\n    reads a;\n{\n    forall j, k :: low <= j < k < high ==> a[j] <= a[k]\n}\nmethod selection_sort(a:array<int>)\n    modifies a;\n    requires a.Length > 0\n    ensures multiset(a[..]) == old(multiset(a[..]));\n    ensures sorted(a, 0, a.Length)\n{\n    var max : int;\n    var i: int;\n    i := a.Length-1;\n    max := i;\n    while i > 0\n    invariant 0 <= i < a.Length;\n    invariant multiset(a[..]) == old(multiset(a[..]))\n    invariant sorted(a, i, a.Length); \n    invariant forall j :: 0 <= j < i < a.Length-1 ==> a[j] <= a[i+1] \n    decreases i;\n    {\n        max := select(a, i);\n        a[i], a[max] := a[max], a[i];\n        i := i-1;\n    }\n}\nmethod select(a:array<int>, i: int) returns (m:int)\n    requires 0 <= i < a.Length\n    ensures 0 <= m <= i\n    ensures multiset(a[..]) == old(multiset(a[..]))\n    ensures forall x :: 0 <= x <= i ==> a[x] <= a[m]\n{\n    var j := i;\n    m := j;\n    while j > 0\n    invariant 0 <= j <= i\n    invariant 0 <= m <= i\n    invariant forall x:: j <= x <= i ==> a[m] >= a[x]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n    decreases j\n    {\n        j := j-1;\n        if( a[j] > a[m])\n        {\n            m := j;\n        }\n    } \n}\nmethod Main ()\n{\n    var A := new int[10];\n    A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9] := 4, 8, 8, 3, 5, 10, 9, 9, 4, 7;\n    print \"A = \", A[..], \"\\n\";\n    selection_sort(A);\n    print \"A = \", A[..], \"\\n\";\n}"
},
{
    "dafny": "method ComputeFact(n : nat) returns (res : nat)\n  requires n > 0;\n  ensures res == fact(n);\n {\n  res := 1;\n  var i := 2;\n  while (i <= n) \n  invariant res == fact(i-1) && n >= i -1;   \n  decreases n-i;             \n  {\n    res := res * i;\n    i := i + 1;\n  }\n }\n function fact(x : int): int\n  requires x >= 0\n  ensures 1 <= fact(x);\n  {\n    if ( x == 0)\n    then\n      1\n    else\n       x * fact(x-1)\n  }"
},
{
    "dafny": "method Abs(x : int) returns (y : int)\nensures 0 <= x ==> y == x;\nensures x < 0 ==> y == -x;\nensures 0 <= y;\n{\nif (x < 0)\n{ y := -x; }\nelse\n{ y := x; }\n}"
},
{
    "dafny": "method Triple(x: int) returns (r: int) {\n    if {\n        case x < 18 =>\n            var a, b := 2 * x, 4 * x;\n            r := (a + b) / 2;\n        case 0 <= x =>\n            var y := 2 * x;\n            r := x + y;\n    }\n    assert r == 3 * x;\n}"
},
{
    "dafny": "newtype uint32 = i:int | 0 <= i < 0x100000000\ndatatype Example0 = Example0(u:uint32, b:bool)\nmethod Test0(e0:Example0)\n{\n  var s := { e0 };\n}\ndatatype Example1 = Ex1a(u:uint32) |  Ex1b(b:bool)\nmethod Test1(t0:Example1)\n{\n  var t := { t0 };\n}\nmethod Test(name:string, b:bool)\n  requires b\n{\n  if b {\n    print name, \": This is expected\\n\";\n  } else {\n    print name, \": This is *** UNEXPECTED *** !!!!\\n\";\n  }\n}\nmethod Basic() {\n  var s:set<uint32> := {1, 2, 3, 4};\n  var t:set<uint32> := {1, 2, 3, 4};\n  Test(\"Identity\", s == s);\n  Test(\"ValuesIdentity\", s == t);\n  Test(\"DiffIdentity\", s - {1} == t - {1});\n  Test(\"DiffIdentitySelf\", s - {2} != s - {1});\n  Test(\"ProperSubsetIdentity\", !(s < s));\n  Test(\"ProperSubset\", !(s < t));\n  Test(\"SelfSubset\", s <= s);\n  Test(\"OtherSubset\", t <= s && s <= t);\n  Test(\"UnionIdentity\", s + s == s);\n  Test(\"Membership\", 1 in s);\n  Test(\"NonMembership1\", !(5 in s));\n  Test(\"NonMembership2\", !(1 in (s - {1})));\n}\nmethod SetSeq() {\n  var m1:seq<uint32> := [1];\n  var m2:seq<uint32> := [1, 2];\n  var m3:seq<uint32> := [1, 2, 3];\n  var m4:seq<uint32> := [1, 2, 3, 4];\n  var n1:seq<uint32> := [1];\n  var n2:seq<uint32> := [1, 2];\n  var n3:seq<uint32> := [1, 2, 3];\n  var s1:set<seq<uint32>> := { m1, m2, m3 };\n  var s2:set<seq<uint32>> := s1 - { m1 };\n  Test(\"SeqMembership1\", m1 in s1);\n  Test(\"SeqMembership2\", m2 in s1);\n  Test(\"SeqMembership3\", m3 in s1);\n  Test(\"SeqNonMembership1\", !(m1 in s2));\n  Test(\"SeqNonMembership2\", !(m4 in s1));\n  Test(\"SeqNonMembership3\", !(m4 in s2));\n  Test(\"SeqMembershipValue1\", n1 in s1);\n  Test(\"SeqMembershipValue2\", n2 in s1);\n  Test(\"SeqMembershipValue3\", n3 in s1);\n}\nmethod SetComprehension(s:set<uint32>)\n  requires forall i :: 0 <= i < 10 ==> i in s\n  requires |s| == 10\n{\n  var t:set<uint32> := set y:uint32 | y in s;\n  Test(\"SetComprehensionInEquality\", t == s);\n  Test(\"SetComprehensionInMembership\", 0 in t);\n}\nmethod LetSuchThat() {\n  var s:set<uint32> := { 0, 1, 2, 3 };\n  var e:uint32 :| e in s;\n  Test(\"LetSuchThatMembership\", e in s);\n  Test(\"LetSuchThatValue\", e == 0 || e == 1 || e == 2 || e == 3);\n}\nmethod Contains() {\n  var m1:seq<uint32> := [1];\n  var m2:seq<uint32> := [1, 2];\n  var m3:seq<uint32> := [1, 2, 3];\n  var m3identical:seq<uint32> := [1, 2, 3];\n  var mm := [m1, m3, m1];\n  if m1 in mm {\n    print \"Membership 1: This is expected\\n\";\n  } else {\n    print \"Membership 1: This is unexpected\\n\";\n    assert false;\n  }\n  if m2 in mm {\n    print \"Membership 2: This is unexpected\\n\";\n    assert false;\n  } else {\n    print \"Membership 2: This is expected\\n\";\n  }\n  if m3 in mm {\n    print \"Membership 3: This is expected\\n\";\n  } else {\n    print \"Membership 3: This is unexpected\\n\";\n    assert false;\n  }\n  if m3identical in mm {\n    print \"Membership 3 value equality: This is expected\\n\";\n  } else {\n    print \"Membership 3 value equality: This is unexpected\\n\";\n    assert false;\n  }\n}\nmethod Main() {\n  Basic();\n  SetSeq();\n  var s := { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  SetComprehension(s);\n  LetSuchThat();\n}"
},
{
    "dafny": "method GetNext(i: int) returns (j: int, possible: bool) {\n  if i == 1 {\n    possible := false;\n    j := 0;\n  } else {\n    possible := true;\n    j := if i % 2 == 0 then  i / 2 else i * 3 + 1;\n  }\n}\nmethod Main()\n{\n  var i := 10;\n  var k := 27;\n  while i > 0\n    invariant i >= 0\n  {\n    label before:\n    var newK, possible := GetNext(k);\n    if(!possible) {\n      break;\n    }\n    k := newK;\n    print k;\n    i := i - 1;\n  }\n}"
},
{
    "dafny": "method Main() {\n  var a: A, b: B, c: C, k: K, l: L := new M, new M, new M, new K<real>, new L<real>;\n  var a', b', c', k', l' := AssignBackAndForth(a, b, c, k, l);\n  print a == a', \" \", b == b', \" \", c == c', \" \", k == k', \" \", l == l', \"\\n\";\n  a', b', c', k', l' := AsBackAndForth(a, b, c, k, l);\n  print a == a', \" \", b == b', \" \", c == c', \" \", k == k', \" \", l == l', \"\\n\";\n  IsTests();\n}\ntrait A<X> { }\ntrait B<Y0, Y1> { }\ntrait C<Z> extends B<int, Z> { }\nclass K<U> extends object, B<int, U> { }\nclass L<V> extends C<V> { }\nclass M extends A<real>, C<real> { }\nmethod AssignBackAndForth<W>(a: A<W>, b: B<int, W>, c: C<W>, k: K<W>, l: L<W>) returns (a': A<W>, b': B<int, W>, c': C<W>, k': K<W>, l': L<W>)\n  ensures a' == a && b' == b && c' == c && k' == k && l' == l\n{\n  var o: object?;\n  o := a;\n  a' := o;\n  o := b;\n  b' := o;\n  o := c;\n  c' := o;\n  o := k;\n  k' := o;\n  o := l;\n  l' := o;\n}\nmethod AsBackAndForth<W>(a: A<W>, b: B<int, W>, c: C<W>, k: K<W>, l: L<W>) returns (a': object, b': object, c': object, k': object, l': object)\n  ensures a' == a && b' == b && c' == c && k' == k && l' == l\n{\n  var o: object?;\n  o := a;\n  a' := o as A<W>;\n  o := b;\n  b' := o as B<int, W>;\n  o := c;\n  c' := o as C<W>;\n  o := k;\n  k' := o as K<W>;\n  o := l;\n  l' := o as L<W>;\n}\nmethod IsTests() {\n  var p := new ClassP;\n  var q := new ClassQ<int>;\n  var r, r' := new ClassR<int>, new ClassR';\n  var s := new ClassS;\n  var t := new ClassT<int>;\n  print \"IsComparisons ----\\n\";\n  IsComparisons0(q, q, p);\n  IsComparisons0(r, r, r);\n  IsComparisons0(s, s, s);\n  IsComparisons0(q, r, r');\n  IsComparisons1(r, t);\n  IsComparisons1(r', t);\n  print \"TestNullIs ----\\n\";\n  TestNullIs(q, q, q, q, q, q);\n  TestNullIs(q, null, q, null, q, null);\n  print \"TestFromTraits ----\\n\";\n  TestFromTraits0(null); \n  TestFromTraits1(null); \n  var xx := new XX;\n  TestFromTraits0(xx); \n  TestFromTraits1(xx); \n  TestFromTraits2(xx); \n  TestFromTraits3(xx); \n}\ntrait TraitA<X> { }\ntrait TraitB<X> { }\nclass ClassP { }\nclass ClassQ<Y> extends TraitA<Y> { }\nclass ClassR<Z> extends TraitA<Z>, TraitB<Z> { }\nclass ClassS extends TraitA<int> { }\nclass ClassT<Z> extends TraitA<seq<Z>> { }\nclass ClassR' extends TraitB<int> { }\nmethod IsComparisons0<U>(au: TraitA<U>, ai: TraitA<int>, o: object) {\n  print au as object is ClassP, \" \", au is ClassQ<U>, \" \", au is ClassR<U>, \" \", au as object is ClassS, \"\\n\";\n  print \"  \", ai is ClassQ<int>, \" \", ai is ClassR<int>, \" \", ai is ClassS, \"\\n\";\n  print \"  \", o is ClassP, \" \", o is ClassS, \"\\n\";\n}\nmethod IsComparisons1<U>(b: TraitB<U>, tz: TraitA<seq<U>>) {\n  print b is ClassR<U>, \" \", tz is ClassT<U>, \"\\n\";\n}\nmethod TestNullIs<U>(o: object, oo: object?, t: TraitA<U>, tt: TraitA?<U>, q: ClassQ<U>, qq: ClassQ?<U>) {\n  ghost var checkit := o is TraitA<U> && o is TraitA?<U> && o is ClassQ<U> && o is ClassQ?<U>;\n  checkit := oo is TraitA<U> && oo is TraitA?<U> && oo is ClassQ<U> && oo is ClassQ?<U>;\n  print o is object, \" \", o is object?, \"\\n\";\n  print oo is object, \" \", oo is object?, \"\\n\";\n  print t is object, \" \", t is object?, \" \", t is TraitA<U>, \" \", t is TraitA?<U>, \" \", t is ClassQ<U>, \" \", t is ClassQ?<U>, \"\\n\";\n  print tt is object, \" \", tt is object?, \" \", tt is TraitA<U>, \" \", tt is TraitA?<U>, \" \", tt is ClassQ<U>, \" \", tt is ClassQ?<U>, \"\\n\";\n  print q is object, \" \", q is object?, \" \", q is TraitA<U>, \" \", q is TraitA?<U>, \" \", q is ClassQ<U>, \" \", q is ClassQ?<U>, \"\\n\";\n  print qq is object, \" \", qq is object?, \" \", qq is TraitA<U>, \" \", qq is TraitA?<U>, \" \", qq is ClassQ<U>, \" \", qq is ClassQ?<U>, \"\\n\";\n}\ntrait XA { }\ntrait XB { }\ntrait XC extends XA, XB { }\ntrait XD extends XC { }\ntrait XE { }\nclass XX extends XD { }\nmethod TestFromTraits0(x: XX?) {\n  var o: object? := x;\n  var c := 0;\n  c := c + if o is XA? then 1 else 0;\n  c := c + if o is XB? then 1 else 0;\n  c := c + if o is XC? then 1 else 0;\n  c := c + if o is XD? then 1 else 0;\n  c := c + if o is XE? then 1 else 0;\n  print c, \"\\n\"; \n}\nmethod TestFromTraits1(x: XX?) {\n  var o: object? := x;\n  var c := 0;\n  c := c + if o is XA then 1 else 0;\n  c := c + if o is XB then 1 else 0;\n  c := c + if o is XC then 1 else 0;\n  c := c + if o is XD then 1 else 0;\n  c := c + if o is XE then 1 else 0;\n  print c, \"\\n\"; \n}\nmethod TestFromTraits2(x: XX) {\n  var o: object := x;\n  var c := 0;\n  c := c + if o is XA? then 1 else 0;\n  c := c + if o is XB? then 1 else 0;\n  c := c + if o is XC? then 1 else 0;\n  c := c + if o is XD? then 1 else 0;\n  c := c + if o is XE? then 1 else 0;\n  print c, \"\\n\"; \n}\nmethod TestFromTraits3(x: XX) {\n  var o: object := x;\n  var c := 0;\n  c := c + if o is XA then 1 else 0;\n  c := c + if o is XB then 1 else 0;\n  c := c + if o is XC then 1 else 0;\n  c := c + if o is XD then 1 else 0;\n  c := c + if o is XE then 1 else 0;\n  print c, \"\\n\"; \n}"
},
{
    "dafny": "datatype List = Nil | Cons(int, List)\nfunction Len(l:List): int\n  ensures Len(l) >= 0\n{\n  match l\n  case Nil => 0\n  case Cons(hd, tl) => Len(tl) + 1\n}\nfunction isEmpty(l:List): bool\n{\n    match l\n    case Nil => true\n    case Cons(hd, tl) => false\n}\nfunction Append(l1:List, l2:List): (lout: List)\n  ensures Len(l1) + Len(l2) == Len(lout)\n  ensures l2 == lout || l1 == lout || Len(lout) > 1\n  ensures l2 == lout || Len(lout) == Len(l2) + 1 || Len(l1) > 1\n  ensures l1 == lout || Len(lout) > Len(l1) + 1 || Len(l2) == 1\n{\n  match l1\n  case Nil => l2\n  case Cons(hd, tl) => Cons(hd, Append(tl, l2))\n}"
},
{
    "dafny": "datatype Door = Closed | Open\nmethod InitializeDoors(n:int) returns (doors:array<Door>)\n  requires n >= 0\n  ensures doors != null && fresh(doors) && doors.Length == n\n  ensures forall j :: 0 <= j < doors.Length ==> doors[j] == Closed;\n{\n  doors := new Door[n];\n  var i := 0;\n  while i < doors.Length\n    invariant i <= doors.Length\n    invariant forall j :: 0 <= j < i ==> doors[j] == Closed;\n  {\n    doors[i] := Closed;\n    i := i + 1;\n  }\n}\nmethod Main ()\n{\n  var doors := InitializeDoors(100);\n  var pass := 1;\n  while pass <= doors.Length\n  {\n    var door := pass;\n    while door < doors.Length\n    {\n      doors[door] := if doors[door] == Closed then Open else Closed;\n      door := door + pass;\n    }\n    pass := pass + 1;\n  }\n  var i := 0;\n  while i < doors.Length\n  {\n    print i, \" is \", if doors[i] == Closed then \"closed\\n\" else \"open\\n\";\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "datatype Nat = Zero | Succ(pred: Nat)\n{\n  function MemberToInt(): int {\n    match this\n    case Zero => 0\n    case Succ(p) => 1 + p.MemberToInt()\n  }\n}\nfunction ExternalToInt(n: Nat): int {\n  match n\n  case Zero => 0\n  case Succ(p) => 1 + ExternalToInt(p)\n}\nfunction Prefix(n: Nat, len: nat): Nat\n  requires len <= n.MemberToInt() && len <= ExternalToInt(n)\n  ensures ExternalToInt(Prefix(n, len)) == len  \n  ensures Prefix(n, len).MemberToInt() == len  \n{\n  if len == 0 then Zero else Succ(Prefix(n.pred, len - 1))\n}"
},
{
    "dafny": "datatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | c.x % 2 == 0 witness Cell(0)\nfunction doubleEvenCell(f: EvenCell): int\n{\n  if f.x % 2 == 1 then 1/0 else f.x * 2\n}\nmethod Main() {\n  var x: set<Cell> := { Cell(1), Cell(2), Cell(3), Cell(4) };\n  var b := forall g :: g in x ==> doubleEvenCell(g) > 0;\n  assert b;\n}"
},
{
    "dafny": "function Fat(n:nat):nat\n{\n    if n == 0 then 1 else n*Fat(n-1)\n}\nmethod Fatorial(n:nat) returns (f:nat)\nensures f == Fat(n)\n{\n    f := 1;\n    var i := 1;\n    while i <= n\n        decreases n-i \n        invariant 1 <= i <= n+1 \n        invariant f == Fat(i-1) \n    {\n        f := f * i;\n        i := i + 1;\n    }\n    return f;\n}"
},
{
    "dafny": "method Deduplicate(a:array<int>, n:int) returns (b:array<int>, m:int)\n  requires a.Length >= 0\n  requires 0 <= n <= a.Length\n  requires sorted(a,n)\n  ensures b.Length >= 0\n  ensures 0 <= m <= b.Length\n  ensures b.Length <= a.Length\n  ensures 0 <= m <= n\n  ensures sorted(b,m) && unique(b,0,m)\n  ensures forall k :: 0 <= k < m ==> contains (a, n, b[k])\n  ensures forall k :: 0 <= k < n ==> contains (b, m, a[k])\n{\n  m := 0;\n  b := new int[n];\n  var i:= 0;\n  while i<n\n    decreases n-i\n    invariant 0 <= m <= i <= n\n    invariant 0 <= m <= b.Length\n    invariant forall k :: 0 <= k < m ==> contains (a, n, b[k])\n    invariant forall k :: 0 <= k < i ==> contains (b, m, a[k])\n    invariant forall j :: 0 <= j < m && i < n ==> b[j] < a[i]\n    invariant forall j,k :: (0 <= j < k < m) ==> b[j] < b[k]\n  {\n   var value:= a[i];\n   b[m] := value;\n   assert forall k :: 0 <= k < i ==> contains (b, m, a[k]);\n   i:= i+1;\n   m:= m+1;\n   var initGroup := i-1;\n   while i<n && a[i] == value\n     decreases n-i\n     invariant i <= n <= a.Length\n     invariant 0 <= initGroup <= i\n     invariant forall j :: initGroup <= j < i ==> a[j] == value\n   {\n       i:= i+1;  \n    }\n  }\n}\nfunction sorted(a:array<int>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ \n    forall i, j:: (0 <= i < j < n) ==> a[i] <= a[j] \n}\nfunction unique(b:array<int>, l:int, h:int):bool\n    reads b;\n    requires 0 <= l <= h <= b.Length\n{ \n     forall k::(l<=k<h) ==> forall j::(k<j<h) ==> b[k] != b[j] \n}\nfunction contains(b:array<int>, m:int, v:int):bool\n    requires 0 <= m <= b.Length \n    reads b\n{\n    v in b[..m]\n}"
},
{
    "dafny": "method FindMax(a: array<int>) returns (idx: int)\n  requires a.Length >= 1;\n  ensures 0 <= idx < a.Length;\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[idx]; \n{\n  var i := 1;\n  idx := 0;\n  var max := a[idx];\n  while (i < a.Length)\n    invariant 0 <= i <= a.Length;\n    invariant 0 <= idx < i;\n    invariant max == a[idx];\n    invariant forall k :: 0 <= k < i ==> max >= a[k];\n  {\n    if (a[i] >= max) {\n      idx := i;\n      max := a[idx];\n    }\n    i := i + 1;\n  }\n  return idx;\n}\nmethod FindMaxVal(a: array<int>) returns (val: int)\n  requires a.Length >= 1;\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= val;\n  ensures exists j :: 0 <= j < a.Length && a[j] == val;\n{\n  var i := 0;\n  val := a[0];\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant forall j :: 0 <= j < i ==> a[j] <= val;\n    invariant exists j :: 0 <= j < a.Length && a[j] == val;\n  {\n    if (a[i] >= val)\n    {\n      val := a[i];\n    }\n    i := i + 1;\n  }\n  return val;\n}"
},
{
    "dafny": "module Sets {\n  lemma ProperSubsetImpliesSmallerCardinality<T>(a: set<T>, b: set<T>)\n    requires a < b\n    ensures |a| < |b|\n  {\n    assert |b| == |a| + |b-a|;\n  }\n  lemma SetInclusionImpliesSmallerCardinality<T>(a: set<T>, b: set<T>)\n    requires a <= b\n    ensures |a| <= |b|\n  {\n    assert b == a + (b - a);\n  }\n  lemma SetInclusionImpliesStrictlySmallerCardinality<T>(a: set<T>, b: set<T>)\n    requires a < b\n    ensures |a| < |b|\n  {\n    assert b == a + (b - a);\n  }\n  lemma SetInclusionAndEqualCardinalityImpliesSetEquality<T>(a: set<T>, b: set<T>)\n    requires a <= b\n    requires |a| == |b|\n    ensures a == b\n  {\n    assert b == a + (b - a);\n  }\n  function SetRange(n: int) : set<int>\n  {\n    set i | 0 <= i < n\n  }\n  lemma CardinalitySetRange(n: int)\n  requires n >= 0\n  ensures |SetRange(n)| == n\n  {\n    if n == 0 {\n    } else {\n      CardinalitySetRange(n-1);\n      assert SetRange(n)\n          == SetRange(n-1) + {n-1};\n    }\n  }\n  lemma SubSetExtensionality<T>(a: set<T>, b: set<T>)\n    requires forall x | x in a :: x in b\n    ensures a <= b\n  {\n  }\n}"
},
{
    "dafny": "predicate sorted_between (a:array<int>, from:nat, to:nat)\n  reads a;\n  requires a != null;\n  requires from <= to;\n  requires to <= a.Length;\n{\n  forall i,j :: from <= i < j < to && 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\npredicate sorted (a:array<int>)\n  reads a;\n  requires a!=null;\n{\n  sorted_between (a, 0, a.Length)\n}\nmethod bubbleSort (a: array<int>)\n  modifies a;\n  requires a != null;\n  requires a.Length > 0;\n  ensures sorted(a);\n  ensures multiset(old(a[..])) == multiset(a[..]);\n{\n  var i:nat := 1;\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant sorted_between (a, 0, i);\n    invariant multiset(old (a[..])) == multiset(a[..]);\n  {\n    var j:nat := i;\n    while (j > 0)\n      invariant 0 <= j <= i;\n      invariant sorted_between (a, 0, j);\n      invariant forall u,v:: 0 <= u < j < v < i+1 ==> a[u] <= a[v];\n      invariant sorted_between (a, j, i+1);\n      invariant multiset(old (a[..])) == multiset(a[..]);\n    {\n      if (a[j-1] > a[j]) {\n        var temp:int := a[j-1];\n        a[j-1] := a[j];\n        a[j] := temp;\n      }\n      j := j - 1;\n    }\n    i := i+1;\n  }\n}"
},
{
    "dafny": "class Rectangle {\n  const width : nat;\n  const height : nat;\n  const x : int;\n  const y : int;\n  const yellowOrBlack : bool;\n  constructor(xx : int, yy : int, ww : nat, hh : nat, yb : bool)\n  requires ww >=0 && hh >=0\n  ensures width >= 0\n  ensures height >= 0\n  ensures width == ww && height == hh && x ==xx && y ==yy && yellowOrBlack ==yb{\n    width := ww as nat;\n    height := hh as nat;\n    x := xx;\n    y := yy;\n    yellowOrBlack := yb;\n  } \n  function area() : nat \n  reads this{\n    width*height\n   }\n    method move(dx : int, dy : int) returns (r : Rectangle) \n    requires width >= 0\n    requires height >= 0\n    ensures r.x == x + dx && r.y == y +dy && width == r.width && height == r.height && yellowOrBlack == r.yellowOrBlack{ \n      r := new Rectangle(x+dx,y+dy,width,height,yellowOrBlack);\n    }\n    method scale( s : nat ) returns (r : Rectangle) \n    requires s >=0\n    requires height >=0\n    requires width >=0\n    ensures r.width >= 0\n    ensures r.height >= 0\n    ensures 0 <= (width *s)\n    ensures 0 <= (height *s)\n    ensures r.width == width*(s) && r.height == height*(s) && r.x == x && r.y ==y && yellowOrBlack == r.yellowOrBlack{ \n      r := new Rectangle(x,y,width*(s),height*(s),yellowOrBlack);\n    }\n    predicate containsPoint(px : int, py : int) reads this \n    requires width >=0\n    requires height >= 0\n    { \n      (x <= px <= (x + width) && y <=py <=(y+height))\n    }\n    predicate containsRectangle(r :Rectangle) \n    reads this \n    reads r\n    requires width >=0\n    requires height >= 0\n    requires r.width >= 0\n    requires r.height >=0 { \n      ((x <= r.x) && ((x+width) >= (r.x+r.width)) && (y <= r.y) && ((y+height) >= (r.y+r.height)))\n    }\n}    \nlemma testContains (outer : Rectangle, inner : Rectangle, px : int, py : int)\n  requires outer.containsRectangle(inner)\n  requires inner.containsPoint(px,py)\n  ensures  outer.containsPoint(px,py) \n  {}\nmethod testScale (inner : Rectangle, px : int, py : int) \n  requires inner.containsPoint(px,py)\n  {\n       var outer := inner.scale(2);\n       testContains(outer,inner,px,py);\n  }\n  method Main () {\n  print true;\n  }"
},
{
    "dafny": "method FindMax(a: array<int>) returns (i: int)\n   requires 0 < a.Length\n   ensures 0 <= i < a.Length && forall k :: 0 <= k < a.Length ==> a[i] >= a[k]\n{\n   var count := 0;\n   i := 0;\n   while count < a.Length\n        invariant 0 <= count <= a.Length\n        invariant 0 <= i < a.Length \n        invariant forall k :: 0 <= k < count ==> a[i] >= a[k]\n        decreases a.Length - count\n   {\n        if a[count] >= a[i] {i := count;}\n        count := count + 1;\n   }\n}\nmethod FindMaxi(a: array<int>) returns (max: int)\n\trequires 0 < a.Length\n\tensures forall k :: 0 < k < a.Length ==> max >= a[k]\n{\n\tvar index := 0;\n\tmax := a[0]; \n\twhile index < a.Length\n\t\tinvariant 0 <= index <= a.Length\n\t\tinvariant forall k :: 0 <= k < index ==> max >= a[k]\n        decreases a.Length - index\n\t{\n\t\tif a[index] >= max { max := a[index]; }\n\t\tindex := index + 1;\n\t}\n}"
},
{
    "dafny": "module Crawler {\n  datatype Variables = Variables(x:int, y:int)\n  predicate Init(s:Variables) {\n    && s.x == 0\n    && s.y == 5\n  }\n  predicate MoveNorth(s:Variables, s':Variables) {\n    && s'.x == s.x\n    && s'.y == s.y + 1\n  }\n  predicate MoveSouthEast(s:Variables, s':Variables) {\n    && s'.x == s.x + 1\n    && s'.y == s.y - 1\n  }\n  predicate Next(s:Variables, s':Variables) {\n    || MoveNorth(s, s')\n    || MoveSouthEast(s, s')\n  }\n  predicate InManhole(s:Variables) {\n    s.x*s.x + s.y*s.y <= 3*3\n  }\n  predicate Safety(s:Variables) {\n    !InManhole(s)\n  }\n  predicate Inv(s:Variables) {\n    s.x + s.y >= 5\n  }\n  lemma SafetyTheorem(s:Variables, s':Variables)\n    ensures Init(s) ==> Inv(s)\n    ensures Inv(s) && Next(s, s') ==> Inv(s')\n    ensures Inv(s) ==> Safety(s)\n  {\n  }\n}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n  requires a != null;\n  ensures -1 <= index < a.Length;\n  ensures 0 <= index < a.Length ==> a[index] == key;\n  ensures index == -1 ==> forall x :: 0 <= x < a.Length ==> a[x] != key;\n  ensures old(a) == a;\n  ensures old(a[..]) == a[..];\n{\n  var i := 0;\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if (a[i] == key) { return i; }\n    i := i + 1;\n  }\n  return -1;\n}"
},
{
    "dafny": "method Main()\n{\n    var a := new int[5];\n    var i := 0;\n    while i < a.Length\n    decreases a.Length - i;\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> a[j] == 0\n    {\n        a[i] := 0;\n        i := i + 1;\n    }\n    var v := a[3];\n    assert v == 0;\n}"
},
{
    "dafny": "method m(n: nat)\n{\n\tvar i: int := 0;\n\twhile i < n\n\t\tinvariant 0 <= i <= n+2\n\t{\n\t\ti := i + 1;\n\t}\n\tassert i <= n+2;\n}"
},
{
    "dafny": "method Q2(x : int, y : int) returns (big : int, small : int)\n  requires x != y;\n  ensures big > small;\n{\n  if (x > y)\n   {big, small := x, y;}\n  else\n   {big, small := y, x;}\n}\nmethod Q2SameParametersAllowed(x : int, y : int) returns (big : int, small : int)\n  ensures big >= small;\n{\n  if (x > y)\n   {big, small := x, y;}\n  else\n   {big, small := y, x;}\n}"
},
{
    "dafny": "datatype List = Nil | Cons(head: int, tail: List)\nmethod Main() {\n  var a := Nil;\n  var b := Cons(5, a);\n  var c := (a, b);\n  var d := (c.1, c.0);\n  var e := ();\n  print a, \"\\n\";\n  print b, \"\\n\";\n  print c, \"\\n\";\n  print d, \"\\n\";\n  print e, \"\\n\";\n  print b.head, \" \", b.tail, \"\\n\";\n  var u := Up(0, 7);\n  print u, \"\\n\";\n  var s := Sum(u);\n  PrintSum(u, \"\");\n  print \" == \", s;\n  s := SumAgain(u);\n  print \" (once more, that's \", s, \")\\n\";\n  AllBerry();\n  TestConflictingNames();\n  TestModule();\n}\nfunction Up(m: nat, n: nat): List\n  requires m <= n\n  decreases n - m\n{\n  if m == n then Nil else Cons(m, Up(m+1, n))\n}\nfunction Sum(xs: List): int {\n  match xs  \n  case Nil => 0\n  case Cons(x, tail) => x + Sum(tail)\n}\nfunction SumAgain(xs: List): int {\n  var r := match xs  \n    case Nil => 0\n    case Cons(x, tail) => x + SumAgain(tail);\n  r\n}\nmethod PrintSum(xs: List, prefix: string) {\n  match xs  \n  case Nil =>\n  case Cons(x, tail) =>\n    print prefix, x;\n    PrintSum(tail, \" + \");  \n}\ndatatype Berry = Smultron | Jordgubb | Hjortron | Hallon\npredicate IsRed(b: Berry) {\n  b != Berry.Hjortron\n}\nmethod AllBerry() {\n  var s := set b: Berry | IsRed(b);\n  print s, \"\\n\";\n}\ndatatype ConflictingNames = ConflictingNames1(len: int, public: char, goto: string) | ConflictingNames2(goto: string)\nmethod TestConflictingNames() {\n  var x := ConflictingNames1(42, 'q', \"hello\");\n  print x.len, \" \", x.public, \" \", x.goto, \"\\n\";\n}\nmodule ModuleM {\n  datatype OptionInt = Some(int) | None\n}\nmethod TestModule() {\n  PrintMaybe(ModuleM.Some(1701));\n}\nmethod PrintMaybe(x: ModuleM.OptionInt) {\n  match x\n  case Some(n) => print n, \"\\n\";\n  case None => print \"None\\n\";\n}"
},
{
    "dafny": "module A {\n  module Inner {\n    export P reveals a,c\n    export Q reveals b,c\n    const a := 10\n    const b := 20\n    const c := 30\n  }\n}\nmodule X {\n  method m() {\n    assert I.a == 10;\n    assert I.c == 30;\n  }\n}\nmodule Y {\n  method m() {\n    assert I.a == 10;\n    assert I.b == 20;\n  }\n}"
},
{
    "dafny": "type uint32 = i:int | 0 <= i < 0x1_0000_0000\nghost function last<T>(s:seq<T>):T\n    requires |s| > 0;\n{\n    s[|s|-1]\n}\nghost function all_but_last<T>(s:seq<T>):seq<T>\n    requires |s| > 0;\n    ensures  |all_but_last(s)| == |s| - 1;\n{\n    s[..|s|-1]\n}\nghost function ConcatenateSeqs<T>(ss:seq<seq<T>>) : seq<T>\n{\n    if |ss| == 0 then [] else ss[0] + ConcatenateSeqs(ss[1..])\n}\nlemma {:axiom} lemma_ReverseConcatenateSeqs<T>(ss:seq<seq<T>>)\n    requires |ss| > 0;\n    ensures  ConcatenateSeqs(ss) == ConcatenateSeqs(all_but_last(ss)) + last(ss);\nlemma Test(word_seqs:seq<seq<uint32>>, words:seq<uint32>)\n{\n    var word_seqs' := word_seqs + [words];\n    calc {\n        ConcatenateSeqs(word_seqs');\n            { lemma_ReverseConcatenateSeqs(word_seqs'); }\n        ConcatenateSeqs(all_but_last(word_seqs')) + last(word_seqs');\n    }\n}\nlemma AltTest(word_seqs:seq<seq<uint32>>, words:seq<uint32>)\n{\n    var word_seqs' := word_seqs + [words];\n    assert last(word_seqs') == words;\n    assert ConcatenateSeqs(word_seqs) + last(word_seqs') == ConcatenateSeqs(word_seqs) + words;\n}\nghost function f<T>(s:seq<T>):seq<T>\nghost function g<T>(ss:seq<seq<T>>) : seq<T>\nlemma {:axiom} lemma_fg<T>(s:seq<seq<T>>)\n    ensures  g(s) == g(f(s));\nlemma Test2(s:seq<seq<uint32>>)\n{\n    calc {\n        g(s);\n            { lemma_fg(s); }\n        g(f(s));\n    }\n}\nlemma AltTest2(s:seq<seq<uint32>>)\n{\n    lemma_fg(s);\n    assert g(s) == g(f(s));\n}"
},
{
    "dafny": "predicate maxSpec_incorrect(a:int,b:int,c:int) \n{\n    && (a > b ==> c == a)\n    && (b > a ==> c == b)\n}\nlemma maxT_correct(a:int,b:int) returns (c:int)\n    ensures maxSpec_incorrect(a,b,c)\n{\n    if(a > b){\n        c := a;\n    }else{\n        c := b;\n    }\n}\npredicate maxSpec_mutat3(a:int,b:int,c:int)\n{\n    (a > c ==> c == a) && (b > a ==> c == b)\n}\nlemma instance3(a:int, b:int, c:int)\n    requires a == b > c\n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma instance3_inverse(a:int, b:int, c:int)\n    requires maxSpec_incorrect(a,b,c)\n    requires !maxSpec_mutat3(a,b,c)\n    ensures a == b > c\n{}\nlemma instance3_test(a:int, b:int, c:int)\n    requires a == b == 2 && c == 1 \n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test1(a:int, b:int, c:int)\n    requires a == 4 && b == 0 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test2(a:int, b:int, c:int)\n    requires a == 4 && b == 3 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test3(a:int, b:int, c:int)\n    requires a == 4 && b == 5 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test4(a:int, b:int, c:int)\n    requires a == 4 && b == 2 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test5(a:int, b:int, c:int)\n    requires a == 4 && b == 4 && c == 2 \n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test6(a:int, b:int, c:int)\n    requires a == 3 && b == 5 && c == 4\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test7(a:int, b:int, c:int)\n    requires a == 3 && b == 5 && c == 0\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test8(a:int, b:int, c:int)\n    requires a == 3 && b == 5 && c == 6\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test9(a:int, b:int, c:int)\n    requires a == 3 && b == 5 && c == 3\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3'_test1(a:int, b:int, c:int)\n    requires a == 4 && b == 2 && c == 1\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3'_test2(a:int, b:int, c:int)\n    requires a == 4 && b == 2 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3'_test3(a:int, b:int, c:int)\n    requires a == 4 && b == 2 && c == 3\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3'_test4(a:int, b:int, c:int)\n    requires a == 2 && b == 4 && c == 1\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3'_test5(a:int, b:int, c:int)\n    requires a == 2 && b == 4 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3'_test6(a:int, b:int, c:int)\n    requires a == 2 && b == 4 && c == 3\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3'_test7(a:int, b:int, c:int)\n    requires a == 2 && b == 2 && c == 1 \n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat3(a,b,c)\n{}"
},
{
    "dafny": "function P(n: nat): nat \n    decreases n\n{ \n    if n <= 2 then 1 else P(n-2) + P(n-3) \n}\nmethod calcP(n: nat) returns (res: nat)     \n    ensures res == P(n) \n{\n    if n <= 2 { return 1; }\n    var a, b, c := 1, 1, 1; \n    var i := 2;\n    while i < n\n        decreases n - i\n        invariant 2 <= i <= n \n        invariant a == P(i-2) && b == P(i-1) && c == P(i)\n    {\n        a, b, c := b, c, a + b;\n        i := i + 1;\n    }\n    res := c;\n}\nmethod test()\n{\n    var p := calcP(0);\n    assert p == 1;\n    p := calcP(1);\n    assert p == 1;\n    p := calcP(2);\n    assert p == 1;\n    p := calcP(3);\n    assert p == 2;\n    p := calcP(4);\n    assert p == 2;\n}"
},
{
    "dafny": "abstract module {:options \"/functionSyntax:4\"} Dafny {\n  trait Validatable {\n    ghost var Repr: set<object>\n    ghost predicate Valid()\n      reads this, Repr\n      decreases Repr, 1\n      ensures Valid() ==> this in Repr\n    ghost predicate ValidComponent(component: Validatable)\n      requires this in Repr\n      reads this, Repr\n      decreases Repr, 0\n    {\n      && component in Repr\n      && component.Repr <= Repr\n      && this !in component.Repr\n      && component.Valid()\n    }\n    twostate predicate ValidAndDisjoint()\n      reads this, Repr\n    {\n      Valid() && fresh(Repr - old(Repr))\n    }\n  }\n  const SIZE_T_LIMIT: nat\n  const MIN_SIZE_T_LIMIT: nat := 128\n  lemma EnsureSizeTLimitAboveMinimum() ensures MIN_SIZE_T_LIMIT <= SIZE_T_LIMIT\n  newtype size_t = x: nat | x < SIZE_T_LIMIT witness (EnsureSizeTLimitAboveMinimum(); 0)\n  const SIZE_T_MAX: size_t := (EnsureSizeTLimitAboveMinimum(); (SIZE_T_LIMIT - 1) as size_t)\n  const ZERO_SIZE: size_t := (EnsureSizeTLimitAboveMinimum(); 0 as size_t)\n  const ONE_SIZE: size_t := (EnsureSizeTLimitAboveMinimum(); 1 as size_t)\n  const TWO_SIZE: size_t := (EnsureSizeTLimitAboveMinimum(); 2 as size_t)\n  const TEN_SIZE: size_t := (EnsureSizeTLimitAboveMinimum(); 10 as size_t)\n  predicate SizeAdditionInRange(a: size_t, b: size_t) {\n    a as int + b as int < SIZE_T_LIMIT\n  } by method {\n    return a <= SIZE_T_MAX - b;\n  }\n  trait {:extern} NativeArray<T> extends Validatable {\n    ghost var values: seq<ArrayCell<T>>\n    ghost predicate Valid()\n      reads this, Repr\n      decreases Repr, 1\n      ensures Valid() ==> this in Repr\n      ensures Valid() ==> |values| < SIZE_T_LIMIT\n    function Length(): size_t\n      requires Valid()\n      reads Repr\n      ensures Length() == |values| as size_t\n    function Select(i: size_t): (ret: T)\n      requires Valid()\n      requires i < Length()\n      requires values[i].Set?\n      reads this, Repr\n      ensures ret == values[i].value\n    method Update(i: size_t, t: T)\n      requires Valid()\n      requires i < Length()\n      modifies Repr\n      ensures ValidAndDisjoint()\n      ensures Repr == old(Repr)\n      ensures values == old(values)[..i] + [Set(t)] + old(values)[(i + 1)..]\n      ensures Select(i) == t\n    method UpdateSubarray(start: size_t, other: ImmutableArray<T>)\n      requires Valid()\n      requires other.Valid()\n      requires start <= Length()\n      requires start as int + other.Length() as int <= Length() as int\n      modifies Repr\n      ensures ValidAndDisjoint()\n      ensures Repr == old(Repr)\n      ensures values ==\n              old(values)[..start] +\n              other.CellValues() +\n              old(values)[(start + other.Length())..]\n    method Freeze(size: size_t) returns (ret: ImmutableArray<T>)\n      requires Valid()\n      requires size <= Length()\n      requires forall i | 0 <= i < size :: values[i].Set?\n      ensures ret.Valid()\n      ensures ret as object != this as object\n      ensures |ret.values| as size_t == size\n      ensures forall i | 0 <= i < size :: ret.values[i] == values[i].value\n    static method {:extern} Make<T>(length: size_t) returns (ret: NativeArray<T>)\n      ensures ret.Valid()\n      ensures fresh(ret.Repr)\n      ensures ret.Length() == length\n    static method {:extern} MakeWithInit<T>(length: size_t, initFn: size_t -> T) returns (ret: NativeArray<T>)\n      ensures ret.Valid()\n      ensures fresh(ret.Repr)\n      ensures ret.Length() == length\n      ensures ret.values == seq(length, ((i: nat) requires 0 <= i < length as nat => Set(initFn(i as size_t))))\n    static method {:extern} Copy<T>(other: ImmutableArray<T>) returns (ret: NativeArray<T>)\n      ensures ret.Valid()\n      ensures fresh(ret.Repr)\n      ensures ret.values == other.CellValues()\n  }\n  datatype ArrayCell<T> = Set(value: T) | Unset\n  trait {:extern} ImmutableArray<T> {\n    ghost const values: seq<T>\n    ghost predicate Valid()\n      ensures Valid() ==> |values| < SIZE_T_LIMIT\n    ghost function CellValues(): seq<ArrayCell<T>> {\n      seq(|values|, i requires 0 <= i < |values| => Set(values[i]))\n    }\n    function Length(): size_t\n      requires Valid()\n      ensures Length() == |values| as size_t\n    function Select(index: size_t): T\n      requires Valid()\n      requires index < |values| as size_t\n      ensures Select(index) == values[index]\n    method Subarray(lo: size_t, hi: size_t) returns (ret: ImmutableArray<T>)\n      requires Valid()\n      requires lo <= hi <= Length()\n      ensures ret.Valid()\n      ensures ret.Length() == hi - lo\n      ensures ret.values == values[lo..hi]\n  }\n  class Vector<T> extends Validatable {\n    var storage: NativeArray<T>\n    var size: size_t\n    ghost predicate Valid()\n      reads this, Repr\n      decreases Repr, 1\n      ensures Valid() ==> this in Repr\n    {\n      && this in Repr\n      && storage in Repr\n      && storage.Repr <= Repr\n      && this !in storage.Repr\n      && storage.Valid()\n      && 0 <= size <= storage.Length()\n      && forall i | 0 <= i < size :: storage.values[i].Set?\n    }\n    constructor(length: size_t)\n      ensures Valid()\n      ensures Value() == []\n      ensures fresh(Repr)\n    {\n      var storage := NativeArray<T>.Make(length);\n      this.storage := storage;\n      size := 0;\n      Repr := {this} + storage.Repr;\n    }\n    ghost function Value(): seq<T>\n      requires Valid()\n      reads this, Repr\n    {\n      seq(size, i requires 0 <= i < size as int && Valid() reads this, Repr => storage.Select(i as size_t))\n    }\n    function Select(index: size_t): T\n      requires Valid()\n      requires index < size\n      reads this, Repr\n      ensures Select(index) == Value()[index]\n    {\n      storage.Select(index)\n    }\n    function Last(): T\n      requires Valid()\n      requires 0 < size\n      reads this, Repr\n      ensures Last() == Value()[size - 1]\n    {\n      storage.Select(size - 1)\n    }\n    method AddLast(t: T)\n      requires Valid()\n      requires size as int + 1 < SIZE_T_LIMIT\n      modifies Repr\n      ensures ValidAndDisjoint()\n      ensures Value() == old(Value()) + [t]\n    {\n      EnsureCapacity(size + ONE_SIZE);\n      storage.Update(size, t);\n      size := size + 1;\n    }\n    function Max(a: size_t, b: size_t): size_t {\n      if a < b then b else a\n    }\n    method EnsureCapacity(newMinCapacity: size_t)\n      requires Valid()\n      modifies Repr\n      ensures ValidAndDisjoint()\n      ensures storage.Length() >= newMinCapacity\n      ensures Value() == old(Value())\n    {\n      if storage.Length() >= newMinCapacity {\n        return;\n      }\n      var newCapacity := newMinCapacity;\n      if storage.Length() <= SIZE_T_MAX / TWO_SIZE {\n        newCapacity := Max(newCapacity, storage.Length() * TWO_SIZE);\n      }\n      var newStorage := NativeArray<T>.Make(newCapacity);\n      var values := storage.Freeze(size);\n      newStorage.UpdateSubarray(0, values);\n      storage := newStorage;\n      Repr := {this} + storage.Repr;\n    }\n    method RemoveLast() returns (t: T)\n      requires Valid()\n      requires 0 < size\n      modifies Repr\n      ensures ValidAndDisjoint()\n      ensures old(Value()) == Value() + [t]\n      ensures Value() == old(Value()[..(size - 1)])\n      ensures t in old(Value())\n    {\n      t := storage.Select(size - 1);\n      size := size - 1;\n    }\n    method Append(other: ImmutableArray<T>)\n      requires Valid()\n      requires other.Valid()\n      requires size as int + other.Length() as int < SIZE_T_LIMIT\n      modifies Repr\n      ensures ValidAndDisjoint()\n      ensures Value() == old(Value()) + other.values\n    {\n      var newSize := size + other.Length();\n      EnsureCapacity(newSize);\n      storage.UpdateSubarray(size, other);\n      size := size + other.Length();\n    }\n    method Freeze() returns (ret: ImmutableArray<T>)\n      requires Valid()\n      ensures ret.Valid()\n      ensures ret.values == Value()\n    {\n      ret := storage.Freeze(size);\n    }\n  }\n  trait {:extern} AtomicBox<T> {\n    ghost const inv: T -> bool\n    ghost predicate Valid()\n    static method {:extern} Make(ghost inv: T -> bool, t: T) returns (ret: AtomicBox<T>)\n      requires inv(t)\n      ensures ret.Valid()\n      ensures ret.inv == inv\n    method {:extern} Get() returns (t: T)\n      requires Valid()\n      ensures inv(t)\n    method {:extern} Put(t: T)\n      requires Valid()\n      requires inv(t)\n  }\n  trait {:extern} Sequence<T> {\n    var isString: bool\n    ghost const NodeCount: nat\n    ghost predicate Valid()\n      decreases NodeCount, 0\n      ensures Valid() ==> 0 < NodeCount\n    function Cardinality(): size_t\n      requires Valid()\n      decreases NodeCount, 1\n    ghost function Value(): seq<T>\n      requires Valid()\n      decreases NodeCount, 2\n      ensures |Value()| < SIZE_T_LIMIT && |Value()| as size_t == Cardinality()\n    method Select(index: size_t) returns (ret: T)\n      requires Valid()\n      requires index < Cardinality()\n      ensures ret == Value()[index]\n    {\n      var a := ToArray();\n      return a.Select(index);\n    }\n    method Drop(lo: size_t) returns (ret: Sequence<T>)\n      requires Valid()\n      requires lo <= Cardinality()\n      decreases NodeCount, 2\n      ensures ret.Valid()\n      ensures ret.Value() == Value()[lo..]\n    {\n      ret := Subsequence(lo, Cardinality());\n    }\n    method Take(hi: size_t) returns (ret: Sequence<T>)\n      requires Valid()\n      requires hi <= Cardinality()\n      decreases NodeCount, 2\n      ensures ret.Valid()\n      ensures ret.Value() == Value()[..hi]\n    {\n      ret := Subsequence(0, hi);\n    }\n    method Subsequence(lo: size_t, hi: size_t) returns (ret: Sequence<T>)\n      requires Valid()\n      requires lo <= hi <= Cardinality()\n      decreases NodeCount, 2\n      ensures ret.Valid()\n      ensures ret.Value() == V"
},
{
    "dafny": "method run() returns (done: int)\n{\n  var sensor_x := 1;\n  var charging_x := 0;\n  var drone_x := 0;\n  var battery := 100;\n  var queue := 0;\n var battery_cost := 20; \n var t := 0;\n  while t < 100\n    invariant 0<=t<=100;\n    invariant battery - queue > 0;\n    decreases 101-t;\n  {\n  var choice := 0;\n if battery > 20\n  {\n    choice := 1;\n  }\n if choice == 0\n    {\n      drone_x := 0;\n      battery := 100;\n      queue := queue + 10;      \n    }\n  else\n    {\n      drone_x := 1;\n      battery := battery-battery_cost;\n      queue := 0;\n    }\n    t := t + 1;\n  }\n return 1;\n}"
},
{
    "dafny": "datatype BT<T> = Tip(T) | Node(BT<T>, BT<T>)\nmethod Main()\n{\n\tvar tree: BT<int>;\n\ttree := Tip(1);\n\tvar f: seq<int> := FrontierIter(tree);\n\tassert f == [1];\n\ttree := Node(tree, Tip(2));\n\tf := FrontierIter(tree);\n\tassert f == [1,2];\n}\nfunction Frontier<T>(tree: BT<T>): seq<T>\n{\n\tmatch tree {\n\t\tcase Tip(n) => [n]\n\t\tcase Node(left, right) => Frontier(left) + Frontier(right)\n\t}\n}\nfunction Fseq<T>(forest:seq<BT<T>>) : seq<T>\n{\n\tif forest == [] then [] else Frontier(forest[0]) + Fseq(forest[1..])\n}\nfunction ForestSize<T>(stack : seq<BT<T>>): nat\n{\n\tif stack == [] then 0\n\telse TreeSize(stack[0]) + ForestSize(stack[1..])\n}\nfunction TreeSize<T>(tree : BT<T>) : nat\n{\n\tmatch tree {\n\t\tcase Tip(n) => 1\n\t\tcase Node(left, right) => TreeSize(left) + TreeSize(right) + 1\n\t}\n}\nmethod FrontierIter<T>(tree: BT<T>) returns (f: seq<T>)\n\tensures f == Frontier(tree)\n{\n\tvar stack: seq<BT<T>>;\n\tstack := [tree];\n\tf := [];\n\twhile stack != []\n\t\tinvariant f + Fseq(stack) == Frontier(tree)\n\t\tdecreases ForestSize(stack)\n\t{\n\tghost var V0 := ForestSize(stack);\n\t\tmatch stack[0]\n\t\t\tcase Tip(n) =>\n\t\t\t\tf:= f + [n];\n\t\t\t\tstack := stack[1..];\n\t\t\tcase Node(left, right) =>\n\t\t\t\tstack := [left, right] + stack[1..];\n\t\tassert 0 <= ForestSize(stack) < V0;\n\t}\n\tassert stack == [] && f + Fseq(stack) == Frontier(tree);\n\tassert f == Frontier(tree);\n}"
},
{
    "dafny": "method MultipleReturns (x:int, y:int) returns (more:int, less:int)\nrequires y > 0\nensures less < x < more\n{\nassert x - y < x < x + y;\nmore := x + y;\nassert x - y < x < more;\nless := x - y;\nassert less < x < more;\n}\nfunction factorial (n:int): int\nrequires n >= 0\n{\nif n == 0 then 1 else n * factorial(n-1)\n}\nmethod ComputeFact (n: int) returns (f:int)\nrequires n >= 0\nensures f == factorial(n)\n{\nvar x := n;\nf := 1;\nwhile \n      x > 0\n  invariant f * factorial(x) == factorial(n)\n{\nassert f * (x * factorial (x-1)) == factorial (n);\nf, x := f * x, x-1;\nassert f * factorial(x) == factorial(n);\n}\n}\nmethod compute_Fact2 (n:int) returns (f:int)\nrequires n >= 0\nensures f == factorial(n)\n{\nvar x := 0;\nf := 1;\nassert f == factorial(x);\nwhile \n         x < n \n\t\t invariant 0 <= x <= n \n\t\t invariant f == factorial(x)\n{\nx, f := x + 1, f * (x+1);\n}\n}\nmethod Square (a:int) returns (x:int)\nrequires a >= 1\nensures x == a*a\n{\nx := 1;\nvar y := 1;\nwhile y < a\n     invariant 1 <= y <= a\n\t invariant x == y*y\n\t{\n\tassert x + 2*y + 1 == (y+1)*(y+1);\n\ty, x := y + 1, x + 2*y + 1; \n\tassert x == y*y;\n\t}\n}\nfunction sumSerie(n:int):int\nrequires n >= 1\n{\nif n == 1 then 1 else sumSerie(n-1) + 2*n - 1\n}\nmethod Square2 (a:int) returns (x:int)\nrequires a >= 1\nensures x == a*a\n{\nx := 1;\nvar y := 1;\nwhile y < a\n     invariant 1 <= y <= a\n\t invariant x == sumSerie(y)\n\t{\n\ty := y + 1;\n\tx := x + 2*y - 1;\n\t}\nassert 1 <= y <= a && x == sumSerie(y) && y >= a;\nassert x == sumSerie(a) ; \nsumSerieProp_Lemma(a);\nassert x == a*a; \n}\nlemma sumSerieProp_Lemma (n:int)\nrequires n >= 1\nensures sumSerie(n) == n*n\n{}\nfunction power(b:int, e:nat):int\n{\nif e == 0 then 1 else b * power(b,e-1)\n}\nmethod compute_power (b:int, e:nat) returns (p:int)\nensures p == power(b,e)\n{\nvar t , x := e, b;\np := 1;\nwhile t > 0\n     invariant  0 <= t <= e\n\t invariant p * power(x,t) == power(b,e)  \n    {\n\tif t % 2 == 0 {\n\t              assume p * power(x*x,t/2) == power(b,e);\n\t              x, t := x*x, t/2;\n\t\t\t\t  assume p * power(x,t) == power(b,e);\n\t              }\n\telse {\n\t      p, t := p*x, t-1;\n\t      }\n\t}\n}\nlemma even_Lemma (b:int, e:nat)\nrequires e%2 == 0\nensures power(b,e) == power(b*b,e/2)"
},
{
    "dafny": "datatype BloodType = O | OP | OM | AP | AM | BP | BM | ABP | ABM\nclass TestedBlood {\n    var id: int;\n    var retrieval: int;\n    var bloodType: BloodType;\n    var expiration: int;\n    predicate Valid()\n    reads this\n    {\n        expiration > retrieval\n    }\n    constructor (bloodid: int, rdate: int, btype: BloodType, edate: int)\n    requires edate > rdate\n    ensures Valid()\n    ensures id == bloodid && rdate == retrieval && edate == expiration && bloodType == btype\n    modifies this`id, this`bloodType, this`retrieval, this`expiration\n    {\n        id := bloodid;\n        bloodType := btype;\n        retrieval := rdate;\n        expiration := edate;\n    }\n}"
},
{
    "dafny": "type T = int \npredicate isSorted(a: array<T>)\n    reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\nmethod bubbleSort(a: array<T>)\n  modifies a\n  ensures isSorted(a)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := a.Length; \n  while i > 1\n    decreases  i - 1\n    invariant forall l, r :: 0 <= l < r < a.Length && r >= i ==> a[l] <= a[r] \n    invariant 0 <= i <= a.Length \n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := 0; \n    while j < i - 1\n      decreases  i - 1 - j\n        invariant forall l, r :: 0 <= l < r < a.Length && (r >= i || r == j) ==> a[l] <= a[r] \n        invariant 0 <= j < i \n        invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n        if (a[j] > a[j+1]) \n        { \n          a[j], a[j+1] := a[j+1], a[j]; \n        }\n        j := j+1; \n    }\n    i := i-1;\n  }\n}\nmethod printArray<T>(a: array<T>)\n{\n      var i := 0;\n      print \"{\";\n      while (i < a.Length)\n      decreases a.Length - i;\n      {\n          if (i > 0)\n          {\n              print \", \";\n          }\n          print a[i];\n          i := i+1;\n      }\n      print \"}\\n\" ;\n}\n method Main() {\n    var a := new int[5];\n    a[0], a[1], a[2], a[3], a[4] := 9, 4, 6, 3, 8;\n    print \"before sorting: \";\n    printArray(a);  \n    bubbleSort(a);\n    print \"after sorting: \";\n    printArray(a);  \n}"
},
{
    "dafny": "predicate zeroes(A:array<int>)\n  reads A\n{\n  forall i :: 0 <= i < A.Length ==> A[i] == 0\n}\nmethod resetArray(A:array<int>)\n  ensures zeroes(A)\n  modifies A\n{\n  var i := 0;\n  while i < A.Length \n  invariant 0 <= i <= A.Length\n  invariant forall j :: 0 <= j < i ==> A[j] == 0\n  decreases A.Length - i\n  {\n    A[i] := 0;\n    i := i + 1;\n  }\n}\npredicate sorted_between(A:array<int>, lo:int, hi:int)\n  reads A\n{\n  forall m,n :: 0 <= lo <= m < n < hi <= A.Length ==> A[m] <= A[n]\n}\npredicate sorted(A:array<int>)\n  reads A\n{\n  sorted_between(A,0,A.Length)\n}\npredicate partitioned(A:array<int>, index:int) \n  reads A \n{\n  forall i,j :: 0 <= i < index <= j < A.Length ==> A[i] <= A[j]\n}\nmethod backwards_selection_sort(A:array<int>)\n  ensures sorted(A)\n  modifies A\n{\n  var i := A.Length;\n  while 0 < i\n    invariant 0 <= i <= A.Length\n    invariant sorted_between(A, i, A.Length)\n    invariant partitioned(A, i)\n    decreases i \n  {\n    var max := 0;\n    var j := 1;\n    while j < i\n      invariant 0 <= max < j <= i\n      invariant forall n :: 0 <= n < j ==> A[n] <= A[max]\n      decreases i - j\n    {\n      if A[max] < A[j] {\n        max := j;\n      }\n      j := j+1;\n    }\n    A[max], A[i-1] := A[i-1], A[max];\n    i := i - 1;\n  }\n}\nmethod recursive_selection_sort_inner(A:array<int>, i:int)\n  requires 0 <= i <= A.Length\n  requires sorted_between(A, 0, i)\n  requires partitioned(A, i)\n  ensures sorted(A)\n  modifies A\n  decreases A.Length - i\n{\n  if i == A.Length { \n    return; \n  }\n  var k := i;\n  var j := i + 1;\n  while j < A.Length\n    invariant 0 <= i <= k < j <= A.Length\n    invariant forall n :: i <= n < j ==> A[k] <= A[n]\n    decreases A.Length - j\n  {\n    if A[k] > A[j] {\n      k := j;\n    }\n    j := j+1;\n  }\n  A[k], A[i] := A[i], A[k];\n  recursive_selection_sort_inner(A, i + 1);\n}\nmethod recursive_selection_sort(A:array<int>)\n  ensures sorted(A)\n  modifies A\n{\n  recursive_selection_sort_inner(A, 0);\n}\nmethod bubble_sort_with_early_stop(A:array<int>) \n  ensures sorted(A)\n  modifies A\n{\n  var stable := false;\n  var i := 0;\n  while !stable\n  invariant 0 <= i <= A.Length + 1\n  invariant partitioned(A, A.Length - i)\n  invariant sorted_between(A, A.Length - i, A.Length)\n  invariant if stable then sorted(A) else i < A.Length + 1\n  decreases A.Length - i \n  {\n    var j := 0;\n    stable := true;\n    while j + 1 < A.Length - i\n    invariant 0 <= i <= A.Length \n    invariant 0 < A.Length ==> 0 <= j < A.Length\n    invariant partitioned(A, A.Length - i)\n    invariant sorted_between(A, A.Length - i, A.Length)\n    invariant if stable then sorted_between(A, 0, j + 1) else i < A.Length\n    invariant forall m :: 0 <= m < j < A.Length ==> A[m] <= A[j]\n    invariant A.Length - i <= j ==> partitioned(A, A.Length - i - 1)\n    decreases A.Length - j\n    {\n      if A[j+1] < A[j] {\n        A[j], A[j+1] := A[j+1], A[j];\n        stable := false;\n      }\n      j := j+1;\n    }\n    i := i+1;\n  }\n}\nmethod cocktail_shaker_sort(A:array<int>)\n  ensures sorted(A)\n  modifies A\n{\n  var i := 0;\n  while i < A.Length / 2\n    invariant i <= A.Length\n    invariant partitioned(A, A.Length - i)\n    invariant partitioned(A, i)\n    invariant sorted_between(A, A.Length - i, A.Length)\n    invariant sorted_between(A, 0, i)\n    decreases A.Length - i\n  {\n    var j := i;\n    while j < A.Length - i - 1\n      invariant j < A.Length - i\n      invariant partitioned(A, A.Length - i)\n      invariant partitioned(A, i)\n      invariant sorted_between(A, A.Length - i, A.Length)\n      invariant sorted_between(A, 0, i)\n      invariant forall m :: 0 <= m < j ==> A[m] <= A[j]\n      decreases A.Length - j \n    {\n      if A[j+1] < A[j] {\n        A[j], A[j+1] := A[j+1], A[j];\n      }\n      j := j+1;\n    }\n    while i < j\n      invariant i <= j < A.Length - i\n      invariant partitioned(A, A.Length - i)\n      invariant partitioned(A, A.Length - i - 1)\n      invariant partitioned(A, i)\n      invariant sorted_between(A, A.Length - i, A.Length)\n      invariant sorted_between(A, 0, i)\n      invariant forall m :: j < m < A.Length ==> A[j] <= A[m]\n      decreases j\n    {\n      if A[j-1] > A[j] {\n        A[j-1], A[j] := A[j], A[j-1];\n      }\n      j := j-1;\n    }\n    i := i+1;\n  }\n}\nmethod Main() {\n  var A:array<int> := new int[7] [4,0,1,9,7,1,2];\n  print \"Before: \", A[0], A[1], A[2], A[3], \n        A[4], A[5], A[6], \"\\n\";\n  recursive_selection_sort(A);\n  print \"After:  \", A[0], A[1], A[2], A[3], \n        A[4], A[5], A[6], \"\\n\";\n}"
},
{
    "dafny": "class Blood {\n\tvar score :real;\n\tconstructor(s :real)\n\t\tmodifies this\n\t\tensures score == s\n\t{\n\t\tscore := s;\n\t}\n}\npredicate Sorted(a: seq<Blood>, low:int, high:int)\n\trequires 0<=low<=high<=|a|\n\treads a\n{\n\tforall j,k:: low<=j<k<high ==> a[j].score>=a[k].score\n}\nmethod sortByScore(bList: array<Blood>) returns (sorted :seq<Blood>)\n\trequires bList != null\n\trequires bList.Length > 1\n\tensures Sorted(bList[..], 0, |bList[..]|)\n  ensures multiset(old(bList)[..]) == multiset(sorted)\n  ensures multiset(bList[..]) == multiset(sorted)\n\tmodifies bList\n{\n\tvar i:=1;\n  var u :seq<Blood> := bList[..];\n  assert u == old(bList)[..];\n  assert u == bList[..];\n  assert multiset(u) == multiset(u);\n  assert multiset(bList[..]) == multiset(u);\n  assert multiset(u) == multiset(old(bList)[..]);\n\twhile (i < bList.Length)\n\t\tinvariant 1 <= i <= bList.Length;\n\t\tinvariant Sorted(bList[..], 0, i);\n\t\tinvariant multiset(bList[..]) == multiset(u);\n\t{\n\t\tvar j := i;\n\t\twhile (j >= 1 && bList[j-1].score < bList[j].score)\n\t\t\tinvariant 0 <= j <= i;\n\t\t\tinvariant forall x,y:: (0<=x<y<=i && y!=j) ==> bList[x].score>=bList[y].score;\n\t\t\tinvariant multiset(bList[..]) == multiset(u);\n\t\t{\n\t\t\tbList[j-1], bList[j] := bList[j], bList[j-1];\n\t\t\tj:=j-1;\n\t\t}\n\t\ti:=i+1;\n\t}\n  sorted := bList[..];\n}"
},
{
    "dafny": "method concat(a:array<int>, b:array<int>) returns (c:array<int>)\n  ensures c.Length==b.Length+a.Length\n  ensures forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n  ensures forall k :: 0 <= k < b.Length ==> c[k+a.Length] == b[k]\n{\n  c := new int[a.Length+b.Length];\n  var i:= 0;\n  while (i < c.Length)\n    invariant 0 <= i <= c.Length\n    invariant if i<a.Length then c[..i]==a[..i] else c[..i]==a[..]+b[..(i-a.Length)]\n  {\n    c[i] := if i<a.Length then a[i] else b[i-a.Length];\n    i:=i+1;\n  }\n}"
},
{
    "dafny": "class SumOfCubes {\n  static function SumEmUp(n: int, m: int): int\n    requires 0 <= n && n <= m;\n    decreases m - n;\n  {\n    if m == n then 0 else n*n*n + SumEmUp(n+1, m)\n  }\n  static method Socu(n: int, m: int) returns (r: int)\n    requires 0 <= n && n <= m;\n    ensures r == SumEmUp(n, m);\n  {\n    var a := SocuFromZero(m);\n    var b := SocuFromZero(n);\n    r := a - b;\n    Lemma0(n, m);\n  }\n  static method SocuFromZero(k: int) returns (r: int)\n    requires 0 <= k;\n    ensures r == SumEmUp(0, k);\n  {\n    var g := Gauss(k);\n    r := g * g;\n    Lemma1(k);\n  }\n  ghost static method Lemma0(n: int, m: int)\n    requires 0 <= n && n <= m;\n    ensures SumEmUp(n, m) == SumEmUp(0, m) - SumEmUp(0, n);\n  {\n    var k := n;\n    while (k < m) \n      invariant n <= k && k <= m;\n      invariant SumEmDown(0, n) + SumEmDown(n, k) == SumEmDown(0, k);\n    {\n      k := k + 1;\n    }\n    Lemma3(0, n);\n    Lemma3(n, k);\n    Lemma3(0, k);\n  }\n  static function GSum(k: int): int\n    requires 0 <= k;\n  {\n    if k == 0 then 0 else GSum(k-1) + k-1\n  }\n  static method Gauss(k: int) returns (r: int)\n    requires 0 <= k;\n    ensures r == GSum(k);\n  {\n    r := k * (k - 1) / 2;\n    Lemma2(k);\n  }\n  ghost static method Lemma1(k: int)\n    requires 0 <= k;\n    ensures SumEmUp(0, k) == GSum(k) * GSum(k);\n  {\n    var i := 0;\n    while (i < k)\n      invariant i <= k;\n      invariant SumEmDown(0, i) == GSum(i) * GSum(i);\n    {\n      Lemma2(i);\n      i := i + 1;\n    }\n    Lemma3(0, k);\n  }\n  ghost static method Lemma2(k: int)\n    requires 0 <= k;\n    ensures 2 * GSum(k) == k * (k - 1);\n  {\n    var i := 0;\n    while (i < k)\n      invariant i <= k;\n      invariant 2 * GSum(i) == i * (i - 1);\n    {\n      i := i + 1;\n    }\n  }\n  static function SumEmDown(n: int, m: int): int\n    requires 0 <= n && n <= m;\n  {\n    if m == n then 0 else SumEmDown(n, m-1) + (m-1)*(m-1)*(m-1)\n  }\n  ghost static method Lemma3(n: int, m: int)\n    requires 0 <= n && n <= m;\n    ensures SumEmUp(n, m) == SumEmDown(n, m);\n  {\n    var k := n;\n    while (k < m)\n      invariant n <= k && k <= m;\n      invariant SumEmUp(n, m) == SumEmDown(n, k) + SumEmUp(k, m);\n    {\n      k := k + 1;\n    }\n  }\n}"
},
{
    "dafny": "module A {\n  export reveals a\n  const a := 10\n  const b := 20\n}\nmodule B refines A {\n  export reveals *\n  const c := 30\n}\nmodule C {\n  method m() {\n    assert B.c == 30;\n    assert B.a == 10;\n    assert B.b == 20;\n  }\n}\nmodule D {\n  method m() {\n    assert B.a == 10;\n  }\n}"
},
{
    "dafny": "method flip (a: array<int>, num: int)\n  requires a != null && a.Length > 0\n  requires 0<=num<a.Length\n  modifies a\nensures forall n:: 0 <= n <= num  ==> a[n] == old(a[num-n]) \nensures forall n:: num < n < a.Length ==> a[n] == old(a[n]);\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\n    invariant 0<=i<=num/2+1\n    invariant num/2<=j<=num\n    invariant i+j==num\n    invariant forall k3 :: 0<=k3<i ==> a[k3]==old(a[num-k3]) && a[num-k3]==old(a[k3])\n    invariant forall k5 :: i<=k5<=j ==> old(a[k5])==a[k5]\n    invariant forall k6 :: num<k6<a.Length ==> old(a[k6])==a[k6]\n    decreases j\n    decreases num-i\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n  ensures x>=0 ==> x==y\n  ensures x<0 ==> x+y==0\n{\n  if x < 0 {\n    return -x;\n  } else {\n    return x;\n  }\n}\nmethod TestAbs()\n{\n  var test1 := Abs(5);\n  print( test1, \"\\n\"); \n  var test2 := Abs(-7);\n  print(test2, \"\\n\"); \n  var test3 := Abs(0);\n  print(test3, \"\\n\"); \n  var test4 := Abs(-1);\n  print( test4, \"\\n\"); \n  var test5 := Abs(9);\n  print( test5, \"\\n\"); \n}\nmethod Main()\n{\n  TestAbs();\n}"
},
{
    "dafny": "datatype Dt = Dt(x:int)\n{\n  method {:timeLimitMultiplier 5} DatatypeTest(y:int) {\n    var z := y;\n    assert z == y;\n  }\n}\nnewtype Even = x : int | x % 2 == 0\n{\n  method {:timeLimitMultiplier 4} NewtypeTest(y:int) {\n    assert y == y;\n  }\n}\ncodatatype Stream<T> = More(head: T, rest: Stream) \n{\n  method {:timeLimitMultiplier 3} CodatatypeTest(y:int) {\n    assert y == y;\n  }\n}"
},
{
    "dafny": "method loop( i : nat ) returns(z : nat) \nensures z == i\n{\n    z := 0 ;\n    while z < i \n    invariant  z <= i\n    {\n        z := z + 1 ;\n    }\n}"
},
{
    "dafny": "method m(n: nat)\n{\n  var i: int := 0;\n  while i != n\n    invariant 0 <= i <= n\n  {\n    i := i + 1;\n  }\n  assert i == n;\n}\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0 else\n    if n == 1 then 1 else\n    fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n  ensures b == fib(n)  \n{\n  var i: int := 0;\n  var c: int := 1;\n  b := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant c == fib(i + 1)\n    invariant b == fib(i)\n  {\n    b, c := c, b + c;\n    i := i + 1;\n  }\n}\nmethod m_ex11()\n{\n  var i, n := 0, 20;\n  while i != n\n    invariant i <= n\n    decreases n - i \n  {\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "function sorted(a:array<int>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ \n    forall i, j :: (0 <= i < j < n) ==> a[i] <= a[j]\n}\nfunction unique(a:array<int>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ \n    forall i :: (0 <= i < n) ==> forall j :: (i < j < n) ==> a[i] != a[j]\n}\nfunction contains(b:array<int>, m:int, v:int):bool\n    requires 0 <= m <= b.Length \n    reads b\n{\n    v in b[..m]\n}\nmethod Deduplicate(a:array<int>, n:int) returns (b:array<int>, m:int)\n    requires 0 <= n <= a.Length\n    requires sorted(a,n) \n    ensures 0 <= m <= b.Length\n    ensures sorted(b,m) && unique(b,m)\n    ensures forall k :: (0 <= k < m) ==> contains(a,n,b[k])\n    ensures fresh(b)\n{\n    b := new int[n];\n    if (n == 0) {\n        return b,0;\n    }\n    b[0] := a[0];\n    var i := 1;\n    m:=1;\n    assert contains(b,1,a[0]);\n    while (i < n)\n        decreases n-i\n        invariant 1 <= i <= n\n        invariant 1 <= m <= i \n        invariant sorted(b, m)\n        invariant unique(b, m)\n        invariant forall k :: (0 <= k < m) ==> contains(a,n,b[k])\n        {\n            if (a[i] > b[m-1]) {\n                b[m] := a[i];\n                m := m + 1;\n                assert contains (b,m,a[i]); \n            }\n            i := i + 1;\n        }\n}"
},
{
    "dafny": "﻿\ndatatype option<A> = None | Some(get: A)\ndatatype ty =  TBase                             \n            |  TArrow(T1: ty, T2: ty)            \ndatatype tm = tvar(id: int)                      \n            | tapp(f: tm, arg: tm)               \n            | tabs(x: int, T: ty, body: tm)      \npredicate value(t: tm)\n{\n  t.tabs?\n}\nfunction fv(t: tm): set<int> \n{\n  match t\n  case tvar(id) => {id}\n  case tabs(x, T, body) => fv(body)-{x}\n  case tapp(f, arg) => fv(f)+fv(arg)\n}\nfunction subst(x: int, s: tm, t: tm): tm \n{\n  match t\n  case tvar(x') => if x==x' then s else t\n  case tabs(x', T, t1) => tabs(x', T, if x==x' then t1 else subst(x, s, t1))\n  case tapp(t1, t2) => tapp(subst(x, s, t1), subst(x, s, t2))\n}\nfunction step(t: tm): option<tm>\n{\n       if (t.tapp? && t.f.tabs? && value(t.arg)) then\n  Some(subst(t.f.x, t.arg, t.f.body))\n         else if (t.tapp? && step(t.f).Some?) then\n  Some(tapp(step(t.f).get, t.arg))\n         else if (t.tapp? && value(t.f) && step(t.arg).Some?) then\n  Some(tapp(t.f, step(t.arg).get))\n  else None\n}\npredicate reduces_to(t: tm, t': tm, n: nat)\n  decreases n;\n{\n  t == t' || (n > 0 && step(t).Some? && reduces_to(step(t).get, t', n-1))\n}\nlemma lemma_step_example1(n: nat)\n  requires n > 0;\n  ensures reduces_to(tapp(tabs(0, TArrow(TBase, TBase), tvar(0)), tabs(0, TBase, tvar(0))),\n                     tabs(0, TBase, tvar(0)), n);\n{\n}\nfunction find(c: map<int,ty>, x: int): option<ty>\n{\n  if (x in c) then Some(c[x]) else None\n}\nfunction extend(x: int, T: ty, c: map<int,ty>): map<int,ty>\n{\n  c[x:=T]\n}\nfunction has_type(c: map<int,ty>, t: tm): option<ty>\n  decreases t;\n{\n  match t\n    case tvar(id) => find(c, id)\n    case tabs(x, T, body) =>\n  var ty_body := has_type(extend(x, T, c), body);\n                     if (ty_body.Some?) then\n  Some(TArrow(T, ty_body.get))          else None\n    case tapp(f, arg) =>\n  var ty_f   := has_type(c, f);\n  var ty_arg := has_type(c, arg);\n                     if (ty_f.Some? && ty_arg.Some?) then\n  if ty_f.get.TArrow? && ty_f.get.T1 == ty_arg.get then\n  Some(ty_f.get.T2)  else None else None\n}\nlemma example_typing_1()\n  ensures has_type(map[], tabs(0, TBase, tvar(0))) == Some(TArrow(TBase, TBase));\n{\n}\nlemma example_typing_2()\n  ensures has_type(map[], tabs(0, TBase, tabs(1, TArrow(TBase, TBase), tapp(tvar(1), tapp(tvar(1), tvar(0)))))) ==\n          Some(TArrow(TBase, TArrow(TArrow(TBase, TBase), TBase)));\n{\n  var c := extend(1, TArrow(TBase, TBase), extend(0, TBase, map[]));\n  assert find(c, 0) == Some(TBase);\n  assert has_type(c, tvar(0)) == Some(TBase);\n  assert has_type(c, tvar(1)) == Some(TArrow(TBase, TBase));\n  assert has_type(c, tapp(tvar(1), tapp(tvar(1), tvar(0)))) == Some(TBase);\n}\nlemma nonexample_typing_1()\n  ensures has_type(map[], tabs(0, TBase, tabs(1, TBase, tapp(tvar(0), tvar(1))))) == None;\n{\n  var c := extend(1, TBase, extend(0, TBase, map[]));\n  assert find(c, 0) == Some(TBase);\n  assert has_type(c, tapp(tvar(0), tvar(1))) == None;\n}\nlemma nonexample_typing_3(S: ty, T: ty)\n  ensures has_type(map[], tabs(0, S, tapp(tvar(0), tvar(0)))) != Some(T);\n{\n  var c := extend(0, S, map[]);\n  assert has_type(c, tapp(tvar(0), tvar(0))) == None;\n}\nlemma theorem_progress(t: tm)\n  requires has_type(map[], t).Some?;\n  ensures value(t) || step(t).Some?;\n{\n}\nlemma {:induction c, t} lemma_free_in_context(c: map<int,ty>, x: int, t: tm)\n  requires x in fv(t);\n  requires has_type(c, t).Some?;\n  ensures find(c, x).Some?;\n  decreases t;\n{\n}\npredicate closed(t: tm)\n{\n  forall x :: x !in fv(t)\n}\nlemma corollary_typable_empty__closed(t: tm)\n  requires has_type(map[], t).Some?;\n  ensures closed(t);\n{\n  forall (x:int) ensures x !in fv(t);\n  {\n    if (x in fv(t)) {\n      lemma_free_in_context(map[], x, t);\n      assert false;\n    }\n  }\n}\nlemma {:induction t} lemma_context_invariance(c: map<int,ty>, c': map<int,ty>, t: tm)\n  requires has_type(c, t).Some?;\n  requires forall x: int :: x in fv(t) ==> find(c, x) == find(c', x);\n  ensures has_type(c, t) == has_type(c', t);\n  decreases t;\n{\n  if (t.tabs?) {\n    assert fv(t.body) == fv(t) || fv(t.body) == fv(t) + {t.x};\n    lemma_context_invariance(extend(t.x, t.T, c), extend(t.x, t.T, c'), t.body);\n  }\n}\nlemma lemma_substitution_preserves_typing(c: map<int,ty>, x: int, s: tm, t: tm)\n  requires has_type(map[], s).Some?;\n  requires has_type(extend(x, has_type(map[], s).get, c), t).Some?;\n  ensures has_type(c, subst(x, s, t)) == has_type(extend(x, has_type(map[], s).get, c), t);\n  decreases t;\n{\n  var S := has_type(map[], s).get;\n  var cs := extend(x, S, c);\n  var T  := has_type(cs, t).get;\n  if (t.tvar?) {\n    if (t.id==x) {\n      assert T == S;\n      corollary_typable_empty__closed(s);\n      lemma_context_invariance(map[], c, s);\n    }\n  }\n  if (t.tabs?) {\n    if (t.x==x) {\n      lemma_context_invariance(cs, c, t);\n    } else {\n      var cx  := extend(t.x, t.T, c);\n      var csx := extend(x, S, cx);\n      var cxs := extend(t.x, t.T, cs);\n      lemma_context_invariance(cxs, csx, t.body);\n      lemma_substitution_preserves_typing(cx, x, s, t.body);\n    }\n  }\n}\nlemma theorem_preservation(t: tm)\n  requires has_type(map[], t).Some?;\n  requires step(t).Some?;\n  ensures has_type(map[], step(t).get) == has_type(map[], t);\n{\n  if (t.tapp? && value(t.f) && value(t.arg)) {\n    lemma_substitution_preserves_typing(map[], t.f.x, t.arg, t.f.body);\n  }\n}\npredicate normal_form(t: tm)\n{\n  step(t).None?\n}\npredicate stuck(t: tm)\n{\n  normal_form(t) && !value(t)\n}\nlemma corollary_soundness(t: tm, t': tm, T: ty, n: nat)\n  requires has_type(map[], t) == Some(T);\n  requires reduces_to(t, t', n);\n  ensures !stuck(t');\n  decreases n;\n{\n  theorem_progress(t);\n  if (t != t') {\n   theorem_preservation(t);\n   corollary_soundness(step(t).get, t', T, n-1);\n  }\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && \n\tpre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || \n\tpre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n\tensures !res <==> isNotPrefixPred(pre,str)\n\tensures  res <==> isPrefixPred(pre,str)\n{\n\treturn |pre| <= |str| && forall i :: 0 <= i < |pre| ==> pre[i] == str[i];\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n\t(exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\t(forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n\tensures  res <==> isSubstringPred(sub, str)\n\tensures  res ==> isSubstringPred(sub, str)\n\tensures  isSubstringPred(sub, str) ==> res\n\tensures  isSubstringPred(sub, str) ==> res\n\tensures !res <==> isNotSubstringPred(sub, str) \n{\n\tif(|str| < |sub|)\n\t{\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tvar i: nat := 0;\n\t \tres := false;\n\t\twhile (i <= |str|-|sub| && res == false)\n\t\tdecreases |str| - |sub| - i + (if !res then 1 else 0)\n\t\tinvariant 0 <= i <= |str|-|sub| + 1\n\t\tinvariant res ==> isSubstringPred(sub,str)\n\t\tinvariant forall j :: 0 <= j < i ==> isNotPrefixPred(sub, str[j..])\n\t\t{\n\t\t\tres := isPrefix(sub,str[i..]);\n\t\t\tif(!res)\n\t\t\t{\n\t\t\t\ti := i + 1;\n\t\t\t}\n\t\t}\n\t}\n}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\texists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\tforall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n\tensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n\tensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) \n{\n\tif (k <= |str1| && k <= |str2|)\n\t{\n\t\tvar slice : string;\n\t\tfound := false;\n\t\tvar i: nat := 0;\n\t\twhile (i <= |str1| - k && found == false)\n\t\tdecreases |str1| - k - i + (if !found then 1 else 0)\n\t\tinvariant found ==> haveCommonKSubstringPred(k,str1,str2)\n\t\tinvariant forall x, y :: 0 <= x < i && found == false && y == x + k && y <= |str1| ==> isNotSubstringPred(str1[x..y], str2)\t\t\n\t\t{\n\t\t\tslice := str1[i..i+k];\n\t\t\tfound := isSubstring(slice, str2);\n\t\t\t\ti := i + 1;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n\trequires (|str1| <= |str2|)\n\tensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n\tensures haveCommonKSubstringPred(len,str1,str2)\n{\n\tassert isPrefixPred(str1[0..0],str2[0..]);\n\tlen := |str1|;\n\tvar hasCommon : bool := true;\n\twhile(len > 0)\n\t\tdecreases len\n\t\tinvariant forall i :: len < i <= |str1| ==> !haveCommonKSubstringPred(i,str1,str2)\n\t{\n\t\thasCommon := haveCommonKSubstring(len, str1, str2);\n\t\tif(hasCommon){\n\t\t\treturn len;\n\t\t}\n\t\tlen := len - 1;\n\t}\n\treturn len;\n}"
},
{
    "dafny": "method Carre(a: nat) returns (c: nat)\nensures c == a*a\n{\n    var i := 0;\n    c := 0;\n    while i != a\n    invariant 0 <= i <= a\n    invariant c == i*i\n    decreases a - i\n  {\n    c := c + 2*i +1;\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method divu10(n: bv16) returns (r: bv16)\n  ensures r == n/10;\n {\n  var q: bv16;\n  q := (n >> 1) + (n >> 2);\n  q := q + (q >> 4);\n  q := q + (q >> 8);\n  q := q >> 3;\n  r := n - (((q << 2) + q) << 1);\n  return q + if (r > 9) then 1 else 0;\n}"
},
{
    "dafny": "function gcd(a: nat, b: nat): nat\n   requires a > 0 && b > 0\n{   \n   if a == b then a else\n   if b > a then gcd(a,b - a) else\n    gcd(a - b,b) \n}\nlemma commutativity(a: nat, b: nat)\n   requires a > 0 && b > 0\n   ensures gcd(a,b) == gcd(b,a)\nlemma AddCancelation(a: nat, b: nat, m: nat)\n   requires a > 0 && b > 0\n   ensures gcd(a +  m * b, b) == gcd(a,b)\nlemma distributivity(a: nat, b: nat, m: nat)\n   requires a > 0 && b > 0\n   requires m > 0\n   ensures gcd(m * a, m * b) == m * gcd(a,b)"
},
{
    "dafny": "method TestSeq( x: seq<int> )\n{\n    assert x == x[0..|x|];\n    assert forall k | 0 <= k <= |x| :: x[0..k]+x[k..|x|] == x;\n    assert forall k | 0 <= k <= |x| :: x[0..k] == x[..k];\n    assert forall k | 0 <= k <= |x| :: x[k..] == x[k..|x|];\n    assert forall k | 0 <= k <= |x| :: x[..k]+x[k..] == x;\n    assert forall z | z in x :: exists i | 0 <= i < |x| :: z==x[i];\n    assert forall z | z in multiset(x) :: exists i | 0 <= i < |x| :: z==x[i];\n    assert forall z :: z in multiset(x) <==> exists i | 0 <= i < |x| :: z==x[i];\n    assert forall p,q | 0 <= p <= q <= |x| :: x[..p]+x[p..q]+x[q..] == x;\n    if x != []\n    {\n        assert x[0] in x;\n        assert x[|x|-1] in x;\n        assert multiset(x) == multiset{x[0]}+multiset(x[1..]);\n        var i :| i in x;\n        if 0 <= i < |x|\n        {\n            assert multiset(x) == multiset(x[..i])+multiset(x[i..]);\n        }\n    }\n    else\n    {\n        assert |x| == 0;\n        assert multiset(x) == multiset{};\n        var s: set<int> := {};\n        assert |s| == 0;\n        assert multiset(x) == multiset(s);\n    }\n}\nmethod TestMultiset( x: multiset<int> )\n{\n    assert x == multiset{} <==> |x| == 0;\n    if |x| == 0\n    {\n        assert x == multiset{};\n    }\n    else\n    {\n        var z:| z in x;\n        assert z in x;\n        var x' := x-multiset{z};\n        assert |x| == |x'|+1;\n        assert x+multiset{z} != x;\n        assert |x+multiset{z}| == |x|+1;\n        assert x == x'+multiset{z};\n    }\n}\nmethod TestSet( x: set<int> )\n{\n    assert x == {} <==> |x| == 0;\n    if |x| == 0\n    {\n        assert x == {};\n    }\n    else\n    {\n        var z:| z in x;\n        assert z in x;\n        var x' := x-{z};\n        assert |x| == |x'|+1;\n        assert x+{z} == x == x'+{z};\n    }\n}"
},
{
    "dafny": "class DishWasher{\n    var loaded: bool;\n    var addedDtgt: bool;\n    var washed: bool;\n    predicate Valid()\n      reads this;\n    {\n      (!this.loaded && this.washed)||(!this.addedDtgt && this.washed) ==> false\n    }\n    constructor()\n      modifies this;\n      ensures this.loaded == false;\n      ensures this.addedDtgt == false;\n      ensures this.washed == false;\n      ensures Valid();\n    {\n        this.loaded := false;\n        this.addedDtgt := false;\n        this.washed := false;\n    }\n    method Load()\n      modifies this;\n      ensures this.loaded == true;\n      ensures this.washed == false;\n      ensures Valid();\n      ensures this.addedDtgt == old(this.addedDtgt);\n    {\n        this.loaded := true;\n        this.washed := false;\n    }\n    method AddDtgt()\n      modifies this;\n      ensures this.addedDtgt == true;\n      ensures this.loaded == old(this.loaded);\n      ensures this.washed == old(this.washed);\n    {\n        this.addedDtgt := true;\n    }\n    method Wash()\n      modifies this;\n      requires this.addedDtgt == true;\n      requires this.loaded == true;\n      ensures this.washed == true;\n      ensures this.loaded == old(this.loaded);\n    {\n        this.addedDtgt := false;\n        this.washed := true;\n    }\n    method Unload()\n      modifies this;\n      requires this.loaded == true;\n      requires this.washed == true;\n      ensures this.loaded == false;\n      ensures this.washed == false;\n      ensures Valid();\n      ensures this.addedDtgt == old(this.addedDtgt);\n    {\n        this.loaded := false;\n        this.washed := false;\n    }\n}\nmethod Test1()\n{\n    var dishwasher := new DishWasher();\n    dishwasher.Load();\n    dishwasher.AddDtgt();\n    dishwasher.Wash();\n    dishwasher.Unload();\n}\nmethod Test2()\n{\n    var dishwasher := new DishWasher();\n    dishwasher.AddDtgt();\n    dishwasher.Load();\n    dishwasher.Wash();\n    dishwasher.Unload();\n}\nmethod Test3()\n{\n    var dishwasher := new DishWasher();\n    dishwasher.Load();\n    dishwasher.AddDtgt();\n    dishwasher.Wash();\n    dishwasher.AddDtgt();\n    dishwasher.Unload();\n    dishwasher.Load();\n    dishwasher.Wash();\n    dishwasher.Unload();\n}\nmethod Test4()\n{\n    var dishwasher := new DishWasher();\n    dishwasher.Load();\n    dishwasher.AddDtgt();\n    dishwasher.Wash();\n    dishwasher.AddDtgt();\n    dishwasher.Wash();\n    dishwasher.Unload();\n}\nmethod Test5()\n{\n    var dishwasher := new DishWasher();\n    dishwasher.Load();\n    dishwasher.Load();\n    dishwasher.Load();\n    dishwasher.AddDtgt();\n    dishwasher.AddDtgt();\n    dishwasher.Wash();\n    dishwasher.Unload();\n}\nmethod ExtraTest1()\n{\n    var dishwasher := new DishWasher();\n    dishwasher.Load();\n    dishwasher.Load();\n    dishwasher.Load();\n    dishwasher.Load();\n    dishwasher.AddDtgt();\n    dishwasher.Wash();\n    dishwasher.Unload();\n}\nmethod ExtraTest2()\n{\n    var dishwasher := new DishWasher();\n    dishwasher.Load();\n    dishwasher.AddDtgt();\n    dishwasher.Wash();\n    dishwasher.Load();\n    dishwasher.AddDtgt();\n    dishwasher.AddDtgt();\n    dishwasher.Wash();\n    dishwasher.Unload();\n}"
},
{
    "dafny": "datatype Color = Red | White | Blue\npredicate Below(c: Color, d: Color)\n{\n  c == Red || c == d || d == Blue\n}\nmethod DutchFlag(a: array<Color>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> Below(a[i],a[j])\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i1, i2, b:= 0, 0, a.Length;\n  while i2 < b\n    invariant 0 <= i1 <= i2 <= b <= a.Length\n    invariant forall i:: 0 <= i < i1 ==> a[i] == Red\n    invariant forall i:: i1 <= i < i2 ==> a[i] == White\n    invariant forall i:: b <= i < a.Length ==> a[i] == Blue\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    decreases  b - i2\n  {\n    match a[i2]\n    {\n      case Red => \n        a[i1], a[i2] := a[i2], a[i1];\n        i1, i2 := i1 + 1, i2 + 1;\n      case White => \n        i2 := i2 + 1;\n      case Blue => \n        b := b - 1;\n        a[i2], a[b] := a[b], a[i2];\n    }\n  }\n}\npredicate boolBelow(a:bool, b:bool)\n{\n  a == false || b == true \n}\nmethod boolSort(a: array<bool>)\nmodifies a\nensures forall i,j:: 0 <= i < j < a.Length ==> boolBelow(a[i], a[j])\nensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var f, t := 0, a.Length;\n  while f < t\n    invariant 0 <= f <= t <= a.Length\n    invariant forall i :: 0 <= i < f ==> a[i] == false\n    invariant forall i :: t <= i < a.Length ==> a[i] == true\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    decreases  t - f\n  {\n    if a[f] {\n      t := t-1;\n      a[f], a[t] := a[t], a[f];\n    } else {\n      f := f+1;\n    }  \n  }\n}\ndatatype quadriColors = C1 | C2 | C3 | C4\npredicate quadBelow(a: quadriColors, b: quadriColors)\n{\n  a == C1 || b == C4 || a == b || (b == C3 && a == C2)\n}\nmethod quadriFlag(a: array<quadriColors>) \nmodifies a\nensures forall i,j :: 0 <= i < j < a.Length ==> quadBelow(a[i], a[j]);\nensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i1, i2, i3, i4 := 0, 0, 0, a.Length;\n  while i3 < i4\n    invariant 0 <= i1 <= i2 <= i3 <= i4 <= a.Length\n    invariant forall i :: 0 <= i < i1 ==> a[i] == C1\n    invariant forall i :: i1 <= i < i2 ==> a[i] == C2\n    invariant forall i :: i2 <= i < i3 ==> a[i] == C3\n    invariant forall i :: i4 <= i < a.Length ==> a[i] == C4\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    decreases  i4 - i3\n  {\n      match a[i3]\n        {\n          case C3 => \n          i3 := i3 + 1;\n          case C1 =>  \n          a[i2], a[i3] := a[i3], a[i2];\n          a[i1], a[i2] := a[i2], a[i1];\n          i1, i2, i3  := i1+1, i2+1, i3+1;\n          case C2 =>\n          a[i2], a[i3] := a[i3], a[i2];\n          i2, i3 := i2+1, i3+1;\n          case C4 =>\n          i4 := i4 -1;\n          a[i4], a[i3] := a[i3], a[i4];\n        }\n    }\n}"
},
{
    "dafny": "newtype sbyte = i:int | -0x80 <= i < 0x80\nnewtype byte = i:int | 0 <= i < 0x100\nnewtype int16 = i:int | -0x8000 <= i < 0x8000\nnewtype uint16 = i:int | 0 <= i < 0x10000\nnewtype int32 = i:int | -0x80000000 <= i < 0x80000000\nnewtype uint32 = i:int | 0 <= i < 0x100000000\nnewtype int64 = i:int | -0x8000000000000000 <= i < 0x8000000000000000\nnewtype uint64 = i:int | 0 <= i < 0x10000000000000000\nnewtype nat8 = i:int | 0 <= i < 0x80\nnewtype nat16 = i:int | 0 <= i < 0x8000\nnewtype nat32 = i:int | 0 <= i < 0x80000000\nnewtype nat64 = i:int | 0 <= i < 0x8000000000000000\nmethod Division(a:int64)\n  requires 0 <= a < 0x1_0000_0000\n{\n  var z := a / 2;\n  print z;\n}\nmethod Main() {\n  var x:uint32 := 40;\n  var y:uint32 := 2;\n  var z := x + y;\n  print \"Result is z = \", z, \"\\n\";\n}"
},
{
    "dafny": "predicate Sorted(a:array<int>)\n  reads a;\n  requires a != null; \n{\n  forall m, n :: 0 <= m < n < a.Length ==> a[m] <= a[n]\n}\npredicate SortedBetween(a:array<int>,lo:int,hi:int)\n  reads a;\n  requires a != null;\n  requires 0 <= lo <= hi < a.Length;\n{\n  forall m, n :: lo <= m < n <= hi ==> a[m] <= a[n]\n}\nmethod MergeSort(u:array<int>) returns (a:array<int>)\n  requires u != null && u.Length > 0;\n  ensures a != null;\n  ensures a.Length == u.Length;\n  ensures Sorted(a);\n{\n  a := RecursiveMerge(u,0,u.Length-1);\n  return;\n}\nmethod RecursiveMerge(u:array<int>,lo:int,hi:int) returns (a:array<int>)\n  requires u != null && u.Length > 0;\n  requires 0 <= lo <= hi < u.Length;\n  decreases hi-lo;\n  ensures a != null;\n  ensures a.Length == u.Length;\n  ensures SortedBetween(a,lo,hi);\n  ensures forall i:: 0 <= i < lo ==> a[i] == u[i]; \n  ensures forall i:: hi < i < a.Length ==> a[i] == u[i]; \n{\n  a := new int[u.Length];\n  forall (k | 0 <= k < u.Length)  {a[k] := u[k];}\n  if (lo >= hi)\n  {\n    return;\n  }\n  else\n  {\n    var mid:int := (lo+hi) / 2;\n    a := RecursiveMerge(a,lo,mid);\n    a := RecursiveMerge(a,mid+1,hi);\n    a := Merge(a,lo,mid,hi);\n    return;\n  }\n}\nmethod Merge(u:array<int>, lo:int, mid:int, hi:int) returns (a:array<int>)\nrequires u != null && u.Length > 0;\nrequires 0 <= lo <= mid <= hi < u.Length;\nrequires SortedBetween(u,lo,mid); \nrequires hi <= mid || SortedBetween(u,mid+1,hi);\nensures a != null;\nensures a.Length == u.Length;\nensures SortedBetween(a,lo,hi);\nensures forall i:: 0 <= i < lo ==> a[i] == u[i] \nensures forall i:: hi < i < u.Length ==> a[i] == u[i] \ndecreases hi-lo; \n{\n  a := new int[u.Length];\n  forall (k | 0 <= k < u.Length)  {a[k] := u[k];}\n  var tmp := new int[hi-lo+1];\n  var x:int := lo;\n  var y:int := mid + 1;\n  var i:int := 0;\n  while (i < hi-lo+1)\n    invariant forall k:: 0 <= k < u.Length ==> a[k] == u[k];\n    invariant 0 <= i <= hi-lo+1; \n    invariant lo <= x <= mid+1; \n    invariant mid+1 <= y <= hi+1; \n    invariant (x-lo) + (y-(mid+1)) == i; \n    invariant i == 0 || SortedBetween(tmp,0,i-1); \n    invariant forall q, r:: 0 <= q < i && (x <= r <= mid || y <= r <= hi) ==> tmp[q] <= a[r]; \n  {\n    if (x > mid) \n    {\n      tmp[i] := a[y];\n      y := y + 1;\n    }\n    else if (y > hi) \n    {\n      tmp[i] := a[x];\n      x := x + 1;\n    }\n    else if (a[x] <= a[y]) \n    {\n      tmp[i] := a[x];\n      x := x + 1;\n    }\n    else\n    {\n      tmp[i] := a[y]; \n      y := y + 1;\n    }\n    i := i + 1;\n  }\n  i := 0;\n  while (i < hi-lo+1)\n    invariant 0 <= i <= hi-lo+1;\n    invariant forall q  :: (0 <= q < lo || hi < q < u.Length) ==> a[q] == u[q]; \n    invariant forall q:: forall r:: 0 <= q < r < hi-lo+1 ==>  tmp[q] <= tmp[r]; \n    invariant forall q:: lo <= q < lo+i ==> tmp[q-lo] == a[q]; \n    invariant forall q:: forall r:: lo <= q < r < lo+i ==> a[q] <= a[r]; \n  {\n    a[lo + i] := tmp[i];\n    i := i + 1;\n  }\n}\nmethod Main() \n{\n  var arr : array<int> := new int[5];\n  arr[0],arr[1],arr[2],arr[3],arr[4] := 7,4,2,6,7;\n  assert arr[0] == 7;\n  assert arr[1] == 4;\n  assert arr[2] == 2;\n  assert arr[3] == 6;\n  assert arr[4] == 7;\n  arr := MergeSort(arr);\n  assert Sorted(arr);\n  print arr[..],\"\\n\";\n}"
},
{
    "dafny": "function twice(x: int) : int\n{\n    (2 * x)\n}\nmethod sum(x: int, y: int) returns (r: int)\n    ensures r == x + y;\n{\n    r := x + y;\n}\nmethod check_sum()\n{\n    var r, r2;\n    r := sum(0, 0);\n    assert(r == 0);\n    r := sum(0, 10);\n    r2 := sum(10, 0);\n    assert(r == r2); \n    r := sum(10, 20);\n    r2 := sum(20, 10);\n    assert(r == r2);  \n    r := sum(10, 20);\n    r := sum(r, 30);\n    r2 := sum(20, 30);\n    r2 := sum(10, r2);\n    assert(r == r2); \n    r := sum(-19, -19);\n    assert(r == twice(-19));\n}"
},
{
    "dafny": "method Main()\n{\n\tvar q := [1,2,2,5,10,10,10,23];\n\tassert Sorted(q);\n\tassert 10 in q;\n\tvar i,j := FindRange(q, 10);\n\tprint \"The number of occurrences of 10 in the sorted sequence [1,2,2,5,10,10,10,23] is \";\n\tprint j-i;\n\tprint \" (starting at index \";\n\tprint i;\n\tprint \" and ending in \";\n\tprint j-1;\n\tprint \").\\n\";\n\tassert i == 4 && j == 7 by {\n\t\tassert q[0] <= q[1] <= q[2] <= q[3] < 10;\n\t\tassert q[4] == q[5] == q[6] == 10;\n\t\tassert 10 < q[7];\n\t}\n}\npredicate Sorted(q: seq<int>)\n{\n\tforall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\npredicate Left(q:seq<int>, left:nat, key:int){\n\t0<=left<|q| && q[left] == key\n}\nmethod IterateRight(q:seq<int>, key:int,prev:nat)returns(next:nat)\n\trequires Sorted(q)\n\trequires |q| > 0\n\trequires 0<=prev<|q|\n\trequires q[prev] == key\n\tensures q[prev] == key\n\tensures next < |q| ==> q[next]>key\n\tensures next <= |q| ==> q[next-1] == key\n\tensures prev<=next<=|q|\n\tdecreases |q| - prev\n{\n\tif prev+1 == |q| {next:=|q|;}\n\telse if q[prev+1] == key {next:=IterateRight(q,key,prev+1);}\n\telse {next:=prev+1;}\n}\nmethod FindInitialRight(q:seq<int>, key:int, seed:nat)returns(right:nat)\n\trequires Sorted(q)\n\trequires |q| > 0\n\trequires 0<=seed<|q|\n\trequires q[seed] == key\n\tensures seed < right <= |q| ==> q[right-1]==key\n\tensures right < |q| ==> q[right] > key\n\tensures right<=|q|\n{\n\tif |q| == 1 || seed == |q| - 1{right:=|q|;}\n\telse{right:=IterateRight(q,key,seed);}\n}\nmethod FindInitialLeft(q:seq<int>, key:int, seed:nat)returns(left:nat)\n\trequires Sorted(q)\n\trequires |q| > 0\n\trequires 0<=seed<|q|\n\trequires q[seed] == key\n\tensures Left(q,left,key)\n\tensures left>0 ==> q[left-1]< key;\n{\n\tif seed == 0 {left:=0;}\n\telse{\tleft:=IterateLeft(q,key,seed);}\n}\nmethod IterateLeft(q:seq<int>, key:int,prev:nat)returns(next:nat)\n\trequires Sorted(q)\n\trequires |q| > 0\n\trequires 0<prev<|q|\n\trequires q[prev] == key\n\tensures next <= prev\n\tensures q[next] == key\n\tensures next>0 ==> q[next-1] < key\n\tdecreases prev\n{\n\tif prev-1 == 0 {\n\t\tif q[prev-1] == key{next:=0;}\n\t\telse {next:=1;}\n\t}\n\telse if q[prev-1] == key {next:=IterateLeft(q,key,prev-1);}\n\telse {next:=prev;}\n}\nmethod FindRange(q: seq<int>, key: int) returns (left: nat, right: nat)\n\trequires Sorted(q)\n\tensures left <= right <= |q|\n\tensures forall i :: 0 <= i < left ==> q[i] < key\n\tensures forall i :: right <= i < |q| ==> q[i] > key\n\tensures forall i :: left <= i < right ==> q[i] == key\n  {\n\t\tif |q| == 0 || key < q[0] {left:=0;right:=0;}\n\t\telse if q[|q| - 1] < key {left:=|q|;right:=|q|;}\n\t\telse if |q| == 1 {\n\t\t\tif q[0] == key {left:=0;right:=|q|;}\n\t\t\telse {left:=0;right:=0;}\n\t\t}\n\t\telse{\n\t\t\tleft,right:= FindRangeInNotTrivialSeq(q,key);\n\t\t}\n\t}\nmethod FindRangeInNotTrivialSeq(q:seq<int>, key:int) returns(left:nat, right:nat)\n\trequires Sorted(q)\n\trequires |q| > 1\n\trequires q[|q|-1]>=key\n\trequires q[0]<=key\n\tensures left <= right <= |q|\n\tensures forall i :: 0 <= i < left ==> q[i] < key\n\tensures forall i :: right <= i < |q| ==> q[i] > key\n\tensures forall i :: left <= i < right ==> q[i] == key\n{\n\t\tif q[0] == key {left:=0;right:=FindInitialRight(q,key, 0);}\n\t\telse if q[|q|-1] == key {right:=|q|;left:=FindInitialLeft(q,key, |q|-1);}\n\t\telse{\n\t\t\tvar mid: int := BinarySearch(q, key);\n\t\t\tif mid < |q| && q[mid] == key{\n\t\t\t\tright := FindInitialRight(q,key, mid);\n\t\t\t\tleft := FindInitialLeft(q,key, mid);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassert key !in q;\n\t\t\t\tright:= mid;\n\t\t\t\tleft:=mid;\n\t\t\t}\n\t\t}\n}\nmethod BinarySearch(q: seq<int>, key: int) returns (mid: nat)\n  requires Sorted(q)\n\trequires |q| > 1\n\trequires q[0] < key\n\trequires q[|q|-1] > key\n\tensures key in q ==> 0<=mid<|q|\n\tensures key in q ==> q[mid] == key\n\tensures key !in q ==> 0<=mid<=|q|\n\tensures key !in q && 0<=mid<|q| ==> q[mid] > key\n\tensures key !in q && 0<=mid-1<|q| ==> q[mid - 1] < key\n{\n  var lo, hi := 0, |q|;\n  while lo < hi\n    invariant 0 <= lo <= hi <= |q|\n    invariant key !in q[..lo] && key !in q[hi..]\n\t\tdecreases hi - lo\n  {\n    mid := (lo + hi) / 2;\n    if key < q[mid] {\n      hi := mid;\n    } else if q[mid] < key{\n      lo := mid + 1;\n    } else {\n\t\t\tassert key in q;\n\t\t\treturn mid;\n    }\n  }\n\tassert key !in q;\n\tassert lo >= hi;\n\tassert hi >= 0;\n\tif lo >= |q| {lo:=|q| - 1;}\n\telse if lo == 0 {lo:=1;}\n\tvar seed:nat;\n\tassert 0<lo<|q|;\n\tif q[lo] > key {seed:=lo;}\n\telse if lo+1<|q| && q[lo+1] > key {seed:=lo+1;}\n\telse if lo + 2 < |q| && q[lo+2] > key {seed:=lo+2;}\n\telse {seed:=|q|-1;}\n\tmid := FindNearestBiggest(q,key,seed);\n}\nmethod FindNearestBiggest(q:seq<int>,key:int,seed:nat)returns(mid:nat)\nrequires key !in q\nrequires 0<seed<|q|\nrequires q[0] < key\nrequires q[|q| - 1] > key\nrequires q[seed] > key\nensures 0<mid<|q|\nensures q[mid] > key\nensures q[mid-1] < key\n{\n\tmid:=seed;\n\tassert q[mid] > key;\n\tif seed - 1 == 0 {mid:=seed;}\n\telse if q[seed - 1] > key {mid:=FindNearestBiggest(q,key,seed - 1);}\n\telse { mid:=seed;}\n}"
},
{
    "dafny": "ghost predicate P0(x: bool)\nghost predicate P1(x: bool)\nghost predicate P2(x: bool)\nghost predicate P3(x: bool)\nghost predicate P4(x: bool)\nghost predicate P5(x: bool)\nghost predicate P6(x: bool)\nghost predicate P7(x: bool)\nghost predicate P8(x: bool)\nghost predicate P9(x: bool)\nghost predicate P10(x: bool)\nghost predicate P11(x: bool)\nghost predicate P12(x: bool)\nghost predicate P13(x: bool)\nghost predicate P14(x: bool)\nghost predicate P15(x: bool)\nghost predicate P16(x: bool)\nghost predicate P17(x: bool)\nghost predicate P18(x: bool)\nghost predicate P19(x: bool)\nghost predicate P20(x: bool)\nghost predicate P21(x: bool)\nghost predicate P22(x: bool)\nghost predicate P23(x: bool)\nghost predicate P24(x: bool)\nghost predicate P25(x: bool)\nghost predicate P26(x: bool)\nghost predicate P27(x: bool)\nghost predicate P28(x: bool)\nghost predicate P29(x: bool)\nghost predicate P30(x: bool)\nghost predicate P31(x: bool)\nghost predicate P32(x: bool)\nghost predicate P33(x: bool)\nghost predicate P34(x: bool)\nghost predicate P35(x: bool)\nghost predicate P36(x: bool)\nghost predicate P37(x: bool)\nghost predicate P38(x: bool)\nghost predicate P39(x: bool)\nghost predicate P40(x: bool)\nghost predicate P41(x: bool)\nghost predicate P42(x: bool)\nghost predicate P43(x: bool)\nghost predicate P44(x: bool)\nghost predicate P45(x: bool)\nghost predicate P46(x: bool)\nghost predicate P47(x: bool)\nghost predicate P48(x: bool)\nghost predicate P49(x: bool)\nmethod M() {\n  assert forall x :: true || P0(x) || P1(x) || P2(x) || P3(x) || P4(x) || P5(x) || P6(x) || P7(x) || P8(x) || P9(x) || P10(x) || P11(x) || P12(x) || P13(x) || P14(x) || P15(x) || P16(x) || P17(x) || P18(x) || P19(x) || P20(x) || P21(x) || P22(x) || P23(x) || P24(x) || P25(x) || P26(x) || P27(x) || P28(x) || P29(x) || P30(x) || P31(x) || P32(x) || P33(x) || P34(x) || P35(x) || P36(x) || P37(x) || P38(x) || P39(x) || P40(x) || P41(x) || P42(x) || P43(x) || P44(x) || P45(x) || P46(x) || P47(x) || P48(x) || P49(x);\n}"
},
{
    "dafny": "ghost function f(x: int, y: int): int\nlemma Associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\nlemma Monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall x :: f(x, y) <= f(x, z)\nlemma DiagonalIdentity(x: int)\n  ensures f(x, x) == x\nmethod CalculationalStyleProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { Associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; Monotonicity(c, x); }\n    f(x, x);\n  ==  { DiagonalIdentity(x); }\n    x;\n  }\n}\nmethod DifferentStyleProof(a: int, b: int, c: int, x: int)\n  requires A: c <= x\n  requires B: x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    Associativity(a, b, c);\n  }\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal B;\n  }\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal A; }\n    Monotonicity(c, x);\n  }\n  assert 3: f(x, x) == x by {\n    DiagonalIdentity(x);\n  }\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}"
},
{
    "dafny": "function fib(n: nat): nat\ndecreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\nmethod fibonacci1(n:nat) returns (f:nat)\nensures f==fib(n)\n{\n   var i := 0;\n   f := 0;\n   var fsig := 1;\n   while i < n\n      decreases n - i\n      invariant f==fib(i) && fsig==fib(i+1)\n      invariant i<=n\n   {\n      f, fsig := fsig, f + fsig;\n      i := i + 1;\n   }\n}\nmethod fibonacci2(n:nat) returns (f:nat)\nensures f==fib(n)\n{\nif (n==0) {f:=0;}\nelse{\n   var i := 1;\n   var fant := 0;\n   f := 1;\n   while i < n\n      decreases n-i\n      invariant fant==fib(i-1) && f==fib(i)\n      invariant i<=n\n   {\n      fant, f := f, fant + f;\n      i := i + 1;\n   }\n}\n}\nmethod fibonacci3(n:nat) returns (f:nat)\nensures f==fib(n)\n{\n{\n   var i: int := 0;\n   var a := 1;\n       f := 0; \n   while i < n\n    decreases n-i\n    invariant 0<=i<=n\n    invariant if i ==0 then a==fib(i+1) && f==fib(i)\n               else a==fib(i-1) && f==fib(i)\n   {\n      a, f := f, a + f; \n      i := i + 1;\n   }\n}\n}"
},
{
    "dafny": "method ANCD(aqpr: seq<char>) returns (retx: bool)\n{\n  if |aqpr| == 0 {\n    return true;\n  }\n  var abcd := 0;\n  var efgh := |aqpr| - 1;\n  retx := true;\n  while (abcd < efgh)\n    invariant 0 <= abcd <= efgh + 1 && 0 <= efgh < |aqpr|\n    invariant abcd + efgh == |aqpr| - 1\n    invariant (forall ijkl :: 0 <= ijkl < abcd ==> aqpr[ijkl] == aqpr[|aqpr| - ijkl - 1])\n  {\n    if aqpr[abcd] != aqpr[efgh] {\n      retx := false;\n      return;\n    }\n    abcd := abcd + 1;\n    efgh := efgh - 1;\n  }\n}"
},
{
    "dafny": "method GCD1(a: int, b: int) returns (r: int)\n    decreases a % b\n    requires a > 0 && b > 0 && a != b\n{\n    if a < b {\n        r := GCD1(b, a);\n    } else if (a % b == 0) {\n        r := b;\n    } else {\n        r := GCD1(b, a % b);\n    }\n}\nmethod GCD2(a: int, b: int) returns (r: int)\n    decreases b + 1\n    requires a >= 0 && b >= 0\n{\n    if b == 0 {\n        r := a;\n    } else {\n        r := GCD2(b, a % b);\n    }\n}"
},
{
    "dafny": "class LimitedStack{\n      var capacity : int; \n      var arr : array?<int>; \n      var top : int; \n      predicate Valid()\n      reads this;\n      {\n        !(arr == null) && (capacity > 0) && (arr.Length == capacity) && (-1<=top<=capacity-1)\n      }\n      predicate Empty()\n      reads this;\n      {\n        (top == -1)\n      }\n      predicate Full()\n      reads this;\n      {\n        (top == capacity-1)\n      }\n      method Init(c : int)\n      modifies this;\n      requires c>0;\n      ensures fresh(arr); \n      ensures this.capacity == c;\n      ensures Valid() && Empty();\n      {\n        capacity := c;\n        arr := new int[c];\n        top := -1;\n      }\n      method isEmpty() returns (res : bool)\n      requires Valid();\n      ensures res == Empty();\n      {\n        if top == -1\n        {res := true;}\n        else\n        {res := false;}\n      }\n      method Peek() returns (elem : int)\n      requires Valid();\n      requires !Empty();\n      ensures elem == arr[top];\n      ensures arr == old(arr);\n      ensures forall i:int :: 0<=i<=top ==> arr[i]==old(arr[i]);\n      {\n        elem := arr[top];\n      }\n      method Push(elem : int)\n      modifies arr;\n      modifies `top;\n      requires Valid() && !Full();\n      ensures Valid();\n      ensures top == old(top) + 1;\n      ensures elem == arr[top];\n      ensures forall i:int :: 0<=i<=old(top) ==> arr[i]==old(arr[i]);\n      {\n        top := top + 1;\n        arr[top] := elem;\n      }\n      method Pop() returns (elem : int)\n      modifies `top;\n      requires Valid() && !Empty();\n      ensures top == old(top)-1;\n      ensures elem == arr[top+1];\n      ensures arr == old(arr);\n      {\n        elem := arr[top];\n        top := top-1;\n      }\n      method Shift()\n      requires Valid() && !Empty();\n      ensures Valid();\n      ensures forall i : int :: 0 <= i < capacity - 1 ==> arr[i] == old(arr[i + 1]);\n      ensures top == old(top) - 1;\n      modifies this.arr, this`top;\n      {\n        var i : int := 0;\n        while (i < capacity - 1 )\n        invariant 0 <= i < capacity;\n        invariant top == old(top);\n        invariant forall j : int :: 0 <= j < i ==> arr[j] == old(arr[j + 1]);\n        invariant forall j : int :: i <= j < capacity ==> arr[j] == old(arr[j]);\n        {\n          arr[i] := arr[i + 1];\n          i := i + 1;\n        }\n        top := top - 1;\n      }\n      method Push2(elem : int)\n      modifies arr;\n      modifies `top;\n      requires Valid();\n      ensures Valid() && !Empty();\n      ensures elem == arr[top];\n      ensures (old(top) < capacity-1) ==> (top == old(top)+1) && forall i:int :: 0<=i<top ==> arr[i]==old(arr[i]);\n      ensures (old(top) == capacity-1) ==> (top == old(top)) && forall i:int :: 0<=i<top-1 ==> arr[i]==old(arr[i+1]);\n      {\n        if(top == capacity - 1)\n        {Shift();Push(elem);}\n        else\n        {Push(elem);}\n      } \n      method Main(){\n           var s := new LimitedStack;\n           s.Init(3);\n           assert s.Empty() && !s.Full(); \n           s.Push(27);\n           assert !s.Empty();\n           var e := s.Pop();\n           assert e == 27;\n           s.Push(5);\n           s.Push(32);\n           s.Push(9);\n           assert s.Full();\n           var e2 := s.Pop();\n           assert e2 == 9 && !s.Full(); \n           assert s.arr[0] == 5;\n           s.Push(e2);\n           s.Push2(99);\n           var e3 := s.Peek();\n           assert e3 == 99;\n           assert s.arr[0] == 32;          \n       }\n}"
},
{
    "dafny": "type T\nghost predicate Below(x: T, y: T)\nlemma Reflexive(x: T)\n  ensures Below(x, x)\nlemma Transitive(x: T, y: T, z: T)\n  ensures Below(x, y) && Below(y, z) ==> Below(x, z)\nghost function f(x: T): T\nghost function g(x: T): T\nlemma Connection(x: T, y: T)\n  ensures Below(f(x), y) == Below(x, g(y))\nlemma Monotonic(u: T, v: T)\n  requires Below(u, v)\n  ensures Below(f(u), f(v)) && Below(g(u), g(v))\n{\n  FMonotonic(u, v);\n  GMonotonic(u, v);\n}\nlemma FMonotonic(u: T, v: T)\n  requires Below(u, v)\n  ensures Below(f(u), f(v))\n{\n  calc {\n    Below(f(u), f(v));\n  ==  { Reflexive(f(v)); }\n    Below(f(v), f(v)) ==> Below(f(u), f(v));\n  ==  { Connection(v, f(v)); Connection(u, f(v)); }\n    Below(v, g(f(v))) ==> Below(u, g(f(v)));\n  <== { Transitive(u, v, g(f(v))); }\n    Below(u, v);\n  }\n}\nghost predicate Above(x: T, y: T)\n{\n  Below(y, x)\n}\nlemma AboveReflexive(x: T)\n  ensures Above(x, x)\n{\n  Reflexive(x);\n}\nlemma AboveTransitive(x: T, y: T, z: T)\n  ensures Above(x, y) && Above(y, z) ==> Above(x, z)\n{\n  Transitive(z, y, x);\n}\nlemma GeneralMonotonic(u: T, v: T, below: (T, T) -> bool, a: T -> T, b: T -> T)\n  requires forall x :: below(x, x)  \n  requires forall x, y, z :: below(x, y) && below(y, z) ==> below(x, z)  \n  requires forall x, y :: below(a(x), y) == below(x, b(y))  \n  requires below(u, v)\n  ensures below(a(u), a(v))\n{\n  calc {\n    below(a(u), a(v));\n  ==  \n    below(a(v), a(v)) ==> below(a(u), a(v));\n  ==  \n    below(v, b(a(v))) ==> below(u, b(a(v)));\n  <== \n    below(u, v);\n  }\n}\nlemma FMonotonic'(u: T, v: T)\n  requires Below(u, v)\n  ensures Below(f(u), f(v))\n{\n  forall x {\n    Reflexive(x);\n  }\n  forall x, y, z {\n    Transitive(x, y, z);\n  }\n  forall x, y {\n    Connection(x, y);\n  }\n  GeneralMonotonic(u, v, Below, f, g);\n}\nlemma GMonotonic(u: T, v: T)\n  requires Below(u, v)\n  ensures Below(g(u), g(v))\n{\n  forall x {\n    AboveReflexive(x);\n  }\n  forall x, y, z {\n    AboveTransitive(x, y, z);\n  }\n  forall x, y {\n    calc {\n      Above(g(x), y);\n    ==  \n      Below(y, g(x));\n    ==  { Connection(y, x); }\n      Below(f(y), x);\n    ==  \n      Above(x, f(y));\n    }\n  }\n  GeneralMonotonic(v, u, Above, g, f);\n}"
},
{
    "dafny": "method Main()\n{\n    var x := 11;\n    var h := if x != 0 then (10 / x) else 1;    \n    assert h == 0;\n    if (h == 0) {x := 3; } else { x := 0; }     \n    assert x == 3;\n    var a: array<int> := new int[0];  \n    var b1: bool := (a.Length != 0) && (a[0]==1);\n    var aSeq: seq<int> := [1, 2, 3];\n    var aVal := aSeq[1];    \n    assert aVal == 2;       \n    var aSet: set<int> := { 1, 2, 3};   \n    assert { 1, 2, 3 } == { 3, 1, 2};   \n    assert [ 1, 2, 3 ] != [ 3, 1, 2];   \n    var mSet := multiset{1, 2, 2, 3, 3, 3};\n    assert (3 in mSet) == true;         \n    assert mSet[3] == 3;                \n    assert mSet[4] == 0;\n    var sqr := map [0 := 0, 1 := 1, 2 := 4, 3 := 9, 4 := 16];\n    assert |sqr| == 5;\n    assert sqr[2] == 4;\n    assert 3 in { 1, 2, 3 };                            \n    assert 4 !in { 1, 2, 3 };                           \n    assert \"foo\" in [\"foo\", \"bar\", \"bar\"];              \n    assert \"foo\" in { \"foo\", \"bar\"};                    \n    assert { \"foo\", \"bar\" } !! { \"baz\", \"bif\"};         \n    assert { \"foo\", \"bar\" } < { \"foo\", \"bar\", \"baz\" };  \n    assert { \"foo\", \"bar\" } == { \"foo\", \"bar\" };        \n    a := new int[10];       \n    var m: array2<int> := new int[10, 10];\n    a[0] := 1;              \n    m[0,0] := 1;            \n    var c1 := | [1, 2, 3] |;\n    assert c1 == 3;\n    var c2 := | { 1, 2, 3 } |;\n    assert c2 == 3;\n    var c3 := | map[ 0 := 0, 1 := 1, 2 := 4, 3 := 9] |;\n    assert c3 == 4;\n    assert | multiset{ 1, 2, 2, 3, 3, 3, 4, 4, 4, 4 } | == 10;\n    assert x == 3;               \n    var sumsquared := (var sum := x + x; sum * sum);  \n    assert sumsquared == 36;     \n}\nmethod incrA0(a: array<nat>) returns (r: array<nat>) \n    requires a != null;\n    requires a.Length > 0;\n    modifies a; \n    ensures a[0] == old(a[0]) + 1;  \n{\n    a[0] := a[0] + 1;\n    return a;\n}"
},
{
    "dafny": "predicate sorted (a : seq<int>)\n{\n    forall j, k :: 0 <= j < k < |a| ==> a[j] <= a[k]\n}\npredicate nodups (a : seq<int>)\n{\n    forall i, j :: 0 <= i < |a| ==> 0 <= j < |a| ==> a[i] == a[j] ==> i == j\n}\nmethod removeDups(a : seq<int>) returns (b:seq<int>)\n    requires sorted(a)\n    ensures nodups(b)\n{\n    var indexb : int;\n    var a' : seq<int>;\n    indexb := 1;\n    a' := [];\n    if( |a| <= 1) \n    {\n        return a;\n    }\n    while (indexb < |a|)\n    invariant 0 <= indexb - 1 < |a|\n    invariant(sorted(a[0..(indexb)]))\n    invariant(sorted(a))\n    invariant(|a| > indexb - 1 ==> sorted(a' + [a[indexb - 1]]))\n    invariant(|a'| > 0 ==> a'[|a'| - 1] <= a[indexb - 1])\n    invariant(sorted(a'))\n    invariant(|a| > indexb - 1 ==> nodups(a' + [a[indexb - 1]]))\n    invariant(nodups(a'))\n    {\n        if(a[indexb] != a[indexb - 1])\n        {\n            a' := (a' + [a[indexb - 1]]);\n        }\n        indexb := indexb + 1;\n    }\n    return a';\n}"
},
{
    "dafny": "module MultisetUtil {\n  function Count<A>(fn: A ~> bool, s: multiset<A>) : nat\n  function Sum<A>(fn: A ~> int, s: multiset<A>) : int\n  lemma Count_ge_1<A>(fn: A -> bool, s: multiset<A>, v: A)\n  requires fn(v)\n  requires v in s\n  ensures Count(fn, s) >= 1\n  lemma Count_ge_2<A>(fn: A -> bool, s: multiset<A>, v: A, w: A)\n  requires fn(v)\n  requires fn(w)\n  requires v in s\n  requires w in s\n  requires v != w\n  ensures Count(fn, s) >= 2\n  lemma get_nonzero_elem<A>(fn: A -> int, s: multiset<A>)\n  returns (v: A)\n  requires Sum(fn, s) != 0\n  ensures v in s\n  ensures fn(v) != 0\n  lemma get_true_elem<A>(fn: A -> bool, s: multiset<A>)\n  returns (v: A)\n  requires Count(fn, s) != 0\n  ensures v in s\n  ensures fn(v)\n  lemma get_2_true_elems<A>(fn: A -> bool, s: multiset<A>)\n  returns (v: A, w: A)\n  requires Count(fn, s) >= 2\n  ensures multiset{v, w} <= s\n  ensures fn(v)\n  ensures fn(w)\n  lemma SumAdditive<A>(fn: A -> int, s: multiset<A>, t: multiset<A>)\n  ensures Sum(fn, s) + Sum(fn, t) == Sum(fn, s + t)\n  lemma SumMultiset1<A>(fn: A -> int, v: A)\n  ensures Sum(fn, multiset{v}) == fn(v)\n  lemma CountAdditive<A>(fn: A -> bool, s: multiset<A>, t: multiset<A>)\n  ensures Count(fn, s) + Count(fn, t) == Count(fn, s + t)\n  lemma CountMultiset1<A>(fn: A -> bool, v: A)\n  ensures fn(v) ==> Count(fn, multiset{v}) == 1\n  ensures !fn(v) ==> Count(fn, multiset{v}) == 0\n  lemma CountSubset<A>(fn: A -> bool, fn2: A -> bool, t: multiset<A>)\n  requires forall x: A :: fn(x) ==> fn2(x)\n  ensures Count(fn, t) <= Count(fn2, t)\n}"
},
{
    "dafny": "method cohendiv(X: int,Y: int) returns (r: int, q: int)\nrequires X>=0\nrequires Y>0\nensures r<Y;\n{\n    r:= 0;\n    q:= X;\n    var A: int;\n    var B: int ;\n    while(r >= Y)\n    {\n    \tA:=1;\n    \tB:=Y;\n    \twhile(r >= 2*B)\n    \t{\n    \t\tA:=2*A;\n    \t\tB:=2*B;\n    \t}\n    \tr:=r-B;\n    \tq:=q+A;\n   }\n}"
},
{
    "dafny": "method indexOf(a:array<int>, n:int, elem:int) returns (idx:int)\nrequires n >= 0 && n <= a.Length\nensures idx >= 0 ==> idx < n\nensures idx >= 0 ==> a[idx] == elem\nensures idx < 0 ==> forall i :: (0 <= i < n) ==> a[i] != elem\n{\n    var i := 0;\n    while (i < n)\n    decreases n - i\n    invariant i >= 0 && i <= n\n    invariant forall idx :: (0 <= idx < i) ==> a[idx] != elem\n    {\n        if (a[i] == elem) {\n            return i;\n        }\n        i := i + 1;\n    } \n    return -1;\n}\nmethod max(a:array<int>, n:int) returns (elem:int, idx:int)\nrequires n > 0 && n <=a.Length \nensures idx >= 0 && idx < n\nensures forall i :: (0 <= i < n) ==> elem >= a[i]\n{\n    if (n == 0) {\n        return 0, -1;\n    }\n    assert n > 0;\n    var max:int := a[0];\n    var maxIdx := 0;\n    var i:int := 1;\n    while (i < n)\n    decreases n - i\n    invariant i > 0 && i <= n\n    invariant maxIdx >= 0 && maxIdx < n\n    invariant a[maxIdx] == max\n    invariant forall n :: (0 <= n < i) ==> a[n] <= max\n    {\n        if (a[i] > max) {\n            max := a[i];\n            maxIdx := i;\n        }\n        i := i + 1;\n    }\n    return max, maxIdx;\n}\nmethod min(a:array<int>, n:int) returns (elem:int, idx:int)\nrequires n > 0 && n <=a.Length \nensures idx >= 0 && idx < n\nensures forall i :: (0 <= i < n) ==> elem <= a[i]\n{\n    if (n == 0) {\n        return 0, -1;\n    }\n    assert n > 0;\n    var min:int := a[0];\n    var minIdx := 0;\n    var i:int := 1;\n    while (i < n)\n    decreases n - i\n    invariant i > 0 && i <= n\n    invariant minIdx >= 0 && minIdx < n\n    invariant a[minIdx] == min\n    invariant forall n :: (0 <= n < i) ==> min <= a[n]\n    {\n        if (a[i] < min) {\n            min := a[i];\n            minIdx := i;\n        }\n        i := i + 1;\n    }\n    return min, minIdx;\n}\nmethod fillK(a:array<int>, n:int, k:int, count:int) returns (b:bool)\nrequires n > 0 && n <= a.Length \nrequires count >= 0 && count <= n;\nensures b ==> forall i :: (0 <= i < count) ==> a[i] == k;\n{\n    var i:int := 0;\n    while (i < count)\n    decreases n - i\n    invariant i >= 0 && i <= count\n    invariant forall n :: (0 <= n < i) ==> a[n] == k\n    {\n        if (a[i] != k) {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\nfunction substring(a:array<char>, offset:int, b:array<char>, n:int):bool\n    reads a,b\n    requires 0 <= n <= b.Length\n    requires 0 <= offset <= a.Length - n\n{\n    forall j :: 0 <= j < n ==> b[j] == a[offset+j]\n}\nmethod isSubString(a:array<char>, offset:int, b:array<char>) returns (r:bool)\n    requires 0 <= offset <= a.Length - b.Length\n    ensures r <==> substring(a,offset, b, b.Length)\n{\n    var i := 0;\n    r := true;\n    while i < b.Length\n        decreases b.Length - i\n        invariant 0 <= i <= b.Length\n        invariant r <==> substring(a,offset, b, i)\n    {\n        if a[offset+i] != b[i]\n        {\n            r := false; \n            break;\n        }\n        i := i + 1;\n    }\n}\nmethod containsSubString(a:array<char>, b:array<char>) returns (pos:int)\n    requires b.Length <= a.Length \n    ensures 0 <= pos ==> pos < a.Length-b.Length && substring(a,pos,b, b.Length)\n    ensures pos == -1 ==> forall j :: 0 <= j < a.Length-b.Length ==> !substring(a,j,b,b.Length)\n{\n    var i := 0;\n    var n := a.Length - b.Length;\n    while i < n\n        decreases n - i\n        invariant 0 <= i <= n\n        invariant forall j :: 0 <= j < i ==> !substring(a,j,b,b.Length)\n    {\n        var r := isSubString(a,i,b);\n        if r \n        { return i; }\n        i := i + 1;\n    }\n    return -1;\n}\nmethod resize(a:array<int>) returns (b:array<int>)\nrequires true\nensures a.Length == 0 ==> b.Length == 2\nensures a.Length > 0 ==> b.Length == 2 * a.Length\nensures forall e :: (0 <= e < a.Length) ==> a[e] == b[e]\n{\n    var result:array<int>;\n    if (a.Length == 0) {\n        result := new int[2];\n    } else {\n        result := new int[a.Length * 2];\n    }\n    var i:int := 0;\n    while (i < a.Length)\n    decreases a.Length - i\n    invariant i >= 0 && i <= a.Length\n    invariant forall e :: (0 <= e < i) ==> a[e] == result[e]\n    {\n        result[i] := a[i];\n        i := i + 1;\n    }\n    return result;\n}\nmethod reverse(a:array<int>, n:int) returns (r:array<int>)\nrequires n >= 0 && n <= a.Length\nensures a.Length == r.Length\nensures forall i :: (0 <= i < n) ==> a[i] == r[n - 1 - i]\n{\n    var b:array<int> := new int[a.Length];\n    var i:int := 0;\n    while (i < n)\n    decreases n - i\n    invariant i >= 0 && i <= n\n    invariant forall idx :: (0 <= idx < i) ==> a[idx] == b[n - 1 - idx]\n    {\n        b[n - 1 - i] := a[i];\n        i := i + 1;\n    }\n    return b;\n}\nmethod push(a:array<int>, na:int, elem:int) returns (b:array<int>, nb:int)\nrequires na >= 0 && na < a.Length\nmodifies a\nensures nb == na + 1\nensures a == b\nensures forall i :: (0 <= i < na) ==> a[i] == b[i];\nensures b[na] == elem\n{\n    a[na] := elem;\n    return a, na + 1;\n}\nmethod pop(a:array<int>, n:int) returns (na:array<int>, nn:int, elem:int)\nrequires n > 0 && n < a.Length\nmodifies a\nensures nn == n - 1\nensures a == na\nensures forall i :: (0 <= i < nn) ==> a[i] == na[i]\nensures elem == a[n - 1]\n{\n    return a, n - 1, a[n - 1];\n}"
},
{
    "dafny": "method Rating(a:seq<int>, n:int, score:int) returns (b:array<int>)\n\trequires n > 0;\n\tensures b.Length == n;\n\tensures forall k :: 0<=k<b.Length && (k in a) ==> b[k] == score;\n\tensures forall k :: 0<=k<b.Length && !(k in a) ==> b[k] == 0;\n{\n\tb := new int[n];\n\tvar i:int := 0;\n\twhile (i < b.Length)\n\t\tdecreases b.Length-i;\n\t\tinvariant i<=b.Length;\n\t\tinvariant forall k :: 0<=k<i && !(k in a) ==> b[k] == 0;\n\t\tinvariant forall k :: 0<=k<i && k in a ==> b[k] == score;\n\t{\n\t\tif (i in a)\n\t\t{\n\t\t\tb[i] := score;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb[i] := 0;\n\t\t}\n\t\ti := i+1;\n\t}\n}"
},
{
    "dafny": "method F() returns(x:int)\n  ensures x == 6;\n{\n  x := 5;\n  x := (var y := 1; y + x);\n}\nmethod Main()\n{\n  var x := F();\n  print x;\n}"
},
{
    "dafny": "predicate clumped1(a: array<int>)\nreads a\n{\n    forall x,y :: 0<=x<y<a.Length && a[x] != a[x+1] ==> a[x] != a[y]\n}\nmethod TEST1()\n{\n    var a: array<int> := new int[5][42,42,42,1,1];\n    assert clumped1(a);\n    var b: array<int> := new int[1][42];\n    assert clumped1(b);\n    var c: array<int> := new int[5][1, 2, -1, 8, 0];\n    assert clumped1(c);\n    var d: array<int> := new int[3][42,1,42];\n    assert d[0]==42 && d[1]==1 && d[2]==42;\n    assert !clumped1(d);\n    var e: array<int> := new int[5][0, -1, -1, -1, 0];\n    assert e[0] == 0 && e[1] == -1 && e[2] == -1 && e[3] == -1 && e[4] == 0;\n    assert !clumped1(e);\n    var f: array<int> := new int[5][0, 0, 0, 0, 0];\n    assert clumped1(f);\n    var g: array<int> := new int[0][];\n    assert clumped1(g);\n    var h: array<int> := new int[5][42,1,42, 1,42];\n    assert h[0]==42 && h[1]==1 && h[2]==42 && h[3]==1 && h[4]==42;\n    assert !clumped1(h);\n    var i: array<int> := new int[8][7,42,42,8,1,1, 2, 3];\n    assert clumped1(i);\n    var j: array<int> := new int[6][0, 0, -1, -1, 0, 0];\n    assert j[0] == 0 && j[1] == 0 && j[2] == -1 && j[3] == -1 && j[4] == 0 && j[5] == 0;\n    assert !clumped1(j);\n}"
},
{
    "dafny": "method Test()\n{\n    var a := new int[][1, 2, 3, 4, 5];\n    assert a[..] == [1, 2, 3, 4, 5];\n    Reverse(a);\n    assert a[..] == [5, 4, 3, 2, 1];\n}\nmethod Reverse(a: array<int>)\n    modifies a;\n    ensures  forall i | 0 <= i < a.Length :: a[i] == old(a[a.Length - i - 1]);\n{\n    var l := 0;\n    var r := a.Length - 1;\n    while l < r\n        decreases r - l;\n        invariant 0 <= l <= (a.Length + 1) / 2;\n        invariant r == a.Length - l - 1;\n        invariant forall i | 0 <= i < l :: a[i] == old(a[a.Length - i - 1]);\n        invariant forall i | r < i < a.Length :: a[i] == old(a[a.Length - i - 1]);\n        invariant forall i | l <= i <= r :: a[i] == old(a[i]);\n    {\n        a[l], a[r] := a[r], a[l];\n        l := l + 1;\n        r := r - 1;\n    }\n}"
},
{
    "dafny": "method CommandCompleter(n: nat, m: nat, b: bool) {\n    var R1 := 0;\n    var R2 := 0;\n    var i := 0;\n    var k := 0;\n    while i < n\n        invariant i==k\n        invariant i<=n\n    {\n        i := i + 1;\n        k := k + 1;\n    }\n    assert k <= n; \n    if (b) {\n        R1 := R1 + k;\n        assert R1 <= n; \n    } else {\n        var j := 0;\n        while j < k\n            invariant j >= R2\n            invariant j <= k\n        {\n            if (b) {\n                R2 := R2 + 1;\n                assert j >= R2; \n            }\n            j := j+1;\n        }\n        assert j<=n; \n    }\n    assert R1 + R2 <= 2*n; \n}"
},
{
    "dafny": "method Test()\n{\n    var res;\n    res := Factorial(0);\n    assert res == 1;\n    res := Factorial(1);\n    assert res == 1;\n    res := Factorial(2);\n    assert res == 2;\n    res := Factorial(3);\n    assert res == 6;\n    res := Factorial(4);\n    assert res == 24;\n    res := Factorial(5);\n    assert res == 120;\n    res := Factorial(6);\n    assert res == 720;\n}\nfunction Fac(n: nat): nat\n    decreases n;\n{\n    if n == 0 then\n        1\n    else\n        n * Fac(n - 1)\n}\nmethod Factorial(n: nat) returns (res: nat)\n    ensures res == Fac(n);\n{\n    res := 1;\n    var i := 0;\n    while i < n\n        decreases n - i;\n        invariant 0 <= i <= n;\n        invariant res == Fac(i);\n    {\n        i := i + 1;\n        res := res * i;\n    }\n}"
},
{
    "dafny": "class List {\n  var a: array<int>;\n  var size: nat;\n  predicate Valid()\n    reads a, this\n  {\n    a != null &&\n      size >= 0 &&\n      size <= a.Length &&\n      0 < a.Length \n  }\n  constructor init(len : int)\n    requires len > 0\n    ensures Valid()\n    ensures fresh(a)\n    ensures size == 0\n    ensures a.Length == len\n    modifies this\n  {\n    a := new int[len];\n    size := 0;\n  }\n  method snoc(e : int)\n    requires Valid() && size < a.Length\n    ensures Valid()\n    ensures size == old(size) + 1\n    ensures a[size - 1] == e\n    ensures forall i :: 0 <= i < old(size) ==> a[i] == old(a[i])\n    modifies a, `size\n  {\n    a[size] := e;    \n    size := size + 1;    \n  }\n  method cons(val : int)\n    requires Valid() && size < a.Length\n    ensures Valid()\n    ensures size == old(size) + 1\n    ensures forall i :: 1 <= i <= old(size) ==> a[i] == old(a[i-1])\n    ensures a[0] == val\n    modifies a, `size\n  {      \n    var i:int := size;\n    while (i > 0) \n      invariant 0 <= i <= size ;\n      invariant forall j :: 0 <= j < i ==> a[j] == old(a[j]) ;\n      invariant forall j :: i < j <= size ==> a[j] == old(a[j-1]) ;\n      decreases i;\n      modifies a;\n    {       \n      a[i] := a[i-1];       \n      i := i - 1 ;\n    }\n    a[0] := val;\n    size := size + 1;\n  }\n  method tail()    \n    requires Valid() && size > 0\n    ensures Valid()\n    ensures size == old(size) - 1\n    ensures forall i :: 0 <= i < size-1 ==> a[i] == old(a[i+1])\n    modifies `size, a\n  { \n    var i:int := 0;\n    while (i < size-1) \n      invariant 0 <= i < size ;\n      invariant forall j :: 0 <= j < i ==> a[j] == old(a[j+1]) ;\n      invariant forall j :: i < j < size ==> a[j] == old(a[j]) ;\n      decreases size - i;\n      modifies a;\n    {       \n      a[i] := a[i + 1];       \n      i := i + 1;\n    }\n    size := size - 1;\n  }\n  method head() returns (h : int)\n    requires Valid() && size > 0\n    ensures h == a[0] \n  {\n    h := a[0] ;\n  }\n}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n   ensures 0 <= index ==> index < a.Length && a[index] == key\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n   index := 0;\n   while index < a.Length\n      invariant 0 <= index <= a.Length\n      invariant forall k :: 0 <= k < index ==> a[k] != key\n   {\n      if a[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}\nmethod Main() {\n  var a := new int[5];\n  a[0] := 12;\n  a[1] := 3;\n  a[2] := 5;\n  a[3] := 2;\n  a[4] := 1;\n  var b := Find(a,5);\n  print \"Index: \", b;\n}"
},
{
    "dafny": "predicate Sorted(a: array<int>, low:int, high:int)\nrequires a != null \nrequires 0 <= low <= high <= a.Length\nreads a\n{ \n   forall j,k:: low <= j < k < high ==> a[j] <= a[k] \n}\nmethod SelectionSort(a: array<int>)\nmodifies a;\nrequires a != null;\nensures Sorted(a, 0, a.Length);\nensures multiset(a[..]) == multiset(old(a[..]));\n{\n   if (a.Length <= 1){\n      return;\n   }\n   var i := 0;\n   while(i < a.Length)\n   invariant 0 <= i <= a.Length;\n   invariant i >= 1 ==> (forall k :: i <= k < a.Length ==> a[i-1] <= a[k])\n   invariant 1 <= i < a.Length ==> (a[i-1] <= a[i])\n   invariant Sorted(a, 0, i)\n   invariant multiset(a[..]) == multiset(old(a[..]));\n   {\n      var li := i;\n      var j := i;\n      while(j < a.Length)\n      invariant 0 <= j <= a.Length;\n      invariant 0 <= li < a.Length;\n      invariant forall k :: i <= k < j ==> a[li] <= a[k];\n      invariant a[li]<=a[i];\n      invariant Sorted(a,0,i);\n      invariant multiset(a[..]) == multiset(old(a[..]));\n      invariant forall q :: 0 <= q < i ==> a[li] >= a[q];\n      invariant 0 <= i <= li < a.Length;\n      {\n         if(a[j] < a[li]){\n            li := j;\n         }\n         j := j + 1;\n      }\n      a[i], a[li] := a[li], a[i];\n      i := i + 1;\n   }\n}"
},
{
    "dafny": "predicate reversed (arr : array<char>, outarr: array<char>)\nrequires arr != null && outarr != null\nrequires arr.Length == outarr.Length\nreads arr, outarr\n{\n  forall k :: 0<=k<=arr.Length-1 ==> outarr[k] == arr[(arr.Length-1-k)]\n}\nmethod yarra(arr : array<char>) returns (outarr : array<char>)\nrequires arr != null && arr.Length > 0\nensures outarr != null && arr.Length == outarr.Length && reversed(arr,outarr)\n{\n  var i:= 0;\n  var j:= arr.Length-1;\n  outarr := new char[arr.Length];\n  outarr[0] := arr[j];\n  i := i+1;\n  j := j-1;\n  while i<arr.Length && 0<=j<arr.Length\n  invariant 0<=i<=arr.Length\n  invariant j == arr.Length - 1 - i\n  invariant forall k | 0 <= k < i :: outarr[k] == arr[arr.Length-1-k]\n  decreases arr.Length-i, j\n  {\n    outarr[i] := arr[j];\n    i:=i+1;\n    j:=j-1;\n  }\n }\nmethod Main()\n{\n  var s := ['a','b','a','b','a','b','a','b','a','b','a','b'];\n  var a,b,c,d := new char[5], new char[5], new char[5], new char[5];\n  a[0], a[1], a[2], a[3], a[4] := 'y', 'a', 'r', 'r', 'a';\n  d[0], d[1], d[2], d[3], d[4] := 'y', 'a', 'r', 'r', 'a';\n  b := yarra(a);\n  c := yarra(b);\n  assert c[..] == a[..];\n}"
},
{
    "dafny": "method firste(a: array<char>) returns (c:int)\nensures -1 <= c < a.Length\nensures 0 <= c < a.Length ==> a[c] == 'e' && forall x :: 0 <= x < c ==> a[x] != 'e'\nensures c == -1 ==> forall x :: 0 <= x < a.Length ==> a[x] != 'e'\n{\n    var i:int := 0;\n    while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall x :: 0 <= x < i ==> a[x] != 'e'\n    {\n        if a[i] == 'e' {\n            return i;\n        }\n        i := i + 1;\n    }\n    return -1;\n}\nmethod Main(){\n    var a := new char[6]['c','h','e','e','s','e'];\n    var p := firste(a);\n    print p;\n}"
},
{
    "dafny": "method Main() {\n  print \"yet here we are\\n\";\n}\nclass C {\n  constructor ()\n    modifies this  \n  {\n  }\n}\ninductive predicate InductivePredicate()  \n{ true }\ncopredicate CoPredicate()  \n{ true }\ninductive lemma InductiveLemma()  \n{ }\ncolemma CoLemma()  \n{ }"
},
{
    "dafny": "function f(i: int): int\nfunction g(i: int): int\nmethod M() {\n  assert forall i :: false ==> f(i) == f(f(i));\n  assert forall i :: false ==> f(i) == f(i+1);\n  assert forall i {:matchingloop} :: false ==> f(i) == f(i+1);\n  assert forall i :: false ==> f(i) == f(i+1) && f(i) == g(i);\n  assert forall i :: false ==> f(i) == f(i+1) && f(i) == f(i);\n  assert forall i {:matchingloop} :: false ==> f(i) == f(i+1) && f(i) == f(i);\n  assert forall i :: false ==> f(i) == 0;\n  assert forall i :: false ==> f(i+1) == 0;\n  assert forall i {:autotriggers false} :: false ==> f(i+1) == 0;\n  assert forall i, j: int :: false ==> f(i) == f(j);\n  assert forall i, j: int :: false ==> f(i) == f(i);\n  assert forall i, j: int :: false ==> f(i) == f(i) && g(j) == 0;\n  assert forall i, j: int :: false ==> f(i) == f(i) && g(j+1) == 0;\n  assert forall i, j: int {:autotriggers false} :: false ==> f(i) == f(i);\n  assert forall i, j: int {:trigger f(i), g(j)} :: false ==> f(i) == f(i);\n}"
},
{
    "dafny": "predicate just1(a: array<int>, key: int)\nreads a\nrequires a != null\n{\n    (exists k | 0 <= k < a.Length :: a[k] == key)&&!(exists k, j | 0<=k<j<a.Length :: a[j]==key&&a[k]==key)\n}\nmethod Just1(a: array<int>, key: int) returns (b: bool)\nrequires a!=null\nensures b == just1(a,key)\n{\n    b := false;\n    var i :=  0;\n    while i < a.Length\n    invariant 0<=i<=a.Length\n    invariant !(exists j | 0<=j<i :: a[j]==key)\n    decreases a.Length - i\n    {\n        if a[i]==key\n        {\n            var k := i+1;\n            if (k == a.Length){\n                b := true;\n                return;\n            }\n            while k<a.Length\n            invariant i+1<=k<=a.Length\n            invariant forall m:: i+1<=m<k ==> a[m]!= key\n            decreases a.Length-k\n            {\n                if a[k]==key{\n                    b := false;\n                    return;\n                }\n                k := k+1;\n            }\n            b:=true;\n            return;\n        }\n        i := i+1;\n    }\n}\nmethod Main(){\n    var arr :=new int[4];\n    arr[0], arr[1], arr[2], arr[3]:= 1,1,2,1;\n    var res:= Just1(arr, 1);\n    assert arr[0]==1;\n    assert arr[1]==1;\n    assert arr[2]==2;\n    assert arr[3]==1;\n    assert !res;\n    print res;\n    print \"\\n\";\n    res:= Just1(arr, 2);\n    assert res;\n    print res;\n    print \"\\n\";\n    res:= Just1(arr, 3);\n    assert !res;\n    print res;\n    print \"\\n\";\n    var arr1 :=new int[1];\n    arr1[0]:=1;\n    res := Just1(arr1, 1);\n    assert arr1[0]==1;\n    assert res;\n    print res;\n    print \"\\n\";\n    res:= Just1(arr1, 2);\n    assert !res;\n    print res;\n    print \"\\n\";\n    var arr2 := new int[0];\n    res := Just1(arr2, 1);\n    assert !res;\n    print res;\n    print \"\\n\";\n}"
},
{
    "dafny": "method DividesIt(x: int, y: int, d: int) returns (r: int)\n  requires x >= 0 &&  y >=0  && d>0 && x%d==0 && y%d==0\n  ensures r % d==0\n{\n  var x1: int := x;\n  var y1: int := y;\n  while (x1 > 0 && y1 > 0) \n    invariant x1>=0 && y1>=0 && x1%d==0 && y1%d==0\n    decreases x1+y1\n  {\n    if (x1 >= y1) \n     {  DivLemma( d,x1,y1 ); \n        x1 := x1 - y1; }\n    else \n     { \n       DivLemma( d,x1,y1 );\n       y1 := y1 - x1;\n     }\n  }\n  r:=x1;\n  if (x1==0) \n    {r:=y1; }\n  else\n    {r:=x1;}\n}\nlemma DivLemma(d: int, a: int, b: int)\nrequires d>0 && a>0 && b>0 && a%d==0 && b%d==0 \nensures (a-b)%d==0  && (b-a) % d==0 \n{\n  assume (a-b)%d==0 && (b-a)%d==0;\n}"
},
{
    "dafny": "class A {\n    predicate Valid() reads this {\n        true\n    }\n    constructor() {\n    }\n}\nclass B {\n    var things: set<A>\n    predicate Valid()\n        reads this, things\n    {\n        forall thing | thing in things :: thing.Valid()\n    }\n    constructor() {\n        things := {};\n    }\n}"
},
{
    "dafny": "method zip(a : array?< int >, b : array?< int >) returns (c : array?< int >)\nrequires a != null && b != null && a.Length == b.Length && a.Length > 0 ;\nensures c != null && c.Length == a.Length + b.Length;\nensures forall i:int :: 0 <= i < c.Length && i % 2 == 0 ==> c[i] == a[i/2];\nensures forall i:int :: 0 <= i < c.Length && i % 2 != 0 ==> c[i] == b[(i-1)/2];\n{\n\tvar len := a.Length + b.Length;\n  c := new int[len];\n  var i := 0;\n  while i < c.Length\n  invariant i <= c.Length;\n  invariant forall j:int :: 0 <= j < i && j % 2 == 0 ==> c[j] == a[j/2];\n  invariant forall j:int :: 0 <= j < i && j % 2 != 0 ==> c[j] == b[(j-1)/2];\n  decreases c.Length - i;\n  {\n  \tif i % 2 == 0 {\n  \t\tc[i] := a[i/2];\n  \t}\n  \tif i % 2 != 0 {\n  \t\tc[i] := b[(i-1)/2];\n  \t}\n  \ti := i+1;\n  }\n}"
},
{
    "dafny": "module MX {\n    method dpStringMX(a: string, b: string) \n    returns (a': string, b': string)\n    requires |a| > 0 && |b| > 0\n    ensures |a'| == |a|+1\n    ensures |b'| == |b|+1\n    ensures a'[0] == '\\0'\n    ensures b'[0] == '\\0'\n    {\n        a' := \"\\0\" + a;\n        b' := \"\\0\" + b;\n    }\n}"
},
{
    "dafny": "function Sum(n:nat):nat\n{\n  if n==0 then  0 else n + Sum(n-1)\n}\nmethod ComputeSum(n:nat) returns (s:nat)\n    ensures s ==Sum(n)\n{\n    s := 0;\n    var i := 0;\n    while i< n\n      invariant 0 <= i <= n\n      invariant s == Sum(i)\n      {\n        s := s + i + 1;\n        i := i+1;\n      }\n}"
},
{
    "dafny": "predicate equal (a: seq<char>, b: seq <char>)\n{\n\t|a| == |b| && forall i :: (0 <= i < |a|) ==> a[i] == b[i]\t\n}\nmethod Prefix (str: array<char>, start: int, sub: array<char>) returns (b: bool)\nrequires 0 <= sub.Length <= str.Length - start <= str.Length;\nrequires start <= str.Length;\nensures b <==> equal(sub[..], str[start..(start + sub.Length)])\n{\n\tvar i := 0;\n\twhile (i < sub.Length) \n\tinvariant i <= sub.Length;\n\tinvariant equal (sub[..i], str[start..(i + start)]);\n\t{\n\t\tif (str[i + start] != sub[i]) {\n\t\t\treturn false;\n\t\t}\n\t\ti := i + 1;\n\t}\n\treturn true;\n}\nmethod Substring (str: array<char>, sub: array<char>) returns (b: bool, index: int)\nensures b <==> index >= 0 && str.Length >= sub.Length && (index + sub.Length < str.Length) && equal (str[index..(index+sub.Length)], sub[..])\n{\n  if (str.Length < sub.Length) {\n  \treturn false, -1;\n  }\n  var i := 0;\n  while (i < str.Length - sub.Length) \n  invariant i <= str.Length - sub.Length;\n  invariant i > 0 ==> !equal (str[(i-1)..(i-1)+sub.Length], sub[..])\n  {\n  \tvar b := Prefix (str, i, sub);\n  \tif (b) {\n  \t\tassert (i + sub.Length <= str.Length);\n  \t\treturn true, i;\n  \t}\n  \ti := i + 1;\n  }\t\n  return false, -1;\n}\nmethod Main () {\n\tvar str := new char[]['h', 'e', 'l', 'l', 'o'];\n\tvar sub := new char[]['h', 'e', 'l', 'l'];\n\tvar b: bool;\n\tvar index: int;\n    b := Prefix (str, 0, sub);\n    assert (b);\n    b, index := Substring (str, sub);\n    print (b);\n    print (index);\n    sub := new char []['e', 'l', 'l'];\n    b := Prefix (str, 0, sub);\n    assert (!b);\n    b := Prefix (str, 1, sub);\n    assert (b);\n    b, index := Substring (str, sub);\n    print (b);\n    print (index);\n    sub := new char []['l', 'l', 'o'];\n    b := Prefix (str, 1, sub);\n    assert (!b);\n    b := Prefix (str, 2, sub);\n    assert (b);\n    b, index := Substring (str, sub);\n    print (b);\n    print (index);\n}"
},
{
    "dafny": "method Mid( p: int, q: int) returns ( m: int )\n    requires p <= q;\n    ensures p<= m <= q;\n    ensures m-p <= q-m;\n    ensures 0 <= (q-m)-(m-p) <= 1;\n{\n    m := (p+q)/2;\n    assert m == p+(q-p)/2;\n}\nmethod Main() \n{\n    var x := Mid(40, 100);\n    print x;\n}"
},
{
    "dafny": "ghost predicate P<A>(s: seq<A>)\ntrait T<A> {\n  method M(a: A)\n    requires Q([a][0 := a])\n    modifies if P([a][0 := a]) then {} else {this}\n    ensures P([a][0 := a])\n    decreases if P([a][0 := a]) then 3 else 4\n  ghost function F(a: A): int\n    requires Q([a][0 := a])\n    reads if P([a][0 := a]) then {} else {this}\n    ensures F(a) == 5 ==> P([a][0 := a])\n    decreases if P([a][0 := a]) then 3 else 4\n}\nghost predicate Q<A>(s: seq<A>)\n  ensures Q(s) ==> P(s)\nclass C extends T<object> {\n  method M(a: object)\n    requires P([a][0 := a])\n    modifies if Q([a][0 := a]) then {} else {this}\n    ensures Q([a][0 := a])\n    decreases if Q([a][0 := a]) then 3 else 2\n  ghost function F(a: object): int\n    requires P([a][0 := a])\n    reads if Q([a][0 := a]) then {} else {this}\n    ensures F(a) == 5 ==> Q([a][0 := a])\n    decreases if Q([a][0 := a]) then 3 else 4\n}"
},
{
    "dafny": "function fact(n: nat): nat \n    ensures fact(n) >= 1\n{\n    if n == 0 then 1 else n * fact(n - 1)\n}\nmethod factorial(n: nat) returns (res: nat)\n    ensures res == fact(n)\n{\n    var i := 1;\n    res := 1;\n    while i < n + 1 \n        invariant 0 < i <= n + 1\n        invariant res == fact(i - 1) \n    {\n        res := i * res;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "type t = seq<int>\nghost predicate P(x:t)\nghost function F(x:t) : int\nghost function C() : int { assume (exists x :: P(x)); var x :| P(x); F(x) }\nlemma L(x:t)\n{\n  assume P(x);\n  assume forall y :: P(y) ==> y == x;\n  assert F(x) == C(); \n}"
},
{
    "dafny": "class SumOfCubes {\n  static ghost function SumEmUp(n: int, m: int): int\n    requires 0 <= n && n <= m;\n    decreases m - n;\n  {\n    if m == n then 0 else n*n*n + SumEmUp(n+1, m)\n  }\n  static method Socu(n: int, m: int) returns (r: int)\n    requires 0 <= n && n <= m;\n    ensures r == SumEmUp(n, m);\n  {\n    var a := SocuFromZero(m);\n    var b := SocuFromZero(n);\n    r := a - b;\n    Lemma0(n, m);\n  }\n  static method SocuFromZero(k: int) returns (r: int)\n    requires 0 <= k;\n    ensures r == SumEmUp(0, k);\n  {\n    var g := Gauss(k);\n    r := g * g;\n    Lemma1(k);\n  }\n  ghost static method Lemma0(n: int, m: int)\n    requires 0 <= n && n <= m;\n    ensures SumEmUp(n, m) == SumEmUp(0, m) - SumEmUp(0, n);\n  {\n    var k := n;\n    while (k < m)\n      invariant n <= k && k <= m;\n      invariant SumEmDown(0, n) + SumEmDown(n, k) == SumEmDown(0, k);\n    {\n      k := k + 1;\n    }\n    Lemma3(0, n);\n    Lemma3(n, k);\n    Lemma3(0, k);\n  }\n  static ghost function GSum(k: int): int\n    requires 0 <= k;\n  {\n    if k == 0 then 0 else GSum(k-1) + k-1\n  }\n  static method Gauss(k: int) returns (r: int)\n    requires 0 <= k;\n    ensures r == GSum(k);\n  {\n    r := k * (k - 1) / 2;\n    Lemma2(k);\n  }\n  ghost static method Lemma1(k: int)\n    requires 0 <= k;\n    ensures SumEmUp(0, k) == GSum(k) * GSum(k);\n  {\n    var i := 0;\n    while (i < k)\n      invariant i <= k;\n      invariant SumEmDown(0, i) == GSum(i) * GSum(i);\n    {\n      Lemma2(i);\n      i := i + 1;\n    }\n    Lemma3(0, k);\n  }\n  ghost static method Lemma2(k: int)\n    requires 0 <= k;\n    ensures 2 * GSum(k) == k * (k - 1);\n  {\n    var i := 0;\n    while (i < k)\n      invariant i <= k;\n      invariant 2 * GSum(i) == i * (i - 1);\n    {\n      i := i + 1;\n    }\n  }\n  static ghost function SumEmDown(n: int, m: int): int\n    requires 0 <= n && n <= m;\n  {\n    if m == n then 0 else SumEmDown(n, m-1) + (m-1)*(m-1)*(m-1)\n  }\n  ghost static method Lemma3(n: int, m: int)\n    requires 0 <= n && n <= m;\n    ensures SumEmUp(n, m) == SumEmDown(n, m);\n  {\n    var k := n;\n    while (k < m)\n      invariant n <= k && k <= m;\n      invariant SumEmUp(n, m) == SumEmDown(n, k) + SumEmUp(k, m);\n    {\n      k := k + 1;\n    }\n  }\n}"
},
{
    "dafny": "method isPrefix(pre: string, str: string) returns (res: bool) \n{\n\tif (|pre| > |str|) {\n\t\treturn false;\n\t}\n\treturn str[..|pre|] == pre;\n}\nmethod isSubstring(sub: string, str: string) returns (res: bool) \n{\n\tvar isAPrefix := isPrefix(sub,  str);\n\tif (isAPrefix) {\n\t\treturn true;\n\t}\n\tif (|str| <= 1) {\n\t\treturn false;\n\t}\n\tvar nextStringToCheck := str[1..];\n\tres :=  isSubstring(sub, nextStringToCheck);\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool) \n{\n\tif (|str1| < k || |str2| < k) {\n\t\treturn false;\n\t}\n\tvar smaller := str1;\n\tvar larger := str2;\n\tif (|str2| < |str1|) {\n\t\tsmaller := str2;\n\t\tlarger := str1;\n\t}\n\tvar i := 0;\n\twhile (i <= |smaller| - k) {\n\t\tassert (i + k) <= |smaller|;\n\t\tvar substr := smaller[i..i+k];\n\t\tassert |substr| == k;\n\t\tvar isSubstr := isSubstring(substr, larger);\n\t\tif (isSubstr) {\n\t\t\treturn true;\n\t\t}\n\t\ti := i + 1;\n\t}\n\treturn false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len: nat) {\n\tvar maxSubstringLength := |str1|;\n\tif (|str2| < |str1|) {\n\t\tmaxSubstringLength := |str2|;\n\t}\n\tlen := maxSubstringLength;\n\twhile (len > 0) {\n\t\tvar hasCommonSubstrOfLen := haveCommonKSubstring(len, str1, str2);\n\t\tif (hasCommonSubstrOfLen) {\n\t\t\treturn len;\n\t\t}\n\t\tlen := len - 1;\n\t}\n\treturn len;\n}"
},
{
    "dafny": "function F(x: int): int \n    decreases x\n{\n    if x < 10 then x else F(x - 1)\n}\nfunction G(x: int): int \n    decreases x\n{\n    if x >= 0 then G(x - 2) else x\n}\nfunction H(x: int): int \n    decreases x + 61\n{\n    if x < -60 then x else H(x - 1)\n}\nfunction I(x: nat, y: nat): int \n    decreases x + y\n{\n    if x == 0 || y == 0 then\n        12\n    else if x % 2 == y % 2 then\n        I(x - 1, y)\n    else\n        I(x, y - 1)\n}\nfunction M(x: int, b: bool): int\n    decreases !b\n{\n    if b then x else M(x + 25, true)\n}\nfunction L(x: int): int \n    decreases 99 - x\n{\n    if x < 100 then L(x + 1) + 10 else x\n}\nfunction J(x: nat, y: nat): int\n    decreases x, y \n{\n    if x == 0 then\n        y\n    else if y == 0 then\n        J(x - 1, 3)\n    else\n        J(x, y - 1)\n}"
},
{
    "dafny": "method firstIndexOf(items: array<int>, item: int) returns (r: int)\n  requires items != null\n  ensures r < items.Length\n  ensures r >= 0 ==> items[r] == item\n  ensures r >= 0 ==> forall k: nat :: k < r ==> items[k] != item\n  ensures r < 0 ==> forall k: nat :: k < items.Length\n                    ==> items[k] != item\n{\n  var i: int := 0;\n  while i < items.Length\n    invariant 0 <= i <= items.Length\n    invariant forall k: nat :: k < i ==> items[k] != item\n  {\n    if items[i] == item\n      { return i; }\n    i := i + 1;\n  } \n  return -1;\n}"
},
{
    "dafny": "class A {\n  var x: int\n  predicate Valid() reads this {\n    x >= 0\n  }\n}\ndatatype B = B(\n  a: A\n) {\n  opaque predicate Valid()\n    reads a\n  {\n    a.Valid()\n  }\n}\nclass C {\n  var a: A\n  constructor()\n  opaque twostate predicate Valid()\n    reads this`a, a\n  {\n    a.Valid() && old(a.Valid())\n  }\n}"
},
{
    "dafny": "datatype Nat = Zero | Succ(n: Nat)\nfunction one(): Nat\n{\n\tSucc(Zero)\n}\nfunction add(x: Nat, y: Nat): Nat\n{\n\tmatch(x) {\n\t\tcase Zero => y\n\t\tcase Succ(n) => Succ(add(n, y))\n\t}\n}\nfunction mult(x: Nat, y: Nat): Nat\n{\n\tmatch(x) {\n\t\tcase Zero => Zero\n\t\tcase Succ(n) => add(mult(n, y), y)\n\t}\n}\nlemma {:induction false} axm_zero(x: Nat)\n\tensures add(x, one()) != Zero\n{\n}\nlemma {:induction false} axm_pluszero(x: Nat)\n\tensures add(x, Zero) == x\n{\n\tif (add(x, Zero) != x) {\n\t\tmatch(x) {\n\t\t\tcase Zero =>\n\t\t\t\tcalc == {\n\t\t\t\t\tadd(x, Zero);\n\t\t\t\t\tadd(Zero, Zero);\n\t\t\t\t\tZero;\n\t\t\t\t\tx;\n\t\t\t\t}\n\t\t\tcase Succ(n) =>\n\t\t\t\tcalc == {\n\t\t\t\t\tadd(x, Zero);\n\t\t\t\t\tadd(Succ(n), Zero);\n\t\t\t\t\tSucc(add(n, Zero));\n\t\t\t\t\t\t{ axm_pluszero(n); } \n\t\t\t\t\tSucc(n);\n\t\t\t\t\tx;\n\t\t\t\t}\n\t\t}\n\t}\n}\nlemma {:induction false} axm_timeszero(x: Nat)\n\tensures mult(x, Zero) == Zero\n{\n\tmatch (x) {\n\t\tcase Zero =>\n\t\t\tcalc == {\n\t\t\t\tmult(Zero, Zero);\n\t\t\t\tZero;\n\t\t\t}\n\t\tcase Succ(n) =>\n\t\t\tcalc == {\n\t\t\t\tmult(Succ(n), Zero);\n\t\t\t\tadd(mult(n, Zero), Zero);\n\t\t\t\t\t{ axm_pluszero(mult(n, Zero)); }\n\t\t\t\tmult(n, Zero);\n\t\t\t\t\t{ axm_timeszero(n); }\n\t\t\t\tZero;\n\t\t\t}\n\t}\n}\nlemma {:induction false} axm_successor(x: Nat, y: Nat)\n\tensures add(x, one()) == add(y, one()) ==> x == y\n{\n\tcalc == {\n\t\tadd(x, one());\n\t\t\t{ add_lemmatwo(x); }\n\t\tSucc(x);\n\t}\n\tcalc == {\n\t\tadd(y, one());\n\t\t\t{ add_lemmatwo(y); }\n\t\tSucc(y);\n\t}\n}\nlemma axm_plussuccessor(x: Nat, y: Nat)\n\tensures add(x, add(y, one())) == add(add(x, y), one())\n{\n  calc == {\n\t\tadd(x, add(y, one()));\n\t\t\t{ add_associative(x, y, one()); }\n\t\tadd(add(x, y), one());\n\t}\n}\nlemma add_lemmatwo(x: Nat)\n\tensures add(x, one()) == Succ(x)\n{}\nlemma add_associative(x: Nat, y: Nat, z: Nat)\n\tensures add(x, add(y, z)) == add(add(x, y), z)\n{\n\tmatch (x) {\n\t\tcase Zero =>\n\t\t\tcalc == {\n\t\t\t\tadd(Zero, add(y, z));\n\t\t\t\tadd(y, z);\n\t\t\t}\n\t\t\tcalc == {\n\t\t\t\tadd(add(Zero, y), z);\n\t\t\t\tadd(y, z);\n\t\t\t}\n\t\tcase Succ(n) =>\n\t\t\tcalc == {\n\t\t\t\tadd(Succ(n), add(y, z));\n\t\t\t\tSucc(add(n, add(y, z)));\n\t\t\t\t\t{ add_associative(n, y, z); }\n\t\t\t\tSucc(add(add(n, y), z));\n\t\t\t}\n\t\t\tcalc == {\n\t\t\t\tadd(add(Succ(n), y), z);\n\t\t\t\tadd(Succ(add(n, y)), z);\n\t\t\t\tSucc(add(add(n, y), z));\n\t\t\t}\n\t}\n}\nlemma add_commutative(x: Nat, y: Nat)\n\tensures add(x, y) == add(y, x)\n{\n\tmatch (x) {\n\t\tcase Zero =>\n\t\t\tcalc == {\n\t\t\t\tadd(Zero, y);\n\t\t\t\ty;\n\t\t\t}\n\t\t\tcalc == {\n\t\t\t\tadd(y, Zero);\n\t\t\t\t\t{ axm_pluszero(y); }\n\t\t\t\ty;\n\t\t\t}\n\t\tcase Succ(n) =>\n\t\t\tcalc == {\n\t\t\t\tadd(Succ(n), y);\n\t\t\t\tSucc(add(n, y));\n\t\t\t\t\t{ add_lemmatwo(add(y, n)); }\n\t\t\t\tadd(add(n, y), one());\n\t\t\t}\n\t\t\tcalc == {\n\t\t\t\tadd(y, Succ(n));\n\t\t\t\t\t{ add_lemmatwo(n); }\n\t\t\t\tadd(y, add(n, one()));\n\t\t\t\t  { add_associative(y, n, one()); }\n\t\t\t\tadd(add(y, n), one());\n\t\t\t\t\t{ add_commutative(n, y); }\n\t\t\t\tadd(add(n, y), one());\n\t\t\t}\n\t}\n}\nlemma axm_timessuccessor(x: Nat, y: Nat)\n\tensures mult(x, add(y, one())) == add(mult(x, y), x)\n{\n\tmatch (x) {\n\t\tcase Zero =>\n\t\t\tcalc == {\n\t\t\t\tmult(Zero, add(y, one()));\n\t\t\t\tZero;\n\t\t\t}\n\t\t\tcalc == {\n\t\t\t\tadd(mult(Zero, y), Zero);\n\t\t\t\t\t{ axm_pluszero(mult(Zero, y)); }\n\t\t\t\tmult(Zero, y);\n\t\t\t\tZero;\n\t\t\t}\n\t\tcase Succ(n) =>\n\t\t\tcalc == {\n\t\t\t\tmult(Succ(n), add(y, one()));\n\t\t\t\tadd(mult(n, add(y, one())), add(y, one()));\n\t\t\t\t\t{ axm_timessuccessor(n, add(y, one())); }\n\t\t\t\tadd(add(mult(n, y), n), add(y, one()));\t\n\t\t\t\t\t{ add_associative(mult(n, y), n, add(y, one())); }\n\t\t\t\tadd(mult(n, y), add(n, add(y, one())));\n\t\t\t\t\t{ add_associative(n, y, one()); }\n\t\t\t\tadd(mult(n, y), add(add(n, y), one()));\n\t\t\t\t\t{ add_commutative(n, y); }\n\t\t\t\tadd(mult(n, y), add(add(y, n), one()));\n\t\t\t}\n\t\t\tcalc == {\n\t\t\t\tadd(mult(Succ(n), y), Succ(n));\n\t\t\t\tadd(add(mult(n, y), y), Succ(n));\n\t\t\t\t\t{ add_lemmatwo(n); }\n\t\t\t\tadd(add(mult(n, y), y), add(n, one()));\n\t\t\t\t\t{ add_associative(mult(n, y), y, add(n, one())); }\n\t\t\t\tadd(mult(n, y), add(y, add(n, one())));\n\t\t\t\t\t{ add_associative(y, n, one()); }\n\t\t\t\tadd(mult(n, y), add(add(y, n), one()));\n\t\t\t}\n\t}\t\n}"
},
{
    "dafny": "method bubbleSort (a: array<int>)\n  requires a != null && a.Length > 1;\n  ensures forall u, v :: 0 <= u < v < a.Length ==> a[u] <= a[v];\n  modifies a;\n{\n  var i:nat := 1;\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant forall u, v:: 0 <= u < v < i ==> a[u] <= a[v];\n  {\n    var j:nat := i;\n    while (j > 0)\n      invariant 0 <= j <= i;\n      invariant forall u, v :: 0 <= u < v < j ==> a[u] <= a[v];\n      invariant forall u, v :: j <= u < v < i+1 ==> a[u] <= a[v];\n      invariant forall u , v :: 0 <= u < j < v < i+1 ==> a[u] <= a[v]\n    {\n      if (a[j-1] > a[j]) {\n        var temp:int := a[j-1];\n        a[j] := temp;\n        a[j-1] := a[j];\n      }\n      j := j - 1;\n    }\n    i := i+1;\n  }\n}"
},
{
    "dafny": "class C {\n  var x: int\n  method Main(ghost u: int) returns (ghost r: bool, ghost s: bool) {\n    print \"hello, instance\\n\";\n    print \"x is \", x, \"\\n\";\n    Client();\n    RegressionClient();\n    r := *;\n    s := *;\n  }\n}\niterator Iter<X(==,0)>(a: array<X>, stop: X) yields (x: X)\n  yield ensures |xs| <= a.Length\n  ensures |xs| <= a.Length\n{\n  var i := 0;\n  while i < a.Length\n    invariant |xs| == i <= a.Length\n  {\n    if i % 2 == 0 {\n      yield a[i];\n    }\n    x := a[i];\n    if x == stop {\n      break;\n    }\n    if i % 2 == 1 {\n      yield;\n    }\n    i := i + 1;\n  }\n}\nmethod Client()\n{\n  var a := new real[6](i => i as real);\n  var iter := new Iter(a, 2.4);\n  while true\n    invariant iter.Valid() && fresh(iter._new)\n    decreases a.Length - |iter.xs|\n  {\n    var more := iter.MoveNext();\n    if (!more) { break; }\n    print iter.x, \" \";\n  }\n  print \"\\n\";\n  iter := new Iter(a, 2.0);\n  while true\n    invariant iter.Valid() && fresh(iter._new)\n    decreases a.Length - |iter.xs|\n  {\n    var more := iter.MoveNext();\n    if (!more) { break; }\n    print iter.x, \" \";\n  }\n  print \"\\n\";\n}\nmethod RegressionClient() {\n  var c := new C;\n  var d := new C;\n  var iter := new RegressionDefaultVsPlaceboInitialization(c, d);\n  var more := iter.MoveNext();\n  if more {\n    print iter.eq, \"\\n\"; \n  }\n}\niterator RegressionDefaultVsPlaceboInitialization<X(==)>(x: X, y: X) yields (eq: bool) {\n  yield x == y;\n}"
},
{
    "dafny": "function count(items: seq<int>, item: int): nat\n{\n  multiset(items)[item]\n}\nmethod occurences(items: array<int>, item: int) returns (num: nat)\n  requires items != null\n  ensures num <= items.Length\n  ensures num == 0 <==> item !in items[..]\n  ensures num == count( items[..], item )\n{\n  num := 0;\n  var i: nat := 0;\n  while i < items.Length\n    invariant num <= i <= items.Length\n    invariant num == 0 <==> item !in items[..i]\n    invariant num == count( items[..i], item )\n  {\n    if items[i] == item\n      { num := num + 1; }\n    i := i + 1;\n  }\n  assert items[..i] == items[..];\n}"
},
{
    "dafny": "method checkPalindrome(s: seq<int>) returns (res: bool)\nrequires |s| >= 0 \nensures isPalindrome(s) <==> res == true \n{\n    res := true;\n    var i := 0 ;\n    var j := | s | - 1 ;\n    while ( i < j && res == true)\n    invariant i == |s| -1 - j && i <= |s| && ((forall k :: 0 <= k < i ==> s[k] == s[|s|-k-1]) <==> res == true) \n    decreases |s| - i\n    {\n        if (s[i] != s[j]) \n        {\n            res := false;\n        } \n        else {\n        }\n        i := i + 1 ;\n        j := j - 1;\n    }\n}\npredicate palindrome(s1: seq<int>, s2: seq<int>)\n{\n    |s1| == |s2| && forall x : int :: 0 <= x < |s1| ==> s1[x] == s2[|s2|-x-1]\n}\npredicate isPalindrome(s: seq<int>)\n{\n    forall x : int :: 0 <= x < |s| ==> s[x] == s[|s|-x-1]\n}"
},
{
    "dafny": "datatype Value = Res(addr: nat) | Nil()\ndatatype Expr = Some(body: Expr)\n              | None()\nfunction f(e: Expr, fuel: nat): Value\n    decreases fuel, 3\n{\n    var ret := Eval(e, fuel);\n    Res(0)\n}\nfunction Eval(e: Expr, fuel: nat): Value\n    decreases fuel, 0\n{\n    if fuel == 0 then Nil() else\n    var fuel' := fuel - 1;\n    match e\n    case Some(body) => f(e.body, fuel')\n    case None() => Nil()\n}\nconst ctxp := Eval(None(), 1)"
},
{
    "dafny": "module Datatype {\n  datatype Box_<T> = Box(t: T)\n  type Box<T> = b: Box_<T> | true witness *\n  datatype List<T> = Nil | Cons(t: T, Box<List<T>>)\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) => 1 + Length(q.t)\n    }\n  }\n}\nmodule Seq {\n  type Box_<T> = seq<T>\n  type Box<T> = b: Box_<T> | |b| == 1 witness *\n  datatype List<T> = Nil | Cons(t: T, Box<List<T>>)\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) =>\n        assert q[0] in q;\n        var l :| l in q;\n        Length(l)\n    }\n  }\n}\nmodule Set {\n  type Box_<T> = set<T>\n  type Box<T> = b: Box_<T> | |b| == 1 witness *\n  datatype List<T(==)> = Nil | Cons(t: T, Box<List<T>>)\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) =>\n        var l :| l in q;\n        Length(l)\n    }\n  }\n}\nmodule Multiset {\n  type Box_<T> = multiset<T>\n  type Box<T> = b: Box_<T> | |b| == 1 witness *\n  datatype List<T(==)> = Nil | Cons(t: T, Box<List<T>>)\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) =>\n        var l :| l in q;\n        Length(l)\n    }\n  }\n}\nmodule Map {\n  type Box_<T> = map<T, bool>\n  type Box<T> = b: Box_<T> | |b| == 1 witness *\n  datatype List<T(==)> = Nil | Cons(t: T, Box<List<T>>)\n  ghost function Length<T>(l: List<T>): int {\n    match l {\n      case Nil => 0\n      case Cons(t, q) =>\n        var l :| l in q.Keys;\n        Length(l)\n    }\n  }\n}"
},
{
    "dafny": "function unique(a:array<int>, n:int):bool\n    requires a != null\n    requires 0 <= n <= a.Length\n    reads a\n{ \n    forall i :: (0 <= i < n) ==> forall j :: (i < j < n) ==> a[i] != a[j]\n}\nfunction sorted(a:array<int>, n:int):bool\n    requires a != null\n    requires 0 <= n <= a.Length\n    reads a\n{ \n    forall i :: (0 <= i < n) ==> forall j :: (i < j < n) ==> a[i] <= a[j]\n}\nfunction contains(b:array<int>, m:int, v:int):bool\n    requires b != null\n    requires 0 <= m <= b.Length \n    reads b\n{\n    v in b[..m]\n}\nmethod Deduplicate(a:array<int>, n:int) returns (b:array<int>, m:int)\n    requires a != null\n    requires 0 <= n <= a.Length\n    requires sorted(a,n)\n    ensures b != null\n    ensures 0 <= m <= b.Length\n    ensures sorted(b,m) && unique(b,m)\n    ensures forall k :: (0 <= k < n) && contains(b,m,a[k]) ==> contains(a,n,a[k])\n{\n    b := new int[n];\n    if (n == 0) {return b,0;}\n    var i := 1;\n    b[0] := a[0];\n    m := 1;\n    while ( i < n)\n        decreases n - i \n        invariant 1 <= i <= n\n        invariant 1 <= m <= i\n        invariant sorted(b,m) && unique(b,m) \n        invariant forall k :: (0 <= k < i) && contains(b,m,a[k]) ==> contains(a,n,a[k])\n    {\n        if (a[i] > b[m-1]) {\n            b[m] := a[i];\n            m := m + 1;\n        }\n        i := i+1;\n    }\n    return b,m;\n}"
},
{
    "dafny": "function P(i: nat, j: nat ) : nat\n     requires j<=i;\n{ if j==0 || i==j then 1 else P(i-1,j-1)+P(i-1,j)  }\nghost method LemmaSym(i: nat, j: nat )\n     requires j<=i;\n     ensures P(i,j)==P(i,i-j);\nmethod CalcP(i: nat, j: nat ) returns (res:nat)\n     requires j<=i;\n{ if (j==0 || i==j) \n  { res:= 1; }\n else \n     { var res1 := CalcP(i-1,j-1);\n       var res2 := CalcP(i-1,j);\n       res:= res1 + res2;\n     }      \n}"
},
{
    "dafny": "function f(k:int):int  \n    requires k>=1;\n{\n    (exp(2,3*k)-exp(3,k))/5\n}\nfunction exp(x:int,e:int):int\n    requires e>=0\n{\n    if e == 0 then 1 else x * exp(x,e-1)\n}\nmethod compute5f(k:int) returns (r:int)\n    requires k>=1\n    ensures r==5*f(k)\n{\n    var i,t1,t2:=0,1,1;\n    while i<k\n        invariant 0<=i<=k;\n        invariant t1==exp(2,3*i);\n        invariant t2==exp(3,i);\n        {\n            expPlus3_Lemma(2,3*i);\n            i,t1,t2:=i+1,8*t1,3*t2;\n        }\n    r:=t1-t2;\n    DivBy5_Lemma(k);\n}\nlemma expPlus3_Lemma(x:int,e:int)\n    requires e>=0;\n    ensures x*x*x*exp(x,e)==exp(x,e+3);\n    {\n        assert x*x*x*exp(x,e)==x*x*exp(x,e+1)==x*exp(x,e+2)==exp(x,e+3);\n    }\nlemma DivBy5_Lemma(k:int)\n    requires k>=1\n    ensures (exp(2,3*k)-exp(3,k))%5==0\n    {\n        if k>1 {\n            expPlus3_Lemma(2,3*(k-1));\n            DivBy5_Lemma(k-1);\n        }\n    }"
},
{
    "dafny": "datatype Blood = Blood(typeOf:char,date:int)\nclass BloodSearcher\n{\n    var a: array<Blood>;\n    constructor (lengthIn : int)\n    requires lengthIn > 0;\n    modifies this;\n    { a := new Blood[lengthIn];}\n    method FindOldest() returns (minimum:Blood) \n    requires a != null;\n    requires a.Length > 0;\n    ensures forall i :: 0 <= i < a.Length ==> minimum.date <= a[i].date;\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    modifies a;\n    {\n        var minimumDate : int := a[0].date;\n        var minimumType : char := a[0].typeOf;\n        var i : int := 1;\n        while (i < a.Length)\n        invariant (i <= a.Length)\n        invariant (forall j :: 0 <= j < i ==> minimumDate <= a[j].date) \n            && (exists k :: 0 <= k < i && minimumDate == a[k].date)\n        {\n            if (a[i].date <= minimumDate){\n                minimumDate := a[i].date;\n                minimumType := a[i].typeOf;\n            }\n            i := i + 1;\n        }\n        minimum := Blood(minimumType,minimumDate);    \n    }\n    method findOldestOfType (typeOf:char) returns (oldest:Blood) \n    requires a != null;\n    requires a.Length > 1;\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    {\n        var newA : array<Blood> := this.FindType(typeOf);\n        if (newA.Length > 0){\n            oldest := newA[0];\n        }else{\n            oldest := Blood('N',0);\n        }\n    }\n    method FindType (typeOf:char) returns (newA:array<Blood>)\n    requires a != null;\n    requires a.Length > 1;\n    ensures newA != null;\n    ensures forall i :: 0 <= i < (newA.Length-1) ==> newA[i].date <= newA[i+1].date;\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    {\n        newA := new Blood[a.Length];\n        var i : int := 1;\n        var count : int := 0;\n        while (i < a.Length)\n        invariant (i <= a.Length)\n        invariant (forall j :: 0 <= j < count && (j < a.Length) ==> newA[j].typeOf == typeOf)\n        invariant (count < i)\n        {\n            if a[i].typeOf == typeOf{\n                newA[count] := a[i];\n                count := count + 1;\n            }\n            i := i + 1;\n        }\n        SortArray(newA);\n    }\n    predicate Sorted(ar: array<Blood>, low:int, high:int)\n    requires ar != null;\n    requires 0<=low<=high<=ar.Length;\n    reads ar;\n    { forall j,k:: low<=j<k<high ==> ar[j].date<=ar[k].date }\n    method SortArray(ar:array<Blood>) \n    requires ar != null;\n    requires ar.Length > 1;\n    ensures forall i :: 0 <= i < (ar.Length-1) ==> ar[i].date <= ar[i+1].date;\n    ensures multiset(ar[..]) == multiset(old(ar[..]));\n    modifies ar;\n    {\n        var up := 1;\n        while (up < ar.Length)\n        invariant 1 <= up <= ar.Length;\n        invariant Sorted(ar,0,up);\n        invariant multiset(ar[..]) == multiset(old(ar[..]));\n        {\n            var down := up;\n            while (down >= 1 && ar[down-1].date > ar[down].date)\n            invariant 0 <= down <= up;\n            invariant forall i,j :: (0<=i<j<=up && j!=down) ==> ar[i].date<=ar[j].date;\n            invariant multiset(ar[..]) == multiset(old(ar[..]))\n            {\n                ar[down-1], ar[down] := ar[down], ar[down-1];\n                down := down - 1;\n            }\n            up := up + 1;\n        }\n    }\n}\nmethod Main() {\n}"
},
{
    "dafny": "class PriorityQueue {\n  var N: nat  \n  var n: nat  \n  ghost var Repr: set<object>  \n  var a: array<int>  \n  ghost predicate Valid()\n    reads this, Repr\n  {\n    MostlyValid() &&\n    forall j :: 2 <= j <= n ==> a[j/2] <= a[j]\n  }\n  ghost predicate MostlyValid()\n    reads this, Repr\n  {\n    this in Repr && a in Repr &&\n    a.Length == N+1 &&\n    0 <= n <= N\n  }\n  constructor Init(capacity: nat)\n    ensures Valid() && fresh(Repr)\n    ensures N == capacity\n  {\n    N := capacity;\n    a := new int[capacity + 1];\n    n := 0;\n    Repr := {this, a};\n  }\n  method Insert(x: int)\n    requires Valid() && n < N\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures n == old(n) + 1 && N == old(N)\n  {\n    n := n + 1;\n    a[n] := x;\n    SiftUp(n);\n  }\n  method SiftUp(k: int)\n    requires 1 <= k <= n\n    requires MostlyValid()\n    requires forall j :: 2 <= j <= n && j != k ==> a[j/2] <= a[j]\n    requires forall j :: 1 <= j <= n ==> j/2 != k  \n    modifies a\n    ensures Valid()\n  {\n    var i := k;\n    assert MostlyValid();\n    while 1 < i\n      invariant i <= k && MostlyValid()\n      invariant forall j :: 2 <= j <= n && j != i ==> a[j/2] <= a[j]\n      invariant forall j :: 1 <= j/2/2 && j/2 == i && j <= n ==> a[j/2/2] <= a[j]\n    {\n      if a[i/2] <= a[i] {\n        return;\n      }\n      a[i/2], a[i] := a[i], a[i/2];\n      i := i / 2;\n    }\n  }\n  method RemoveMin() returns (x: int)\n    requires Valid() && 1 <= n\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures n == old(n) - 1\n  {\n    x := a[1];\n    a[1] := a[n];\n    n := n - 1;\n    SiftDown(1);\n  }\n  method SiftDown(k: int)\n    requires 1 <= k\n    requires MostlyValid()\n    requires forall j :: 2 <= j <= n && j/2 != k ==> a[j/2] <= a[j]\n    requires forall j :: 2 <= j <= n && 1 <= j/2/2 != k ==> a[j/2/2] <= a[j]\n    modifies a\n    ensures Valid()\n  {\n    var i := k;\n    while 2*i <= n  \n      invariant 1 <= i && MostlyValid()\n      invariant forall j :: 2 <= j <= n && j/2 != i ==> a[j/2] <= a[j]\n      invariant forall j :: 2 <= j <= n && 1 <= j/2/2 != i ==> a[j/2/2] <= a[j]\n    {\n      var smallestChild;\n      if 2*i + 1 <= n && a[2*i + 1] < a[2*i] {\n        smallestChild := 2*i + 1;\n      } else {\n        smallestChild := 2*i;\n      }\n      if a[i] <= a[smallestChild] {\n        return;\n      }\n      a[smallestChild], a[i] := a[i], a[smallestChild];\n      i := smallestChild;\n      assert 1 <= i/2/2 ==> a[i/2/2] <= a[i];\n    }\n  }\n}\nclass PriorityQueue_Alternative {\n  var N: nat  \n  var n: nat  \n  ghost var Repr: set<object>  \n  var a: array<int>  \n  ghost predicate Valid()\n    reads this, Repr\n  {\n    MostlyValid() &&\n    forall j :: 2 <= j <= n ==> a[j/2] <= a[j]\n  }\n  ghost predicate MostlyValid()\n    reads this, Repr\n  {\n    this in Repr && a in Repr &&\n    a.Length == N+1 &&\n    0 <= n && n <= N\n  }\n  constructor Init(capacity: nat)\n    ensures Valid() && fresh(Repr)\n    ensures N == capacity\n  {\n    N := capacity;\n    a := new int[capacity + 1];\n    n := 0;\n    Repr := {this, a};\n  }\n  method Insert(x: int)\n    requires Valid() && n < N\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures n == old(n) + 1 && N == old(N)\n  {\n    n := n + 1;\n    a[n] := x;\n    SiftUp();\n  }\n  method SiftUp()\n    requires MostlyValid()\n    requires forall j :: 2 <= j <= n && j != n ==> a[j/2] <= a[j]\n    modifies a\n    ensures Valid()\n  {\n    var i := n;\n    assert MostlyValid();\n    while 1 < i\n      invariant i <= n && MostlyValid()\n      invariant forall j :: 2 <= j <= n && j != i ==> a[j/2] <= a[j]\n      invariant forall j :: 1 <= j/2/2 && j/2 == i && j <= n ==> a[j/2/2] <= a[j]\n    {\n      if a[i/2] <= a[i] {\n        return;\n      }\n      a[i/2], a[i] := a[i], a[i/2];\n      i := i / 2;\n    }\n  }\n  method RemoveMin() returns (x: int)\n    requires Valid() && 1 <= n\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures n == old(n) - 1\n  {\n    x := a[1];\n    a[1] := a[n];\n    n := n - 1;\n    SiftDown();\n  }\n  method SiftDown()\n    requires MostlyValid()\n    requires forall j :: 4 <= j <= n ==> a[j/2] <= a[j]\n    modifies a\n    ensures Valid()\n  {\n    var i := 1;\n    while 2*i <= n  \n      invariant 1 <= i && MostlyValid()\n      invariant forall j :: 2 <= j <= n && j/2 != i ==> a[j/2] <= a[j]\n      invariant forall j :: 1 <= j/2/2 && j/2 == i && j <= n ==> a[j/2/2] <= a[j]\n    {\n      var smallestChild;\n      if 2*i + 1 <= n && a[2*i + 1] < a[2*i] {\n        smallestChild := 2*i + 1;\n      } else {\n        smallestChild := 2*i;\n      }\n      if a[i] <= a[smallestChild] {\n        return;\n      }\n      a[smallestChild], a[i] := a[i], a[smallestChild];\n      i := smallestChild;\n      assert 1 <= i/2/2 ==> a[i/2/2] <= a[i];\n    }\n  }\n}"
},
{
    "dafny": "predicate sorted(a:array<int>, begin:int, end:int)\n    reads a;\n    requires a != null\n    requires 0<= begin <= end < a.Length\n{\n  forall i, j :: (i >= 0 && begin <= i <= j <= end) ==> a[i] <= a[j]\n}\nmethod insertSort(a : array<int>)\n  modifies a;\n  requires a != null\n  requires a.Length >= 1\n  ensures sorted(a, 0, a.Length - 1)\n{\n  var i := 1;\n  while (i < a.Length)\n    invariant 1 <= i <= a.Length\n    invariant sorted(a, 0, i - 1)\n    decreases a.Length - i\n  {\n    var j := i;\n    var value := a[i];\n    a[i] := a[i-1];\n    while (j > 0 && a[j-1] > value)\n       invariant forall k :: j <= k <= i - 1 ==> value < a[k]\n       invariant sorted(a, 0, i)\n       decreases j\n    {\n      a[j] := a[j-1];\n      j := j - 1;\n    }\n    a[j] := value;\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "class DataTypes\n{\n    var iSet1: set<int>;\n    var iSet2 : set<int>;\n    method SetDemo()\n        modifies this;\n    {\n        iSet1 := {0, 2, 1, 4, 1};\n        iSet2 := {0, 3, 4};\n        print \"iSet1: \", iSet1, \" iSet2: \", iSet2, \"\\n\";\n        print \"iSet1 * iSet2 : \", iSet1 * iSet2, \"\\n\" ;\n        print \"iSet1 + iSet2: \", iSet1 + iSet2, \"\\n\";\n        print \"iSet1 - iSet2: \", iSet1 - iSet2, \"\\n\";\n        print \"\\nSet Comprehension\\n\\n\";\n        var iSet3 := set x | x in {-2,-1,0,1,2} :: x * x;\n        print \"iSet3 := set x | x in {-2,-1,0,1,2} :: x * x is \", iSet3, \"\\n\";\n        print \"{} < iSet1: \", {} < iSet1, \"\\n\";\n        print \"iSet1 < iSet1: \", iSet1 < iSet1, \"\\n\";\n        print \"iSet3 < iSet1: \", iSet3 < iSet1, \"\\n\";\n        print \"iSet3 <= iSet1: \", iSet3 <= iSet1, \"\\n\";\n        var bigSet := {iSet1, iSet2};\n        print \"iSet1 in bigSet: \", iSet1 in bigSet, \"\\n\";\n        print \"{2} in bigSet: \", {2} in bigSet, \"\\n\";\n        print \"\\n\", bigSet, \" has \", |bigSet|, \" elements\\n\";\n        var wordSet := {\"cat\", \"lion\"};\n        print \"{\\\"dog\\\", \\\"monkey\\\", \\\"cat\\\", \\\"mouse\\\"} - wordSet: \", \n        {\"dog\", \"monkey\", \"cat\", \"mouse\"} - wordSet, \"\\n\";\n    }\n}\nmethod Main()\n{\n   print \"Sets\\n\\n\";\n   var c := new DataTypes;\n   c.SetDemo();\n}"
},
{
    "dafny": "method findMax(s: seq<int>) returns(lo: int)\nrequires |s| > 0\nensures isMax(s, lo)\n{\n    assert(|s| > 0);\n    assert(0 < 1 <= |s| && isMax(s[..1], 0));\n    lo := 0;\n    assert(0 <= lo < |s| && isMax(s[..1], lo)); \n    var hi : int := |s| - 1 ;\n    assert(0 <= hi < |s| && isMax(s[hi..], 0));\n    assert(hi - lo >= 0);\n    while (lo < hi) \n        decreases hi - lo\n        invariant 0 <= lo <= hi < |s|\n        invariant (isMax2(s, 0, lo, lo) && isMax2(s, hi, |s|-1 , lo)) || (isMax2(s, 0, lo, hi) && isMax2(s, hi, |s|-1 , hi))\n    {\n        if(s[lo] <= s[hi])\n        {\n            lo := lo + 1;\n        }\n        else\n        {\n            hi := hi - 1;   \n        }\n    }   \n}\npredicate isMax2(s: seq<int>, lo: int, hi: int, max: int){\n    0 <= max < |s| && 0 <= lo <= hi < |s| && forall x : int :: lo <= x <= hi ==> s[max] >= s[x]\n}\npredicate isMax(s : seq<int>, lo: int){\n    0 <= lo < |s| && forall x: int :: 0 <= x < |s| ==> s[lo] >= s[x]\n}"
},
{
    "dafny": "method isPrefix(pre: string, str: string) returns (res: bool)\n  requires |pre| <= |str|\n  ensures str == pre + str[|pre|..] ==> res == true\n  ensures str != pre + str[|pre|..] ==> res == false\n{\n  if pre == str[0..|pre|]\n  {\n    return true;\n  }\n  return false;\n}\nmethod isSubstring(sub: string, str: string) returns (res: bool)\n{\n  if |sub| > |str| \n  {\n    return false;\n  }\n  var prefResult := isPrefix(sub, str);\n  if prefResult == true\n  {\n    return true;\n  }\n  else if(|str| >= 1) \n  {\n    var subResult := isSubstring(sub, str[1..]);\n    if subResult == true\n    {\n      return true;\n    }\n  }\n  return false;\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n{\n  if |str1| < k || |str2| < k \n  {\n    return false;\n  }\n  var result := isSubstring(str1[0..k], str2);\n  if result == true\n  {\n    return true;\n  }\n  else if |str1| >= 1 \n  {\n    var result2 := haveCommonKSubstring(k, str1[1..], str2);\n    if result2 == true\n    {\n      return true;\n    }\n  }\n  return false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len: nat)\n{\n    len := 0;\n    var i := 1;\n    while(i <= |str1| && i <= |str2|)\n    {\n      var result := haveCommonKSubstring(i, str1, str2);\n      if result == true\n      {\n        len := i;\n      }\n      i := i + 1;\n    }\n}\nmethod testFirst3()\n{\n  var str1 := \"pre\";\n  var str2 := \"prefix\";\n  var result := isPrefix(str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"ppre\";\n  result := isPrefix(str1, str2);\n  print \"Expected false got:\";\n  print result;\n  str1 := \"fix\";\n  result := isPrefix(str1, str2);\n  print \"Expected false got:\";\n  print result;\n  str1 := \"\";\n  result := isSubstring(str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"pre\";\n  result := isSubstring(str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"ix\";\n  result := isSubstring(str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"f\";\n  result := isSubstring(str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"efi\";\n  result := isSubstring(str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"ppre\";\n  result := isSubstring(str1, str2);\n  print \"Expected false got:\";\n  print result;\n  str1 := \"ppre\";\n  result := haveCommonKSubstring(0, str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"\";\n  result := haveCommonKSubstring(0, str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"ppre\";\n  result := haveCommonKSubstring(3, str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"ppre\";\n  result := haveCommonKSubstring(4, str1, str2);\n  print \"Expected false got:\";\n  print result;\n  str1 := \"pppppp\";\n  result := haveCommonKSubstring(1, str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"xiferp\";\n  result := haveCommonKSubstring(1, str1, str2);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"xiferp\";\n  result := haveCommonKSubstring(2, str1, str2);\n  print \"Expected false got:\";\n  print result;\n  str1 := \"ppre\";\n  result := haveCommonKSubstring(0, str2, str1);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"\";\n  result := haveCommonKSubstring(0, str2, str1);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"ppre\";\n  result := haveCommonKSubstring(3, str2, str1);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"ppre\";\n  result := haveCommonKSubstring(4, str2, str1);\n  print \"Expected false got:\";\n  print result;\n  str1 := \"pppppp\";\n  result := haveCommonKSubstring(1, str2, str1);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"xiferp\";\n  result := haveCommonKSubstring(1, str2, str1);\n  print \"Expected true got:\";\n  print result;\n  str1 := \"xiferp\";\n  result := haveCommonKSubstring(2, str2, str1);\n  print \"Expected false got:\";\n  print result;\n}\nmethod testLastMethod()\n{\n  var str1 := \"ppre\";\n  var str2 := \"prefix\";\n  var result := maxCommonSubstringLength(str1, str2);\n  print \"Expected 3 got:\";\n  print result;\n  str1 := \"ppre\";\n  str2 := \"nothing\";\n  result := maxCommonSubstringLength(str1, str2);\n  print \"Expected 0 got:\";\n  print result;\n  str1 := \"fix\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str1, str2);\n  print \"Expected 3 got:\";\n  print result;\n  str1 := \"sebfikfix\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str1, str2);\n  print \"Expected 3 got:\";\n  print result;\n  str1 := \"jvcjsereficjawbd\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str1, str2);\n  print \"Expected 4 got:\";\n  print result;\n  str1 := \"prefix\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str1, str2);\n  print \"Expected 6 got:\";\n  print result;\n  str1 := \"\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str1, str2);\n  print \"Expected 0 got:\";\n  print result;\n  str1 := \"\";\n  str2 := \"\";\n  result := maxCommonSubstringLength(str1, str2);\n  print \"Expected 4 got:\";\n  print result;\n  str1 := \"ppre\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str2, str1);\n  print \"Expected 3 got:\";\n  print result;\n  str1 := \"ppre\";\n  str2 := \"nothing\";\n  result := maxCommonSubstringLength(str2, str1);\n  print \"Expected 0 got:\";\n  print result;\n  str1 := \"fix\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str2, str1);\n  print \"Expected 3 got:\";\n  print result;\n  str1 := \"sebfikfix\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str2, str1);\n  print \"Expected 3 got:\";\n  print result;\n  str1 := \"jvcjsereficjawbd\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str2, str1);\n  print \"Expected 4 got:\";\n  print result;\n  str1 := \"prefix\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str2, str1);\n  print \"Expected 6 got:\";\n  print result;\n  str1 := \"\";\n  str2 := \"prefix\";\n  result := maxCommonSubstringLength(str2, str1);\n  print \"Expected 0 got:\";\n  print result;\n  str1 := \"\";\n  str2 := \"\";\n  result := maxCommonSubstringLength(str2, str1);\n  print \"Expected 4 got:\";\n  print result;\n}"
},
{
    "dafny": "method copy_neg (a: array<int>, b: array<int>)\n  requires a != null && b != null && a != b\n  requires a.Length == b.Length\n  modifies b\n{\n  var i := 0;\n  var r := 0;\n  ghost var sa := set j | 0 <= j < a.Length :: a[j];\n  while i < a.Length\n    invariant 0 <= r <= i <= a.Length\n    invariant sa == set j | 0 <= j < a.Length :: a[j]\n  {\n    if a[i] < 0 {\n      assert sa == set j | 0 <= j < a.Length :: a[j]; \n      b[r] := a[i];\n      assert sa == set j | 0 <= j < a.Length :: a[j]; \n      r := r + 1;\n    }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "abstract module M0 {\n  class {:autocontracts} Container<T(==)> {\n    ghost var Contents: set<T>\n    ghost predicate Valid() {\n      Valid'()\n    }\n    ghost predicate {:autocontracts false} Valid'()\n      reads this, Repr\n    constructor ()\n      ensures Contents == {}\n    method Add(t: T)\n      ensures Contents == old(Contents) + {t}\n    method Remove(t: T)\n      ensures Contents == old(Contents) - {t}\n    method Contains(t: T) returns (b: bool)\n      ensures Contents == old(Contents)\n      ensures b <==> t in Contents\n  }\n}\nabstract module M1 refines M0 {\n  class Container<T(==)> ... {\n    constructor... {\n      Contents := {};\n      Repr := {this};\n      new;\n      label CheckPost:\n      assume Valid'();  \n    }\n    method Add... {\n      Contents := Contents + {t};\n      label CheckPost:\n      assume Valid'();  \n    }\n    method Remove... {\n      Contents := Contents - {t};\n      label CheckPost:\n      assume Valid'();  \n    }\n    method Contains... {\n      b :| assume b <==> t in Contents;\n    }\n  }\n}\nabstract module M2 refines M1 {\n  class Container<T(==)> ... {\n    var elems: seq<T>\n    ghost predicate Valid'...\n    {\n      Contents == (set x | x in elems) &&\n      (forall i,j :: 0 <= i < j < |elems| ==> elems[i] != elems[j]) &&\n      Valid''()\n    }\n    ghost predicate {:autocontracts false} Valid''()\n      reads this, Repr\n    method FindIndex(t: T) returns (j: nat)\n      ensures j <= |elems|\n      ensures if j < |elems| then elems[j] == t else t !in elems\n    {\n      j := 0;\n      while (j < |elems|)\n        invariant j <= |elems|\n        invariant forall i :: 0 <= i < j ==> elems[i] != t\n      {\n        if (elems[j] == t) {\n          return;\n        }\n        j := j + 1;\n      }\n    }\n    constructor... {\n      elems := [];\n      new;\n      label CheckPost:\n      assume Valid''();  \n      assert ...;\n    }\n    method Add... {\n      var j := FindIndex(t);\n      if j == |elems| {\n        elems := elems + [t];\n      }\n      ...;\n      label CheckPost:\n      assume Valid''();  \n      assert ...;\n    }\n    method Remove... {\n      var j := FindIndex(t);\n      if j < |elems| {\n        elems := elems[..j] + elems[j+1..];\n      }\n      ...;\n      label CheckPost:\n      assume Valid''();  \n      assert ...;\n    }\n    method Contains... {\n      var j := FindIndex(t);\n      b := j < |elems|;\n    }\n  }\n}\nmodule M3 refines M2 {\n  datatype Cache<T> = None | Some(index: nat, value: T)\n  class Container<T(==)> ... {\n    var cache: Cache<T>\n    ghost predicate Valid''... {\n      cache.Some? ==> cache.index < |elems| && elems[cache.index] == cache.value\n    }\n    constructor... {\n      cache := None;\n      new;\n      ...;\n      assert ...;\n    }\n    method FindIndex... {\n      if cache.Some? && cache.value == t {\n        return cache.index;\n      }\n    }\n    method Add... {\n      ...;\n      assert ...;\n    }\n    method Remove... {\n      ...;\n      if ... {\n        if cache.Some? {\n          if cache.index == j {\n            cache := None;\n          } else if j < cache.index {\n            cache := cache.(index := cache.index - 1);\n          }\n        }\n      }\n      ...;\n      assert ...;\n    }\n  }\n}\nabstract module Client {\n  method Test() {\n    var c := new M.Container();\n    c.Add(56);\n    c.Add(12);\n    var b := c.Contains(17);\n    assert !b;\n    print b, \" \";  \n    b := c.Contains(12);\n    assert b;\n    print b, \" \";  \n    c.Remove(12);\n    b := c.Contains(12);\n    assert !b;\n    print b, \" \";  \n    assert c.Contents == {56};\n    b := c.Contains(56);\n    assert b;\n    print b, \"\\n\";  \n  }\n}\nmodule CachedClient refines Client {\n  method Main() {\n    Test();\n  }\n}"
},
{
    "dafny": "method Partition( m: multiset<int> )\n        returns( pre: multiset<int>, p: int, post: multiset<int> )\n    requires |m| > 0;\n    ensures p in m;\n    ensures m == pre+multiset{p}+post;\n    ensures forall z | z in pre :: z <= p;\n    ensures forall z | z in post :: z >= p;\n{\n    p :| p in m;\n    var m' := m;\n    m' := m' - multiset{p};\n    pre := multiset{};\n    post := multiset{};\n    while m' != multiset{}\n        decreases m';\n        invariant m == m' + pre + multiset{p} + post;\n        invariant forall k | k in pre :: k <= p;\n        invariant forall k | k in post :: k >= p;\n    {\n        var temp :| temp in m';\n        m' := m' - multiset{temp};\n        if temp <= p\n        {\n            pre := pre + multiset{temp};\n        }\n        else\n        {\n            post := post + multiset{temp};\n        }\n    }\n    return pre,p,post;\n}\nmethod QuickSelect( m: multiset<int>, k: int )\n        returns( pre: multiset<int>, kth: int, post: multiset<int> )\n    decreases m;\n    requires 0 <= k < |m|;\n    ensures kth in m;\n    ensures m == pre+multiset{kth}+post;\n    ensures |pre| == k;\n    ensures forall z | z in pre :: z <= kth;\n    ensures forall z | z in post :: z >= kth;\n{\n    pre,kth,post := Partition(m);\n    assert m == pre + multiset{kth} + post;\n    if |pre| != k\n    {\n        if k > |pre|\n        {\n            var pre',p,post' := QuickSelect(post,k-|pre| - 1);\n            assert pre' + multiset{p} + post' == post;\n            pre := pre + multiset{kth} + pre';\n            post := post - pre' - multiset{p};\n            kth := p;\n        }\n        else if k < |pre|\n        {\n            var pre',p,post' := QuickSelect(pre,k);\n            pre := pre - multiset{p} - post';\n            post := post + multiset{kth} + post';\n            kth := p;\n        }\n    }\n    else{\n        return pre,kth,post;\n    } \n}"
},
{
    "dafny": "method concat(a:array<int>, b:array<int>) returns (c:array<int>)\n  ensures c.Length==b.Length+a.Length\n  ensures forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n  ensures forall k :: 0 <= k < b.Length ==> c[k+a.Length] == b[k]\n  ensures a[..]+b[..]==c[..]\n{\n  c := new int[a.Length+b.Length];\n  var i:= 0;\n  while (i < c.Length)\n    invariant 0 <= i <= c.Length\n    invariant if i<a.Length then c[..i]==a[..i] else c[..i]==a[..]+b[..(i-a.Length)]\n  {\n    c[i] := if i<a.Length then a[i] else b[i-a.Length];\n    i:=i+1;\n  }\n}\nmethod print_array(a:array<int>)\n{\n  for i:= 0 to a.Length{\n    print(a[i]);\n  }\n  print(\";\");\n}\nmethod TestMethod(){\n  var a1 := new int[3][1,2,3];\n  var b1 := new int[3][4,5,6];\n  var test1 := concat(a1, b1);\n  print_array(test1);\n  var a2 := new int[3][-1,-2,-3];\n  var b2 := new int[3][-4,-5,-6];\n  var test2 := concat(a2, b2);\n  print_array(test2);\n  var a3 := new int[0][];\n  var b3 := new int[3][7,8,9];\n  var test3 := concat(a3, b3);\n  print_array(test3);\n  var a4 := new int[2][10,11];\n  var b4 := new int[0][];\n  var test4 := concat(a4, b4);\n  print_array(test4);\n  var a5 := new int[0][];\n  var b5 := new int[0][];\n  var test5 := concat(a5, b5);\n  print_array(test5);\n}\nmethod Main(){\n  TestMethod();\n}"
},
{
    "dafny": "class Ref<A> {\n  var val : A\n  constructor (a : A)\n    ensures val == a\n  {\n    val := a;\n  }\n}\nmethod Main() {\n  print \"1 = \", (x => x)(1), \"\\n\";\n  print \"3 = \", (x => y => x + y)(1)(2), \"\\n\";\n  print \"3 = \", ((x,y) => y + x)(1,2), \"\\n\";\n  print \"0 = \", (() => 0)(), \"\\n\";\n  var y := 1;\n  var f := x => x + y;\n  print \"3 = \", f(2), \"\\n\";\n  print \"4 = \", f(3), \"\\n\";\n  y := 2;\n  print \"3 = \", f(2), \"\\n\";\n  print \"4 = \", f(3), \"\\n\";\n  var z := new Ref(1);\n  f := x reads z => x + z.val;\n  print \"3 = \", f(2), \"\\n\";\n  print \"4 = \", f(3), \"\\n\";\n  z.val := 2;\n  print \"4 = \", f(2), \"\\n\";\n  print \"5 = \", f(3), \"\\n\";\n  f := x => x;\n  y := 10;\n  while y > 0\n    invariant forall x :: f.requires(x)\n    invariant forall x :: f.reads(x) == {}\n  {\n    f := x => f(x+y);\n    y := y - 1;\n  }\n  print \"55 = \", f(0), \"\\n\";\n  print \"0 = \", (x => var y:=x;y)(0), \"\\n\";\n  print \"1 = \", (y => (x => var y:=x;y))(0)(1), \"\\n\";\n}"
},
{
    "dafny": "function add (x: nat, y: nat): nat\n  decreases y\n{\n  if (y == 0) then x\n  else add (x, y-1) + 1\n}\nlemma add_zero_lemma (x: nat)\n  ensures add (x, 0) == x\n{\n  calc\n  {\n    add (x, 0);\n    x;\n  }\n}\nlemma zero_add_lemma (x: nat)\n  ensures add (0, x) == x\n{\n  if (x == 0) { }\n  else\n  {\n    calc\n    {\n      add (0, x);\n      add (0, x-1) + 1;\n      { zero_add_lemma (x-1); }\n      x -1 + 1;\n      x;\n    }\n  }\n}\nlemma add_plus_one (x: nat, y: nat)\n  ensures add(x, y) + 1 == add(x, y+1);\n{\n  calc\n  {\n    add (x, y) + 1;\n    add (x, y + 1);\n  }\n}\nlemma one_plus_add (x: nat, y: nat)\n  ensures add(x, y) + 1 == add (x+1, y)\n{\n  if (y == 0) { }\n  else\n  {\n    calc\n    {\n      add (x, y) + 1;\n      add (x, y-1) + 1 + 1;\n      { one_plus_add (x, y-1); }\n      add (x+1, y-1) + 1;\n      { add_plus_one (x+1, y-1); }\n      add (x+1, y);\n    }\n  }\n}\nlemma add_comm_lemma (x: nat, y: nat)\n  ensures add (x, y) == add (y, x);\n{\n  if (y == 0) { }\n  else\n  {\n    calc\n    {\n      add (x, y);\n      add (x, y-1) + 1;      \n      add (y-1, x) + 1;\n      add (y, x);\n    }\n  }\n}"
},
{
    "dafny": "datatype Option<T> = None | Some(get: T)\nfunction Unreachable<R>(): R\n    requires false\n{\n    var o: Option<R> := None;\n    assert o.Some?;\n    o.get\n}\ntrait NatOutcome {\n    predicate IsFailure()\n    function PropagateFailure(): NatOutcome requires IsFailure()\n    function Extract(): nat requires !IsFailure()\n}\nclass NatSuccess extends NatOutcome {\n    const value: nat\n    constructor(value: nat) {\n        this.value := value;\n    }\n    predicate IsFailure() {\n        false\n    }\n    function PropagateFailure(): NatOutcome requires IsFailure() {\n        Unreachable<NatOutcome>()\n    }\n    function Extract(): nat requires !IsFailure() {\n        value\n    }\n}\nclass NatFailure extends NatOutcome {\n    const error: string\n    constructor(error: string) {\n        this.error := error;\n    }\n    predicate IsFailure() {\n        true\n    }\n    function PropagateFailure(): NatOutcome requires IsFailure() {\n        this\n    }\n    function Extract(): nat requires !IsFailure() {\n        Unreachable<nat>()\n    }\n}\nmethod MakeNatSuccess(n: nat) returns (res: NatOutcome) {\n    res := new NatSuccess(n);\n}\nmethod MakeNatFailure(msg: string) returns (res: NatOutcome) {\n    res := new NatFailure(msg);\n}"
},
{
    "dafny": "predicate Sorted(a: array?<int>,start:int,end:int)\n   reads a;\n   requires a != null\n   requires 0 <= start < end <= a.Length\n{\n  forall j, k :: start <= j < k < end ==> a[j] <= a[k]\n}\nmethod InsertionSortShuffle(a:array?<int>)\n  requires a != null;\n  modifies a;\n  requires a.Length > 0;\n  ensures a.Length > 0;\n  ensures Sorted(a,0,a.Length);\n  ensures multiset(a[..]) == multiset(old(a[..]));  \n{\n  if(a.Length > 1){   \n     var i := 1;\n     while(i < a.Length)\n      invariant 1 <= i <= a.Length;\n      invariant forall x,y:: 0 <= x < y < i  ==> a[x] <= a[y]; \n      invariant multiset(a[..]) == multiset(old(a[..])); \n    {\n      var key := a[i];\n      var j := i - 1;\n      a[i] := a[j];\n      while(j >= 0 && a[j] > key)\n        invariant -1 <= j < i;\n        invariant forall x,y:: 0 <= x < y < i+1  ==> a[x] <= a[y]; \n        invariant forall x :: j < x < i ==> key < a[x];\n        invariant multiset(a[..]) - multiset([a[j+1]]) + multiset([key]) ==  multiset(old(a[..]));\n      {\n        a[j+1] := a[j];\n        j := j -1;\n      }\n      a[j+1] := key;\n      i := i + 1;\n    }\n  }\n}\nmethod Main()\n{\n   var a := new int[][6,2,0,6,3,5,0,4,1,6,0]; \n   var msa := multiset(a[..]);\n   InsertionSortShuffle(a);\n   assert Sorted(a, 0, a.Length);\n   var msa' := multiset(a[..]);\n   assert msa==msa';\n   var b := new int[][8,7];  \n   InsertionSortShuffle(b);\n   print a[..], b[..];\n}"
},
{
    "dafny": "datatype Tag = Unique(t: nat, c: nat) | SharedRO(t: nat, c:nat)   \n              | Disabled | Owner\nclass State {\n   var counter: nat; \n   var mem: array<int>;\n   var tagmem: array<Tag>;\n   var predecessor: array<int>;\n   var rawfrom: array<int>;  \n   constructor(mem: array<int>)\n   ensures fresh(tagmem) && fresh(rawfrom) && fresh(predecessor);\n   ensures this.mem == mem && counter == 0;\n   ensures forall i:: 0 <= i && i < tagmem.Length ==> tagmem[i] == Owner;\n   ensures forall i:: 0 <= i && i < rawfrom.Length ==> rawfrom[i] == -1;\n   ensures forall i:: 0 <= i && i < predecessor.Length ==> predecessor[i] == -1;\n   ensures rawfrom != predecessor && mem!= predecessor;\n   ensures valid();\n   {\n     this.mem := mem;\n     tagmem := new Tag[mem.Length](_ => Owner);\n     rawfrom := new int[mem.Length](_ => -1);\n     predecessor := new int[mem.Length](_ =>-1);\n     counter := 0;\n   }\n   predicate valid()\n   reads this, mem, tagmem, rawfrom, predecessor;\n   {\n    rawfrom != predecessor && mem != predecessor && rawfrom != mem &&\n    mem.Length == tagmem.Length && mem.Length == rawfrom.Length &&\n    mem.Length == predecessor.Length && predecessor != rawfrom &&\n    (forall i:: 0 <= i && i < tagmem.Length && tagmem[i].Unique? ==> \n          predecessor[i] < tagmem[i].t && tagmem[i].t <= counter)  &&\n    (forall i:: 0 <= i && i < tagmem.Length && tagmem[i].SharedRO? ==> \n          predecessor[i] < tagmem[i].t && tagmem[i].t <= counter)   \n   } \n   predicate valid_addr(addr: int)\n   requires valid();\n   reads this, mem,tagmem, rawfrom, predecessor;\n   {\n      0 <= addr && addr < mem.Length\n   }\npredicate invalidTag(addr: nat, tag: Tag, predece: int)\n requires valid() && valid_addr(addr);\n requires tag.Unique? ==>  predece < tag.t;\n reads this, tagmem, rawfrom, mem, predecessor;\n {\n    match (tagmem[addr], tag, predece)\n    case (Unique(n1, c1), Unique(n2, c2),  n3) => \n     if (rawfrom[addr] != -1) then n2 != n1\n      else n1 < n2 || (n1 > n2 && n3 <= n1)\n    case (SharedRO(n1, c1), Unique(n2, c2), _) => \n     if (rawfrom[addr] != -1) then true \n     else false  \n    case (Unique(n1, c1), SharedRO(n2, c2), _) => n2 < n1\n    case (SharedRO(n1, c1), SharedRO(n2, c2), n3) =>   \n          n3 < n1 \n    case (Owner, _, _) => false\n    case (_, _, _) => true\n}  \npredicate validTag(addr: nat, tag: Tag, predece: int)\nrequires valid() && valid_addr(addr);\nrequires tag.Unique? ==>  predece < tag.t;\nreads this, tagmem, rawfrom, mem, predecessor;\n{\n   (tag.Unique?  ==> tag.t <= counter && !invalidTag(addr, tag, predece)) && \n   (tag.SharedRO? ==> tag.t <= counter && !invalidTag(addr, tag, predece))\n}\n   method generateID() returns (ret: nat) \n   requires valid();\n   modifies this;\n   ensures counter == old(counter) + 1 && ret == counter;\n   ensures mem == old(mem) && tagmem == old(tagmem) && rawfrom == old(rawfrom) && predecessor == old(predecessor);\n   ensures forall i:: 0 <= i && i < tagmem.Length && tagmem[i].Unique? ==> tagmem[i].t < ret; \n   ensures valid();\n   {\n     counter := counter + 1;\n     ret := counter;\n   }\n   predicate isWritable(p: Pointer)\n   requires valid();\n   requires p.valid(this);\n   requires p.tag.Unique?;\n   reads this, mem, rawfrom, tagmem, predecessor, p;\n   { \n      validTag(p.addr, p.tag, p.predecessor)\n   }\n  method write(p: Pointer, v: int)\n     requires valid();\n     requires p.valid(this) && p.tag.Unique? && isWritable(p);\n     requires p.tag.Unique? ==> p.tag.t <= counter;\n     modifies this, mem, tagmem, rawfrom, predecessor;\n     ensures mem == old(mem) && tagmem == old(tagmem)  && rawfrom == old(rawfrom) && predecessor == old(predecessor) && counter == old(counter);\n     ensures forall i :: 0 <= i && i < tagmem.Length && i != p.addr ==> tagmem[i] == old(tagmem[i]);\n     ensures forall i :: 0 <= i && i < mem.Length && i != p.addr ==> mem[i] == old(mem[i]);\n     ensures forall i :: 0 <= i && i < rawfrom.Length && i != p.addr ==> rawfrom[i] == old(rawfrom[i]);\n     ensures forall i :: 0 <= i && i < predecessor.Length && i != p.addr ==> predecessor[i] == old(predecessor[i]);\n     ensures p.tag.Unique? ==> tagmem[p.addr] == p.tag && predecessor[p.addr] == p.predecessor;\n     ensures mem[p.addr] == v;\n     ensures valid();\n   {\n     match p.tag\n     case Unique(t, c) =>\n       mem[p.addr] := v;\n       tagmem[p.addr] := p.tag;\n       predecessor[p.addr] := p.predecessor;\n   }\n} \nclass Pointer{\n  var addr: nat;\n  var tag: Tag;\n  var predecessor: int; \n predicate valid(s: State)\n requires s.valid();\n reads s, s.tagmem, s.rawfrom, s.mem, s.predecessor, this;\n {\n    s.valid_addr(addr) && \n    (tag.Unique? ==> predecessor < tag.t && s.validTag(addr, tag, predecessor)) &&\n    (tag.SharedRO? ==> predecessor < tag.t && s.validTag(addr, tag, predecessor))\n }\n constructor(addr: nat, tag: Tag, predecessor: int, s: State) \n  requires s.valid() && s.valid_addr(addr);\n  requires tag.Unique? || tag.SharedRO?;\n  requires tag.Unique?  ==> predecessor < tag.t && tag.t == s.counter;\n  requires tag.SharedRO? ==> predecessor <  tag.t && tag.t == s.counter;\n  requires s.validTag(addr, tag, predecessor);\n   ensures this.addr == addr && this.tag == tag && this.predecessor == predecessor;\n  ensures valid(s);\n  {\n    this.addr := addr;\n    this.tag := tag;\n    this.predecessor := predecessor;\n  }\n}\nmethod createMutableRef(p: Pointer, s: State) returns(ret: Pointer)\nrequires s.valid() &&  s.valid_addr(p.addr)  && p.tag.Unique?;\nrequires p.tag.Unique? ==> p.tag.t <= s.counter;\nmodifies s, s.tagmem, s.rawfrom, s.predecessor;\nensures s.tagmem == old(s.tagmem)  && s.rawfrom == old(s.rawfrom) && s.predecessor == old(s.predecessor);\nensures s.counter == old(s.counter) + 1;\nensures forall i :: 0 <= i && i < s.tagmem.Length && i != p.addr ==> s.tagmem[i] == old(s.tagmem[i]);\nensures forall i :: 0 <= i && i < s.rawfrom.Length && i != p.addr ==> s.rawfrom[i] == old(s.rawfrom[i]);\nensures forall i :: 0 <= i && i < s.predecessor.Length && i != p.addr ==> s.predecessor[i] == old(s.predecessor[i]);\nensures s.tagmem[p.addr] == ret.tag && s.rawfrom[p.addr] == -1 && s.predecessor[p.addr] == p.tag.t;\nensures ret.addr == p.addr && ret.tag == Unique(s.counter, p.tag.c);\nensures fresh(ret);\nensures s.valid() && ret.valid(s);\n{\n  var newID := s.generateID();\n  match p.tag\n    case Unique(t, c?) =>\n       var newtag := Unique(newID, c?);\n       s.tagmem[p.addr] := newtag;\n       s.rawfrom[p.addr] := -1;\n       s.predecessor[p.addr] := t;\n       ret := new Pointer(p.addr, newtag, t, s);\n}"
},
{
    "dafny": "module syntax\n{\n    datatype propVar = mkPropVar(name: string) \n    datatype prop = \n        pTrue | \n        pFalse |\n        pVar (v: propVar) |\n        pNot (e: prop) |\n        pAnd (e1: prop, e2: prop) |\n        pOr (e1: prop, e2: prop) |\n        pImpl (e1: prop, e2: prop) |\n        pEquiv(e1: prop, e2: prop)\n    method foo()\n    {\n        var X := mkPropVar(\"X\");\n        var Y := mkPropVar(\"Y\");\n        var Xexp := pVar(X);\n        var XandY := pAnd(pVar(X),pVar(Y));\n    }\n    method showProp(e: prop) returns (f: string) \n        decreases e\n    {\n        match e {\n            case pTrue => return \"pTrue\";\n            case pFalse => return \"pFalse\";\n            case pVar(s) => return s.name;\n            case pNot(e') =>\n            {\n                var s:= showProp(e');\n                return \"Not(\" +  s + \")\"; \n            }\n            case pAnd(e1,e2) => \n            {\n                var s1:= showProp(e1);\n                var s2:= showProp(e2);\n                return \"And(\" + s1 + \", \" + s2 + \")\";\n            }\n            case pOr(e1,e2) => \n            {\n                var s1:= showProp(e1);\n                var s2:= showProp(e2);\n                return \"Or(\" + s1 + \", \" + s2 + \")\";\n            }\n            case pImpl(e1,e2) => \n            {\n                var s1:= showProp(e1);\n                var s2:= showProp(e2);\n                return \"Implies(\" + s1 + \", \" + s2 + \")\";\n            }\n            case pEquiv(e1, e2) => \n            {\n                var s1:= showProp(e1);\n                var s2:= showProp(e2);\n                return \"Iff(\" + s1 + \", \" + s2 + \")\";\n            }\n        }\n    }\n}"
},
{
    "dafny": "method run(n: int, m: int)\n{\n  assume n>=0;\n  assume m>=0;\n  assume m<n;\n  var x: int := 0; \n  var y: int := m;\n  while x<n\n    invariant (x <= n) && (x <= m ==> y == m) && (x > m ==> x == y)  \n  {\n    x := x+1;\n    if(x>m) {\n      y := y+1;\n    }\n  }\n  assert y==n;\n}"
},
{
    "dafny": "method Main() {\n  var a := new nat[][3, 6, 23, 9];\n  var s := SmallestMissing(a);\n  print s, \"\\n\";  \n  a := new nat[][3, 2, 0, 5, 4];\n  s := SmallestMissing(a);\n  print s, \"\\n\";  \n  a := new nat[][2, 4, 6, 0, 1, 3, 100];\n  s := SmallestMissing(a);\n  print s, \"\\n\";  \n  a := new nat[0];  \n  s := SmallestMissing(a);\n  print s, \"\\n\";  \n}\nghost predicate Has<T>(a: array<T>, x: T)\n  reads a\n{\n  exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod SmallestMissing(a: array<nat>) returns (s: nat)\n  ensures forall i :: 0 <= i < a.Length ==> a[i] != s  \n  ensures forall x :: 0 <= x < s ==> Has(a, x)  \n{\n  var N := a.Length;  \n  var e := new bool[N](_ => false);  \n  forall n | 0 <= n < N && a[n] < N {\n    e[a[n]] := true;\n  }\n  s := 0;\n  while s < N && e[s]\n    invariant 0 <= s <= N\n    invariant forall j :: 0 <= j < s ==> Has(a, j)\n  {\n    s := s + 1;\n  }\n  if s == N {\n    Lemma(a);\n  }\n}\nlemma Lemma(a: array<nat>)\n  requires forall x :: 0 <= x < a.Length ==> Has(a, x)\n  ensures forall i :: 0 <= i < a.Length ==> a[i] < a.Length\n{\n  var ms := multiset(a[..]);\n  var i, ns := 0, multiset{};\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall x :: x in ns ==> 0 <= x < i\n    invariant |ns| == i && ns <= ms\n  {\n    assert Has(a, i);\n    ns := ns + multiset{i};\n    i := i + 1;\n  }\n  assert |ms - ns| == 0;\n  forall i | 0 <= i < a.Length\n    ensures a[i] < a.Length\n  {\n    assert a[i] in ms;\n  }\n}\nmethod SmallestMissing_Loop(a: array<nat>) returns (s: nat)\n  ensures forall i :: 0 <= i < a.Length ==> a[i] != s  \n  ensures forall x :: 0 <= x < s ==> Has(a, x)  \n{\n  var N := a.Length;  \n  var e := new bool[N](_ => false);  \n  var n := 0;\n  while n < N\n    invariant 0 <= n <= N\n    invariant forall i :: 0 <= i < n && a[i] < N ==> e[a[i]]\n    invariant forall j :: 0 <= j < N && e[j] ==> Has(a, j)\n  {\n    if a[n] < N {\n      e[a[n]] := true;\n    }\n    n := n + 1;\n  }\n  s := 0;\n  while s < N && e[s]\n    invariant 0 <= s <= N\n    invariant forall j :: 0 <= j < s ==> Has(a, j)\n  {\n    s := s + 1;\n  }\n  if s == N {\n    Lemma(a);\n  }\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && pre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    !(|pre| <= |str|) || !(pre == str[..|pre|])\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\npredicate isSubstringPred(sub:string, str:string)\n{\n  exists x :: ((|sub| <= x <= |str|) && (isPrefixPred(sub,str[x..]))) \n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    forall x :: !((|sub| <= x <= |str|) && (isPrefixPred(sub,str[x..])))\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n  \texists i,j :: (((j==i+k) && (k<=|str1| && k<=|str2|) && (0<=i<=|str1|-k)) && isSubstringPred(str1[i..j],str2))\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\t forall i,j :: !(((j==i+k) && (k<=|str1| && k<=|str2|) && (0<=i<=|str1|-k)) && isSubstringPred(str1[i..j],str2))\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==> haveNotCommonKSubstringPred(k,str1,str2)\n{}"
},
{
    "dafny": "method best_time_to_buy_and_sell_stock(prices: array<int>) returns (max_profit: int)\n    requires 1 <= prices.Length <= 100000\n    requires forall i :: 0 <= i < prices.Length ==> 0 <= prices[i] <= 10000\n    ensures forall i, j :: 0 <= i < j < prices.Length ==> max_profit >= prices[j] - prices[i]\n{\n    var min_price := 10001;\n    max_profit := 0;\n    var i := 0;\n    while (i < prices.Length)\n        invariant 0 <= i <= prices.Length\n        invariant forall j :: 0 <= j < i ==> min_price <= prices[j]\n        invariant forall j, k :: 0 <= j < k < i ==> max_profit >= prices[k] - prices[j]\n    {\n        var price := prices[i];\n        if (price < min_price)\n        {\n            min_price := price;\n        }\n        if (price - min_price > max_profit) {\n            max_profit := price - min_price;\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "function I(f:int->bool):int->bool\n    ensures I(f) == f;\npredicate G<S>(s:S)\ntype D<X>\ntype E\nlemma L1<S>(b:int->S)\n    requires forall i :: b.reads(i) == {};\n    requires forall i :: b.requires(i);\n    requires I(j => G(b(j)))(0); \nlemma L2(b:int->D<E>)\n    requires forall i :: b.reads(i) == {};\n    requires forall i :: b.requires(i);\n    requires I(j => G(b(j)))(0);\n{\n    L1(b); \n}"
},
{
    "dafny": "predicate just1(a:array?<int>,key:int)\n   reads a\n   requires a != null\n   requires a.Length >= 1\n{\n  (exists k | 0 <= k < a.Length :: a[k] == key) && !(exists k,j | 0 <= k < j < a.Length :: a[k] == key && a[j] == key)\n}\nmethod Just1(a: array?<int>, key: int) returns (b: bool)\n    requires a != null\n    requires a.Length >= 1\n    ensures just1(a,key) == b\n{\n   var i := 0;\n   assert i == 0;\n   while i < a.Length\n    invariant 0 <= i <= a.Length;\n    invariant !(exists k | 0 <= k < i :: a[k] == key)\n    decreases (a.Length - i)\n   {\n     if(a[i] == key){\n       var n := i + 1;\n       assert n == i+1 && n > i;\n       assert a[i] == key ==> exists k | 0 <= k <= i :: a[k] == key;\n       if(n == a.Length){\n         assert ((a[a.Length - 1] == key) && (forall k :: 0 <= k < (a.Length - 1) ==> a[k] != key));\n         return true;\n       }\n       while n <  a.Length\n         invariant a[i] == key;\n         invariant i+1 <= n <= a.Length;\n         invariant forall k :: (i + 1) <= k < n ==> a[k] != key;\n         decreases (a.Length - n)\n       {\n         if(a[n] == key){\n           assert forall k :: 0 <= k < i ==> a[k] != key && a[i] == key && !(forall j ::0<= i < j < a.Length ==> a[i] == key ==> a[j] != key);\n           assert exists  k,y | 0 <= k < y < a.Length :: a[k] == key ==> a[y] == key;\n           return false;\n         }\n          n := n + 1;\n       }\n       assert forall k :: (i + 1) <= k < a.Length ==> a[k] != key;\n       assert a[i] == key && forall m :: 0 <= m < i ==> a[m] != key;\n       return true;\n     }\n     i := i + 1;\n   }\n   assert i == a.Length;\n   assert forall k :: 0<= k < a.Length ==> a[k] != key;\n   assert !(exists k | 0 <= k < a.Length :: a[k] == key);\n   return false;\n}\nmethod test(){\n  var a1: array<int> := new int[][1,3,3,2,0,2,3,3,4];\n  assert a1[0] == 1 && a1[1] == 3 && a1[2] == 3 && a1[3] == 2 && a1[4] == 0 && a1[5] == 2 && a1[6] == 3 && a1[7] == 3 && a1[8] == 4;\n  assert just1(a1,1);\n  assert just1(a1,0);\n  assert just1(a1,4);\n  assert !just1(a1,2);\n  assert !just1(a1,3);\n  assert !just1(a1,5);\n}"
},
{
    "dafny": "predicate isSorted(a: array<int>)\n    reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\npredicate notContains(a: array<int>, x: int)\n    reads a\n{\n    x !in a[..]\n}\nmethod binarySearch(a: array<int>, x: int) returns (index: int)\n    requires isSorted(a)\n    ensures -1 <= index < a.Length\n    ensures (index == -1 && notContains(a, x)) || (0 <= index < a.Length && x == a[index])\n{   \n    var low, high := 0, a.Length;\n    while low < high \n        decreases high - low\n        invariant 0 <= low <= high <= a.Length\n        invariant forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n        invariant x in a[low..high] || notContains(a, x)\n    {\n        var mid := low + (high - low) / 2;\n        if \n        {\n            case a[mid]  < x => low := mid + 1;\n            case a[mid]  > x => high := mid;\n            case a[mid] == x => return mid;\n        }\n    }\n    return -1;\n}"
},
{
    "dafny": "datatype Enum = One | Two | Three {\n  predicate Even() {\n    this.Two?\n  }\n  predicate Even'() {\n    match this\n      case One | Three => false\n      case Two => true\n  }\n  predicate Even''() {\n    match this\n      case Two => true\n      case One | Three => false\n  }\n  lemma EvenOk() ensures Even() == Even'() == Even''() {}\n}\nmodule Constants {\n  const ONE := 1\n  const TWO := 2\n  method M(i: int) {\n    match i\n      case | ONE | TWO => return; \n      case | _ => \n  }\n}\nmodule Lists {\n  datatype List<T> = Nil | Cons(car: T, cdr: List<T>) {\n    ghost function {:fuel 5} Length(): nat {\n      match this\n        case Nil => 0\n        case Cons(_, t) => 1 + t.Length()\n    }\n  }\n  predicate ContainsOne(l: List<int>)\n    requires l.Length() == 3\n  {\n    l.car == 1 || l.cdr.car == 1 || l.cdr.cdr.car == 1\n  }\n  predicate ContainsOne'(l: List<int>)\n    requires l.Length() == 3\n  {\n    match l\n      case Cons(1, Cons(_, Cons(_, Nil)))\n         | Cons(_, Cons(1, Cons(_, Nil)))\n         | Cons(_, Cons(_, Cons(1, Nil))) =>\n       true\n      case Cons(_, Cons(_, Cons(_, Nil))) =>\n        false\n  }\n  lemma ContainsOneOK(l: List<int>)\n    requires l.Length() == 3\n    ensures ContainsOne(l) == ContainsOne'(l)\n  {}\n}\nmodule TestVariables {\n  datatype DT = A | B | C\n  method M(dt: DT) returns (j: int) {\n    match dt {\n      case C => return 0;\n      case A | B => var x := (y => y)(1); assert x == 1;\n        return x;\n    }\n  }\n  method M2(dt: DT) returns (j: int) {\n    match dt {\n      case C => return 0;\n      case _ => var x := (y => y)(1); assert x == 1;\n        return x;\n    }\n  }\n  function F(dt: DT): int {\n    match dt {\n      case C => 0\n      case A | B => var x := (y => y)(1); assert x == 1; x\n    }\n  }\n  function F2(dt: DT): int {\n    match dt {\n      case C => 0\n      case _ => var x := (y => y)(1); assert x == 1; x\n    }\n  }\n}\nmethod Main() {\n  expect One.Even() == One.Even'() == One.Even''() == false;\n  expect Two.Even() == Two.Even'() == Two.Even''() == true;\n  expect Three.Even() == Three.Even'() == Three.Even''() == false;\n  var a0 := Cons(0, Cons(0, Cons(0, Nil)));\n  expect ContainsOne(a0) == ContainsOne'(a0) == false;\n  var a1 := Cons(1, Cons(0, Cons(0, Nil)));\n  expect ContainsOne(a1) == ContainsOne'(a1) == true;\n  var a2 := Cons(0, Cons(1, Cons(0, Nil)));\n  expect ContainsOne(a2) == ContainsOne'(a2) == true;\n  var a3 := Cons(0, Cons(0, Cons(1, Nil)));\n  expect ContainsOne(a3) == ContainsOne'(a3) == true;\n  var b0 := M(A);\n  var b1 := M(B);\n  var b2 := M2(A);\n  var b3 := M2(B);\n  var b4 := F(A);\n  var b5 := F(B);\n  var b6 := F2(A);\n  var b7 := F2(B);\n  expect 1 == b0 == b1 == b2 == b3 == b4 == b5 == b6 == b7;\n  print \"OK\\n\";\n}"
},
{
    "dafny": "module dafny_wrappers {\n    function SeqLength<T>(s:seq<T>) : int { |s| }\n    function SeqSlice<T>(s:seq<T>, start:int, end:int) : seq<T>\n        requires 0 <= start <= end <= |s|;\n        { s[start..end] }\n    function SeqTail<T>(s:seq<T>, tail:nat) : seq<T> requires tail <= |s| { s[tail..] }\n    function SeqDrop<T>(s:seq<T>, tail:int) : seq<T>\n        requires 0 <= tail <= |s|\n        { s[..tail] }\n    function SeqAppendElt<T>(s:seq<T>, elt:T) : seq<T> { s + [elt] }\n    function SeqBuild<T>(elt:T) : seq<T> { [elt] }\n    function SeqRange<T>(s:seq<T>, start:int, end:int) : seq<T>\n        requires 0 <= start <= end <= |s|;\n        { s[start..end] }\n    predicate InSet<T>(x:T, s:set<T>) { x in s }\n    predicate InMap<T,S>(x:T, s:map<T,S>) { x in s }\n}"
},
{
    "dafny": "function fib(n : nat ) : nat\n  decreases n\n{\n    if n < 2 then n else fib(n - 2) + fib(n - 1)\n}\nmethod computeFib (n : nat) returns (x : nat)\n  ensures x == fib(n)\n{\n    var i := 0;\n    x := 0;\n    var y := 1;\n    assert x == fib(i) && y == fib(i+1) && 0 <= i <= n; \n    while  i < n \n      decreases n - i \n      invariant x == fib(i) && y == fib(i+1) && 0 <= i <= n \n    {\n      ghost var V0 := n - i;\n      assert i < n && x == fib(i) && y == fib(i+1) && 0 <= i <= n \n             && n - i == V0; \n        x, y := y, x + y; \n        i := i + 1;\n      assert x == fib(i) && y == fib(i+1) && 0 <= i <= n \n             && 0 <= n-i < V0; \n    }\n    assert i >= n && x == fib(i) && y == fib(i+1) && 0 <= i <= n;\n}"
},
{
    "dafny": "method exercise2(a:int, n:int) returns (x:int)\nensures x >= n && (x == 2*a - n || x == 3*n - 2*a + 1)\n{\n    x := 3*n - 2*a + 1;\n    assert (x > n || x <= n) && x == 3*n - 2*a + 1;\n    if (x <= n) {\n        assert x <= n && x == 3*n - 2*a + 1;\n        assert 3*n-2*a+1 <= n && x == 3*n - 2*a + 1;\n        assert 2*a >= 2*n+1 && x == 3*n - 2*a + 1;\n        assert a > n && x == 3*n - 2*a + 1;\n        x := 2*a-n;\n        assert a > n && x == 2*a - n;\n        assert 2*a > 2*n && x+n == 2*a;\n        assert x+n > 2*n && x+n == 2*a;\n        assert x > n && x == 2*a - n;\n    }\n    assert x > n && (x == 2*a - n || x== 3*n - 2*a + 1);\n}"
},
{
    "dafny": "method inversemod(a: nat, n: nat) returns (t: nat, flag: bool)\nrequires a>0 && n>0;\nensures (!flag ==> t == 1) || (flag ==> (a*t)%n==1)\n{\n    var x := 0;\n    while x<=a && (1+n*x)%a!=0\n    invariant 0<=x<=a+1\n    decreases (a-x) {\n        x := x + 1;\n    }\n    if (x == a+1){\n        flag := false; t := 1;\n    }\n    else{\n        flag := true; t := (1+n*x)/a;\n    }\n}\nfunction power(b: nat, e: nat): nat \ndecreases e\n{\n    if e == 0 then 1 else b * power(b,e-1)\n}\nmethod expoBySquare(x:nat,n:nat) returns (p:nat)\nrequires n>=0\nensures p == power(x,n)\ndecreases *\n{\n    var N,q := n,x;\n    p := 1;\n    while N>=0\n    decreases *\n    {\n        p := if N%2 == 0 then p else p*q;\n        q := q * q;\n        N := if N%2 == 0 then N/2 else (N-1)/2;\n    }\n}\nfunction fact (n:nat) : nat\nrequires n >= 0\ndecreases n\n{\n    if n <= 0 then 1 else n*fact(n-1)\n}\nmethod Factorial(n: nat) returns (p: nat)\nrequires n>=0\nensures p == fact(n)\n{\n    var i : nat;\n    i, p := 1,1;\n    while i <= n\n    invariant i<= n+1\n    invariant p == fact(i-1)\n    decreases n + 1 - i\n    {\n        p := p * i;\n        i := i + 1;\n    }\n}\nclass primeRandomNumber{\n    var xk: nat;\n    constructor()\n    ensures xk == 4;\n    {\n        xk := 4;\n    }\n    method primePRNG() returns (r: nat)\n    modifies this\n    ensures xk == (12*old(xk))%40\n    ensures 40 < r < 1602\n    {\n        xk := (12*xk)%40;\n        r  := xk*xk + xk + 41;\n    }\n}\nmethod RSAencrypt (m: nat) returns (c: nat, flag: bool)\nrequires m>=0\ndecreases *\n{\n    var m1: nat; var f2: bool;\n    var h := new primeRandomNumber();\n    var p := h.primePRNG();\n    var q := h.primePRNG();\n    var n := p * q;\n    var ph :=(p-1)*(q-1);\n    var e := h.primePRNG();\n    var d, f1 := inversemod(e,ph);\n    if (f1){\n        c := expoBySquare(m,e);\n        c := c % n;\n        m1 := expoBySquare(c,d);\n        m1 := m1 % n;\n        f2 := (m==m1);\n        flag := f2 && f1;\n    }else{\n        flag := true;\n        c := 9999;\n    }\n}"
},
{
    "dafny": "type Small = x: int | 0 <= x < 100 && x != 3\nfunction F(x: int): int\n  requires x != 3\n{\n  if x == 3 then 1/0 else 100\n}\nmethod Main() {\n  var b := !exists n: Small :: F(n) != 100;\n  assert b;\n  print b;\n}"
},
{
    "dafny": "function And(a: bool, b: bool): bool { a && b }\nfunction Or(a: bool, b: bool): bool { a || b }\nfunction Not(a: bool): bool { ! a }\nlemma test(Y: int, r0: int, r: int, q: int, q0: int, r1: int, q1 : int)\n    ensures\n  Not( Or( And( 131072 <= Y, Y < 139264),\n       Or( And( 268468224 <= Y, Y < 268500992),\n       Or( And( 268509184 <= Y, Y < 268513280), And( 268513280 <= Y, Y < 268517376))))) ==>\n  (Or( And( 131072 <= r0, r0 < 139264),\n   Or( And( 268468224 <= r0, r0 < 268500992),\n   Or( And( 268509184 <= r0, r0 < 268513280), And( 268513280 <= r0, r0 < 268517376)))) ==>\n   (r == 0 ==>\n    (And( 0 <= Y, Y < 4294967296) ==>\n     ((Not( 4 == 0) ==> r0 == 4 * q + r) ==>\n      ((0 < 4 ==> And( 0 <= r, r < 4)) ==>\n       ((4 < 0 ==> And( 4 < r, r <= 0)) ==>\n        ((4 == 0 ==> q == 0) ==>\n         ((4 == 0 ==> r == 0) ==>\n          ((Not( 4294967296 == 0) ==> Y - r1 == 4294967296 * q0 + r0) ==>\n           ((0 < 4294967296 ==> And( 0 <= r0, r0 < 4294967296)) ==>\n            ((4294967296 < 0 ==> And( 4294967296 < r0, r0 <= 0)) ==>\n             ((4294967296 == 0 ==> q0 == 0) ==>\n              ((4294967296 == 0 ==> r0 == 0) ==>\n               ((Not( 4294967296 == 0) ==> 2 == 4294967296 * q1 + r1) ==>\n                ((0 < 4294967296 ==> And( 0 <= r1, r1 < 4294967296)) ==>\n                 ((4294967296 < 0 ==> And( 4294967296 < r1, r1 <= 0)) ==>\n                  ((4294967296 == 0 ==> q1 == 0) ==> ((4294967296 == 0 ==> r1 == 0) ==> false))))))))))))))))))\n{}"
},
{
    "dafny": "class Learner<T(==)>\n{\n  var majority: int; \n  var current:  int; \n  var accepted: map<T, seq<int>>; \n  constructor ()\n    modifies this;\n  {\n    majority := 0;\n    current  := -1;\n  }\n  method Learn(id: int, round: int, value: T) returns (learned: bool, ret: T)\n    modifies this;\n  {\n    if round > current {\n      current := round;\n      accepted := map[]; \n    }\n    if round == current {\n      if value !in accepted {\n        accepted := accepted[ value := [id] ];\n      } else {\n        accepted := accepted[ value := accepted[value] + [id] ];\n      }\n      if |accepted[value]| >= majority {\n        return true, value;\n      }\n    }\n    return false, value;\n  }\n  method Configure(num_acceptors: int)\n    modifies this;\n  {\n    majority := num_acceptors/2 + 1;\n  }\n}"
},
{
    "dafny": "function gcd(m: nat, n: nat): nat\n  requires m>=1;\n  requires n>=1;\n  decreases m+n;\n{ \n  if (n==m) then n \n  else if (m>n) then gcd(m-n, n) \n  else gcd(m, n-m) \n}\nmethod GcdCal(m: nat, n: nat) returns (res: nat)\n  requires m>=1;\n  requires n>=1;\n  ensures res == gcd(m, n);\n{ \n  var m1: nat, n1: nat := m, n;\n  while (m1!=n1) \n    invariant m1 >= 1;\n    invariant n1 >= 1;\n    invariant gcd(m1, n1) == gcd (m, n)\n    decreases m1+n1\n  {  \n    if (m1>n1) { \n      m1 := m1-n1; \n    } \n    else { \n      n1 := n1-m1; \n    }\n }\n return m1;\n}"
},
{
    "dafny": "method isPrefix(pre: string, str: string) returns (res:bool)\n{\n var i := 0;\n if |pre| > |str|\n {\n\treturn false;\n } \n while i < |str| && i < |pre|\n invariant i >= 0; \n {\n  if pre[i] != str[i]\n  {\n    return false;\n  }\n  i := i + 1; \n } \n return true;\n}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n{\n var i := 0;\n while i < |str|\n {\n  var isSub := isPrefix(sub,str[i..]);\n  if isSub == true { return true; }\n  else { i := i + 1; } \n }\n return false;\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n{\n  var i := 0;\n  while i <= (|str1|-k)\n  {\n    var isSub := isSubstring(str1[i..i+k], str2);\n\tif isSub == true { return true;}\n\telse {i := i + 1;}\n  }\n  return false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n{\n  var i := 1;\n  while i <= |str1| && i <= |str2|\n  {\n    var hasCommon := haveCommonKSubstring(i, str1, str2);\n    if(hasCommon == false){ return i-1;}\n    i := i+1;\n  }\n  return i-1;\n}"
},
{
    "dafny": "method Multi(x: int, y: int) returns (r: int)\n    requires 0 <= x && 0 <= y\n    ensures r == x * y\n    decreases x\n{\n    if x == 0 {\n        r := 0;\n    } else {\n        var z := Multi(x - 1, y);\n        r := z + y;\n    }\n}"
},
{
    "dafny": "datatype Interval = Interval(lo: real, hi: real)\npredicate contains(i: Interval, r: real) {\n  i.lo <= r <= i.hi\n}\npredicate empty(i: Interval) {\n  i.lo > i.hi\n}\nlemma empty_ok(i: Interval)\n  ensures empty(i) <==> !exists r :: contains(i, r)\n{\n  if empty(i) {\n  } else {\n    assert contains(i, i.lo);\n  }\n}\nfunction min(r1: real, r2: real): real {\n  if r1 < r2 then r1 else r2\n}\nfunction max(r1: real, r2: real): real {\n  if r1 > r2 then r1 else r2\n}\nfunction intersect(i1: Interval, i2: Interval): Interval {\n  Interval(max(i1.lo, i2.lo), min(i1.hi, i2.hi))\n}\nlemma intersect_ok(i1: Interval, i2: Interval)\n  ensures forall r :: contains(intersect(i1, i2), r) <==> contains(i1, r) && contains(i2, r)\n{\n}\npredicate overlap(i1: Interval, i2: Interval) {\n  !empty(intersect(i1, i2))\n}\nlemma overlap_ok(i1: Interval, i2: Interval)\n  ensures overlap(i1, i2) <==> exists r :: contains(i1, r) && contains(i2, r)\n{\n  if overlap(i1, i2) {\n    if i1.lo >= i2.lo {\n      assert contains(i2, i1.lo);\n    } else {\n      assert contains(i1, i2.lo);\n    }\n  }\n}\nfunction union(i1: Interval, i2: Interval): Interval\n  requires overlap(i1, i2)\n{\n  Interval(min(i1.lo, i2.lo), max(i1.hi, i2.hi))\n}\nlemma union_ok(i1: Interval, i2: Interval)\n  requires overlap(i1, i2)\n  ensures forall r :: contains(union(i1, i2), r) <==> contains(i1, r) || contains(i2, r)\n{\n}\nlemma overlap_witness(i1: Interval, i2: Interval) returns (r: real)\n  requires overlap(i1, i2)\n  ensures contains(i1, r) && contains(i2, r)\n{\n  if i1.lo >= i2.lo {\n    r := i1.lo;\n  } else {\n    r := i2.lo;\n  }\n}"
},
{
    "dafny": "module Math__div_nonlinear_i {\nlemma lemma_div_of_0(d:int)\n    requires d != 0;\n    ensures 0/d == 0;\n{ }\nlemma lemma_div_by_self(d:int)\n    requires d != 0;\n    ensures d/d == 1;\n{ }\nlemma lemma_small_div()\n    ensures forall x, d {:trigger x / d} :: 0 <= x < d && d > 0 ==> x / d == 0;\n{ }\nlemma lemma_mod_of_zero_is_zero(m:int)\n    requires 0 < m;\n    ensures 0 % m == 0;\n{ }\nlemma lemma_fundamental_div_mod(x:int, d:int)\n    requires d != 0;\n    ensures x == d * (x/d) + (x%d);\n{ }\nlemma lemma_0_mod_anything()\n    ensures forall m:int {:trigger 0 % m} :: m > 0 ==> 0 % m == 0;\n{ }\nlemma lemma_mod_yourself(m:int)\n    ensures m > 0 ==> m % m == 0;\n{ }\nlemma lemma_small_mod(x:nat, m:nat)\n    requires x<m;\n    requires 0<m;\n    ensures x % m == x;\n{ }\nlemma lemma_mod_range(x:int, m:int)\n    requires m > 0;\n    ensures 0 <= x % m < m;\n{ }\nlemma lemma_real_div_gt(x:real, y:real)\n    requires x > y;\n    requires x >= 0.0;\n    requires y > 0.0;\n    ensures  x / y > (1 as real);\n{ }\n}"
},
{
    "dafny": "method replaceTagsBuilderHelper(len: nat, r1: nat, r2: nat, r3: nat)\n    requires 0 < r3 <= r2\n    requires r1 > 0\n    requires r2 > 0\n{\n    var R1 := 0;\n    var R2 := 0;\n    var R3 := 0;\n    var linePointer := 0;\n    var startTagLocation := 0;\n    var endTagLocation := 0;\n    while endTagLocation < len\n        invariant linePointer >= 0 \n        invariant startTagLocation >= 0 \n        invariant endTagLocation >= 0 \n        invariant linePointer == endTagLocation \n        invariant R1+R2 <= endTagLocation \n    {\n        startTagLocation := endTagLocation+r1;\n        endTagLocation := startTagLocation+r2;\n        if (endTagLocation < len) {\n            R1 := R1+startTagLocation-linePointer;\n            R2 := R2+r3;\n            assert R1+R2 <= len; \n        }\n        linePointer := endTagLocation;\n    }\n    assert linePointer>=0; \n    R3 := R3+len-linePointer;\n    assert R3<=len; \n}"
},
{
    "dafny": "codatatype Stream<X> = Nil | Cons(head: X, tail: Stream<X>)\nleast predicate Finite<Y>(s: Stream<Y>) {\n  s == Nil || Finite(s.tail)\n}\nleast predicate F0<Y>(s: Stream<Y>) {\n  var nil := Nil;\n  s == nil || F0(s.tail)\n}\nleast predicate F1<Y>(s: Stream<Y>) {\n  s.Nil? || F1(s.tail)\n}\nleast predicate G0<Y>(s: Stream<Y>) {\n  s is Stream<Y>\n}\nleast predicate G1<Y>(s: Stream<Y>) {\n  s == Identity(s)\n}\nleast predicate G2<Y>(s: Stream<Y>) {\n  s == Identity<Stream<Y>>(s)\n}\nghost function Identity<W>(w: W): W { w }\nleast lemma About<Z>(s: Stream<Z>)\n  requires s == Nil\n  requires s.Nil?\n  requires var nil := Nil; s == nil\n  requires s is Stream<Z>\n  requires s == Identity(s)\n  requires s == Identity<Stream<Z>>(s)\n  requires Finite(s)\n  requires F0(s)\n  requires F1(s)\n  requires G0(s)\n  requires G1(s)\n  requires G2(s)\n{\n}"
},
{
    "dafny": "method square0(n:nat) returns (sqn : nat)\nensures sqn == n*n\n{\n    sqn := 0;\n    var i:= 0;\n    var x;\n    while i < n\n    invariant i <= n && sqn == i*i \n    {\n        x := 2*i+1;\n        sqn := sqn+x;\n        i := i+1;\n    }\n}\nmethod square1(n:nat) returns (sqn : nat)\nensures sqn == n*n\n{\n    sqn := 0;\n    var i:= 0;\n    while i < n\n    invariant i <= n && sqn == i*i \n    {\n        var x := 2*i+1;\n        sqn := sqn+x;\n        i := i+1;\n    }\n}\nmethod q(x:nat, y:nat) returns (z:nat)\nrequires y - x > 2\nensures x < z*z < y\nmethod strange()\nensures 1==2\n{\n    var x := 4;\n    var c:nat := q(x,2*x); \n}\nmethod test0(){\n    var x:int := *;\n    assume x*x < 100;\n    assert x<= 9;\n}"
},
{
    "dafny": "class C { \n  var f: real\n}\npredicate P(z: int) { true }\nmethod M(c: C)\n  modifies c\n  decreases *\n{\n  var x := 3;  \n  var y;  \n  y := 4;\n  y := *;  \n  x, y := x, *;  \n  y :| true;  \n  if * {  \n    x := x + 1;\n  }\n  if {  \n    case true =>  x := x + 1;\n    case true =>  x := x + 2;\n  }\n  if c.f < 500.0 {\n    if {  \n      case c.f < 1000.0 => x := x + 1;\n    }\n  }\n  if z :| 10 <= z < 15 && P(z) {  \n    x := z;\n  }\n  while *  \n    decreases *\n  {\n    x := x + 1;\n  }\n  while  \n    decreases if x <= 100 then 100-x else x\n  {\n    case x < 100 => x := x + 1;\n    case 100 < x => x := x - 1;\n  }\n  var a := new int[100](_ => 750);\n  forall i | 0 <= i < a.Length {\n    a[i] := *;  \n  }\n  modify c;  \n  modify c {  \n  }\n}\nmethod OutputParameters0(x: int) returns (s: int, t: int)\n{\n  return x, x+45;  \n}\nmethod DeclWithHavoc(yes: bool)\n  requires yes\n{\n  var b: int := *;  \n  var c: int; \n  var d: int;\n  if yes {\n    var e := b; \n  } else {\n    var e := d;\n  }\n}\niterator IterWeird() yields ()  \n{\n}\niterator Iter() yields (x: int)  \n{\n}\nclass C' { \n}\nclass C'' { \n  const u := 15\n}\nclass C''' { \n  const u: int\n}\nclass D {\n  var f: real \n  const u: int \n  const w := 15\n  constructor D() {\n    f := 0.9;\n    u := 90;\n  }\n}"
},
{
    "dafny": "method BubbleSort(a:array<int>) \n  requires a != null;\n  ensures forall k:: forall l:: 0 <= k < l < a.Length ==> a[k] <= a[l];\n  modifies a;\n{\n  var i:int := a.Length - 1;\n  while(i > 0)\n\tinvariant -1 <= i < a.Length;\n\tinvariant forall par1:: forall par2:: 0 <= par1 <= i && i < par2 < a.Length ==> a[par1] <= a[par2];\n\tinvariant forall elem1:: forall elem2:: i < elem1 < elem2 < a.Length ==> a[elem1] <= a[elem2];\n    decreases i;\n  {\n    var j:int := 0;\n    while (j < i)\n\t  invariant 1 <= i < a.Length;\n\t  invariant 0 <= j <= i;\n\t  invariant forall par1:: forall par2:: 0 <= par1 <= i && i < par2 < a.Length ==> a[par1] <= a[par2];\n\t  invariant forall par1:: 0 <= par1 <= j ==> a[par1] <= a[j];\n\t  invariant forall elem1:: forall elem2:: i < elem1 < elem2 < a.Length ==> a[elem1] <= a[elem2];\n\t  decreases i - j;\n    {\n      if (a[j] > a[j + 1]) {\n        var t:int := a[j];\n        a[j] := a[j + 1];\n        a[j + 1] := t;\n      }\n\t  j := j + 1;\n    }\n\ti := i - 1;\n  }\n}"
},
{
    "dafny": "function power(x: int, y: int): int\n    requires y >= 0\n{\n    if (y == 0) then 1 else x * power(x, y-1)\n}\nmethod exponent(x: int, y: int) returns (z:int)\n    requires y >= 0\n    ensures z == power(x, y)\n{\n    assert 1 == power(x, y-y);      \n    z := 1;\n    assert z == power(x, y-y);      \n    var c := y;\n    assert z == power(x, y-c);      \n    while (c != 0)\n        decreases c\n        invariant z == power(x, y-c)    \n    {\n        assert z*x == power(x, y-(c-1));\n        z := z * x;\n        assert z == power(x, y-(c-1));  \n        c := c - 1;\n        assert z == power(x, y-c);      \n    }\n    assert z == power(x, y);        \n}"
},
{
    "dafny": "function rank(y:int, i:int) : int {\n  y - i\n}\nfunction inv(i: int, y:int, x:int, r: int) : bool\n{\n  i <= y &&  r == x + i && rank(y, i) >= 0\n}\nmethod add_by_one_2 (x:int, y:int) returns (r:int)\n{\n  assume(y >= 0);\n  var i:int := 0;\n  r := x;\n  assert(inv(i, y, x, r));\n  i, r := *, *;\n  assume(inv(i, y, x, r));\n  if (i < y)\n  {\n    ghost var rank0 := rank(y, i);\n    r := r + 1;\n    i := i + 1;\n    ghost var rank1 := rank(y, i);\n    assert(inv(i, y, x, r));\n    assert (rank1 < rank0);\n    assume(false);\n  } \n  assert(r == x + y);\n  return r;\n}\nmethod add_by_one (x:int, y:int) returns (r:int)\n  requires y >= 0;\n  ensures r == x + y;\n{\n  var i:int := 0;\n  r := x;\n  while (i < y)\n  decreases y - i;\n  invariant i <= y ;\n  invariant r == x + i;\n  {\n    assume(i <= 2);\n    r := r + 1;\n    i := i + 1;\n  }\n  return r;\n}"
},
{
    "dafny": "module InductiveThings {\n  ghost predicate P(x: int)\n  ghost predicate Q(x: int)\n  least predicate A(x: int)\n  {\n    P(x) || B(x+1)\n  }\n  least predicate B(x: int)\n  {\n    Q(x) || A(x+1)\n  }\n  least lemma AA(x: int)  \n    requires A(x)\n  {\n    if B(x+1) {  \n      BB(x+1);\n    }\n  }\n  least lemma BB(x: int)  \n    requires B(x)\n  {\n    if A(x+1) {  \n      AA(x+1);\n    }\n  }\n}\nmodule CoThings {\n  greatest predicate A(x: int)\n  {\n    B(x+1)\n  }\n  greatest predicate B(x: int)\n  {\n    A(x+1)\n  }\n  greatest lemma AA(x: int)  \n    ensures A(x)\n  {\n    BB(x+1);\n    assert B(x+1);  \n  }\n  greatest lemma BB(x: int)  \n    ensures B(x)\n  {\n    AA(x+1);\n    assert A(x+1);  \n  }\n}\nmodule SingleThings {\n  ghost predicate P(x: int)\n  least predicate A(x: int)\n  {\n    P(x) || A(x+1)\n  }\n  least lemma AA(x: int)  \n    requires A(x)\n  {\n    if A(x+1) {  \n      AA(x+1);\n    }\n  }\n}"
},
{
    "dafny": "method removeMemberFromAllDiscussions(n: nat)\n{\n    var R := 0;\n    var i := 0;\n    while i < n\n        invariant R <= i\n        invariant i <= n\n    {\n        i := i + 1;\n        R := R + 1;\n        assert R <= i; \n    }\n    assert i <= n; \n    assert R <= n; \n}"
},
{
    "dafny": "method AbsArray(a:array<int>)\n  modifies a;\n  requires a != null;\n  ensures forall k :: 0 <= k < a.Length ==> a[k] >= 0;\n{\n  var i:int := 0;\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant forall k :: 0 <= k < i ==> a[k] >= 0;\n  {\n    if (a[i] <\t0)\n    {\n      a[i] := -a[i];\n    }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "function sum_up_to (n: nat): nat\n{\n  if (n == 0) then 0\n  else sum_up_to (n-1) + 1\n}\nmethod SumUpTo (n: nat) returns (r: nat)\n  ensures r == sum_up_to (n);\n{\n  var i := 0;\n  r := 0;\n  while (i < n)\n    invariant 0 <= i <= n;\n    invariant r == sum_up_to (i);\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n}\nfunction total (a: seq<nat>) : nat\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\nlemma total_lemma (a: seq<nat>, i:nat) \n  requires |a| > 0;\n  requires 0 <= i < |a|;\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1]);\n{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}\nmethod Total (a: seq<nat>) returns (r:nat)\n  ensures r == total (a[0..|a|]); \n{\n  var i := 0;\n  r := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|;\n    invariant r == total (a[0..i]);\n  { \n    total_lemma (a, i);\n    r := r + a[i];\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "module AmbiguousNestedModule {}\nmodule Library {\n  method EntryPoint() {\n    print \"hello from the library\\n\";\n    OpaqueFunctions.IsFive();\n    AutoGhostRegression.Q();\n    ExternCode.C();\n  }\n  module AmbiguousNestedModule {\n    method EntryPoint() {\n      print \"hello from a nested module\\n\";\n    }\n  }\n}\nmodule {:extern \"ExternCode\"} ExternCode {\n  method {:extern} C()\n}\nmodule OpaqueFunctions {\n  ghost function {:opaque} Five(): int { 5 }\n  lemma IsFive()\n    ensures Five() == 5\n  {\n    reveal Five();\n  }\n}\nmodule AutoGhostRegression {\n  method P() returns (a: int, ghost b: int) {\n    a, b := 9, 11;\n  }\n  method NeedsNonGhost(u: int) {\n  }\n  method Q() {\n    var u, v := P();  \n    NeedsNonGhost(u);\n  }\n}"
},
{
    "dafny": "function Sum(vc:seq<int>) : int\nensures vc == [] ==> Sum(vc) == 0\nensures vc != [] ==> Sum(vc) == vc[0] + Sum(vc[1..])\n{\n\tif(|vc| == 0) then 0\n\telse vc[0] + Sum(vc[1..])\n}\nmethod ventana(vc : array<int>, m : int) returns (s: int, p1 : int)\nrequires vc != null && vc.Length >= 0\nrequires 0 <= m <= vc.Length\nensures s == Sum(vc[..m])"
},
{
    "dafny": "class MyList<T>\n{\n}\nmethod AAA<U>(aax: MyList?<U>) returns (aay: MyList?<U>)\n  ensures BBB(aax, aay)\nghost predicate BBB<V>(bbx: MyList?<V>, bby: MyList?<V>)\n{\n  CCC(bbx, null)\n}\nghost predicate CCC<W>(ccx: MyList?<W>, ccy: MyList?<W>)"
},
{
    "dafny": "method IsPalindrome(x: seq<char>) returns (result: bool)\n{\n  if |x|==0 {\n    return true;\n  }\n  var i := 0;\n  var j := |x| - 1;\n  result := true;\n  while (i < j)\n    invariant 0<=i<=j+1 && 0<=j < |x|\n    invariant i+j==|x|-1\n    invariant (forall k :: 0 <= k < i ==> x[k] == x[|x| - k - 1])\n  {\n    if x[i] != x[j] {\n      result := false;\n      return;\n    }\n    i := i + 1;\n    j := j - 1;\n  }\n}"
},
{
    "dafny": "lemma andb_eq_orb() \n    ensures forall b, c :: (b && c) == (b || c) ==> b == c;\n{\n    forall b, c | true\n    ensures (b && c) == (b || c) ==> b == c\n    {}\n}\nlemma mul_comm()\n    ensures forall m, n : nat :: m * n == n * m;\n{}"
},
{
    "dafny": "opaque function F(x: int): char\n{ 'D' }\nfunction InitArray<D>(f: int -> D): (a: D)\n{\n  f(44)\n}\nmethod Main() {\n  reveal F();\n  var c := InitArray(F);\n  assert c == 'D';\n}"
},
{
    "dafny": "method copy_neg (a: array<int>, b: array<int>)\n  returns (r: nat)\n  requires a != null && b != null && a != b\n  requires a.Length <= b.Length\n  modifies b\n  ensures 0 <= r <= a.Length\n  ensures forall x | x in a[..] :: x < 0 <==> x in b[..r]\n{\n  r := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= r <= i <= a.Length\n    invariant forall x | x in b[..r] :: x < 0\n    invariant forall x | x in a[..i] && x < 0 :: x in b[..r]\n  {\n    if a[i] < 0 {\n      b[r] := a[i];\n      assert forall x | x in b[..r] :: x < 0;\n      r := r + 1;\n    }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "datatype Result<T> = Success(value: T) | Failure(error: string)\n{\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): Result<U>\n    requires Failure?\n  {\n    Failure(this.error)\n  }\n  function Extract(): T\n    requires Success?\n  {\n    value\n  }\n}\nmethod mn() returns (r: Result<int>, out: int)\n  ensures r.Failure? && out == -2\n{\n  var t, k :- m(1);\n  assert t == 1 && k == 2;\n  var rr;\n  rr, out :- m(-1); \n  return Success(k), out;\n}\nmethod mn1() returns (r: Result<int>, out: int)\n  ensures r.Failure? && out == 42\n{\n  out := 42;\n  var k :- m1(1);\n  assert k == 1;\n  out :- m1(-1); \n  return Success(k), out;\n}\nmethod m(i: int) returns (r: Result<int>, o: int)\n  ensures 0 <= i ==> r.Success? && r.Extract() == i && o == i+i\n  ensures i < 0 ==> r.Failure? && o == i+i\n{\n  if i < 0 { return Failure(\"negative\"), i+i; }\n  return Success(i), i+i;\n}\nmethod m1(i: int) returns (r: Result<int>)\n  ensures 0 <= i ==> r.Success? && r.Extract() == i\n  ensures i < 0 ==> r.Failure?\n{\n  if i < 0 { return Failure(\"negative\"); }\n  return Success(i);\n}\nmethod Main() {\n  var x, out := mn();\n  print x.Failure?, \" \", out, \"\\n\";\n  x, out := mn1();\n  print x.Failure?, \" \", out, \"\\n\";\n  print \"End\\n\";\n}"
},
{
    "dafny": "method findMax (a : array?<int>, n : int) returns (r:int)\n  requires a != null && a.Length > 0;\n  requires 0 < n <= a.Length;\n  ensures 0 <= r < n;\n  ensures forall l :: 0<= l < n ==> a[l] <= a[r]\n{\n  var mi;\n  var i;\n  mi := 0;\n  i := 0;\n  while (i < n)\n  invariant 0<= i <= n;\n  invariant 0<= mi < n;\n  decreases n-i;\n  invariant forall k :: 0<= k < i ==> a[k] <= a[mi]\n  {\n    if (a[i] > a[mi])\n    { mi := i; }\n    i := i + 1;\n  }\n  return mi;\n}"
},
{
    "dafny": "function Sum(s: seq<nat>): nat {\n  if |s| == 0 then 0\n  else s[0] + Sum(s[1..])\n}\nfunction Sum_(s: seq<nat>, n: nat): nat\n  ensures Sum(s) == Sum_(s,n)\n  ensures |s| > 0 && n > 0 ==> Sum_(s,n) == s[0] + Sum_(s[1..], n-1)\n{\n  if |s| == 0 || n == 0 then Sum(s)\n  else s[0] + Sum_(s[1..], n-1)\n}\nlemma Sum1(s: seq<nat>)\n  requires |s| == 1\n  ensures Sum(s) == s[0]\n{\n}\nlemma Sum3(s: seq<nat>)\n  requires |s| == 3\n  ensures Sum(s) == s[0] + s[1] + s[2]\n{\n  var _ := Sum_(s, 3);\n}\nlemma Sum9(s: seq<nat>)\n  requires |s| == 9\n  ensures Sum(s) == s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6] + s[7] + s[8]\n{\n  var _ := Sum_(s, 9);\n}"
},
{
    "dafny": "method abcd(efgh: seq<char>, ijkl: seq<char>) returns (mnop: seq<char>)\n{\n  mnop := [];\n  var qrst := if |efgh| <|ijkl| then |efgh| else |ijkl|;\n  for tuvw:= 0 to qrst\n    invariant |mnop|==tuvw <=  qrst<=|efgh| && qrst<=|ijkl|\n    invariant |mnop| <= |efgh| && mnop == efgh[0..|mnop|] && |mnop| <= |ijkl| && mnop == ijkl[0..|mnop|]\n  {\n    if efgh[tuvw] != ijkl[tuvw] {\n      return;\n    }\n    mnop := mnop + [efgh[tuvw]];\n  }\n}"
},
{
    "dafny": "ghost function upCast(o: object): object {o}\ntrait Universe {\n  ghost var content: set<Object>\n  ghost predicate globalBaseInv() reads this, content {\n    forall o: Object | o in content :: o.universe == this && upCast(o) != this\n  }\n  ghost predicate globalInv() reads * {\n    globalBaseInv() && forall o: Object | o in content :: o.inv()\n  }\n  twostate predicate globalInv2() reads * {\n    forall o: Object | o in old(content) :: o in content && o.inv2()\n  }\n  twostate predicate legalTransition() reads * {\n    && old(globalInv())\n    && globalBaseInv()\n    && old(content) <= content\n    && (forall o: Object | o in old(content) :: unchanged(o) || (o.inv2() && o.inv()))\n    && (forall o: Object | o in content && o !in old(content) :: o.inv())\n  }\n  twostate lemma lci()\n    requires legalTransition()\n    ensures globalInv() && globalInv2()\n  {\n    forall o: Object | o in old(content) && o.goodPreAndLegalChanges() ensures o.inv2() && o.inv() { o.adm(); }\n  }\n}\ntrait Object {\n  ghost const universe: Universe\n  ghost predicate baseInv() reads * { this in universe.content && universe.globalBaseInv() }\n  ghost method join()\n    requires universe.globalBaseInv() && upCast(this) != universe\n    modifies universe \n    ensures baseInv() && universe.content == old(universe.content) + { this }\n  {\n    universe.content := universe.content + { this }; \n  }\n  twostate predicate goodPreAndLegalChanges() reads * {\n    && old(baseInv() && universe.globalInv())\n    && baseInv()\n    && unchanged(this)\n    && universe.legalTransition()\n  }\n  ghost predicate globalInv() reads * { baseInv() && universe.globalInv() }\n  twostate predicate globalInv2() requires old(globalInv()) reads * { baseInv() && universe.globalInv2() }\n  ghost predicate inv() reads *\n  twostate predicate inv2() reads *\n  twostate lemma adm() requires goodPreAndLegalChanges() ensures inv2() && inv()\n}\nclass A extends Object {\n  ghost var valid: bool \n  ghost var b: B\n  ghost predicate inv() reads * {\n    && localInv()\n    && (valid ==> b.localInv())\n  }\n  ghost predicate localInv() reads * {\n    && baseInv()\n    && universe == b.universe\n    && (valid ==>\n      && b.valid\n      && b.a == this\n    )\n  }\n  twostate predicate inv2() reads * {\n    && localInv2()\n    && (old(valid) ==> b.localInv2())\n  }\n  twostate predicate localInv2() reads * {\n    && (old(valid) ==>\n      && valid \n      && old(b) == b\n    )\n  }\n  twostate lemma adm() requires goodPreAndLegalChanges() ensures inv2() && inv() {}\n  constructor (ghost universe: Universe, b: B)\n    requires universe.globalInv() && universe == b.universe && b.inv() && !b.valid\n    modifies universe, b\n    ensures this.baseInv() && universe.globalInv()\n  {\n    this.universe := universe;\n    this.b := b;\n    new;\n    join();\n    this.b.a := this;\n    this.valid := true;\n    this.b.valid := true;\n    universe.lci();\n  }\n}\nclass B extends Object {\n  ghost var valid: bool \n  ghost var a: A\n  ghost predicate inv() reads * {\n    && localInv()\n    && (valid ==> a.inv())\n  }\n  ghost predicate localInv() reads * {\n    && baseInv()\n    && universe == a.universe\n    && (valid ==>\n      && a.valid\n      && a.b == this\n    )\n  }\n  twostate predicate inv2() reads * {\n    && localInv2()\n    && (old(valid) ==> a.inv2())\n  }\n  twostate predicate localInv2() reads * {\n    && (old(valid) ==>\n      && valid \n      && old(a) == a\n    )\n  }\n  twostate lemma adm() requires goodPreAndLegalChanges() ensures inv2() && inv() {}\n  constructor (ghost universe: Universe, a: A)\n    requires universe.globalInv() && universe == a.universe && a.inv() && !a.valid\n    modifies universe, a\n    ensures this.baseInv() && universe.globalInv()\n  {   \n    this.universe := universe;\n    this.a := a;\n    new;\n    join();\n    this.a.b := this;\n    this.valid := true;\n    this.a.valid := true;\n    universe.lci();\n  }\n}"
},
{
    "dafny": "method Triple(x: int) returns (r: int)\n    requires x % 2 == 0\n    ensures r == 3 * x\n{\n    var y := x / 2;\n    r := 6 * y;\n}\nmethod Caller() {\n    var t := Triple(18);\n    assert t < 100;\n}"
},
{
    "dafny": "method swap(arr: array?<char>, i: int, j: int) returns (new_arr: array?<char>)\n    requires arr != null\n    requires 0 <= i < arr.Length\n    requires 0 <= j < arr.Length\n    ensures new_arr != null\n    ensures new_arr.Length == arr.Length\n    modifies arr\n{\n    var temp_char := arr[i];\n    arr[i] := arr[j];\n    arr[j] := temp_char;\n    return arr;\n}\nmethod dutch(arr: array?<char>) returns (k: int)\n    requires arr != null\n    ensures k != 0 || forall i: int :: 0 <= i < k ==> arr[i] == 'r'\n    ensures k != arr.Length || forall j: int :: k <= j < arr.Length ==> arr[j] == 'b'\n    modifies arr\n{\n    k := 0;\n    var counter := 0;\n    while(counter < arr.Length && k < arr.Length)\n        invariant 0 <= k <= arr.Length\n        decreases arr.Length - counter\n    {\n        if(arr[counter] == 'r') { k := k+1; }\n        counter := counter + 1;\n    }\n    var i := 0;\n    if(0 < k < arr.Length){\n        while(i < k && i < arr.Length)\n            invariant 0 <= i <= k\n            decreases k-i\n        {\n            if(arr[i] == 'b'){\n              var j := k;\n                while(j < arr.Length)\n                    invariant k <= j\n                    decreases arr.Length - j\n                {\n                    if(arr[j] == 'r'){\n                        var new_arr := swap(arr,i,j);\n                        arr[i] := new_arr[i];\n                        arr[j] := new_arr[j];\n                        break;\n                    }\n                    j := j+1;\n                }\n            }\n            i := i+1;\n        }\n    }\n    return k;\n}"
},
{
    "dafny": "function calcSum(n: nat) : nat \n{   \n    n * (n - 1) / 2\n}\nmethod sum(n: nat) returns(s: nat)\n    ensures s == calcSum(n + 1)\n{\n    s := 0;\n    var i := 0;\n    while i < n \n        decreases n - i\n        invariant 0 <= i <= n\n        invariant s == calcSum(i + 1)\n    {\n        i := i + 1;\n        s := s + i;\n    }\n}"
},
{
    "dafny": "method Main() {\n  print F(), \" \", G(802.11), \"\\n\";  \n}\nfunction F(): int {\n  var rx := false;\n  assert 20 < 30 by {\n    var u := 5.0;  \n    assert u < 6.0;\n  }\n  12\n}\nfunction G<T>(t: T): int {\n  var rx := false;\n  assert 20 < 30 by {\n    var u: T := t;  \n    {\n      var v: T := u;\n      assert t == v;\n      v := t;\n      assert t == u;\n    }\n    assert u == t;\n  }\n  15\n}"
},
{
    "dafny": "class AdvertisingManager {\n    var availableBanners: seq<Banner>;\n    var publishers: seq<Publisher>;\n    var ads: map <Publisher, Ad>;\n    constructor()\n    modifies this;\n    {\n        availableBanners := [];\n        publishers := [];\n        ads := map[];\n    }\n    function isPriceLessThanMinPrice (price : int, ads: map <Publisher, Ad>) : bool\n    reads valuesOfAds(ads)\n    requires forall p :: p in ads ==> ads[p] != null\n    {\n      forall p :: p in ads ==> ads[p].price >= price\n    }\n    function valuesOfAds (myAds : map<Publisher, Ad>) : set<Ad>\n    {\n      set p: Publisher | p in myAds :: myAds[p]\n    }\n    method replaceMin (publisher : Publisher, price : int)\n    modifies this\n    requires publisher != null\n    requires publisher !in publishers\n    requires publisher !in ads\n    requires forall p :: p in publishers ==> p != null\n    requires forall p :: p in publishers ==> p in ads\n    requires forall p :: p in ads ==> ads[p] != null\n    requires forall p :: p in ads ==> ads[p].banner != null\n    requires |publishers| > 0\n    {\n        var minPublisher := publishers[0];\n        var minPrice := ads[minPublisher].price;\n        var index := 1;\n        while (index < |publishers|)\n        decreases |publishers| - index\n        invariant   minPublisher in publishers && 0 <= index <= |publishers| && minPublisher in ads && forall i :: 0 <= i < index ==> minPrice <= ads[publishers[i]].price \n        {\n            var curPrice := ads[publishers[index]].price;\n            if (curPrice < minPrice)\n            {\n                minPrice := curPrice;\n                minPublisher := publishers[index];\n            }\n            index := index + 1;\n        }\n        if (price > minPrice)\n        {\n            var newAd : Ad := new Ad(ads[minPublisher].banner, price); \n            ads := ads[publisher := newAd]; \n            publishers := publishers + [publisher]; \n            ads:= map p | p in ads && p != minPublisher :: ads[p]; \n            removePublisherFromPublishers(minPublisher);\n        }\n    }\n    method stopPublish(publisher: Publisher)\n    modifies this;\n    requires publisher != null;\n    requires publisher in ads;\n    requires publisher in publishers;\n    requires ads[publisher] != null\n    requires forall p :: p in publishers ==> ads[publisher].banner != null && ads[publisher].banner !in availableBanners\n    requires forall p :: p in ads ==> ads[p] != null\n    ensures publisher !in ads;\n    ensures publisher !in publishers;\n    {\n        var banner := ads[publisher].getBanner();\n        addBanner(banner, publisher);\n        ads:= map p | p in ads && p != publisher :: ads[p]; \n        removePublisherFromPublishers(publisher);\n    } \n    method removePublisherFromPublishers (publisher: Publisher)\n    modifies this;\n    requires publisher != null;\n    requires publisher in publishers;\n    requires publisher !in ads;\n    requires forall p :: p in ads ==> ads[p] != null\n    ensures publisher !in publishers;\n    ensures publisher !in ads;\n    ensures forall p :: p in ads ==> ads[p] != null\n    {\n        var index := 0;\n        var newPublishers : seq<Publisher> := [];\n        while (index < |publishers|)\n        decreases |publishers| - index \n        invariant 0 <= index <= |publishers| && publisher !in newPublishers \n        {\n            if (publishers[index] != publisher)\n            {\n                newPublishers := newPublishers + [publishers[index]];\n            }\n            index := index + 1;\n        }\n        publishers := newPublishers;\n    }\n    method addBanner (banner : Banner, publisher : Publisher)\n    modifies this;\n    requires banner != null\n    requires banner !in availableBanners;\n    requires forall p :: p in ads ==> ads[p] != null\n    requires publisher in publishers;\n    ensures banner in availableBanners;\n    ensures publisher in publishers;\n    ensures forall p :: p in ads ==> ads[p] != null\n    {\n        availableBanners := availableBanners + [banner];\n    }\n}\nclass Publisher\n{\n}\nclass Banner\n{\n}\nclass Ad\n{\n    var banner : Banner;\n    var price : int;\n    constructor(bannerArg : Banner, priceArg : int)\n    modifies this;\n    requires bannerArg != null;\n    ensures banner == bannerArg;\n    ensures price == priceArg;\n    {\n        banner := bannerArg;\n        price := priceArg;\n    }\n    method getBanner() returns (b: Banner)\n    ensures b == banner;\n    {\n        return banner;\n    }\n    method getPrice() returns (p: int)\n    ensures p == price;\n    {\n        return price;\n    }\n}"
},
{
    "dafny": "class A {\n  var a: array<array<int>>\n  constructor(b: array<array<int>>) {\n    var c := b;\n    a := b;\n  }\n}\nmethod sub(a: array<array<int>>)\n  requires a.Length > 0\n  requires a[0].Length > 0\n{\n  print a[0][0], \" \";\n  var b := a;\n  print b[0][0], \"\\n\";\n}\nmethod Main() {\n  var a := new array<int>[2];\n  a[0] := new int[2];\n  a[0][0] := 42;\n  print a[0][0], \" \";\n  sub(a);\n  var b := new A(a);\n  MoreTests();\n}\nmethod MoreTests() {\n  TestA();\n  TestB();\n  TestC();\n  TestD();\n  TestE();\n}\nmethod TestA() {\n  var a := new int[2];\n  var b := new array<int>[2];\n  var c := new array<array2<int>>[2];\n  var d := new array2<array<int>>[2];\n  var e := new array4<array3<int>>[2];\n  a[0] := 5000;\n  b[0] := new int[10];\n  b[0][4] := 5000;\n  c[0] := new array2<int>[10];\n  c[0][4] := new int[70,80];\n  c[0][4][63,73] := 5000;\n  d[0] := new array<int>[70,80];\n  d[0][63,73] := new int[10];\n  d[0][63,73][4] := 5000;\n  e[0] := new array3<int>[12,2,3,15];\n  e[0][11,1,2,14] := new int[20,1,1];\n  e[0][11,1,2,14][18,0,0] := 5000;\n  print a[0], \" \", b[0][4], \" \";\n  print c[0][4][63,73], \" \", d[0][63,73][4], \" \";\n  print e[0][11,1,2,14][18,0,0], \"\\n\";\n}\nmethod TestB() {\n  var a := new int[2,3];\n  var b := new array<int>[2,3];\n  var c := new array<array2<int>>[2,3];\n  var d := new array2<array<int>>[2,3];\n  var e := new array4<array3<int>>[2,3];\n}\nmethod TestC() {\n  var a := new int[2];\n  var b := new array?<int>[2];\n  var c := new array?<array2?<int>>[2];\n  var d := new array2?<array?<int>>[2];\n  var e := new array4?<array3?<int>>[2];\n}\nmethod TestD() {\n  var a: array2<int> := new int[3,2];\n  var b: array<array2<int>> := new array2<int>[5];\n  b := new array2<int>[5][a, a, a, a, a];\n  b := new array2<int>[5](_ => a);\n  var c: array3<array<array2<int>>> := new array<array2<int>>[5,4,3];\n  c := new array<array2<int>>[5,4,3]((_,_,_) => b);\n}\nmethod TestE() {\n  var a: array2?<int> := new int[3,2];\n  var b: array?<array2?<int>> := new array2?<int>[5];\n  b := new array2?<int>[5][a, a, a, a, a];\n  b := new array2?<int>[5](_ => a);\n  var c: array3?<array?<array2?<int>>> := new array?<array2?<int>>[5,4,3];\n  c := new array?<array2?<int>>[5,4,3]((_,_,_) => b);\n  var d: array15?<int>;\n  var e: array16<int>;\n}"
},
{
    "dafny": "function sumNat ( n: nat) : nat\n{\n    if n == 0 then 0 else (n*(n+1))/2\n}\nmethod sum ( n: nat ) returns ( s: nat )\n    ensures s == sumNat(n);\n{\n    s := 0;\n    var i := 0;\n    while i < n \n        invariant 0 <= i <= n;\n        invariant s == sumNat(i);\n        decreases n - i;\n    {\n        i := i + 1;\n        s := s + i ;\n    }\n}"
},
{
    "dafny": "method CalcProduct(m: nat, n: nat) returns (res: nat)\n  ensures res == m*n;\n{\n  var m1: nat := m;\n  res := 0;\n  while (m1!=0)\n    invariant res == (m-m1)*n\n  {\n    var n1: nat := n;\n    ghost var old_res := res;\n    while (n1!=0)\n      invariant res == old_res + (n-n1);\n     {\n       res := res+1;\n       n1 := n1-1;\n     }\n    m1 := m1-1;\n  }\n}"
},
{
    "dafny": "method max(a: array<int>, b: array<int>, i: int, j: int)\n  returns (m: int)\n  requires 0 <= i < a.Length\n  requires 0 <= j < b.Length\n  ensures  a[i] > b[j] ==> m == a[i]\n  ensures  a[i] <= b[j] ==> m == b[j]\n{\n  if a[i] > b[j] {\n    m := a[i];\n  } else  {\n    m := b[j];\n  }\n}\nmethod testMax(a:array<int>, b:array<int>, i: int, j: int)\n  requires 0 <= i < a.Length\n  requires 0 <= j < b.Length\n{\n  var max := max(a,b,i,j);\n  assert a[i] > b[j] ==> max == a[i];\n  assert a[i] <= b[j] ==> max == b[j];\n}"
},
{
    "dafny": "datatype List = Nil | Cons(int, List)\ndatatype Stack = SList(list: List)\nfunction ListLen(l:List): int\n{\n  match l\n  case Nil => 0\n  case Cons(hd, tl) => ListLen(tl) + 1\n}\nfunction isEmptyList(l:List): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => false\n}\nfunction StackLen(st:Stack): int\n{\n  match st\n  case SList(l) => ListLen(l)\n}\nfunction isEmptyStack(st:Stack): bool\n{\n  match st\n  case SList(l) => isEmptyList(l)\n}\nmethod Pop(st:Stack) returns (stout: Stack, v:int)\n  requires !isEmptyStack(st)\n  ensures StackLen(st) == StackLen(stout) + 1\n{\n  match st\n  case SList(l) => \n    match l {\n      case Nil => stout := SList(Nil); v := 0;\n      case Cons(hd, tl) => stout := SList(tl); v := hd;\n    }\n}"
},
{
    "dafny": "method Main()\n{\n  test0(10);\n\ttest5(11);\n\ttest6(12);\n\ttest1();\n\ttest2();\n}\npredicate valid(x:int) \n{\n  x > 0\n}\nfunction ref1(y:int) : int\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption1()\n  ensures forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n{\n} \nmethod test0(a: int)\n{\n  if ref1.requires(a) {\n    ghost var b := ref1(a);\n  }\n}\nmethod test5(a: int)\n{\n  if valid(a) {\n    assert ref1.requires(a);\n  }  \n} \nmethod test6(a: int)\n{\n  if ref1.requires(a) {\n    assert valid(a);\n  }  \n}\nmethod test1()\n{\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref1.requires(a) && ref1.requires(b) && ref1(a) == ref1(b) \n                          ==> a == b;\n  }\n}\nfunction {:opaque} ref2(y:int) : int        \n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption2()\n  ensures forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b;\n{\n  reveal_ref2();\n}\nmethod test2()\n{\n  assumption2();\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref2.requires(a) && ref2.requires(b) && ref2(a) == ref2(b) \n                          ==> a == b;\n  }\n}"
},
{
    "dafny": "method memcpy(a:array<int>, b:array<int>, n:int)\nmodifies b;\nrequires a != null && b != null;\nrequires n >= 0 && a.Length >= n && b.Length >= n;\nensures forall j :: 0 <= j < n ==> a[j] == b[j];\n{\n  var i:int := 0;\n  while (i<n)\n  invariant 0 <= i <= n;\n  invariant forall j :: 0 <= j < i ==> a[j] == b[j];\n  {\n    b[i] := a[i];\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method A8Q1(x: int, y: int, z: int) returns (m: int)\n   requires true;\n  ensures m<=x && m<=y && m<=z;\n{ \n      if(z<y){\n          if(z<x){\n                m := z;\n          }else{\n                m := x;\n          }\n      }else{\n          m := y;\n          if (x<y){\n                m := x;\n          }\n      }\n}"
},
{
    "dafny": "function Expt(b: int, n: nat): int\n  requires n >= 0\n{\n  if n == 0 then 1 else b * Expt(b, n - 1)\n}\nmethod expt(b: int, n: nat) returns (res: int) \n  ensures res == Expt(b, n)\n{\n  var i := 1;\n  res := 1;\n  while i < n + 1 \n    invariant 0 < i <= n + 1\n    invariant res == Expt(b, i - 1)\n  {\n    res := res * b;\n    i := i + 1;\n  }\n}\nlemma {:induction a} distributive(x: int, a: nat, b: nat) \n  ensures Expt(x, a) * Expt(x, b) == Expt(x, a + b)"
},
{
    "dafny": "method calcP(n: nat) returns (res: nat)  \n    ensures res == P(n) \n{\n    if n <= 2 { return 1; }\n    var a, b, c := 1, 1, 1; \n    var i := 2;\n    while i < n \n        decreases n - i \n        invariant 2 <= i <= n \n        invariant a == P(i - 2) && b == P(i - 1) && c == P(i)\n    { \n        a, b, c := b, c, a + b;\n        i := i + 1;\n    }\n    res := c;\n}\nfunction P(n: nat): nat { if n <= 2 then 1 else P(n-2) + P(n-3) }"
},
{
    "dafny": "method Main() {\n  var a := new Issue.Foo<int>();\n  Issue.CallUseFoo(a);\n  var b := new Variation.Foo<int>();\n  Variation.CallUseFoo(b);\n  var c := new AnotherVariation.Foo<int>();\n  AnotherVariation.CallUseFoo(c);\n  print \"\\n\";\n}\nmodule Issue\n{\n  class Foo<T> {\n    ghost function Repr(): set<object> { {this} }\n    constructor() {}\n  }\n  method UseFoo<T>(t: Foo<T>)\n    modifies t.Repr()\n  {\n    print 0;\n  }\n  method CallUseFoo<T>(t: Foo<T>)\n    modifies t.Repr()\n  {\n    UseFoo(t);\n  }\n}\nmodule Variation {\n  class Foo<T> {\n    ghost function Repr(): set<object> { {this} }\n    constructor() {}\n  }\n  class UseFooHelper<T>\n  {\n    const foo: Foo<T>\n    constructor(foo: Foo<T>)\n      ensures this.foo == foo\n    {\n      this.foo := foo;\n    }\n    method Do()\n      modifies foo.Repr()\n    {\n      print 1;\n    }\n  }\n  method CallUseFoo<T>(t: Foo<T>)\n    modifies t.Repr()\n  {\n    var fh := new UseFooHelper(t);\n    fh.Do();\n  }\n}\nmodule AnotherVariation\n{\n  class Foo<T> {\n    ghost function Repr(): set<object> { {this} }\n    constructor() {}\n    method UseFoo()\n      modifies Repr()\n    {\n      print 2;\n    }\n  }\n  method CallUseFoo<T>(t: Foo<T>)\n    modifies t.Repr()\n  {\n    t.UseFoo();\n  }\n}"
},
{
    "dafny": "method noBranch(a:int , c:int) returns (result:int)\n    requires a > c\n    requires c > 5\n    ensures result > 0\n{\n    var b := 3 + a;\n    var result1 := c + b;\n    var answer := a * b;\n    assert answer > 0;\n    result := result1 * answer;\n    return result;\n}\nmethod testing()\n{\n    var a:= 20 ;\n    var c:= 10 ;\n    var Result := noBranch(a,c);\n    assert a > c ;\n    assert c > 5 ;\n    assert a > 0 ;\n}"
},
{
    "dafny": "predicate EOSorted(a: array<int>)\n    reads a \n{\n    a.Length >= 2 ==>  \n    (forall j:: (2 <= j < a.Length && j%2 == 0) ==> a[j] >= a[j-2]) &&  \n    (forall k:: (3 <= k < a.Length && k%2 == 1) ==> a[k] >= a[k-2])\n}\npredicate Sorted (a:array<int>)\nreads a\n{ forall j,k:: 0<=j<k<a.Length ==> a[j]<=a[k] }\nmethod Test()\n{\n    var a:array<int> := new int[][];\n    assert EOSorted(a);\n    var b:array<int> := new int[][2,1,4,2,6,3];\n    assert EOSorted(b);\n    var c:array<int> := new int[][1,2,3,1];\n    assert c[0]==1;\n    assert c[1]==2;\n    assert c[2]==3;\n    assert c[3]==1;\n    assert  !EOSorted(c);\n    var d:array<int> := new int[][1,2,1,2,1];\n    assert EOSorted(d);\n    var e:array<int> := new int[][1,1,1,1,1];\n    assert EOSorted(e);\n    var f:array<int> := new int[][1,100,1,100,1,200];\n    assert EOSorted(f);\n    var g:array<int> := new int[][1,2,4,2,2,1,1];\n    assert g[0] ==1;\n    assert g[1] ==2;\n    assert g[2] ==4;\n    assert g[3] ==2;\n    assert g[4] ==2;\n    assert g[5] ==1;\n    assert g[6] ==1;\n    assert !EOSorted(g);\n    var h: array<int> := new int[][1,2,3,4,1];\n}"
},
{
    "dafny": "method iter_copy<T(0)>(s: array<T>) returns (t: array<T>)\n  ensures s.Length==t.Length\n  ensures forall i::0<=i<s.Length ==> s[i]==t[i]\n{\n  t := new T[s.Length];\n  var i:= 0;\n  while (i < s.Length)\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> s[x] == t[x]\n  {\n    t[i] := s[i];\n    i:=i+1;\n  }\n}"
},
{
    "dafny": "ghost function SeqRepeat<T>(count:nat, elt:T) : seq<T>\n    ensures |SeqRepeat<T>(count, elt)| == count\n    ensures forall i :: 0 <= i < count ==> SeqRepeat<T>(count, elt)[i] == elt\ndatatype Maybe<T> = Nothing | Just(v: T)\ntype Num = x | 0 <= x < 10\ndatatype D = C(seq<Maybe<Num>>)\nlemma test()\n{\n    ghost var s := SeqRepeat(1, Nothing);\n    ghost var e := C(s);\n    assert e == C(SeqRepeat(1, Nothing));\n}"
},
{
    "dafny": "method Invert(a: array<int>, b: array<int>)\n  requires a != b;\n  requires a != null;\n  requires b != null;\n  requires a.Length == b.Length;\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] < a.Length;\n  requires forall i, j:: 0 <= i < a.Length && 0 <= j < a.Length && i != j ==> a[i] != a[j];\n  ensures forall i :: 0 <= i < a.Length\n                      && 0 <= a[i] < b.Length \n                      ==> b[a[i]] == i; \n  modifies b;\n{\t\n\tvar i:int := 0; \n\twhile (i < a.Length) \n\tinvariant a.Length == b.Length;\n\tinvariant 0 <= i <= b.Length;\n\tinvariant 0 <= i <= a.Length;\n\tdecreases a.Length-i;\n\tmodifies b;\n    invariant forall j:: 0 <= j < a.Length ==> 0 <= a[j] < b.Length;\n\tinvariant forall k:: 0 <= k < i <= a.Length ==> b[a[k]] == k; \n\t{\n\t\tb[a[i]] := i;\n\t\tassert (b[a[i]] == i);\n\t\ti := i + 1;\n\t}\n}\nmethod Main() \n{  \n  var a := new int[10];\n  a[0] := 9;\n  a[1] := 3;\n  a[2] := 8;\n  a[3] := 2;\n  a[4] := 7;\n  a[5] := 4;\n  a[6] := 0;\n  a[7] := 1;\n  a[8] := 5;\n  a[9] := 6;\n  var b := new int[10];\n  Invert(a, b);\n  var i:int := 0;\n  while(i < b.Length)\n  {\n    print b[i];\n    print \" \";\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method ComputeFact(n : nat) returns (res : nat)\nrequires n > 0;\nensures res == fact(n);\n{\n\tres := 1;\n\tvar i := 2;\n\twhile (i <= n)\n\tinvariant (i <= n + 1) && res == fact(i - 1);\n\tdecreases (n - i + 1);\n\t{\n\t\tres := res * i;\n\t\ti := i + 1;\n\t}\n}\nfunction fact(m : nat) : nat\nrequires m > 0;\n{\n\tif (m == 1) then 1 else m * fact(m - 1)\n}"
},
{
    "dafny": "method findMax (a : array<int>, n : int) returns (r:int)\nrequires a.Length > 0;\nrequires 0 < n <= a.Length;\nrequires a != null;\nensures 0 <= r < n && forall k :: 0 <= k < n ==> a[r] >= a[k];\n{\n  var mi;\n  var i;\n  mi := 0;\n  i := 0;\n  while (i < n)\n    invariant 0 <= i <= n;\n    invariant 0 <= mi < n;\n    invariant forall k :: 0 <= k < i ==> a[mi] >= a[k];\n    decreases n - i;\n  {\n    if (a[i] > a[mi])\n    { mi := i; }\n    i := i + 1;\n  }\n  return mi;\n}"
},
{
    "dafny": "method isPalindrome(chars: array<int>) returns (r: bool)\n  requires chars != null\n  ensures r <==> forall x: int :: 0 <= x < chars.Length\n                 ==> chars[x] == chars[chars.Length - (x + 1)]\n{\n    var i: nat := 0;\n    var j: nat := chars.Length;\n    while i < j\n      invariant i + j == chars.Length && i >= 0\n      invariant forall k: int :: 0 <= k < i\n                ==> chars[k] == chars[chars.Length - (k + 1)]\n    {\n        j := j - 1;\n        if chars[i] != chars[j]\n        {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}"
},
{
    "dafny": "predicate sorted_between(A:array<int>, from:int, to:int)\n    reads A\n{\n    forall i, j :: 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]\n}\npredicate sorted(A:array<int>)\n    reads A\n{\n    sorted_between(A, 0, A.Length-1)\n}"
},
{
    "dafny": "method Max(a: int, b: int) returns (c: int)\n    ensures c == a || c == b\n    ensures c >= a && c >= b \n{\n    if (a > b) {\n        return a;\n    }\n    else {\n        return b;\n    }\n}"
},
{
    "dafny": "ghost function Power(n: nat): nat {\n  if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(n: nat) returns (p: nat)\n  ensures p == Power(n)\n{\n  p := 1;\n  var i := 0;\n  while i != n\n    invariant 0 <= i <= n\n    invariant p == Power(i)\n  {\n    p := 2 * p;\n    i := i + 1;\n  }\n}\nmethod ComputePower'(n: nat) returns (p: nat)\n  ensures p == Power(n)\n{\n  p := 1;\n  var i := 0;\n  while i != n\n    invariant 0 <= i <= n\n    invariant p * Power(n - i) == Power(n)\n  {\n    p := 2 * p;\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "module ModelingTM {\n    type ProcessId = nat\n    type MemoryObject = nat\n    type TimeStamp = nat\n    class Operation {\n        const isWrite: bool\n        const memObject: MemoryObject\n    }\n    class Transaction {\n        const ops: seq<Operation>\n    }\n    class ProcessState {\n        const currentTx: nat\n        const currentOp: int\n        const currentSubOp: nat\n        const readSet: map<MemoryObject, TimeStamp>\n        const writeSet: set<MemoryObject>\n        constructor () {\n            currentTx := 0;\n            currentOp := 0;\n            currentSubOp := 0;\n            readSet := map[];\n            writeSet := {};\n        }\n        constructor nextSubOp(that: ProcessState)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == that.currentOp\n            ensures this.currentSubOp == that.currentSubOp + 1\n            ensures this.readSet == that.readSet\n            ensures this.writeSet == that.writeSet\n        {\n            currentTx := that.currentTx;\n            currentOp := that.currentOp;\n            currentSubOp := that.currentSubOp + 1;\n            readSet := that.readSet;\n            writeSet := that.writeSet;\n        }\n        constructor nextOp(that: ProcessState)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == that.currentOp + 1\n            ensures this.currentSubOp == 0\n            ensures this.readSet == that.readSet\n            ensures this.writeSet == that.writeSet\n        {\n            currentTx := that.currentTx;\n            currentOp := that.currentOp + 1;\n            currentSubOp := 0;\n            readSet := that.readSet;\n            writeSet := that.writeSet;\n        }\n        constructor abortTx(that: ProcessState)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == -1\n            ensures this.currentSubOp == 0\n            ensures this.readSet == that.readSet\n            ensures this.writeSet == that.writeSet\n        {\n            currentTx := that.currentTx;\n            currentOp := -1;\n            currentSubOp := 0;\n            readSet := that.readSet;\n            writeSet := that.writeSet;\n        }\n        constructor restartTx(that: ProcessState)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == 0\n            ensures this.currentSubOp == 0\n            ensures this.readSet == map[]\n            ensures this.writeSet == {}\n        {\n            currentTx := that.currentTx;\n            currentOp := 0;\n            currentSubOp := 0;\n            readSet := map[];\n            writeSet := {};\n        }\n        constructor nextTx(that: ProcessState)\n            ensures this.currentTx == that.currentTx + 1\n            ensures this.currentOp == 0\n            ensures this.currentSubOp == 0\n            ensures this.readSet == map[]\n            ensures this.writeSet == {}\n        {\n            currentTx := that.currentTx + 1;\n            currentOp := 0;\n            currentSubOp := 0;\n            readSet := map[];\n            writeSet := {};\n        }\n        constructor addToReadSet(that: ProcessState, obj: MemoryObject, ts: TimeStamp)\n            ensures currentTx == that.currentTx\n            ensures currentOp == that.currentOp\n            ensures currentSubOp == that.currentSubOp\n            ensures readSet.Keys == that.readSet.Keys + {obj}\n                && readSet[obj] == ts\n                && forall o :: o in readSet && o != obj ==> readSet[o] == that.readSet[o]\n            ensures writeSet == that.writeSet\n        {\n            currentTx := that.currentTx;\n            currentOp := that.currentOp;\n            currentSubOp := that.currentSubOp;\n            readSet := that.readSet[obj := ts];\n            writeSet := that.writeSet;\n        }\n        constructor addToWriteSet(that: ProcessState, obj: MemoryObject)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == that.currentOp\n            ensures this.currentSubOp == that.currentSubOp\n            ensures this.readSet == that.readSet\n            ensures this.writeSet == that.writeSet + {obj}\n        {\n            currentTx := that.currentTx;\n            currentOp := that.currentOp;\n            currentSubOp := that.currentSubOp;\n            readSet := that.readSet;\n            writeSet := that.writeSet + {obj};\n        }\n    }\n    class TMSystem {\n        const txQueues : map<ProcessId, seq<Transaction>>\n        const procStates : map<ProcessId, ProcessState>\n        const dirtyObjs: set<MemoryObject>\n        const lockedObjs: set<MemoryObject>\n        const objTimeStamps: map<MemoryObject, nat>\n        constructor (q: map<ProcessId, seq<Transaction>>) {\n            txQueues := q;\n            procStates := map[];\n            dirtyObjs := {};\n            lockedObjs := {};\n            objTimeStamps := map[];\n        }\n        constructor initTimestamp(that: TMSystem, obj: MemoryObject)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps.Keys ==  that.objTimeStamps.Keys + {obj}\n                && objTimeStamps[obj] == 0\n                && forall o :: o in objTimeStamps && o != obj ==> objTimeStamps[o] == that.objTimeStamps[o]\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := that.objTimeStamps[obj := 0];\n        }\n        constructor updateState(that: TMSystem, pid: ProcessId, state: ProcessState)\n            ensures txQueues == that.txQueues\n            ensures procStates.Keys == that.procStates.Keys + {pid}\n                && procStates[pid] == state\n                && forall p :: p in procStates && p != pid ==> procStates[p] == that.procStates[p]\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps ==  that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates[pid := state];\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := that.objTimeStamps;\n        }\n        constructor markDirty(that: TMSystem, obj: MemoryObject)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs + {obj}\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps ==  that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs + {obj};\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := that.objTimeStamps;\n        }\n        constructor clearDirty(that: TMSystem, writeSet: set<MemoryObject>)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs - writeSet\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps ==  that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs - writeSet;\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := that.objTimeStamps;\n        }\n        constructor acquireLock(that: TMSystem, o: MemoryObject)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs + {o}\n            ensures objTimeStamps == that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs + {o};\n            objTimeStamps := that.objTimeStamps;\n        }\n        constructor releaseLocks(that: TMSystem, objs: set<MemoryObject>)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs - objs\n            ensures objTimeStamps ==  that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs - objs;\n            objTimeStamps := that.objTimeStamps;\n        }\n        constructor updateTimestamps(that: TMSystem, objs: set<MemoryObject>)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps.Keys == that.objTimeStamps.Keys\n                && forall o :: o in that.objTimeStamps ==>\n                if(o in objs) then objTimeStamps[o] != that.objTimeStamps[o] else objTimeStamps[o] == that.objTimeStamps[o]\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := map o | o in that.objTimeStamps ::\n                if(o in objs) then (that.objTimeStamps[o] + 1) else that.objTimeStamps[o];\n        }\n        predicate stateValid(pid: ProcessId, state: ProcessState)\n            requires pid in procStates && state == procStates[pid]\n        {\n            && pid in txQueues\n            && state.currentTx <= |txQueues[pid]|\n            && if state.currentTx == |txQueues[pid]| then (\n                && state.currentOp"
},
{
    "dafny": "ghost function f(n: nat): nat {\n    if n == 0 then 1 \n    else if n%2 == 0 then 1 + 2*f(n/2)\n    else 2*f(n/2)\n}\nmethod mod(n:nat) returns (a:nat) \nensures a == f(n)\n{\n    var x:nat := 0;\n    var y:nat := 1;\n    var k:nat := n;\n    while k > 0\n    invariant f(n) == x + y*f(k)\n    invariant 0 <= k <= n\n    decreases k\n    {\n        assert f(n) == x + y*f(k);\n        if (k%2 == 0) {\n            assert f(n) == x + y*f(k);\n            assert f(n) == x + y*(1+2*f(k/2));\n            assert f(n) == x + y + 2*y*f(k/2);\n            x := x + y;\n            assert f(n) == x + 2*y*f(k/2);\n        } else {\n            assert f(n) == x + y*(2*f(k/2));\n            assert f(n) == x + 2*y*f(k/2);\n        }\n        y := 2*y;\n        assert f(n) == x + y*f(k/2);\n        k := k/2;\n        assert f(n) == x + y*f(k);\n    }\n    assert k == 0;\n    assert f(n) == x+y*f(0);\n    assert f(n) == x+y;\n    a := x+y;\n}"
},
{
    "dafny": "method Main() {\n  UnusedLabel();\n  var c := new C;\n  c.x := 4;\n  c.LabelUsedInGhostCode();  \n  print c.x, \"\\n\";\n}\nmethod UnusedLabel()\n{\n  label foo: {}\n}\nclass C {\n  var x: int\n  method LabelUsedInGhostCode()\n    modifies this\n  {\n    x := x + 2;\n    label A:\n    x := x + 1;\n    label B:\n    x := x + 3;\n    assert x == old(x) + 6;\n    assert x == old@A(x) + 4;\n    assert old@B(x) + x == 2 * old(x) + 9;\n  }\n}"
},
{
    "dafny": "method Main() {\n  print \"Hello wordny\";\n}\nmethod SimpleMethod(x : int, b :bool) {\n  var y := x + 3;\n  print y, \" \", b, \"\\n\";\n}\nmethod MethodWithResults(x : int) returns (r : int, s : int) {\n  r := x;\n  s := x + 3;\n}\npredicate HashMnimum(s : set<int>) {\n  exists m :: m in s && forall x :: x in s ==> m <= x\n}\npredicate sIndexOfMinimum(i : int, s : seq<int>){\n  && 0 <= i < |s|\n}\nnewtype int32 = x : int | -0x8000_0000 <= x < 0x800000\nmethod Example1s(){\n  var a : int;\n  var b : int32;\n  var c : bv32;\n  a := 25;\n  b := 25;\n  c := 25;\n  var e;\n  e := 25 as int32;\n}\nmethod Combine(a : set<real>, b : set<real>) returns (c : set<real>){\n  c := a + b;\n  assert |c| <= |a| + |b|;\n  c := c + {2.0, 37.3};\n}\nmethod Suffle(s : seq<char>) returns (r : string) {\n  var n := |s| / 2;\n  r := s[n..] + ['a','b'] + s[..n] + \"xyz\";\n}\nmethod Squares(n : nat){\n  var s := set i | 0  <= i < n;\n  var t := set i | 0  <= i < n :: i * i;\n  var m := map i | 0 <= i < n :: i * i;\n  var q := seq(n, i => i * i); \n}\ndatatype List<X> = Nil |  Cons(head: X, tail : List<X>)\ndatatype Rainbow = L | G | W\ndatatype Expr = Const(value : int) | Plus(0 : Expr, 1 : Expr)\ndatatype Record = Record(name: string, age:nat)\nmethod Print(expr: Expr){\n  match expr\n  case Const(value) => print value;\n  case Plus(left,right) => Print(left); print \" + \"; Print(right);\n}\nmethod Double(expr:Expr){\n  if expr.Const? {\n    var u := expr.(value := 2 * expr.value);\n  }\n}\ndatatype Macklemore = Macklemore(rhyme:string) \ncodatatype Stream<X> = Next(head : X, tail: Stream<X>)\ntype Even = x : int | x % 2 == 0\nclass Cell {\n  var data : int\n}"
},
{
    "dafny": "method Division(x : int, y : int) returns (q : int, r : int)\n  requires x >= 0\n  requires y > 0\n  ensures q * y + r == x\n  ensures 0 <= r < y; \n{\n  q := 0;\n  r := x;\n  while (r >= y) \n    invariant q * y + r == x\n    invariant r >= 0;\n    decreases r;\n  {\n    r := r - y;\n    q := q + 1;\n  }\n}"
},
{
    "dafny": "newtype uint32 = i:int | 0 <= i < 0x100000000\nclass MyClass {\n  var a: uint32\n  const b: uint32\n  const c:uint32 := 17\n  static const d: uint32\n  static const e:uint32 := 18\n  var ar: array<uint32>\n  constructor (x: uint32)\n    requires x < 100\n    ensures this.a < 300\n    ensures this.b < 300\n    ensures fresh(this.ar)\n  {\n    a := 100 + x;\n    b := 200 + x;\n    ar := new uint32[5];\n  }\n  function F(): uint32 { 8 }\n  static function G(): uint32 { 9 }\n  method M() returns (r: uint32) { r := 69; }\n  static method N() returns (r: uint32) { return 70; }\n  method stuffWithAr()\n    modifies this\n    modifies this.ar\n  {\n    print \"stuffWithAr\\n\";\n    this.ar := new uint32[5];\n    this.ar[0] := 5;\n    print this.ar[0];\n    print \"\\n\";\n  }\n}\nmethod CallEm(c: MyClass, t: MyClass, i: MyClass)\n  requires c.a as int + t.a as int + i.a as int < 1000\n  ensures c.ar == old(c.ar)\n  modifies c, t, i\n{\n  print c.a, \" \", t.a, \" \", i.a, \" \";\n  c.a := c.a + 3;\n  t.a := t.a + 3;\n  i.a := i.a + 3;\n  print c.a, \" \", t.a, \" \", i.a, \"\\n\";\n  var u;\n  print c.b, \" \";\n  print c.c, \" \";\n  print c.d, \" \";\n  print c.e, \" \";\n  print c.F(), \" \";\n  print c.G(), \" \";\n  u := c.M();\n  print u, \" \";\n  u := c.N();\n  print u, \"\\n\";\n  print t.b, \" \";\n  print t.c, \" \";\n  print t.d, \" \";\n  print t.e, \" \";\n  print t.F(), \" \";\n  print t.G(), \" \";\n  u := t.M();\n  print u, \" \";\n  u := t.N();\n  print u, \"\\n\";\n  print i.b, \" \";\n  print i.c, \" \";\n  print i.d, \" \";\n  print i.e, \" \";\n  print i.F(), \" \";\n  print i.G(), \" \";\n  u := i.M();\n  print u, \" \";\n  u := i.N();\n  print u, \"\\n\";\n  print MyClass.d, \" \";\n  print MyClass.e, \" \";\n  print MyClass.G(), \" \";\n  u := MyClass.N();\n  print u, \"\\n\";\n  print MyClass.d, \" \";\n  print MyClass.e, \" \";\n  print MyClass.G(), \" \";\n  u := MyClass.N();\n  print u, \"\\n\";\n  print MyClass.d, \" \";\n  print MyClass.e, \" \";\n  print MyClass.G(), \" \";\n  u := MyClass.N();\n  print u, \"\\n\";\n}\nmethod TestMyClass()\n{\n  var c := new MyClass(3);\n  var t := new MyClass(2);\n  var i := new MyClass(2);\n  print t == t, \" \", i == i, \" \", i == t, \"\\n\";\n  var t2 : MyClass := t;\n  var t3 : MyClass;\n  t3 := t;\n  CallEm(c, t, i);\n  c.stuffWithAr();\n}\nclass AClass {\n  var x:uint32\n  var y:uint32\n  constructor()\n  {\n    x := 0;\n    y := 0;\n  }\n}\nmethod TestEquality() {\n  var a := new AClass();\n  a.x := 25;\n  a.y := 15;\n  if a == a {\n    print \"EqualityReflexive: This is expected\\n\";\n  } else {\n    print \"EqualityReflexive: This is unexpected\\n\";\n    assert false;\n  }\n  var b := new AClass();\n  b.x := 1;\n  b.y := 2;\n  if a == b {\n    print \"ClassAndPtrDiffer: This is unexpected\\n\";\n    assert false;\n  } else {\n    print \"ClassAndPtrDiffer: This is expected\\n\";\n  }\n  var c := new AClass();\n  c.x := 25;\n  c.y := 15;\n  if a == c {\n    print \"DeepEquality: This is unexpected\\n\";\n    assert false;\n  } else {\n    print \"DeepEquality: This is expected\\n\";\n  }\n}\nmethod Main() {\n  TestMyClass();\n  TestEquality();\n}"
},
{
    "dafny": "method Main() {\n   var i := 2;\n   var s := [1, i, 3, 4, 5];\n   print |s|; \n   assert s[|s|-1] == 5; \n   assert s[|s|-1..|s|] == [5]; \n   assert s[1..] == [2, 3, 4, 5]; \n   assert s[..|s|-1] == [1, 2, 3, 4]; \n   assert s == s[0..] == s[..|s|] == s[0..|s|] == s[..]; \n}\nmethod foo (s: seq<int>)\nrequires |s| > 1\n{\n    print s[1];\n}"
},
{
    "dafny": "type role = string\ndatatype message = Nil | Aenc(aencMsg:message,aencKey:message) | Senc(m1:message,m2:message) | K(r1:role,r2:role) | Pk(r:role) | Sk(r:role) | Str(r:role) | Var(n:role) | Pair(m1:message,m2:message)\ntype channel = array<message>\nmethod AliceSendMsg_1(c:channel,advKnw:set<message>)\n    requires c.Length>0\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw\n    ensures c[0] != Nil\n    modifies c\n{\n    var msg := Pair(Str(\"A\"),Str(\"B\"));\n    c[0] := msg;\n}\nmethod ServerSendMsg_1(c:channel,advKnw:set<message>)\n    requires c.Length>0\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw\n    ensures c[0] != Nil\n    modifies c\n{\n    var aencMsg := Pair(Pk(\"B\"),Str(\"B\"));\n    var msg := Aenc(aencMsg,Pk(\"S\"));\n    c[0] := msg;\n}\nmethod AliceSendMsg_2(c:channel,advKnw:set<message>)\n    requires c.Length>0\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw\n    ensures c[0] != Nil\n    modifies c\n{\n    var aencMsg := Pair(Var(\"Na\"),Str(\"A\"));\n    var msg := Aenc(aencMsg,Pk(\"B\"));\n    c[0] := msg;\n}\nmethod BobSendMsg_1(c:channel,advKnw:set<message>)\n    requires c.Length>0\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw\n    ensures c[0] != Nil\n    modifies c\n{\n    var msg := Pair(Str(\"B\"),Str(\"A\"));\n    c[0] := msg;\n}\nmethod ServerSendMsg_2(c:channel,advKnw:set<message>)\n    requires c.Length>0\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw\n    ensures c[0] != Nil\n    modifies c\n{\n    var aencMsg := Pair(Pk(\"A\"),Str(\"A\"));\n    var msg := Aenc(aencMsg,Pk(\"S\"));\n    c[0] := msg;\n}\nmethod BobSendMsg_2(c:channel,advKnw:set<message>)\n    requires c.Length>0\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw\n    ensures c[0] != Nil\n    modifies c\n{\n    var aencMsg := Pair(Pair(Var(\"Na\"),Var(\"Nb\")),Str(\"B\"));\n    var msg := Aenc(aencMsg, Pk(\"A\"));\n    c[0] := msg;\n}\nmethod AliceSendMsg_3(c:channel,advKnw:set<message>)\n    requires c.Length>0\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw\n    ensures c[0] != Nil\n    modifies c\n{\n    var aencMsg := Var(\"Nb\");\n    var msg := Aenc(aencMsg,Pk(\"B\"));\n    c[0] := msg;\n}\nmethod IntruderGetMsg(c:channel,advKnw:set<message>,i:int) returns (advKnw1:set<message>)\n    requires c.Length > 0\n    requires c[0] != Nil && c[0] != Var(\"Nb\")\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw1    \n    ensures c[0] == Nil\n    modifies c\n{   \n    advKnw1 := advKnw + {c[0]};\n    c[0]:=Nil;\n}\nmethod IntruderSendMsg(c:channel,m:message,advKnw:set<message>)\n    requires c.Length > 0\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw\n    requires m != Nil\n    requires m in advKnw\n    ensures c[0]!=Nil\n    modifies c\n{\n    c[0] :=m;\n} \nmethod aencrtpy(aencMsg:message,aencKey:message,advKnw:set<message>) returns (advKnw1:set<message>)\n    requires aencMsg in advKnw\n    requires aencKey in advKnw\n    requires Aenc(aencMsg,aencKey) !in advKnw\n    ensures Aenc(aencMsg,aencKey) in advKnw1\n{\n    var aencMsg1:=Aenc(aencMsg,aencKey);\n    advKnw1:=advKnw+{aencMsg1};\n}\nmethod dencrtpy(msg:message,aencKey:message,aencMsg:message,advKnw:set<message>) returns (advKnw1:set<message>)\n    requires msg in advKnw\n    requires aencKey in advKnw\n    requires aencMsg != Var(\"Nb\")\n    requires aencMsg !in advKnw\n    requires msg == Aenc(aencMsg,aencKey)\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw1\n    ensures aencMsg in advKnw1\n{\n     advKnw1:=advKnw+{aencMsg};\n}\nmethod sencrtpy(sencMsg:message,sencKey:message,advKnw:set<message>) returns (advKnw1:set<message>)\n    requires sencMsg in advKnw\n    requires sencKey in advKnw\n    requires Senc(sencMsg,sencKey) !in advKnw\n    ensures Senc(sencMsg,sencKey) in advKnw1\n{\n        var sencMsg1:=Senc(sencMsg,sencKey);\n        advKnw1:=advKnw+{sencMsg1};\n}\nmethod dsencrtpy(msg:message,sencKey:message,sencMsg:message,advKnw:set<message>) returns (advKnw1:set<message>)\n    requires msg in advKnw\n    requires sencKey in advKnw\n    requires sencMsg !in advKnw\n    requires msg == Senc(sencMsg,sencKey)\n    requires sencMsg != Var(\"Nb\")\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw1\n    ensures sencMsg in advKnw1\n{\n        advKnw1:=advKnw+{sencMsg};\n}\nmethod Separate(pairMsg:message,m1:message,m2:message,advKnw:set<message>)returns (advKnw1:set<message>)\n    requires pairMsg in advKnw\n    requires pairMsg == Pair(m1,m2)\n    requires m1 !in advKnw || m2 !in advKnw\n    requires m1 != Var(\"Nb\") && m2 != Var(\"Nb\")\n    requires Var(\"Nb\") !in advKnw\n    ensures Var(\"Nb\") !in advKnw1\n    ensures m1 in advKnw1 && m2 in advKnw1\n{\n        advKnw1:=advKnw+{m1,m2};\n}\nmethod Pairing(m1:message,m2:message,advKnw:set<message>) returns (advKnw1:set<message>)\n    requires m1 in advKnw\n    requires m2 in advKnw\n    requires Pair(m1,m2) !in advKnw\n    ensures Pair(m1,m2) in advKnw1\n{ \n    advKnw1:=advKnw+{Pair(m1,m2)};    \n}"
},
{
    "dafny": "method Reverse<T(0)>(arr: array<T>) returns (revarr: array<T>)\n  requires arr.Length >= 0\n{\n  var i := 0;\n  revarr := new T[arr.Length];\n  while (i < arr.Length)\n  invariant 0 <= i <= arr.Length \n  {\n    revarr[i] := arr[arr.Length-1-i];\n    i:= i+1;\n  }\n}\nmethod Main()\n{\n\tvar input := new int[5];\n\tinput[0],input[1],input[2],input[3],input[4] := 1,2,3,4,5;\n\tvar output := Reverse(input);\n\tvar i := 0;\n\twhile i < output.Length\n\tinvariant i <= output.Length\n\t{\n\t\tprint output[i];\n\t\ti := i + 1;\n\t}\n}"
},
{
    "dafny": "class C { }\nghost function f(c: C): C reads c\nghost function g(c: C): C\nghost function h(c: C, i: int): C\nmethod M0(i: int, j: int, sc: set<C>) {\n  assert forall c | c in sc :: true || h(c, i) == h(h(c, j), j);\n}\nmethod M1(f: int -> int, g: int -> int) {\n  assert forall x :: true || f(x) == g(f(x));\n}\nmethod M2(sc: set<C>) {\n  assert forall c | c in sc :: true || f(c) == old(f(f(c)));\n}"
},
{
    "dafny": "method Reverse<T(0)>(arr: array<T>) returns (revarr: array<T>)\n  requires arr.Length >= 0\n{\n  var i := 0;\n  revarr := new T[arr.Length];\n  while (i < arr.Length)\n  invariant 0 <= i <= arr.Length \n  {\n    revarr[i] := arr[arr.Length-1-i];\n    i:= i+1;\n  }\n}"
},
{
    "dafny": "class {:autocontracts} UserTable\n{\n    var id: int;\n    var username: string;\n    var password: string;\n    var email: string;\n      constructor(user: string, pass: string, email: string)\n      requires |user| > 0 && |pass| > 0 && |email| > 0;\n      ensures this.id == -1 && this.username == user && this.password == pass && this.email == email;\n      {\n          this.id := -1;\n          this.username := user;\n          this.password := pass;\n          this.email := email;\n      }\n      method SetID(id: int)\n      requires id >= 0 && this.id == -1;\n      ensures this.id == id;\n      ensures this.username == old(this.username) && this.password == old(this.password) && this.email == old(this.email);\n      { this.id := id; }\n}\nclass {:autocontracts} BusinessTable\n{\n    var id: int;\n    var userID: int;\n    var title: string;\n    var email: string;\n    constructor(user: int, business_name: string, email: string)\n    requires user >= 0 && |business_name| > 0 && |email| > 0;\n    ensures this.id == -1 && this.userID == user && this.title == business_name && this.email == email;\n    {\n        this.id := -1;\n        this.userID := user;\n        this.title := business_name;\n        this.email := email;\n    }\n    method SetID(id: int)\n    requires id >= 0 && this.id == -1;\n    ensures this.id == id;\n    ensures this.userID == old(this.userID) && this.title == old(this.title) && this.email == old(this.email);\n    {\n        this.id := id;\n    }\n}\npredicate BidderRequired(id: int, BusinessDB: array<BusinessTable>)\nreads BusinessDB;\nreads set i | 0 <= i < BusinessDB.Length :: BusinessDB[i];\n{\n    exists k:: 0 <= k < BusinessDB.Length && BusinessDB[k].userID == id\n}\nclass {:autocontracts} Session\n{\n    var userID: int;\n    var username: string;\n    var businessID: int;\n    var bidder: bool;\n    predicate LoginRequired()\n    { |this.username| > 0 && this.userID >= 0 }\n    constructor()\n    ensures this.userID == -1 && this.username == \"\" && this.businessID == -1 && !this.bidder;\n    {\n        this.userID := -1; \n        this.username := \"\"; \n        this.businessID := -1; \n        this.bidder := false; \n    }\n    method Login(user: int, username: string, BusinessDB: array<BusinessTable>)\n    requires user >= 0 && |username| > 0;\n    requires this.userID == -1 && this.username == \"\" && !this.bidder && this.businessID == -1;\n    ensures BusinessDB[..] == old(BusinessDB[..]);\n    ensures this.userID == user && this.username == username;\n    ensures this.businessID == old(this.businessID);\n    ensures LoginRequired();\n    ensures this.bidder ==> exists i:: 0 <= i < BusinessDB.Length && BusinessDB[i].userID == user;\n    ensures !this.bidder ==> forall i:: 0 <= i < BusinessDB.Length ==> BusinessDB[i].userID != user;\n    {\n        this.userID := user;\n        this.username := username;\n        this.bidder := exists i:: 0 <= i < BusinessDB.Length && BusinessDB[i].userID == user;\n    }\n    method AccessBusiness(BusinessDB: array<BusinessTable>, business_name: string) returns (err: bool)\n    requires this.bidder;\n    ensures BusinessDB[..] == old(BusinessDB[..])\n    ensures this.userID == old(this.userID) && this.username == old(this.username) && this.bidder == old(this.bidder);\n    ensures err ==> this.businessID == -1 && forall i:: 0 <= i < BusinessDB.Length ==> (BusinessDB[i].userID != this.userID || BusinessDB[i].title != business_name);\n    ensures !err ==> 0 <= this.businessID < BusinessDB.Length && BusinessDB[this.businessID].title == business_name && BusinessDB[this.businessID].userID == this.userID;\n    {\n        this.businessID := -1;\n        err := true;\n        var i := 0;\n        while (i < BusinessDB.Length && err)\n        invariant 0 <= i <= BusinessDB.Length;\n        invariant err ==> this.businessID == -1 && forall j:: 0 <= j < i ==> (BusinessDB[j].userID != this.userID || BusinessDB[j].title != business_name);\n        invariant !err ==> 0 <= this.businessID < BusinessDB.Length && BusinessDB[this.businessID].userID == this.userID && BusinessDB[this.businessID].title == business_name;\n        {\n            if (BusinessDB[i].userID == this.userID && BusinessDB[i].title == business_name)\n            {\n                this.businessID := i;\n                return false;\n            }\n            i := i + 1;\n        }\n    }\n    method Logout()\n    requires this.userID >= 0 && |this.username| > 0;\n    requires LoginRequired();\n    ensures this.userID == -1 && this.username == \"\" && this.businessID == -1 && !this.bidder;\n    {\n        this.userID := -1;\n        this.username := \"\";\n        this.businessID := -1;\n        this.bidder := false;\n    }\n}\nmethod SignUp(UserDB: array<UserTable>, newUser: UserTable) returns (err: bool)\nensures UserDB[..] == old(UserDB[..]);\nensures err ==> exists i:: 0 <= i < UserDB.Length && (UserDB[i].username == newUser.username || UserDB[i].email == newUser.email);\nensures !err ==> forall i:: 0 <= i < UserDB.Length ==> (UserDB[i].username != newUser.username && UserDB[i].email != newUser.email);\n{\n    err := false;\n    var i := 0;\n    while (i < UserDB.Length && !err)\n    invariant 0 <= i <= UserDB.Length;\n    invariant err ==> exists j:: 0 <= j < i && (UserDB[j].username == newUser.username || UserDB[j].email == newUser.email);\n    invariant !err ==> forall j:: 0 <= j < i ==> (UserDB[j].username != newUser.username && UserDB[j].email != newUser.email);\n    {\n        if (UserDB[i].username == newUser.username)\n        {\n            err := true;\n        }\n        if (UserDB[i].email == newUser.email)\n        {\n            err := true;\n        }\n        i := i + 1;\n    }\n}\nmethod LinkBusiness(BusinessDB: array<BusinessTable>, newBusiness: BusinessTable) returns (err: bool)\nensures BusinessDB[..] == old(BusinessDB[..]);\nensures err ==> exists i:: 0 <= i < BusinessDB.Length && BusinessDB[i].title == newBusiness.title;\nensures !err ==> forall i:: 0 <= i < BusinessDB.Length ==> BusinessDB[i].title != newBusiness.title;\n{\n    err := false;\n    var i := 0;\n    while (i < BusinessDB.Length && !err)\n    invariant 0 <= i <= BusinessDB.Length;\n    invariant err ==> exists j:: 0 <= j < i && BusinessDB[j].title == newBusiness.title;\n    invariant !err ==> forall j:: 0 <= j < i ==> BusinessDB[j].title != newBusiness.title;\n    {\n        if (BusinessDB[i].title == newBusiness.title)\n        {\n            err := true;\n        }\n        i := i + 1;\n    }\n}\nmethod InsertBusiness(BusinessDB: array<BusinessTable>, newBusiness: BusinessTable, tempBusinesses: array<BusinessTable>) returns (newBusinessDB: array<BusinessTable>)\nmodifies tempBusinesses;\nrequires tempBusinesses.Length == BusinessDB.Length + 1;\nensures newBusinessDB.Length == BusinessDB.Length + 1;\nensures forall i:: 0 <= i < old(BusinessDB.Length) ==> newBusinessDB[i] == old(BusinessDB[i]);\nensures newBusinessDB[old(BusinessDB.Length)] == newBusiness;\n{\n    forall i | 0 <= i < BusinessDB.Length { tempBusinesses[i] := BusinessDB[i]; }\n    tempBusinesses[BusinessDB.Length] := newBusiness;\n    return tempBusinesses;\n}\nmethod TestBusiness()\n{\n    var session := new Session();\n    var Businesses: array<BusinessTable> := new BusinessTable[0];\n    var tempBusiness := new BusinessTable(0, \"tmp\", \"tmp\");\n    var admin := new UserTable(\"admin\", \"pass\", \"admin@admin.com\");\n    assert admin.username == \"admin\" && admin.password == \"pass\" && admin.email == \"admin@admin.com\";\n    admin.SetID(0);\n    assert admin.username == \"admin\" && admin.password == \"pass\" && admin.email == \"admin@admin.com\" && admin.id == 0;\n    var Users: array<UserTable> := new UserTable[1][admin];\n    session.Login(admin.id, admin.username, Businesses);\n    assert session.username == admin.username && session.userID == admin.id && !session.bidder;\n    var b1 := new BusinessTable(admin.id, \"Flourist\", \"flou@rist.com\");\n    var err_linkb := LinkBusiness(Businesses, b1);\n    assert !err_linkb;\n    var tempBusinessDB: array<BusinessTable> := new BusinessTable[Businesses.Length + 1][tempBusiness];\n    b1.SetID(Businesses.Length);\n    Businesses := InsertBusiness(Businesses, b1, tempBusinessDB);\n    assert Businesses.Length == 1 && Businesses[0] == b1;\n    assert BidderRequired(session.userID, Businesses);\n    session.Logout();\n    assert session.userID == -1 && session.username == \"\" && session.businessID == -1 && !session.bidder;\n    session.Login(admin.id, admin.username, Businesses);\n    assert session.username == admin.username && session.userID == admin.id && session.bidder;\n    assert Businesses.Length == 1 && Businesses[0] == b1 && Businesses[0].title == \"Flourist\" && Businesses[0].userID == admin.id;\n    var err_session_business := session.AccessBusiness(Businesses, \"Flourist\");\n    assert !err_session_business && session.businessID == b1.id;\n}"
},
{
    "dafny": "codatatype Stream<T> = Cons(head: T, tail: Stream)\nfunction zeros(): Stream<int> { Cons(0, zeros()) }\nfunction ones(): Stream<int> { Cons(1, ones()) }\nfunction blink(): Stream<int> { Cons(0, Cons(1, blink())) }\nfunction zip(a: Stream, b: Stream): Stream { Cons(a.head, zip(b, a.tail)) }\ncolemma BlinkZipProperty()\n  ensures zip(zeros(), ones()) == blink();\n{\n    BlinkZipProperty();\n}\ndatatype Bit = O | I\nfunction bitnot(b: Bit): Bit\n{\n  if b == O then I else O\n}\nfunction not(s: Stream<Bit>): Stream<Bit>\n{\n  Cons(bitnot(s.head), not(s.tail))\n}\nfunction morse(): Stream<Bit>\nfunction morseTail(): Stream<Bit>\nlemma MorseProperties()\n  ensures morse().head == O;\n  ensures morseTail() == morse().tail;\n  ensures morseTail().head == I;\n  ensures morseTail().tail == zip(morseTail(), not(morseTail()));\nfunction f(s: Stream<Bit>): Stream<Bit>\n{\n  Cons(s.head, Cons(bitnot(s.head), f(s.tail)))\n}\ncolemma FProperty(s: Stream<Bit>)\n  ensures f(s) == zip(s, not(s));\n{\n  calc {\n    zip(s, not(s));\n    Cons(s.head, zip(not(s), s.tail));\n    Cons(s.head, Cons(not(s).head, zip(s.tail, not(s).tail)));\n  }\n  FProperty(s.tail);\n}\nlemma Fixpoint()\n  ensures f(morse()) == morse();\n{\n  MorseProperties();\n  FProperty(morseTail());\n}"
},
{
    "dafny": "method has_close_elements(numbers: seq<real>, threshold: real) returns (res: bool)\n  ensures res ==> exists i: int, j: int :: 0 <= i < |numbers| && 0 <= j < |numbers| && i != j && (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) < threshold\n  ensures !res ==> (forall i: int, j: int :: 1 <= i < |numbers| && 0 <= j < i ==>  (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold)\n{\n  res := false;\n  var idx: int := 0;\n  while idx < |numbers| && !res\n    invariant 0 <= idx <= |numbers|\n    invariant !res\n    invariant forall i: int, j: int :: 0 <= i < idx && 0 <= j < i ==> (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold\n  {\n    var idx2: int := 0;\n    while idx2 < idx && !res\n      invariant 0 <= idx <= |numbers|\n      invariant 0 <= idx2 <= idx\n      invariant !res\n      invariant forall j: int :: 0 <= j < idx2 ==> (if numbers[idx] - numbers[j] < 0.0 then numbers[j] - numbers[idx] else numbers[idx] - numbers[j]) >= threshold\n    {\n      var distance :=  (if numbers[idx2] - numbers[idx] < 0.0 then numbers[idx] - numbers[idx2] else numbers[idx2] - numbers[idx]);\n      if distance < threshold  {\n        res := true;\n        return;\n      }\n      idx2 := idx2 + 1;\n    }\n    idx := idx + 1;\n  }\n}"
},
{
    "dafny": "module InductiveThings {\n  predicate P(x: int)\n  predicate Q(x: int)\n  inductive predicate A(x: int)\n  {\n    P(x) || B(x+1)\n  }\n  inductive predicate B(x: int)\n  {\n    Q(x) || A(x+1)\n  }\n  inductive lemma AA(x: int)  \n    requires A(x)\n  {\n    if B(x+1) {  \n      BB(x+1);\n    }\n  }\n  inductive lemma BB(x: int)  \n    requires B(x)\n  {\n    if A(x+1) {  \n      AA(x+1);\n    }\n  }\n}\nmodule CoThings {\n  copredicate A(x: int)\n  {\n    B(x+1)\n  }\n  copredicate B(x: int)\n  {\n    A(x+1)\n  }\n  colemma AA(x: int)  \n    ensures A(x)\n  {\n    BB(x+1);\n    assert B(x+1);  \n  }\n  colemma BB(x: int)  \n    ensures B(x)\n  {\n    AA(x+1);\n    assert A(x+1);  \n  }\n}"
},
{
    "dafny": "datatype BloodType = AP | AN | BP | BN | ABP | ABN | OP | ON\nclass Blood {\n  var blood_id: int;\n  var blood_type: BloodType;\n  var volume: int;\n  var suitablity: bool;\n  var use_by_date: int;\n  var location: string;\n  var donor_name: string;\n  var donor_email: string;\n  var ordered: bool;\n  predicate Valid()\n  reads this;\n  {\n    volume > 0 && use_by_date > 0 &&\n    location != \"\" && donor_name != \"\" && donor_email != \"\"\n  }\n  constructor (id: int, b: BloodType, v: int, s: bool, u: int, \n    l: string, dn: string, de: string, o: bool) \n  requires v > 0 && u > 0;\n  requires l != \"\" && dn != \"\" && de != \"\"\n  ensures Valid();\n  modifies this;\n  {\n    blood_id := id;\n    blood_type := b;\n    volume := v;\n    suitablity := s;\n    use_by_date := u;\n    location := l;\n    donor_name := dn;\n    donor_email := de;\n    ordered := o;\n  }\n  method OrderBlood()\n  requires Valid();\n  ensures Valid();\n  requires ordered == false;\n  ensures ordered == true;\n  modifies this;\n  {\n    ordered := true;\n  }\n}\npredicate isRequestable(s: seq<Blood>, cd: int)\nrequires forall j :: 0 <= j < |s| ==> s[j] != null && s[j].Valid();\nreads s;\nreads set x | x in s[..];\n{\n  forall j :: 0 <= j < |s| ==> !s[j].ordered &&\n    s[j].suitablity && cd <= s[j].use_by_date\n}\npredicate isDisposable(s: seq<Blood>, cd: int)\nrequires forall j :: 0 <= j < |s| ==> s[j] != null && s[j].Valid();\nreads s;\nreads set x | x in s[..];\n{\n  forall j :: 0 <= j < |s| ==> !s[j].ordered &&\n    (!s[j].suitablity || cd > s[j].use_by_date)\n}\npredicate isOrdered(s: seq<Blood>)\nrequires forall j :: 0 <= j < |s| ==> s[j] != null && s[j].Valid();\nreads s;\nreads set x | x in s[..];\n{\n  forall j :: 0 <= j < |s| ==> s[j].ordered\n}\nmethod GetRequestableBlood(s1: seq<Blood>, cd: int) returns (s2: seq<Blood>)\nrequires forall j :: 0 <= j < |s1| ==> s1[j] != null && s1[j].Valid();\nensures forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\nensures 0 <= |s2| <= |s1|;\nensures isRequestable(s2, cd);\n{\n  s2 := [];\n  var i := 0;\n  while i < |s1|\n  invariant 0 <= |s2| <= i <= |s1|;\n  invariant forall j :: 0 <= j < |s1| ==> s1[j] != null && s1[j].Valid();\n  invariant forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\n  invariant forall j :: 0 <= j < |s2| ==> !s2[j].ordered &&\n    s2[j].suitablity && cd <= s2[j].use_by_date;\n  decreases |s1| - i;\n  {\n    if !s1[i].ordered && s1[i].suitablity \n      && cd <= s1[i].use_by_date {\n      var s3 := [s1[i]];\n      s2 := s2 + s3;\n    }\n    i := i + 1;\n  }\n}\nmethod GetDisposableBlood(s1: seq<Blood>, cd: int) returns (s2: seq<Blood>)\nrequires forall j :: 0 <= j < |s1| ==> s1[j] != null && s1[j].Valid();\nensures forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\nensures 0 <= |s2| <= |s1|;\nensures isDisposable(s2, cd);\n{\n  s2 := [];\n  var i := 0;\n  while i < |s1|\n  invariant 0 <= |s2| <= i <= |s1|;\n  invariant forall j :: 0 <= j < |s1| ==> s1[j] != null && s1[j].Valid();\n  invariant forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\n  invariant forall j :: 0 <= j < |s2| ==> !s2[j].ordered &&\n    (!s2[j].suitablity || cd > s2[j].use_by_date);\n  decreases |s1| - i;\n  {\n    if !s1[i].ordered && (!s1[i].suitablity \n      || cd > s1[i].use_by_date) {\n      var s3 := [s1[i]];\n      s2 := s2 + s3;\n    }\n    i := i + 1;\n  }\n}\nmethod GetOrderedBlood(s1: seq<Blood>) returns (s2: seq<Blood>)\nrequires forall j :: 0 <= j < |s1| ==> s1[j] != null && s1[j].Valid();\nensures forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\nensures 0 <= |s2| <= |s1|;\nensures isOrdered(s2);\n{\n  s2 := [];\n  var i := 0;\n  while i < |s1|\n  invariant 0 <= |s2| <= i <= |s1|;\n  invariant forall j :: 0 <= j < |s1| ==> s1[j] != null && s1[j].Valid();\n  invariant forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\n  invariant forall j :: 0 <= j < |s2| ==> s2[j].ordered;\n  decreases |s1| - i;\n  {\n    if s1[i].ordered {\n      var s3 := [s1[i]];\n      s2 := s2 + s3;\n    }\n    i := i + 1;\n  }\n}\nmethod Main() \n{\n  var b1 := new Blood(1, AP, 3, true, 100, \"UNSW\", \"John Doe\", \"Donor01@gmail.com\", false);\n  var b2 := new Blood(2, AN, 4, true, 90, \"UNSW\", \"Steve Doe\", \"Donor02@gmail.com\", true);\n  var b3 := new Blood(3, BN, 8, true, 70, \"UNSW\", \"Kate Doe\", \"Donor03@gmail.com\", false);\n  var b4 := new Blood(4, AP, 8, false, 60, \"UNSW\", \"Kale Doe\", \"Donor04@gmail.com\", true);\n  var b5 := new Blood(5, OP, 4, true, 70, \"UNSW\", \"Peter Doe\", \"Donor05@gmail.com\", false);\n  var b6 := new Blood(6, AP, 10, true, 40, \"UNSW\", \"Parker Doe\", \"Donor06@gmail.com\", false);\n  assert b1 != null && b1.Valid();\n  assert b2 != null && b2.Valid();\n  assert b3 != null && b3.Valid();\n  assert b4 != null && b4.Valid();\n  assert b5 != null && b5.Valid();\n  assert b6 != null && b6.Valid();\n  var s1: seq<Blood> := [b1, b2, b3, b4, b5, b6];\n  assert s1[0] == b1 && s1[0] != null && s1[0].Valid();\n  assert s1[1] == b2 && s1[1] != null && s1[1].Valid();\n  assert s1[2] == b3 && s1[2] != null && s1[2].Valid();\n  assert s1[3] == b4 && s1[3] != null && s1[3].Valid();\n  assert s1[4] == b5 && s1[4] != null && s1[4].Valid();\n  assert s1[5] == b6 && s1[5] != null && s1[5].Valid();\n  assert forall j :: 0 <= j < |s1| ==> s1[j] != null && s1[j].Valid();\n  var s2 := GetRequestableBlood(s1, 50);\n  assert isRequestable(s2, 50);\n  var i := 0;\n  print \"Requestable Blood\", \"\\n\";\n  while i < |s2|\n  invariant 0 <= i <= |s2|\n  invariant forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\n  decreases |s2| - i;\n  {\n    print s2[i].blood_id, \" suitablity: \", s2[i].suitablity, \" use_by_date: \", \n      s2[i].use_by_date, \" ordered status: \", s2[i].ordered, \"\\n\";\n    i := i + 1;\n  }\n  s2 := GetDisposableBlood(s1, 50);\n  assert isDisposable(s2, 50);\n  i := 0;\n  print \"Disposable Blood\", \"\\n\";\n  while i < |s2|\n  invariant 0 <= i <= |s2|\n  invariant forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\n  decreases |s2| - i;\n  {\n    print s2[i].blood_id, \" suitablity: \", s2[i].suitablity, \" use_by_date: \", \n      s2[i].use_by_date, \" ordered status: \", s2[i].ordered, \"\\n\";\n    i := i + 1;\n  }\n  s2 := GetOrderedBlood(s1);\n  assert isOrdered(s2);\n  i := 0;\n  print \"Ordered Blood\", \"\\n\";\n  while i < |s2|\n  invariant 0 <= i <= |s2|\n  invariant forall j :: 0 <= j < |s2| ==> s2[j] != null && s2[j].Valid();\n  decreases |s2| - i;\n  {\n    print s2[i].blood_id, \" suitablity: \", s2[i].suitablity, \" use_by_date: \", \n      s2[i].use_by_date, \" ordered status: \", s2[i].ordered, \"\\n\";\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "datatype Colour = RED | BLUE | YELLOW | GREEN \nmethod FlagSort(flag:array<Colour>) \n    modifies flag;\n    ensures forall x::  0 < x < flag.Length ==> \n        (flag[x] == RED ==> flag[x-1] == RED) \n    ensures forall x::  0 < x < flag.Length ==> \n        (flag[x] == BLUE ==> \n            (flag[x-1] == BLUE || flag[x-1] == RED )) \n    ensures forall x::  0 < x < flag.Length ==> \n        (flag[x] == YELLOW ==> \n            (\n                flag[x-1] == BLUE || \n                flag[x-1] == RED  ||\n                flag[x-1] == YELLOW \n            )\n        ) \n    ensures forall x::  0 < x < flag.Length ==> \n        (flag[x] == GREEN ==> (\n            flag[x-1] == BLUE   ||\n            flag[x-1] == RED    || \n            flag[x-1] == YELLOW || \n            flag[x-1] == GREEN\n        )) \n{\n    var next := 0;\n    var blue := 0;\n    var yellow := flag.Length; \n    var green := flag.Length; \n    while (next != yellow) \n        decreases yellow + green - next\n        invariant 0 <= blue <= next <= yellow <= green <= flag.Length\n        invariant forall x:: 0      <= x < blue        ==> flag[x] == RED\n        invariant forall x:: blue   <= x < next        ==> flag[x] == BLUE\n        invariant forall x:: yellow <= x < green       ==> flag[x] == YELLOW\n        invariant forall x:: green  <= x < flag.Length ==> flag[x] == GREEN\n    {\n        match (flag[next])\n        {\n            case BLUE => \n                next := next + 1; \n            case RED => \n                flag[blue], flag[next] := flag[next], flag[blue];\n                blue := blue + 1;\n                next := next + 1;\n            case YELLOW => \n                yellow := yellow -1;\n                flag[yellow] , flag[next] := flag[next], flag[yellow];\n            case GREEN => \n                green := green -1;\n                yellow := yellow -1;\n                flag[green] , flag[next] := flag[next], flag[green];\n                if ( yellow != green){\n                    flag[next], flag[yellow]:= flag[yellow],flag[next];\n                }\n        }\n    }\n}"
},
{
    "dafny": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;\n b:=false;\n while (i<v.Length && !b)\n    invariant 0<=i<=v.Length\n    invariant b <==> exists k::0<=k<i && v[k]<0\n    invariant b ==> v[i-1]<0 && positive(v[0..i-1])\n    decreases v.Length - i\n  { \n    b:=(v[i]<0);\n    i:=i+1;\n   }\n  if (b){i:=i-1;}\n}\nmethod mfirstNegative2(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;b:=false;\n while (i<v.Length && !b)\n    invariant 0<=i<=v.Length\n    invariant b ==> i<v.Length && v[i]<0 && !(exists k::0<=k<i && v[k]<0)\n    invariant b <== exists k::0<=k<i && v[k]<0\n    decreases v.Length - i - (if b then 1 else 0)\n  { \n    b:=(v[i]<0);\n    if (!b) {i:=i+1;}\n   }\n}"
},
{
    "dafny": "method Main() {\n  M0();\n  M1();\n  EqualityOfStrings0();\n  EqualityOfStrings1();\n}\nmethod M0()\n{\n  assert {\"x\",\"y\",\"z\"}-{\"y\"} == {\"x\",\"z\"};\n}\nmethod M1()\n{\n  var n :| (\"R\",n) in {(\"R\",2),(\"P\",1)};\n  assert n == 2;\n  print n, \"\\n\";\n}\nmethod EqualityOfStrings0() {\n  assert \"a\" != \"b\";\n}\nmethod EqualityOfStrings1() {\n  assert \"a\" + \"b\" == \"ab\";\n}\nmethod M2()\n{\n  assert !( [0,0] in {[0,2],[1,2]} );\n}\nmethod M3()\n{\n  assert [0,0] !in {[0,2],[1,2]};\n}"
},
{
    "dafny": "method Reverse(a: array<char>) returns (b: array<char>)\nrequires a.Length > 0\nensures a.Length == b.Length\nensures forall k :: 0 <= k < a.Length ==> b[k] == a[(a.Length-1) - k];\n{\n    b := new char[a.Length];\n    assert b.Length == a.Length;\n    var i:= 0;\n    while(i < a.Length)\n    invariant 0<=i<=a.Length\n    invariant forall k :: 0 <= k < i ==> b[k] == a[(a.Length-1) - k]\n    {\n        b[i] := a[(a.Length-1) - i];\n        i := i + 1;\n    }\n}\nmethod Main()\n{\n  var a := new char[8];\n  a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7] := 'd', 'e', 's', 'r', 'e', 'v', 'e', 'r';\n  var b := Reverse(a);\n  assert b[..] == [ 'r', 'e', 'v', 'e', 'r', 's', 'e', 'd' ];\n  print b[..];\n  a := new char[1];\n  a[0] := '!';\n  b := Reverse(a);\n  assert b[..] == [ '!' ];\n  print b[..], '\\n';\n}"
},
{
    "dafny": "method main() returns (t1: int, t2: int, x: int, y: int)\nensures y >= 1\n{\n    x := 1;\n    y := 1;\n    t1 := 0;\n    t2 := 0;\n    while(x <= 100000) \n        invariant x == y;\n    {\n        t1 := x;\n        t2 := y;\n        x := t1 + t2;\n        y := t1 + t2;\n    }\n}"
},
{
    "dafny": "method FindMax(a: array<int>) returns (max: int)\n  requires a != null && a.Length > 0;\n  ensures 0 <= max < a.Length;\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[max];\n{\n  var i := 0;\n  max := 0;\n  while ( i < a.Length )\n    invariant i <= a.Length;\n    invariant max < a.Length;\n    invariant forall k :: 0 <= k < i ==> a[k] <= a[max];\n  {\n    if (a [i] > a[max]) { max := i; }\n    i := i + 1;\n  }\n  return max;\n}"
},
{
    "dafny": "datatype state = I| T| C| E\n  type client=nat\ntype boolean=bool\nclass TopC{\nvar\nx : boolean,\nn : array<state>;\nconstructor (){\n}\n}\nmethod n_Tryinv__1_0(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i==p__Inv4\nrequires   (top.n[i] == I)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := T;\n}\nmethod n_Tryinv__1_1(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i==p__Inv3\nrequires   (top.n[i] == I)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := T;\n}\nmethod n_Tryinv__1_2(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i!=p__Inv3&&i!=p__Inv4\nrequires (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nrequires   (top.n[i] == I)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := T;\n}\nmethod n_Critinv__1_0(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i==p__Inv4\nrequires (!((top.n[p__Inv3] == C) && (top.x == true)))\nrequires   ((top.n[i] == T) && (top.x == true))\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := C;\n  top.x := false;\n}\nmethod n_Critinv__1_1(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i==p__Inv3\nrequires (!((top.n[p__Inv4] == C) && (top.x == true)))\nrequires   ((top.n[i] == T) && (top.x == true))\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := C;\n  top.x := false;\n}\nmethod n_Critinv__1_2(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i!=p__Inv3&&i!=p__Inv4\nrequires (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nrequires   ((top.n[i] == T) && (top.x == true))\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := C;\n  top.x := false;\n}\nmethod n_Exitinv__1_0(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i==p__Inv4\nrequires   (top.n[i] == C)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := E;\n}\nmethod n_Exitinv__1_1(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i==p__Inv3\nrequires   (top.n[i] == C)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := E;\n}\nmethod n_Exitinv__1_2(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i!=p__Inv3&&i!=p__Inv4\nrequires (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nrequires   (top.n[i] == C)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := E;\n}\nmethod n_Idleinv__1_0(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i==p__Inv4\nrequires   (top.n[i] == E)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := I;\n  top.x := true;\n}\nmethod n_Idleinv__1_1(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i==p__Inv3\nrequires   (top.n[i] == E)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := I;\n  top.x := true;\n}\nmethod n_Idleinv__1_2(top:TopC,i:nat,N0:nat,p__Inv3:nat,p__Inv4:nat)\nrequires 0<=i<N0\nrequires N0>0\nrequires top.n.Length==N0\nrequires forall i,j::0<=i<top.n.Length&&0<=j<top.n.Length==>top.n[i]!=top.n[j]\nensures top.n==old(top.n)\nrequires p__Inv3!=p__Inv4&&p__Inv4<N0&& p__Inv3<N0\nrequires i!=p__Inv3&&i!=p__Inv4\nrequires (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nrequires   (top.n[i] == E)\nensures   (!((top.n[p__Inv4] == C) && (top.n[p__Inv3] == C)))\nmodifies top.n\nmodifies top\nmodifies top\n{\n  top.n[i] := I;\n  top.x := true;\n}"
},
{
    "dafny": "method Max(n1: int, n2: int) returns (max: int)\n  ensures n1 > n2 ==> max == n1\n  ensures n2 > n1 ==> max == n2\n  ensures n1 == n2 ==> ( n1 == n2 == max)\n{\n  max := n1;\n  if n2 > max\n  {\n    max := n2;\n  }\n}"
},
{
    "dafny": "method findInEven (a: array<int>, x:int) returns (r:int)\n  requires a != null\n  ensures 0<=r ==> r%2==0 &&  r< a.Length && a[r] == x \n  ensures r<0 ==> forall k :: 0 <= k < a.Length && k%2==0 ==> a[k] != x\n{\n  r := -1;\n  var i := 0;\n  while (i < a.Length)\n    invariant 0 <= i<= a.Length+1 && i%2==0    \n    invariant r<0 ==> forall k :: 0 <= k < i && k%2==0 ==> a[k] != x\n    invariant 0<=r ==> r%2==0 &&  r< a.Length && a[r] == x\n  {\n    if (x == a[i]) { r := i;return; }\n    i := i + 2;\n  }\n  return;\n}"
},
{
    "dafny": "method is_expired(expiry:int, today:int) returns (expired:bool)\nrequires expiry > 0 && today > 0\nensures expiry > today ==> expired == false\nensures expiry <= today ==> expired == true\n{\n    if (expiry > today){\n        expired := false;\n    } else {\n        expired := true;\n    }\n}\nmethod test_is_expired()\n{\n    var today:int;\n    var expiry:int;\n    var retval:bool;\n    today := 10;\n    expiry := 11;\n    retval := is_expired(expiry, today);\n    assert(retval == false);\n    today := 11;\n    expiry := 11;\n    retval := is_expired(expiry, today);\n    assert(retval == true);\n    today := 12;\n    expiry := 11;\n    retval := is_expired(expiry, today);\n    assert(retval == true);\n}"
},
{
    "dafny": "predicate perm(A:seq<int>, B:seq<int>)\n{\n\tmultiset(A) == multiset(B)\n}\npredicate partOrdered(A:array<int>, a:int, b:int)\n\trequires 0 <= a <= b <= A.Length\n\treads A\n{\n\tforall i,j :: a <= i < j < b ==> A[i] <= A[j]\n}\npredicate ordered(A:array<int>)\n\treads A\n{\n\tpartOrdered(A, 0, A.Length)\n}\nmethod selectionSort (A:array<int>)\n\tmodifies A\n\tensures ordered(A)                          \n\tensures perm (A[..], old(A[..]))            \n{\n\tif A.Length > 1\n\t{\n\t\tvar i, j := 0, 0;\n\t\tvar min_idx := i;\n\t\twhile i < A.Length\n\t\tinvariant 0 <= i <= A.Length\n\t\tinvariant 0 <= min_idx < A.Length\n\t\tinvariant perm (A[..], old(A[..]))          \n\t\tinvariant forall k, l :: 0 <= k < i <= l < A.Length ==> A[k] <= A[l]        \n\t\tinvariant partOrdered(A, 0, i)              \n\t\t{\n\t\t\tj := i + 1;\n\t\t\tmin_idx := i;\n\t\t\twhile j < A.Length\n\t\t\tinvariant 1 <= j <= A.Length\n\t\t\tinvariant i <= min_idx < A.Length\n\t\t\tinvariant perm (A[..], old(A[..]))              \n\t\t\tinvariant forall k :: i <= k < j ==> A[k] >= A[min_idx]\n\t\t\t{\n\t\t\t\tif A[j] < A[min_idx]\n\t\t\t\t{\n\t\t\t\t\tmin_idx := j;\n\t\t\t\t}\n\t\t\t\tj := j + 1;\n\t\t\t}\n\t\t\tA[i], A[min_idx] := A[min_idx], A[i];\n\t\t\ti := i + 1;\n\t\t}\n\t}\n}\nmethod Main() {\n\tvar A := new int[10];\n\tA[0],A[1],A[2],A[3],A[4],A[5],A[6],A[7],A[8],A[9] := 4,8,8,3,5,10,9,9,4,7;\n\tprint \"A = \", A[..], \"\\n\";\n\tselectionSort(A);\n\tprint \"A = \", A[..], \"\\n\";\n}"
},
{
    "dafny": "module Commons {\npredicate sorted(a: array<int>)\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod Copy(a: array<int>) returns (b: array<int>) \n    ensures multiset(a[..]) ==  multiset(b[..])\n    ensures a.Length == b.Length\n{ \n    b := new int[a.Length];\n    var i := 0;\n    while i < a.Length \n        decreases a.Length - i\n        invariant a.Length == b.Length\n        invariant 0 <= i <= a.Length\n        invariant forall k :: 0 <= k < i ==> a[k] == b[k]\n    {\n        b[i] := a[i];\n        i := i + 1;\n    }\n    assert a[..] == b[..];\n}\nmethod Swap(a: array<int>, i: int, j: int) \n    modifies a\n    requires 0 <= i < a.Length\n    requires 0 <= j < a.Length\n    ensures forall x :: 0 <= x < a.Length && x != i && x!= j ==> a[x] == old(a[x])\n    ensures a[j] == old(a[i]) && a[i] == old(a[j])\n{\n    var ai, aj := a[i], a[j];\n    a[i] := aj;\n    a[j] := ai;\n}\n}"
},
{
    "dafny": "lemma MergeLShift(v: bv128, i: nat, j: nat)\n  requires i <= 128 && j <= 128 && i + j <= 128\n  ensures v << i << j == v << i + j\nmethod M2(i: nat)\n  requires i <= 64\n{\n  ghost var half: bv128 := 0xffff_ffff_ffff_ffff;\n  MergeLShift(half, 64, 64 - i);\n  assert half << 64 - i << 64 == half << (128 - i);\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n  ensures 0 <= y  \n  ensures 1 <= y + 1\n{\n  if x < 0 {\n    return -x;\n  } else {\n    return x;\n  }\n}\nmethod LessMore(x: int, y: int) returns (sum: int, sub: int)\n  requires y > 0\n  ensures sum > x\n  ensures sub < x\n{\n  sum := x + y;\n  sub := x - y;\n}\nmethod Max(a: int, b: int) returns (c: int)\n  ensures c >= a\n  ensures c >= b\n{\n  c := a;\n  if b > c {\n    c := b;\n  }\n}"
},
{
    "dafny": "function Abs(x:int):int\n{\n    if x >= 0 then x else -x\n}\nmethod IncDec(x: int, y: int) returns (sum: int)\n    ensures sum == x + y\n{\n    sum:=x;\n    var tmp := y;\n    while tmp != 0\n    invariant sum + tmp == x + y;\n    decreases Abs(tmp);\n    {\n        if(tmp > 0){\n            sum := sum + 1;\n            tmp := tmp - 1;\n        }\n        else if(tmp < 0){\n            sum := sum -1;\n            tmp := tmp +1;\n        }\n    }\n}\nmethod Test(){\n    var sum := IncDec(5, 15);\n    assert sum == 20;\n    sum := IncDec(5, -15);\n    assert sum == -10;\n    sum := IncDec(5, 0);\n    assert sum == 5;\n    sum := IncDec(-5, 15);\n    assert sum == 10;\n    sum := IncDec(-5, -15);\n    assert sum == -20;\n    sum := IncDec(-5, 0);\n    assert sum == -5;\n}"
},
{
    "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    calc {\n      x;\n    <=  { assert x <= 0; }\n      0;\n    <  \n      1;\n    ==  \n      More(x);\n    }\n  } else {\n    calc {\n      More(x);\n    ==  \n      More(x - 2) + 3;\n    >  { Increasing(x - 2); }\n      x - 2 + 3;\n    >  \n      x;\n    }\n  }\n}"
},
{
    "dafny": "method random(a: int, b: int) returns (r: int)\n  ensures a <= b ==> a <= r <= b\nlemma eqMultiset_t<T>(t: T, s1: seq<T>, s2: seq<T>)\n  requires multiset(s1) == multiset(s2)\n  ensures t in s1 <==> t in s2\n{\n  calc <==> {\n    t in s1;\n    t in multiset(s1);\n  }\n}\nlemma eqMultiset<T>(s1: seq<T>, s2: seq<T>)\n  requires multiset(s1) == multiset(s2)\n  ensures forall t :: t in s1 <==> t in s2\n{\n  forall t {\n    eqMultiset_t(t, s1, s2);\n  }\n}\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}\nmethod getAllShuffledDataEntries<T(0)>(m_dataEntries: array<T>) returns (result: array<T>)\n  ensures result.Length == m_dataEntries.Length\n  ensures multiset(result[..]) == multiset(m_dataEntries[..])\n{\n  result := new T[m_dataEntries.Length];\n  forall i | 0 <= i < m_dataEntries.Length {\n    result[i] := m_dataEntries[i];\n  }\n  assert result[..] == m_dataEntries[..];\n  var k := result.Length - 1;\n  while (k >= 0)\n    invariant multiset(result[..]) == multiset(m_dataEntries[..])\n  {\n    var i := random(0, k);\n    assert i >= 0 && i <= k;\n    if (i != k) {\n      swap(result, i, k);\n    }\n    k := k - 1;\n  }\n}\nfunction set_of_seq<T>(s: seq<T>): set<T>\n{\n  set x: T | x in s :: x\n}\nlemma in_set_of_seq<T>(x: T, s: seq<T>)\n  ensures x in s <==> x in set_of_seq(s)\nlemma subset_set_of_seq<T>(s1: seq<T>, s2: seq<T>)\n  requires set_of_seq(s1) <= set_of_seq(s2)\n  ensures forall x :: x in s1 ==> x in s2\nmethod getRandomDataEntry<T(==)>(m_workList: array<T>, avoidSet: seq<T>) returns (e: T)\n  requires m_workList.Length > 0\n{\n  var k := m_workList.Length - 1;\n  while (k >= 0)\n  {\n    var i := random(0, k);\n    assert i >= 0 && i <= k;\n    e := m_workList[i];\n    if (e !in avoidSet) {\n      return e;\n    }\n    k := k - 1;\n  }\n  return m_workList[0];\n}"
},
{
    "dafny": "datatype channelType = epsilon| req_shared| req_exclusive\ndatatype cacheType = invalid| shared| exclusive\ntype client=nat\ntype boolean=bool\nmethod n_t3inv__2_0(cache:array<cacheType>,    home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires  p__Inv2<N0\nrequires i==p__Inv2\nrequires ((home_current_command[0] == req_exclusive) && (home_sharer_list[i] == true)) \nensures   (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := invalid;\n  home_sharer_list[i] := false;\n}\nmethod n_t3inv__2_1(cache:array<cacheType>,    home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires  p__Inv2<N0\nrequires i!=p__Inv2\nrequires (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nrequires ((home_current_command[0] == req_exclusive) && (home_sharer_list[i] == true)) \nensures   (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := invalid;\n  home_sharer_list[i] := false;\n}\nmethod n_t3inv__2_2(cache:array<cacheType>,    home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires  p__Inv2<N0\nrequires i!=p__Inv2\nrequires (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nrequires ((home_current_command[0] == req_exclusive) && (home_sharer_list[i] == true)) \nensures   (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := invalid;\n  home_sharer_list[i] := false;\n}\nmethod n_t4inv__2_0(cache:array<cacheType>,    home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires  p__Inv2<N0\nrequires i==p__Inv2\nrequires ((home_current_command[0] == req_shared) && (home_exclusive_granted[0] == true) && (home_sharer_list[i] == true)) \nensures   (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := shared;\n  home_sharer_list[i] := true;\n}\nmethod n_t4inv__2_1(cache:array<cacheType>,    home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires  p__Inv2<N0\nrequires i!=p__Inv2\nrequires (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nrequires ((home_current_command[0] == req_shared) && (home_exclusive_granted[0] == true) && (home_sharer_list[i] == true)) \nensures   (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := shared;\n  home_sharer_list[i] := true;\n}\nmethod n_t4inv__2_2(cache:array<cacheType>,    home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires  p__Inv2<N0\nrequires i!=p__Inv2\nrequires (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nrequires ((home_current_command[0] == req_shared) && (home_exclusive_granted[0] == true) && (home_sharer_list[i] == true)) \nensures   (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := shared;\n  home_sharer_list[i] := true;\n}\nmethod n_t5inv__2_0(cache:array<cacheType>,    home_current_client:array<client>,  home_current_command:array<channelType>, home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_client.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_client.Length&&0<=j<home_current_client.Length==>home_current_client[i]!=home_current_client[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires  p__Inv2<N0\nrequires i==p__Inv2\nrequires ((home_current_client[0] == i) && (home_current_command[0] == req_shared) && (home_exclusive_granted[0] == false)) \nensures   (!((home_sharer_list[p__Inv2] == false) && (cache[p__Inv2] == exclusive)))\nmodifies cache\nmodifies home_current_command\nmodifies home_sharer_list\n{\n  home_current_command[0] := epsilon;\n  home_sharer_list[i] := true;\n  cache[i] := shared;\n}\nmethod n_t5inv__2_1(cache:array<cacheType>,    home_current_client:array<client>,  home_current_command:array<channelType>, home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_client.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires f"
},
{
    "dafny": "method add_by_one (x:int, y:int) returns (r:int)\n  requires y >= 0;\n  ensures r == x + y;\n{\n  var i:int := 0;\n  r := x;\n  while (i < y)\n    invariant i <= y;\n    invariant r == x + i;\n    decreases y-i;\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n  return r;\n}\nmethod bar (x:int, y:int) returns (r:int)\n  requires y >= 0;\n  ensures r == x + y;\n{\n  var i := 0;\n  r := x;\n  assert (i <= y && r == x + i);\n  assert (y-i >= 0);\n  i, r := *, *;\n  assume (i <= y && r == x + i);\n  assume (y-i >= 0);\n  ghost var rank_before := y-i;\n  if (i < y)\n  {\n    r := r + 1;\n    i := i + 1;\n    assert (i <= y && r == x + i);\n    assert (y-i >= 0);\n    assert (rank_before - (y-i) > 0);\n    assume (false);\n  }\n  return r;\n}"
},
{
    "dafny": "module GT {\n    trait Node {}\n    trait Edge {\n        var from: Node;\n        var to: Node;\n    }\n    trait Graph {\n        var nodes: set<Node>;\n        var edges: set<Edge>;\n        var paths: set<seq<Edge>>;\n    }\n    class WeightedDAG extends Graph {\n        constructor(nodes: set<Node>, edges: set<WeightedEdge>, paths: set<seq<WeightedEdge>>)\n        requires forall i :: i in edges ==> i.from in nodes && i.to in nodes;\n        {\n            this.nodes := nodes;\n            this.edges := edges;\n            this.paths := paths;\n        }\n    }\n    class WeightedEdge extends Edge {\n        var weight :nat;\n        constructor(from: Node, to: Node, weight: nat) {\n            this.from := from;\n            this.to := to;\n            this.weight := weight;\n        }\n    }\n    predicate isPath(edges: set<WeightedEdge>, subEdges: seq<WeightedEdge>) \n    reads subEdges\n    requires forall i :: i in subEdges ==> i in edges\n    {\n        forall i :: 0 <= i < |subEdges|-1 ==>\n                subEdges[i].to == subEdges[i+1].from\n    }\n}"
},
{
    "dafny": "datatype Result<T> = Failure(msg: string) | Success(value: T) {\n  predicate IsFailure() { Failure? }\n  function PropagateFailure(): Result<T> requires IsFailure() { this }\n  function Extract(): (t: T) requires !IsFailure() ensures t == this.value { this.value }\n}\nclass D {\n  constructor (vv: int) ensures v == vv { v := vv; }\n  var v: int\n}\nmethod Main() {\n  var _ := m();\n  var _ := mm();\n  var _ := mmm();\n}\nmethod m() returns (rr: Result<int>) {\n  var d0 := new D(42);\n  var r := Success(100);\n  var d: D := new D(90);\n  var dd: D := d;\n  print d.v, \" \", dd.v, \"\\n\"; \n  assert d.v == 90 && dd.v == 90;\n  expect d.v == 90 && dd.v == 90;\n  d.v, d :- r, d0;\n  print d.v, \" \", dd.v, \" \", d != dd, \"\\n\"; \n  assert d.v == 42;\n  assert dd.v == 100;\n  expect d.v == 42 && dd.v == 100;\n  rr := *;\n}\nmethod mm() returns (rr: Result<int>) {\n  var d0 := new int[1]; d0[0] := 42;\n  var r := Success(100);\n  var d := new int[1]; d[0] :=  90;\n  var dd := d;\n  print d[0], \" \", dd[0], \"\\n\"; \n  assert d[0] == 90 && dd[0] == 90;\n  expect d[0] == 90 && dd[0] == 90;\n  d[0], d :- r, d0;\n  print d[0], \" \", dd[0], \" \", d != dd, \"\\n\"; \n  assert d[0] == 42 && dd[0] == 100;\n  expect d[0] == 42 && dd[0] == 100;\n  rr := *;\n}\nmethod mmm() returns (rr: Result<int>) {\n  var d0 := new int[1,1]; d0[0,0] := 42;\n  var r := Success(100);\n  var d := new int[1,1]; d[0,0] :=  90;\n  var dd := d;\n  print d[0,0], \" \", dd[0,0], \"\\n\"; \n  assert d[0,0] == 90 && dd[0,0] == 90;\n  expect d[0,0] == 90 && dd[0,0] == 90;\n  d[0,0], d :- r, d0;\n  print d[0,0], \" \", dd[0,0], \" \", d != dd, \"\\n\"; \n  assert d[0,0] == 42 && dd[0,0] == 100;\n  expect d[0,0] == 42 && dd[0,0] == 100;\n  rr := *;\n}\nclass C {\n  var x: int\n  method m() returns (rr: Result<int>)\n    modifies this\n  {\n    var y: int;\n    var r := Success(100);\n    x, y :- r, 100;\n    rr := r;\n  }\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int) \n    ensures (x < 0 && y == -x) || (x >= 0 && y == x)\n{\n    if x < 0\n    { y := -x;}\n    else\n    { y := x;}\n}\nmethod UsingAbs(x:int) {\n    var a := Abs(x);\n    assert 0 <= a;\n    print a;\n}\nmethod Min2(x: int, y : int) returns (w:int)\n    ensures w == x || w == y\n    ensures w <= x && w <= y\n{\n    if x < y\n    {w := x;}\n    else\n    {w := y;}\n}\nmethod Min22(x: int, y : int) returns (w:int)\n    ensures x <= y ==> w == x\n    ensures x > y ==> w == y\n{\n    if x < y\n    {w := x;}\n    else\n    {w := y;}\n}\nmethod CompareTo(x:int, y:int) returns (c:int)\n    ensures c == 0 || c == 1 || c == -1\n{\n    if x > y\n        { c:= 1;}\n    else if x < y\n        { c:= -1;}\n    else\n        { c:= 0;}\n}\nmethod CompareTo2(x:int, y:int) returns (c:int)\n    ensures c == 0 <==> x == y\n    ensures c == -1 <==> x < y\n    ensures c == 1 <==> x > y\n{\n    if x > y\n        { c:= 1;}\n    else if x < y\n        { c:= -1;}\n    else\n        {c := 0;}\n}\nfunction abs(x:int):int\n{\n    if x < 0 then -x else x\n}\nmethod Abs3(x: int) returns (y: int) \n    ensures y == abs(x)\n{\n    if x < 0\n    { y := -x;}\n    else\n    { y := x;}\n}\nmethod Max(a:array<int>) returns (m:int)\n    requires 0 < a.Length\n    ensures forall k : int :: 0 <= k < a.Length ==> a[k] <= m\n{\n    m := a[0];\n    assert forall k : int :: 0 <= k < 1 ==> a[k] <= m;\n    var i := 1;\n    while i < a.Length\n        decreases a.Length-i \n        invariant 1 <= i <= a.Length\n        invariant forall k : int :: 0 <= k < i ==> a[k] <= m\n    {\n        if m < a[i]\n        { m := a[i];} \n        i := i + 1;\n    }\n    assert forall k : int :: 0 <= k < a.Length ==> a[k] <= m;\n}\nfunction fib(n:int):int \n    requires n >= 0\n    decreases n\n{\n    if n == 0 then 1\n    else if n == 1 then 1\n    else fib(n-1)+fib(n-2)\n}\nmethod Fib(n:int) returns (f:int)\n    requires n >= 0\n    ensures f == fib(n)\n{\n    if n == 0\n    {f:=1;}\n    else\n    {\n        var a := 1;\n        var b := 1;\n        var i := 1;\n        while i < n\n            decreases n - i\n            invariant 1 <= i <= n\n            invariant a == fib(i-1)\n            invariant b == fib(i)\n        {\n            a, b := b, a+b;\n            i := i + 1;\n        }\n        f := b;\n    }\n}"
},
{
    "dafny": "predicate member(n: int, s: seq<int>) {\n    exists i :: 0 <= i < |s| && s[i] == n\n}\npredicate notmember(n: int, s: seq<int>) {\n    forall i :: 0 <= i < |s| ==> s[i] != n\n}\nmethod isMember(m: int, s: seq<int>) returns (ismember: bool)\n    ensures ismember ==> member(m, s)\n    ensures !ismember ==> notmember(m, s)\n{\n    ismember := false;\n    var i := 0;\n    assert notmember(m, s[..i]); \n    while (i < |s| && !ismember) \n        decreases |s| - i + (if ismember then 0 else 1)\n        invariant 0 <= i <= |s|\n        invariant notmember(m, s[..i])\n        invariant ismember ==> i < |s|  \n        invariant (ismember ==> member(m, s[..i+1]))\n    {\n        assert notmember(m, s[..i]);\n        assert (i < |s| && !ismember);\n        assert (s[i] == m) ==> notmember(m, s[..i]);\n        assert !(s[i] == m) ==> notmember(m, s[..i+1]);  \n        assert (s[i] == m) ==> member(m, s[..i+1]);\n        if s[i] == m {\n            assert member(m , s[..i+1]);\n            assert true ==> member(m, s[..i+1]);\n            assert notmember(m, s[..i]); \n            ismember := true;\n            assert ismember ==> member(m, s[..i+1]);\n            assert notmember(m, s[..i]);\n        } else {\n            assert ismember ==> member(m, s[..i]);\n            assert notmember(m, s[..i+1]);  \n            i := i + 1;\n            assert ismember ==> member(m, s[..i]);\n            assert notmember(m, s[..i]);\n        }\n        assert ismember ==> member(m, s[..i+1]);\n        assert notmember(m, s[..i]);\n    }\n    assert notmember(m, s[..i]) && !(i < |s| && !ismember); \n    assert ismember ==> member(m, s[..i+1]) && !(i < |s| && !ismember);\n}"
},
{
    "dafny": "function fib(n : nat ) : nat\n  decreases n\n  {\n    if n < 2 then n else fib(n - 2) + fib(n - 1)\n  }\nmethod computeFib (n : nat) returns (x : nat)\nensures fib(n) == x\n{\n  var i := 0;\n  x := 0;\n  var y := 1;\n  while  i < n\n    decreases n - i\n    invariant x == fib(i)\n    invariant y == fib(i + 1)\n    invariant i <= n\n  {\n    x, y := y, x + y; \n    i := i + 1;\n  }\n}\nmethod Main() {\n  print \"hello, Dafny\\n\";\n  var x := computeFib(1);\n  print x;\n  print \"\\n\";\n  x := computeFib(2);\n  print x;\n  print \"\\n\";\n  x := computeFib(3);\n  print x;\n  print \"\\n\";\n  x := computeFib(4);\n  print x;\n  print \"\\n\";\n  x := computeFib(5);\n  print x;\n  print \"\\n\";\n}"
},
{
    "dafny": "class Counter {\n  var value : int ;\n  predicate valid()\n    reads this;\n  {\n    value >= 0\n  }\n  constructor init()\n    ensures value == 0;\n    ensures valid();\n    modifies `value;\n  {\n    value := 0 ;\n  }\n  method getValue() returns (x:int)\n    ensures x == value;\n  {\n    x := value ;\n  }\n  method inc()\n    requires valid();\n    ensures value == old(value) + 1;\n    ensures valid();\n    modifies `value;\n  {\n    value := value + 1;\n  }\n  method dec()\n    requires valid();\n    requires value > 0; \n    ensures value == old(value) - 1;\n    ensures valid();\n    modifies `value;\n  { \n    value := value - 1 ;\n  }\n  method Main ()\n  {\n   var count := new Counter.init() ;\n   count.inc();\n   count.inc();\n   count.dec();\n   count.inc();\n   var aux : int := count.getValue();\n   assert (aux == 2) ;\n  }\n}"
},
{
    "dafny": "predicate sqrt(x: int, r: int) {\n    r*r <= x && (r+1)*(r+1) > x\n}\nlemma uniqueSqrt(x: int, r1: int, r2: int)\nrequires x >= 0 && r1 >= 0 && r2 >= 0;\nensures sqrt(x, r1) && sqrt(x, r2) ==> r1 == r2\n{}\nmethod mySqrt(x: int) returns (res: int)\nrequires 0 <= x;\nensures sqrt(x, res);\n{\n    var l, r := 0, x;\n    while (l <= r)\n    decreases r - l;\n    invariant l >= 0;\n    invariant r >= 0;\n    invariant l*l <= x;\n    invariant (r+1)*(r+1) > x;\n    {\n        var mid := (l + r) / 2;\n        if (mid * mid <= x && (mid + 1) * (mid + 1) > x) {\n            return mid;\n        } else if (mid * mid <= x) {\n            l := mid + 1;\n        } else {\n            r := mid - 1;\n        }\n    }\n}"
},
{
    "dafny": "ghost predicate P(s: seq)\nmethod M(s: seq<int>, i: nat, v: int, n: nat)\n  requires i < n <= |s|\n  requires P(s[n..])\n{\n  var t := s[i := v];\n  assert P(t[n..]);\n}\nmethod Workaround(s: seq<int>, i: nat, v: int, n: nat)\n  requires i < n <= |s|\n  requires P(s[n..])\n{\n  var t := s[i := v];\n  assert s[n..] == t[n..];\n  assert P(t[n..]);\n}"
},
{
    "dafny": "predicate sorted(a:array<int>, from:int, to:int)\n  requires a != null;\n  reads a;\n  requires 0 <= from <= to <= a.Length;\n{\n  forall u, v :: from <= u < v < to ==> a[u] <= a[v]\n}\npredicate pivot(a:array<int>, to:int, pvt:int)\n  requires a != null;\n  reads a;\n  requires 0 <= pvt < to <= a.Length;\n{\n  forall u, v :: 0 <= u < pvt < v < to ==> a[u] <= a[v]\n}\nmethod bubbleSort (a: array<int>)\n  requires a != null && a.Length > 0;\n  modifies a;\n  ensures sorted(a, 0, a.Length);\n  ensures multiset(a[..]) == multiset(old(a[..]));\n{\n  var i:nat := 1;\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant sorted(a, 0, i);\n    invariant multiset(a[..]) == multiset(old(a[..]));\n  {\n    var j:nat := i;\n    while (j > 0)\n      invariant multiset(a[..]) == multiset(old(a[..]));\n      invariant sorted(a, 0, j);\n      invariant sorted(a, j, i+1);\n      invariant pivot(a, i+1, j);\n    {\n      if (a[j-1] > a[j]) {\n        var temp:int := a[j-1];\n        a[j-1] := a[j];\n        a[j] := temp;\n      }\n      j := j - 1;\n    }\n    i := i+1;\n  }\n}"
},
{
    "dafny": "predicate Permutacao(a: seq<int>, b:seq<int>)\n{\n    multiset(a) == multiset(b)\n}\nmethod Main()\n{\n    var a:= new int[3];\n    a[0], a[1], a[2] := 1, 2, 3;\n    var b:= new int[3];\n    b[0], b[1], b[2] := 3, 1, 2;\n    assert a[..] == [1,2,3];\n    assert b[..] == [3,1,2];\n    assert Permutacao(a[..], b[..]);\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && pre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || pre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\nmethod isPrefix(pre: string, str: string) returns (res:bool)\nensures !res <==> isNotPrefixPred(pre,str)\nensures  res <==> isPrefixPred(pre,str)\n{\n  \tif(|str| >= |pre|)\n\t{\n\t\tvar i := 0;\n    \tres := true;\n\t\twhile (i < |pre|)\n    \tinvariant 0 <= i <= |pre|\n    \tinvariant (isPrefixPred(pre[0..i],str) <==> res) || (isNotPrefixPred(pre[0..i],str) <==> !res)\n    \tdecreases |pre| - i\n\t\t{\n\t\t\tif(pre[i] != str[i])\n\t\t\t{\n        \t\tres := false;\n      \t\t}\n\t\t\ti:=i+1;\n\t\t}\n    \tassert i == |pre|;\n\t}\n  \telse\n  \t{\n    \tres := false;\n  \t}\n  \tassert res <==> isPrefixPred(pre,str);\n\tassert !res <==> isNotPrefixPred(pre,str);\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n\t(exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\t(forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\nensures  res <==> isSubstringPred(sub, str)\nensures !res <==> isNotSubstringPred(sub, str) \n{\n\tif(|str| >= |sub|)\n\t{\n\t\tvar i := 0;\n\t \tres := false;\n\t\twhile (i <= |str|-|sub| && !res)\n\t\tinvariant 0 <= i <= |str|-|sub| + 1\n\t\tinvariant forall x :: 0 <= x < i ==> isNotPrefixPred(sub, str[x..])\n\t\tinvariant res ==> isSubstringPred(sub,str)\n\t\tdecreases |str| - |sub| - i + (if res then 0 else 1)\n\t\t{\n\t\t\tres := isPrefix(sub,str[i..]);\n\t\t\tif(res)\n\t\t\t{\n\t\t\t\tassert isSubstringPred(sub,str) <==> res;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ti := i + 1;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tres := false;\n\t}\n\tassert isNotSubstringPred(sub,str) <==> !res;\n\tassert isSubstringPred(sub,str) <==> res;\n}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\texists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\tforall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n\tensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n\tensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) \n{\n\tif(|str1| >= k && |str2| >= k )\n\t{\n\t\tvar i := 0;\n\t\tfound := false;\n\t\twhile((i+k <= |str1|) && !found)\n\t\tinvariant 0 <= (i+k) <= |str1|+1\n\t\tinvariant found ==> haveCommonKSubstringPred(k,str1,str2)\n\t\tinvariant forall x,y :: (0 <= x < i) && !found && y == (x+k) && y <= |str1| ==> isNotSubstringPred(str1[x..y], str2)\n\t\tdecreases |str1|- (i + k)\n\t\t{\n\t\t\tfound := isSubstring(str1[i..i+k],str2);\n\t\t\ti := i+1;\n\t\t}\n\t\tassert found <==> haveCommonKSubstringPred(k,str1,str2);\n\t\tassert !found <==> haveNotCommonKSubstringPred(k,str1,str2);\n\t}\n\telse\n\t{\n\t\tfound := false;\n\t}\n\tassert found <==> haveCommonKSubstringPred(k,str1,str2);\n\tassert !found <==> haveNotCommonKSubstringPred(k,str1,str2);\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n\trequires (|str1| <= |str2|)\n\tensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n\tensures haveCommonKSubstringPred(len,str1,str2)\n{\n\tif(|str1|>0)\n\t{\n\t\tvar k := |str1|;\n\t\tvar temp := false;\n\t\twhile(k > 0 && !temp)\n\t\tinvariant k >= 0\n\t\tinvariant temp ==> haveCommonKSubstringPred(k, str1, str2)\n\t\tinvariant forall x :: k < x <= |str1| ==> !haveCommonKSubstringPred(x, str1, str2)\n\t\tdecreases k - 0\n\t\t{\n\t\t\ttemp := haveCommonKSubstring(k,str1,str2);\n\t\t\tif(temp)\n\t\t\t{\n\t\t\t\tassert haveCommonKSubstringPred(k, str1, str2);\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\tk := k - 1;\n\t\t}\n\t\tassert isPrefixPred(str1[0..0],str2[0..]);\n\t\tassert haveCommonKSubstringPred(k,str1,str2);\n\t\tassert k == 0;\n\t\tlen := k;\n\t}\n\telse\n\t{\n\t\tassert isPrefixPred(str1[0..0],str2[0..]);\n\t\tlen := 0;\n\t}\n}"
},
{
    "dafny": "class Question3 {\n  var x:int;\n  method loop() returns (ret:int)\n   requires x > 0;\n   ensures ret == x * x;\n  {\n    var y:int := x;\n    var z:int := 0;\n    while (y > 0) \n     invariant y >= 0;\n     invariant x * y + z == x * x;\n     decreases y;\n    {\n       z := z + x;\n       y := y - 1;\n    }\n    return z;\n  }\n}"
},
{
    "dafny": "datatype Color = Red | White | Blue\npredicate Below(a: Color, b: Color)\n{\n    a == Red || b == Blue || a == b\n}\nmethod DutchFlag(a: array<Color>)\n    modifies a\n    ensures forall i,j :: 0 <= i < j < a.Length ==> Below(a[i], a[j])\n    ensures multiset(a[..]) == multiset(old(a[..])) \n{\n    var r, w, b := 0, 0, a.Length;\n    while w < b \n        decreases b - w\n        invariant 0 <= r <= w <= b <= a.Length\n        invariant forall i :: 0 <= i < r ==> a[i] == Red\n        invariant forall i :: r <= i < w ==> a[i] == White\n        invariant forall i :: b <= i < a.Length ==> a[i] == Blue\n        invariant multiset(a[..]) == multiset(old(a[..])) \n    {\n        match a[w]\n        case Red =>\n            a[r], a[w] := a[w], a[r];\n            r, w := r + 1, w + 1;\n        case White =>\n            w := w + 1;\n        case Blue =>\n            a[b - 1], a[w] := a[w], a[b-1];\n            b := b - 1;\n    }\n}"
},
{
    "dafny": "module DivInternalsNonlinear {\n  lemma LemmaDivOf0(d:int)\n    requires d != 0\n    ensures 0 / d == 0\n  { \n  }\n  lemma LemmaDivBySelf(d:int)\n    requires d != 0\n    ensures d / d == 1\n  { \n  }\n  lemma LemmaSmallDiv()\n    ensures forall x, d {:trigger x / d} :: 0 <= x < d && d > 0 ==> x / d == 0\n  { \n  }\n  lemma LemmaRealDivGt(x:real, y:real)\n    requires x > y\n    requires x >= 0.0\n    requires y > 0.0\n    ensures  x / y > 1 as real\n  { \n  }\n}"
},
{
    "dafny": "method Add(x: int, y: int) returns (r: int)\n  requires y >= 0\n  ensures r == x + y\n{\n  r := x;\n  var n := y;\n  while n != 0\n    invariant \n      0 <= n &&\n      r == x + y - n\n  {\n    r := r + 1;\n    n := n - 1;\n  }\n}"
},
{
    "dafny": "predicate sorted(a:array<int>, from:int, to:int)\n  reads a;\n{\n  true\n}\npredicate pivot(a:array<int>, to:int, pvt:int)\n  reads a;\n{\n  true\n}\nmethod bubbleSort (a: array<int>)\n  requires true; \n  ensures true; \n  modifies a;\n{\n}"
},
{
    "dafny": "function fact (n:nat) : nat\ndecreases n\n{\n    if n <= 0 then 1 else n*fact(n-1)\n}\nmethod Factorial(n: nat) returns (p: nat)\nrequires n>=0\nensures p == fact(n)\n{\n    var i : nat;\n    i, p := 1,1;\n    while i <= n\n    invariant i<= n+1\n    invariant p == fact(i-1)\n    decreases n + 1 - i\n    {\n        p := p * i;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "trait J\n{\n  var x: int\n}\nclass C extends J\n{\n}\nmethod Main()\n{\n  var c := new C;\n  var j: J? := new C;\n  j.x := 8;\n  c.x := 9;\n  assert j.x + 1 == c.x;\n  j := c;\n  assert j.x == 9;\n  print \"j\"; Print(j);\n  print \"c\"; Print(c);\n  c := null;\n  assert j != null;\n  j := null;\n}\nmethod Print(j: J)\n{\n  print \".x = \", j.x, \"\\n\";\n}"
},
{
    "dafny": "method Main() {\n  var a1: array<string> := new string[5];\n  a1[0], a1[1], a1[2], a1[3], a1[4]:= \"A: 330ml\", \"AB: 250ml\",\"A: 500ml\",\"O: 1000ml\", \"B: 450ml\";\n  var a3 := deleteFromList(a1,2);\n}\nmethod deleteFromList(blood: array<string>, indexv: int) returns (result: array<string>)\nrequires blood != null\nrequires 0 <= indexv < blood.Length\nensures result != null\nensures 0 <= indexv <= result.Length\n{\n  result := new string[blood.Length - 1];\n  if (indexv != 0) {\n    result[0] := blood[0];\n  } \n  var i:= 0;\n  while (i < result.Length) \n  invariant 0 <= i <= result.Length\n  { \n    if (i < indexv) {\n        result[i] := blood[i];\n    } else {\n        result[i] := blood[i+1];\n    }\n    i := i + 1;  \n  }\n}"
},
{
    "dafny": "method Tangent(r: array<int>, x: array<int>) returns (b: bool)\n    requires forall i, j :: 0 <= i <= j < x.Length ==> x[i] <= x[j] \n    requires forall i, j :: (0 <= i < r.Length && 0 <= j < x.Length) ==> (r[i] >= 0 && x[j] >= 0)       \n    ensures !b ==> forall i, j :: 0 <= i< r.Length && 0 <= j < x.Length ==> r[i] != x[j]   \n    ensures b ==> exists i, j :: 0 <= i< r.Length && 0 <= j < x.Length && r[i] == x[j]\n{\n    var tempB, tangentMissing, k, l := false, false, 0, 0;\n    while k != r.Length && !tempB\n        invariant 0 <= k <= r.Length\n        invariant tempB ==> exists i, j :: 0 <= i < r.Length && 0 <= j < x.Length && r[i] == x[j]\n        invariant !tempB ==> forall i, j :: (0 <= i<k && 0 <= j < x.Length) ==> r[i] != x[j]\n        decreases r.Length - k\n    {\n        l:= 0;\n        tangentMissing := false;\n        while l != x.Length && !tangentMissing\n            invariant 0 <= l <= x.Length\n            invariant tempB ==> exists i, j :: 0 <= i < r.Length && 0 <= j < x.Length && r[i] == x[j]\n            invariant !tempB ==> forall i :: 0 <= i< l ==> r[k] != x[i]\n            invariant tangentMissing ==> forall i :: (l <= i < x.Length) ==> r[k] != x[i]\n            decreases x.Length - l, !tempB, !tangentMissing\n        {\n            if  r[k] == x[l] {\n                tempB := true;\n            }\n            if (r[k] < x[l]) {\n                tangentMissing := true;\n            }\n            l := l + 1;\n        }\n        k := k + 1;\n    }\n    b := tempB;\n}"
},
{
    "dafny": "predicate IsSorted(s:seq<int>)\n{\n  forall i :: 0 <= i < |s|-1 ==> s[i] <= s[i+1]\n}\npredicate SortSpec(input:seq<int>, output:seq<int>)\n{\n  && IsSorted(output)\n  && multiset(output) == multiset(input)\n}\nmethod merge_sort(input:seq<int>) returns (output:seq<int>)\n  ensures SortSpec(input, output)\n{\n  if |input| <= 1 {\n    output := input;\n  } else {\n    var pivotIndex := |input| / 2;\n    var left := input[..pivotIndex];\n    var right := input[pivotIndex..];\n    var leftSorted := left;\n    leftSorted := merge_sort(left);\n    var rightSorted := right;\n    rightSorted := merge_sort(right);\n    output := merge(leftSorted, rightSorted);\n    assert left + right == input; \n  }\n}\nmethod merge(a:seq<int>, b:seq<int>) returns (output:seq<int>)\n  requires IsSorted(a)\n  requires IsSorted(b)\n  ensures SortSpec(a+b, output)\n{\n  var ai := 0;\n  var bi := 0;\n  output := [];\n  while ai < |a| || bi < |b|\n    invariant 0 <= ai <= |a|\n    invariant 0 <= bi <= |b|\n    invariant 0 < |output| && ai < |a| ==> output[|output|-1] <= a[ai]\n    invariant 0 < |output| && bi < |b| ==> output[|output|-1] <= b[bi]\n    invariant forall i :: 0 <= i < |output|-1 ==> output[i] <= output[i+1]\n    invariant multiset(output) == multiset(a[..ai]) + multiset(b[..bi])\n    decreases |a|-ai + |b|-bi\n  {\n    ghost var outputo := output;\n    ghost var ao := ai;\n    ghost var bo := bi;\n    if ai == |a| || (bi < |b| && a[ai] > b[bi]) {\n      output := output + [b[bi]];\n      bi := bi + 1;\n      assert b[bo..bi] == [b[bo]];  \n    } else {\n      output := output + [a[ai]];\n      ai := ai + 1;\n      assert a[ao..ai] == [a[ao]];  \n    }\n    assert a[..ai] == a[..ao] + a[ao..ai];  \n    assert b[..bi] == b[..bo] + b[bo..bi];  \n  }\n  assert a == a[..ai];  \n  assert b == b[..bi];\n}\nmethod fast_sort(input:seq<int>) returns (output:seq<int>)\n{\n  output := [1, 2, 3];\n}"
},
{
    "dafny": "function sorted(a:array<char>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ \n    forall i, j:: (0 <= i < j < n) ==> a[i] <= a[j]\n}\nmethod BSearch(a:array<char>, n:int, value:char) returns (pos:int)\n    requires 0 <= n <= a.Length\n    requires sorted(a, n)\n    ensures 0 <= pos ==> pos < n && a[pos] == value\n    ensures pos < 0  ==> forall i :: (0<= i < n) ==> a[i] != value\n{\n    var low, high := 0, n;\n    while low < high\n        decreases high - low\n        invariant 0 <= low <= high <= n\n        invariant forall i :: 0 <= i < n && i < low ==> a[i] != value\n        invariant forall i :: 0 <= i < n && high <= i ==> a[i] != value\n    {\n        var mid := (low + high) / 2;\n        if a[mid] < value          { low := mid + 1; }\n        else if value < a[mid]     { high := mid; }\n        else  { return mid; }\n    }\n    return -1;\n}"
},
{
    "dafny": "predicate knows(a: int, b: int)\npredicate isCelebrity(n : int, i : int)\nrequires n >= 0 && 0 <= i < n;\n{\n    forall j :: 0 <= j < n && i != j ==> knows(j, i) && !knows(i, j)\n}\nlemma knowerCannotBeCelebrity(n: int, i: int)\nrequires n >= 0 && 0 <= i < n\nensures (exists j :: 0 <= j < n && j != i && knows(i, j)) ==> !isCelebrity(n, i)\n{}\nghost method isCelebrityP(n: int, i: int) returns (r : bool)\nrequires n >= 0 && 0 <= i < n;\nensures r <==> isCelebrity(n, i);\n{\n    var j := 0;\n    r := true;\n    while j < n\n    decreases n - j;\n    invariant 0 <= j <= n;\n    invariant r ==> forall k :: 0 <= k < j && k != i ==> knows(k, i) && !knows(i, k);\n    {\n        if j != i {\n            if !knows(j, i) || knows(i, j) {\n                return false;\n            }\n        }\n        j := j + 1;\n    }\n    return r;\n} \nghost method findCelebrity(n : int) returns (r : int)\nrequires 2 <= n <= 100;\nensures 0 <= r < n ==> isCelebrity(n, r);\nensures r == -1 ==> forall i :: 0 <= i < n ==> !isCelebrity(n, i);\n{\n    var candidate := 0;\n    var i := 1;\n    while i < n \n    invariant 1 <= i <= n;\n    invariant forall j :: 0 <= j < i && j != candidate ==> !isCelebrity(n, j);\n    invariant 0 <= candidate < i;\n    {\n        if knows(candidate, i) {\n            candidate := i;\n        }\n        i := i + 1;\n    }\n    var isCelebrityC := isCelebrityP(n, candidate);\n    if isCelebrityC {\n        r := candidate;\n    } else {\n        r := -1;\n    }\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n    ensures y >= 0\n{\n   if (x < 0)\n   {\n       return -x; \n   }\n   else\n   {\n        return x;\n   }\n}\nmethod TestBench()\n{\n    var ten := Abs(10);\n    var minusFive := Abs(-5);\n    assert 0 <= ten;\n    assert 0 <= minusFive;\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int) {\n  if (x < 0) {\n    return -x;\n  }\n  return x;\n}\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int) {\n   more := x + y;\n   less := x - y;\n}\npredicate sorted(mySeq: seq<int>) {\n  forall i, j :: 0 <= i < j < |mySeq| ==> mySeq[i] <= mySeq[j]\n}\npredicate sorted2(mySeq: seq<int>) {\n  0 < |mySeq| ==> ((forall i :: 0 < i < |mySeq| ==> mySeq[0] <= mySeq[i]) && sorted2(mySeq[1..]))\n}\nmethod SequenceNotes(mySeq: seq<int>) {\n  var otherSeq := [1, 2, 3];\n  var singletonBoolean := [true];\n  var s := [1, 2, 3, 4, 5];\n  assert s[|s| - 1] == 5;               \t\t\t\t\t\t\t\t\n  assert s[|s| - 1 .. |s|] == [5];\t\t\t\t\t\t\t\t\t\t\t\n\tassert s[1..] == [2, 3, 4, 5];\t\t\t\t\t\t\t\t\t\t\t\t\n\tassert s[ .. |s|-1] == [1, 2, 3, 4];\t\t\t\t\t\t\t\t\t\n\tassert s == s[0..] == s[..|s|] == s[0..|s|] == s[..];\t\n\tassert [1, 2, 3] == [1] + [2, 3];\t\t\t\t\t\t\t\t\t\t\t\n\tassert s == s + [];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tassert forall i :: 0 <= i <= |s| ==> \n\t\ts == s[..i] + s[i..];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tassert 5 in s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tassert 0 !in s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tvar p := [2, 3, 1, 0];\n\tassert forall i :: i in p ==> 0 <= i < |s|;\t\t\t\t\t\t\n\tassert forall k :: 0 <= k < |s| ==> -1 != s[k]; \t\t\t\n\tassert -1 !in s;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tassert -1 !in s[1..];\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n}\nfunction updateSequenceByIndex(s: seq<int>, i: int, newVal: int): seq<int>\n\trequires 0 <= i < |s|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tensures updateSequenceByIndex(s, i, newVal) == s[i := newVal]\t\t\t\t\n{\n\ts[..i] + [newVal] + s[i+1..]\n}"
},
{
    "dafny": "function sumInts( n: int ): int\n    requires n >= 0;\n    decreases n;\n{\n    if n == 0 then\n        0\n    else\n        sumInts(n-1)+n\n}\nmethod SumIntsRecursive( n: int ) returns ( s: int )\n    requires n >= 0;\n    ensures s == sumInts(n)\n    ensures s == n*(n+1)/2;\n    decreases n;\n{\n    if n == 0 { return 0; }\n    s := SumIntsRecursive(n-1);\n    s := s+n;\n}\nmethod Main()\n{\n    var x := SumIntsRecursive(100);\n    print x;\n}"
},
{
    "dafny": "lemma {:induction false} Divby2(n: nat)\nensures (n*(n-1))%2 == 0\n{\n    if n == 0 {\n        assert (1*(1-1))%2 == 0; \n    } else {\n        Divby2(n - 1); \n        assert (n-1)*(n-2) == n*n -3*n + 2; \n    }\n}"
},
{
    "dafny": "predicate NaoPertence(x:int, a:array<int>)\nreads a\n{\n    forall i :: 0 <= i < a.Length ==> a[i] != x\n}\npredicate NaoPertence2(x:int, a:array<int>)\nreads a\n{\n    x !in a[..]\n}\nfunction Sum(xs: seq<int>): int\n{\n    if |xs| == 0\n    then 0\n    else\n    xs[0] + Sum(xs[1..])\n}\nmethod Somatorio(a: array<int>) returns (s : int)\nensures s == Sum(a[..])\n{\n    s := 0;\n    var i := 0;\n    while i < a.Length\n    decreases a.Length - i\n    invariant 0 <= i <= a.Length\n    invariant s == Sum(a[a.Length-i..])\n    {\n        s := s + a[a.Length - i - 1];\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method firstTest() returns () {\n\tvar fnc := new array<int>[3];\n\tfnc[0] := new int[2];\n\tfnc[1] := new int[3];\n\tfnc[2] := new int[2];\n\tfnc[0][0] :=  1;\n\tfnc[0][1] := -2;\n\tfnc[1][0] := -1;\n\tfnc[1][1] :=  3;\n\tfnc[1][2] := -4;\n\tfnc[2][0] :=  2;\n\tfnc[2][1] := -3;\n\tassert fnc.Length == 3;\n\tassert fnc[0].Length == 2;\n\tassert fnc[0][0] == 1;\n\tvar i := 0;\n\twhile i < fnc.Length\n\t\tinvariant 0 <= i <= fnc.Length;\n\t{\n\t\tvar j := 0;\n\t\twhile j < fnc[i].Length\n\t\t\tinvariant 0 <= j <= fnc[i].Length;\n\t\t{\n\t\t\tprint fnc[i][j];\n\t\t\tj := j+1;\n\t\t}\n\t\ti := i+1;\n\t}\n\thd(fnc);\n}\nmethod hd(a: array<array<int>>)\n\trequires a.Length > 0\n\trequires a[0].Length > 0\n{\n\tprint a[0][0];\n\tvar b := a;\n\tprint b[0][0];\n}\nclass A {\n\tvar a: array<array<int>>;\n\tconstructor(b: array<array<int>>) {\n\t\ta := b;\n\t}\n}\nmethod secondTest() {\n\tvar b: array<int>;\n\tb := new int[3];\n\tvar c := new int[4];\n\tvar d := new array<int>[5];\n\td[0] := new int[3];\n\thd(d);\n\tvar e := new A(d);\n}\nmethod Main() {\n\tfirstTest();\n\tsecondTest();\n\tvar tab := new int[0];\n\tvar tab2 := new int[5];\n\tvar i := 0;\n\twhile i < 5\n\t\tinvariant 0 <= i <= 5\n\t{\n\t\tprint tab2[i];\n\t\ti := i+1;\n\t}\n}"
},
{
    "dafny": "method Max(a:int, b:int) returns(c:int)\n    ensures a < b ==> c == b\n    ensures b <= a ==> c == a\n{\n        if (a <b){\n            return b;\n        }else{\n            return a;\n    }\n}"
},
{
    "dafny": "method F(X: int) returns (Y: int)\n  requires X % 2 == 0;\n{\n  var Xdiv2: int;\n  Xdiv2 := G(X); \n  Xdiv2 := Xdiv2 / 2;\n  Y := Xdiv2 + Xdiv2;\n}\nmethod G(X : int) returns (Y: int)\n{\n  Y := X;\n}"
},
{
    "dafny": "method Reverse (str: array?<char>) returns(b: array<char>)\nrequires str != null;\nensures str.Length == b.Length;\nensures forall k: int :: 0 <= k < str.Length ==> b[k] == str[(str.Length - 1) - k]\n{\n    b := new char[str.Length];\n    print str.Length, '\\n';\n    var i := str.Length - 1;\n    var j := 0;\n    while j < str.Length\n    invariant j <= str.Length\n    invariant forall k: int :: 0 <= k < j ==> b[k] == str[(str.Length - 1) - k]\n    {\n        b[j] := str[i - j];\n        j := j + 1;\n    }\n}\nmethod Main()\n{\n    var a := new char[8];\n    a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7] := 'd', 'e', 's', 'r', 'e', 'v', 'e', 'r';\n    var b := Reverse(a);\n    print b[..];\n    assert b[..] == [ 'r', 'e', 'v', 'e', 'r', 's', 'e', 'd' ];\n    a := new char[1];\n    a[0] := '!';\n    b := Reverse(a);\n    assert b[..] == [ '!' ];\n    print b[..], '\\n';\n}"
},
{
    "dafny": "datatype Cell = Cell(x: int)\ntype EvenCell = c: Cell | c.x % 2 == 0 witness Cell(0)\nfunction doubleEvenCell(c: EvenCell): int\n{\n  if c.x % 2 == 1 then 1/0 else c.x * 2\n}\nmethod Main() {\n  var x: set<Cell> := {Cell(1), Cell(2), Cell(3), Cell(4)};\n  var z: map<EvenCell, nat> := map c: EvenCell | c in x :: c.x;\n  var y := z.Keys;\n  var b := forall c :: c in y ==> doubleEvenCell(c) > 0;\n  assert b;\n  print Cell(1) in y, \" \", z[Cell(2)], \"\\n\";\n}"
},
{
    "dafny": "datatype pc_label = x_pc | y_pc | done\nclass TeachingConcurrency {\n    var pc: array<pc_label>;\n    var x: array<int>;\n    var y: array<int>;\n    method Init()\n    requires pc.Length == x.Length == y.Length;\n    requires forall i : int :: 0 <= i < pc.Length ==> pc[i] == x_pc;\n    requires x != y\n    requires 1 < pc.Length; \n    ensures IndInv();\n    modifies pc;\n    {\n        assert pc[1] != done;\n    }\n    method Proc(i: int)\n    requires 0 <= i < pc.Length;\n    requires IndInv();\n    ensures IndInv();\n    modifies x, y, pc;\n    {\n        x[i] := 1;\n        pc[i] := y_pc;\n        Yield(i);\n        y[i] := x[(i - 1) % x.Length];\n        pc[i] := done;\n        assert x_Inv();\n        assert AllDone() ==> x[(i - 1) % x.Length] == 1;\n        assert AllDone() ==> y[i] == 1;\n        Yield(i);\n    }\n    predicate AllDone()\n    reads `pc, pc;\n    {\n        forall i : int :: 0 <= i < pc.Length ==> pc[i] == done\n    }\n    predicate Safety()\n    requires pc.Length == y.Length;\n    reads `pc, pc, `y, y;\n    {\n        AllDone() ==> exists i : int :: 0 <= i < y.Length && y[i] == 1\n    }\n    predicate x_Inv()\n    requires pc.Length == x.Length;\n    reads `pc, pc, `x, x;\n    {\n        forall i : int ::\n            (0 <= i < pc.Length && pc[i] in {y_pc, done}) ==>\n            x[i] == 1\n    }\n    predicate IndInv()\n    reads `pc, pc, `x, x, `y, y;\n    {\n        x != y && pc.Length == x.Length == y.Length &&\n        Safety() && x_Inv()\n    }\n    method Yield(i: int)\n    requires 0 <= i < pc.Length;\n    requires IndInv();\n    ensures IndInv();\n    ensures pc[i] == old(pc[i]);\n    modifies pc, x, y;\n}"
},
{
    "dafny": "newtype T1 = nat\nnewtype T2 = int\nnewtype T3 = n: nat | true\nnewtype T4 = i: int | 0 <= i\nmethod M(s1: set<T1>, s2: set<T2>, s3: set<T3>, s4: set<T4>)\n  requires s1 != {} && s2 != {} && s3 != {} && s4 != {} \n{\n  var i1: T1 :| i1 in s1;\n  var i2: T2 :| i2 in s2;\n  var i3: T3 :| i3 in s3;\n  var i4: T4 :| i4 in s4;\n}"
},
{
    "dafny": "method LinealSearch(A:array<int>, key:int) returns (index:int)\n    ensures 0 <= index ==> index < A.Length && A[index] == key\n    ensures index < 0 ==> key !in A[..]\n{\n    var N := A.Length;\n    var i := 0;\n    while i < N\n        invariant 0 <= i <= N\n        invariant forall k :: 0 <= k < i ==> A[k] != key\n        decreases N - i\n    {\n        if A[i] == key\n        {\n            return i;\n        }\n        i := i + 1;\n    }\n    return -1;\n}\nmethod Main() {\n    var a := new int[10];\n    a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9] := 2, 4, 6, 8, 10, 12, 14, 16, 18, 20;\n    var index := LinealSearch(a, 12);\n    print index;\n}"
},
{
    "dafny": "datatype Abc = End | Wrapper(seq<Abc>)\nlemma SeqRank0(a: Abc)\n  ensures a != Wrapper([a])\n{\n  assert [a][0] == a;  \n}\nlemma SeqRank1(s: seq<Abc>)\n  requires s != []\n  ensures s[0] != Wrapper(s)\n{\n}\ndatatype Def = End | MultiWrapper(multiset<Def>)\nlemma MultisetRank(a: Def)\n  ensures a != MultiWrapper(multiset{a})\n{\n}\ndatatype Ghi = End | SetWrapper(set<Ghi>)\nlemma SetRank(a: Ghi)\n  ensures a != SetWrapper({a})\n{\n}"
},
{
    "dafny": "predicate Sorted(a:array<int>, low:int, high:int)\n\treads a\n{\n\t0 <= low <= high <= a.Length &&\n\tforall i,j :: low <= i < j < high ==> a[i] <= a[j]\n}\npredicate MinElementIndex(a:array<int>, low:int, high:int, index:int)\n\treads a\n{\n\tlow >= 0 && high < a.Length &&\n\tlow <= index < a.Length &&\n\tforall i :: low <= i <= high ==> a[i] >= a[index]\n}\nmethod SelectionSort(a:array<int>)\n\tmodifies a\n\trequires a.Length > 1\n\tensures Sorted(a, 0, a.Length)\n\tensures multiset(a[..]) == multiset(old(a[..]))\n{\n\tvar i := 0;\n\twhile (i < a.Length)\n\t\tinvariant 0 <= i <= a.Length\n\t\tinvariant Sorted(a, 0, i)\n\t\tinvariant forall x :: 0 <= x < i ==> forall y :: i <= y < a.Length ==> a[x] <= a[y]\n\t\tinvariant multiset(a[..]) == multiset(old(a[..]))\n\t{\n\t\tvar min_element_index := i;\n\t\tvar j := i;\n\t\twhile (j < a.Length)\n\t\t\tinvariant i <= j <= a.Length\n\t\t\tinvariant forall x :: 0 <= x < i ==> forall y :: i <= y < a.Length ==> a[x] <= a[y]\n\t\t\tinvariant MinElementIndex(a, i, j-1, min_element_index)\n\t\t\tinvariant multiset(a[..]) == multiset(old(a[..]))\n\t\t{\n\t\t\tif (a[j] < a[min_element_index])\n\t\t\t{\n\t\t\t\tmin_element_index := j;\n\t\t\t}\n\t\t\tj := j + 1;\n\t\t}\n\t\ta[i], a[min_element_index] := a[min_element_index], a[i];\n\t\ti := i + 1;\n\t}\n}"
},
{
    "dafny": "predicate P(x: int, y: int)\npredicate Q(x: int)\nmethod Test(z: int) {\n  assume forall x: int, y: int :: P(x, y) == P(y, x);\n  assume forall x: int, y: int :: P(x, y) == (P(y, x));\n  assume forall x: int, y: int :: P(x, y) == P(x, y+1);\n  assert forall x :: true || Q(x) || Q(0);\n  assert forall x :: true || Q(x) || Q(z);\n  assert forall x :: true || P(x, 1) || P(x, z);\n  assert forall x :: true || Q(x) || Q(0+1);\n  assert forall x :: true || Q(x) || Q(if z > 1 then z else 3 * z + 1);\n  assert forall x :: true || Q(x) || Q(if z > 1 then x else 3 * z + 1);\n  assert forall x :: true || Q(x) || (var xx := x+1; Q(xx));\n}"
},
{
    "dafny": "method IndexOf(a:array<char>, n:int, K:char)\n    returns (pos:int)\n    requires 0 <= n <= a.Length\n    ensures pos == -1 ==> forall j : int :: 0 <= j < n ==> a[j] != K    \n    ensures 0 <= pos < n ==> a[pos] == K                                \n    ensures -1 <= pos < n\n{\n    var i := 0;\n    pos := -1;\n    while i < n\n        decreases n-i               \n        invariant 0 <= i <= n       \n        invariant -1 <= pos < i     \n        invariant 0 <= pos < i ==> a[pos] == K\n        invariant pos == -1 ==> forall j : int :: 0 <= j < i ==> a[j] != K    \n    {\n        if a[i] == K\n        {\n            pos := i;\n        }\n        i := i + 1;\n    }\n}\nmethod Fillk(A:array<char>, n:int, K:char) returns (s:bool)\n    requires 0 <= n <= A.Length\n    ensures s <==> forall j : int :: 0 <= j < n ==> A[j] == K          \n{\n    var i := 0;\n    s := true;\n    while i < n\n        decreases n-i\n        invariant 0 <= i <= n\n        invariant  s  <==> forall j : int :: 0 <= j < i ==> A[j] == K\n    {\n        if A[i] != K \n        { s := false; }\n        i := i + 1;\n    }\n} \nmethod FillkUsingExists(A:array<char>, n:int, K:char) returns (s:bool)\n    requires 0 <= n <= A.Length\n    ensures !s <==> exists j : int :: 0 <= j < n && A[j] != K            \n{\n    var i := 0;\n    s := true;\n    while i < n\n        decreases n-i\n        invariant 0 <= i <= n\n        invariant !s <==> exists j : int :: 0 <= j < i && A[j] != K\n    {\n        if A[i] != K \n        { s := false; }\n        i := i + 1;\n    }\n} \nmethod Fillk2(A:array<char>, n:int, K:char) returns (s:bool)\n    requires 0 <= n <= A.Length\n    ensures s <==> forall j : int :: 0 <= j < n ==> A[j] == K          \n{\n    var i := 0;\n    s := true;\n    while i < n\n        decreases n-i\n        invariant 0 <= i <= n\n        invariant  s  <==> forall j : int :: 0 <= j < i ==> A[j] == K\n    {\n        if A[i] != K \n        { return false; }\n        i := i + 1;\n    }\n    return true;\n} \nmethod Reverse(a:array<int>, n:int) returns (b:array<int>)\n    requires 0 <= n <= a.Length\n    ensures a.Length == b.Length\n    ensures forall k : int :: 0 <= k < n ==> b[k] == a[n-1-k]\n    ensures forall k : int :: n <= k < a.Length ==> b[k] == a[k]\n{\n    b := new int[a.Length];\n    var i := 0;\n    while i < n\n        decreases n-i\n        invariant 0 <= i <= n\n        invariant forall k : int :: 0 <= k < i ==> b[k] == a[n-1-k]\n    {\n        b[i] := a[n-1-i];\n        i := i + 1;\n    }\n    while i < a.Length\n        decreases a.Length - i\n        invariant n <= i <= a.Length\n        invariant forall k : int :: 0 <= k < n ==> b[k] == a[n-1-k]\n        invariant forall k : int :: n <= k < i ==> b[k] == a[k]\n    {\n        b[i] := a[i];\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "datatype Tree<T> = Leaf | Node(Tree<T>, Tree<T>, T)\ndatatype List<T> = Nil | Cons(T, List<T>)\nfunction flatten<T>(tree:Tree<T>):List<T>\n{\n\tmatch tree\n    case Leaf => Nil\n    case Node(l_tree,r_tree,v) => Cons(v,append(flatten(l_tree),flatten(r_tree)))\n}\nfunction append<T>(xs:List<T>, ys:List<T>):List<T>\n{\n\tmatch xs\n    case Nil => ys\n    case Cons(x,xs') => Cons(x, append(xs',ys))\n}\nfunction treeContains<T(==)>(tree:Tree<T>, element:T):bool\n{\n    match tree\n    case Leaf => false\n    case Node(l_tree, r_tree, v) => treeContains(l_tree,element) || treeContains(r_tree,element) || (v == element) \n}\nfunction listContains<T(==)>(xs:List<T>, element:T):bool\n{\n\tmatch xs\n    case Nil => false\n    case Cons(x,xs') => (x == element) || listContains(xs', element)\n}\nlemma memberOfAppend<T>(e:T, xs:List<T>, ys:List<T>)\nensures listContains(append(xs,ys),e) == ( listContains(xs,e)  ||  listContains(ys,e) )\n{\n    match xs\n    case Nil => {}\n    case Cons(x,xs') => {\n        calc {\n           listContains(append(xs,ys),e);\n            == listContains(append(Cons(x,xs'),ys),e);\n            == listContains(Cons(x,append(xs',ys)),e);\n            == (e==x) || listContains(append(xs',ys),e);\n            == { memberOfAppend(e,xs',ys); }\n               (e==x) || listContains(xs',e) || listContains(ys,e);\n            == listContains(Cons(x,xs'),e)  || listContains(ys,e);\n            == listContains(xs,e)           || listContains(ys,e);\n        }\n    }\n}\nlemma sameElements<T>(tree:Tree<T>, element:T)\nensures treeContains(tree, element) <==> listContains(flatten(tree), element)\n{\n    match tree\n    case Leaf => {}\n    case Node (l_tree,r_tree,v) => {\n        calc{treeContains(tree,element);\n        == treeContains(Node (l_tree,r_tree,v),element);\n        == treeContains(l_tree,element) || treeContains(r_tree,element) || (v==element);\n        == {sameElements(l_tree,element);\n           sameElements(r_tree,element);}\n        listContains(flatten(l_tree),element) || listContains(flatten(r_tree),element) || (v==element);\n        =={memberOfAppend(element,flatten(l_tree),flatten(r_tree));} \n        listContains(append(flatten(l_tree),flatten(r_tree)),element) || (v==element);\n        ==listContains(Cons(v,append(flatten(l_tree),flatten(r_tree))),element);\n        ==listContains(flatten(tree), element);\n        }      \n    }  \n}"
},
{
    "dafny": "newtype uint32 = i:int | 0 <= i < 0x100000000\nmethod returnANullArray() returns (a: array?<uint32>)\n  ensures a == null\n{\n  a := null;\n}\nmethod returnANonNullArray() returns (a: array?<uint32>)\n  ensures a != null\n  ensures a.Length == 5\n{\n  a := new uint32[5];\n  a[0] := 1;\n  a[1] := 2;\n  a[2] := 3;\n  a[3] := 4;\n  a[4] := 5;\n}\nmethod LinearSearch(a: array<uint32>, len:uint32, key: uint32) returns (n: uint32)\n  requires a.Length == len as int\n  ensures 0 <= n <= len\n  ensures n == len || a[n] == key\n{\n  n := 0;\n  while n < len\n    invariant n <= len\n  {\n    if a[n] == key {\n      return;\n    }\n    n := n + 1;\n  }\n}\nmethod PrintArray<A>(a:array?<A>, len:uint32)\n  requires a != null ==> len as int == a.Length\n{\n  if (a == null) {\n    print \"It's null\\n\";\n  } else {\n    var i:uint32 := 0;\n    while i < len {\n      print a[i], \" \";\n      i := i + 1;\n    }\n    print \"\\n\";\n  }\n}\ndatatype ArrayDatatype = AD(ar: array<uint32>)\nmethod Main() {\n  var a := new uint32[23];\n  var i := 0;\n  while i < 23 {\n    a[i] := i;\n    i := i + 1;\n  }\n  PrintArray(a, 23);\n  var n := LinearSearch(a, 23, 17);\n  print n, \"\\n\";\n  var s : seq<uint32> := a[..];\n  print s, \"\\n\";\n  s := a[2..16];\n  print s, \"\\n\";\n  s := a[20..];\n  print s, \"\\n\";\n  s := a[..8];\n  print s, \"\\n\";\n  a[0] := 42;\n  print s, \"\\n\";\n  PrintArray<uint32>(null, 0);\n  print \"Null array:\\n\";\n  var a1 := returnANullArray();\n  PrintArray<uint32>(a1, 5);\n  print \"Non-Null array:\\n\";\n  var a2 := returnANonNullArray();\n  PrintArray<uint32>(a2, 5);\n  print \"Array in datatype:\\n\";\n  var someAr := new uint32[3];\n  someAr[0] := 1;\n  someAr[1] := 3;\n  someAr[2] := 9;\n  var ad := AD(someAr);\n  PrintArray<uint32>(ad.ar, 3);\n}"
},
{
    "dafny": "method Min(a:int, b:int, c:int) returns (m:int)\n  ensures (a >= 0 && m <= a) || (a < 0 && m <= -1*a);\n  ensures (b >= 0 && m <= b) || (b < 0 && m <= -1*b);\n  ensures (c >= 0 && m <= c) || (c < 0 && m <= -1*c);\n  ensures m >= 0;\n{\n  var a_abs:int := a;\n  var b_abs:int := b;\n  var c_abs:int := c;\n  if(a_abs < 0)\n  {\n    a_abs := a_abs * -1;\n  }\n  if(b_abs < 0)\n  {\n    b_abs := b_abs * -1;\n  }\n  if(c_abs < 0)\n  {\n    c_abs := c_abs * -1;\n  }\n  if(a_abs <= b_abs && a_abs <= c_abs)\n  {\n    m := a_abs;\n  }\n  else if (b_abs <= a_abs && b_abs <= c_abs)\n  {\n    m := b_abs;\n  }\n  else if (c_abs <= a_abs && c_abs <= b_abs)\n  {\n    m := c_abs;\n  }    \n}"
},
{
    "dafny": "datatype Result<T> = Failure(msg: string) | Success(value: T) {\n  predicate IsFailure() { Failure? }\n  function PropagateFailure(): Result<T> requires IsFailure() { this }\n  function Extract(): (t: T) requires !IsFailure() ensures t == this.value { this.value }\n}\nclass Cell {\n  var data: int\n}\nmethod M(a: array<int>, c: Cell) returns (r: Result<int>)\n  requires a.Length == 10\n  modifies a, c\n  ensures r.Success? ==> r.value == 200\n  ensures c.data == 9\n{\n  a[7] := 180;\n  c.data := 9;\n  r := Success(200);\n}\nmethod P() returns (r: Result<int>){\n  var a := new int[10];\n  a[7] := 321;\n  a[9] := 142;\n  var c := new Cell;\n  c.data := 7;\n  a[c.data] :- M(a, c);\n  assert a.Length == 10;\n  assert a[7] == 200;\n  assert c.data == 9;\n  print c.data, \" \", a[7], \" \", a[9], \"\\n\"; \n  r := *;\n}\nmethod Main() {\n  var _ := P();\n}"
},
{
    "dafny": "method Main()\n{\n    var a := new int[5];\n    a[0] := 0;\n    a[1] := 1;\n    a[2] := 2;\n    a[3] := 3;\n    a[4] := 4;\n    var s := a[..];\n    assert s == [0,1,2,3,4];\n    assert |s| == a.Length;\n    assert a[0..2] == [0,1];\n    assert 10 !in a[..];\n    assert a[3] == 3;\n    assert exists i :: 0 <= i < a.Length && a[i] == 3;\n}"
},
{
    "dafny": "method Saddleback(b: array2<int>, value: int) returns (x: int, y: int)\n  requires b != null;\n  requires (forall i,j0,j1:int :: 0 <= i && i < b.Length0 && \n     0 <= j0 && j0 <= j1 && j1 < b.Length1 ==> b[i,j0] <= b[i,j1]);\n  requires (forall i0, i1, j:int :: 0 <= i0 && i0 <= i1 && i1 < b.Length0 && \n     0 <= j && j < b.Length1 ==> b[i0,j] <= b[i1,j]);\n  ensures x == -1 ==> \n     (forall i,j:int :: 0 <= i && i < b.Length0 &&\n         0<=j && j < b.Length1 ==>\n         b[i, j] != value);\n  ensures x != -1 ==>\n     0 <= x && x < b.Length0 && 0 <= y && y < b.Length1 && value == b[x,y];\n{\n  x := 0;\n  y := b.Length1 - 1;\n  while(x < b.Length0 && y >= 0)\n    invariant 0 <= x && x <= b.Length0 &&\n\t-1 <= y && y < b.Length1 &&\n\t(forall i,j:int :: 0 <= i && i < b.Length0 &&\n\t\t0 <= j && j < b.Length1 ==>\n\t\t\t(i < x || j > y) ==> b[i, j] != value);\n    decreases b.Length0 - x + y;\n  {\n    var k := b[x,y];\n    if(k == value) {\n\t  return;\n    }\n    if(k < value) {\n      x := x + 1;\n    } else {\n      y := y - 1;\n    }\n  }\n  x := -1;\n}"
},
{
    "dafny": "method findmin(a: array<int>, i:int, j:int) returns (m: int)\n   requires 0 <= i < j <= a.Length ;\n   ensures i <= m < j ;\n   ensures forall k :: i <= k < j ==> a[m] <=a[k] ;\n{\n   m := i;\n   var index:int := i+1;\n   while (index < j)\n      invariant i+1 <= index <= j;\n      invariant i <= m < j ;\n      invariant forall k :: i <= k < index ==> a[m] <= a[k];\n      decreases a.Length-index ;\n   {\n        if( a[index]<a[m] ){\n          m := index;\n        }\n        index := index + 1;\n   }\n}"
},
{
    "dafny": "method Max(a: int, b: int) returns (c: int)\n  ensures c >= a\n  ensures c >= b\n  ensures a == c || b == c\n{\n  if (a > b) {\n    return a;\n  }\n  else {\n    return b;\n  }\n}"
},
{
    "dafny": "module BinarySearch{ \n    method BinarySearch(arr: array<int>, target: int) returns (index: int) \n    requires arr.Length > 0 \n    requires forall i :: 0 <= i < arr.Length-1 ==> arr[i+1] > arr[i] \n    ensures index == -1 || (0 <= index < arr.Length && arr[index] == target){\n        var hi:nat := arr.Length;\n        var lo:nat := 0;\n        while lo < hi decreases hi-lo\n        invariant 0 <= lo <= hi <= arr.Length{\n            index := (hi + lo) / 2;\n            if arr[index] < target {\n                lo := index + 1;\n            } else if arr[index] > target {\n                hi := index;\n            } else {\n                return;\n            }\n        }\n        return -1;\n    }   \n}"
},
{
    "dafny": "method MultipleReturns(x: int ,y: int ) returns (more: int , less: int)\n\tensures more + less == 2*x\n\tensures more - less == 2*y\n{\n\tmore := x + y;\n\tassert more == x + y;\n\tless := x - y;\n\tassert less == x - y;\n}\nmethod MultipleReturns2(x: int ,y: int ) returns (more: int, less: int)\n\trequires 0 < y\n\tensures less < x < more\n{\n\tmore := x + y;\n\tassert more > x;\n\tless := x - y;\n\tassert x > less;\n}\nmethod MultipleReturns3(x: int ,y: int ) returns (more: int, less: int)\n\trequires 0 < y\n\tensures less < x < more\n{\n\tassert x - y < x < x + y;\n\tmore := x + y;\n\tassert x - y < x < more;\n\tless := x - y;\n\tassert less < x < more;\n}\nfunction abs(x: int): int\n{\n\tif x < 0 then -x else x\n}\nmethod ComputeAbs(x: int) returns (y: int)\n\tensures y == abs(x)\n{\n\tif x < 0 { \n\t\treturn -x; \n\t}\n\telse { \n\t\treturn x; \n\t}\n}\npredicate isPrime(x: nat)\n{\n\tx > 1 && forall y :: 1 < y < x ==> x % y != 0\n}\npredicate isEven(x: nat )\n{\n\tx % 2 == 0\n}\nlemma Goldbach()\n\tensures forall x :: (x > 2 && isEven (x)) ==> \n\texists y1: nat, y2: nat :: isPrime(y1) && isPrime(y2) && x == y1 + y2\nfunction factorial(n: int ): int\n\trequires n >= 0\n{\n\tif n == 0 then 1 else n * factorial(n -1)\n}\nmethod ComputeFact (n: int) returns (f: int)\nrequires n >= 0\nensures f == factorial (n)\n{\n\tvar x := n;\n\tf := 1;\n\twhile x > 0\n\t\tinvariant f * factorial(x) == factorial(n);\n\t{\n\t\tf := f * x;\n\t\tx := x - 1;\n\t}\n}\nmethod compute_Fact2(n: int) returns (f: int)\n\trequires n >= 0\n\tensures f == factorial(n)\n{\n\tvar x := 0;\n\tf := 1;\n\twhile x < n \n\t\tinvariant 0 <= x <= n\n\t\tinvariant f == factorial(x);\n\t{\n\t\tx := x + 1;\n\t\tf := f * x;\n\t}\n}\nmethod Square (a: int) returns (x: int)\n\trequires a >= 1\n\tensures x == a * a\n{\n\tx := 1;\n\tvar y := 1;\n\twhile y < a\n\t\tinvariant 1 <= y <= a\n\t\tinvariant x == y*y\n\t{\n\t\ty := y + 1;\n\t\tx := x + 2*y - 1;\n\t}\n}\nmethod Square2 (a: int) returns (x: int)\n\trequires a >= 1\n\tensures x == a * a\n{\n\tx := 1;\n\tvar y := 1;\n\twhile y < a\n\t\tinvariant 1 <= y <= a\n\t\tinvariant x == sumSerie(y)\n\t{\n\t\ty := y + 1;\n\t\tx := x + 2*y - 1;\n\t}\n\tassert 1 <= y <= a && x == sumSerie(y) && y >= a;\n\tassert y == a && x == sumSerie(y);\n\tassert x == sumSerie(a);\n\tsumSerie_Lemma(a);\n\tassert x == a * a;\n}\nfunction sumSerie (n: int): int\n\trequires n >= 1\n{\n\tif n == 1 then 1 else sumSerie(n-1) + 2*n - 1\n}\nlemma sumSerie_Lemma(n: int)\n\trequires n >= 1\n\tensures sumSerie(n) == n*n\n{}\nfunction power(b: int, e: nat): int\n{\n\tif e == 0 then 1 else b* power(b, e-1)\n}\nmethod compute_power(b: int, e: nat) returns (p: int)\n\tensures p == power(b, e)\n{\n\tvar t, x := e, b;\n\tp := 1;\n\twhile t > 0\n\t\tinvariant 0 <= t <= e\n\t\tinvariant p * power(x, t) == power(b, e)\n\t{\n\t\tif t % 2 == 0 {\n\t\t\teven_Lemma(x, t);\n\t\t\tx, t := x*x, t/2;\n\t\t}\n\t\telse {\n\t\t\tp, t := p*x, t-1;\n\t\t}\n\t}\n}\nlemma even_Lemma (b: int, e: nat)\n\trequires e % 2 == 0\n\tensures power(b, e) == power(b*b, e/2)\n{\n\tif e > 0 {\n\t\teven_Lemma(b, e-2);\n\t\tassert power(b, e) == b*b * power(b, e-2) == b*b * power(b*b, (e/2-1)) == power(b*b, e/2);\n\t}\n}"
},
{
    "dafny": "predicate valid_base(b : nat) {\n  b >= 2\n}\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\nmethod nit_increment(b : nat, n : nat) returns (sum : nat, carry : nat)\n  requires (valid_base(b))\n  requires (nitness(b, n))\n  ensures (nitness(b, sum))\n  ensures (nitness(b, carry))\n{\n  sum := (n + 1) % b;\n  carry := (n + 1) / b;\n}\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\nmethod max_nit(b: nat) returns (nmax : nat)\n  requires (valid_base(b))\n  ensures (nitness(b, nmax))\n  ensures (is_max_nit(b, nmax))\n{\n  nmax := b - 1;\n}\nmethod nit_flip(b: nat, n : nat) returns (nf : nat)\n  requires (valid_base(b))\n  requires (nitness(b, n))\n  ensures (nitness (b, nf))\n{\n  var mn : nat := max_nit(b);\n  assert 0 < n < b ==> n <= b - 1;\n  assert 0 == n ==> n <= b - 1;\n  assert n <= b - 1;\n  assert mn == b - 1;\n  assert 0 <= n <= mn;\n  nf := mn - n;\n}\nmethod nit_add(b : nat, x : nat, y : nat) returns (z : nat, carry : nat)\n  requires (valid_base(b))\n  requires (nitness(b, x))\n  requires (nitness(b, y))\n  ensures  (nitness(b, z))\n  ensures  (nitness(b, carry))\n  ensures  (carry == 0 || carry == 1)\n{\n  z := (x + y) % b;\n  carry := (x + y) / b;\n  assert x + y < b + b;\n  assert (x + y) / b < (b + b) / b;\n  assert (x + y) / b < 2;\n  assert carry < 2;\n  assert carry == 0 || carry == 1;\n}\nmethod nit_add_three(b : nat, c : nat, x : nat, y : nat) returns (z : nat, carry : nat)\n  requires (valid_base(b))\n  requires (c == 0 || c == 1)\n  requires (nitness(b, x))\n  requires (nitness(b, y))\n  ensures  (nitness(b, z))\n  ensures  (nitness(b, carry))\n  ensures  (carry == 0 || carry == 1)\n{\n  if(c == 0) {\n    z, carry := nit_add(b, x, y);\n  } else {\n    z := (x + y + 1) % b;\n    carry := (x + y + 1) / b;\n    assert 0 <= b - 1;\n    assert 0 <= x < b;\n    assert 0 == x || 0 < x;\n    assert 0 < x ==> x <= b - 1;\n    assert 0 <= x <= b - 1;\n    assert 0 <= y < b;\n    assert 0 == y || 0 < y;\n    assert 0 <= b - 1;\n    assert 0 < y ==> y <= b - 1;\n    assert 0 <= y <= b - 1;\n    assert x + y <= (b - 1) + (b - 1);\n    assert x + y <= 2 * b - 2;\n    assert x + y + 1 <= 2 * b - 2 + 1;\n    assert x + y + 1 <= 2 * b - 1;\n    assert 2 * b - 1 < 2 * b;\n    assert x + y + 1 < 2 * b;\n    assert (x + y + 1) / b < 2;\n    assert (x + y + 1) / b == 0 || (x + y + 1) / b == 1;\n  }\n}\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\nmethod bibble_add(b : nat, p : seq<nat>, q : seq<nat>) returns (r : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  requires (bibble(b, q))\n  ensures  (bibble(b, r))\n{\n  var z3, c3 := nit_add(b, p[3], q[3]);\n  var z2, c2 := nit_add_three(b, c3, p[2], q[2]);\n  var z1, c1 := nit_add_three(b, c2, p[1], q[1]);\n  var z0, c0 := nit_add_three(b, c1, p[0], q[0]);\n  r := [z0, z1, z2, z3];\n}\nmethod bibble_increment(b : nat, p : seq<nat>) returns (r : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  ensures  (bibble(b, r))\n{\n  var q : seq<nat> := [0, 0, 0, 1];\n  assert bibble(b, q);\n  r := bibble_add(b, p, q);\n}\nmethod bibble_flip(b : nat, p : seq<nat>) returns (fp : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  ensures  (bibble(b, fp))\n{\n  var n0 := nit_flip(b, p[0]);\n  var n1 := nit_flip(b, p[1]);\n  var n2 := nit_flip(b, p[2]);\n  var n3 := nit_flip(b, p[3]);\n  fp := [n0, n1, n2, n3];\n}\nmethod n_complement(b : nat, p : seq<nat>) returns (com : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  ensures  (bibble(b, com))\n{\n  var fp := bibble_flip(b, p);\n  var fpi := bibble_increment(b, fp);\n  com := fpi;\n}\nmethod Main() {\n  var b := 3;\n  var bibble1 := [2, 1, 0, 2];\n  var complement := n_complement(b, bibble1);\n  var bibble_sum := bibble_add(b, bibble1, complement);\n  print bibble1, \" + \", complement, \" = \", bibble_sum, \" (should be [0, 0, 0, 0])\\n\";\n}"
},
{
    "dafny": "method QuickSort(a: array<int>, start: int, end: int)\n   requires a.Length >= 1;\n   requires 0 <= start <= end <= a.Length; \n   requires 0 <= start <= end < a.Length ==> \n    forall j :: start <= j < end ==> a[j] < a[end];\n   requires 0 < start <= end <= a.Length ==>\n    forall j :: start <= j < end ==> a[start - 1] <= a[j];\n   modifies a;\n   ensures sorted(a, start, end);\n   ensures forall j :: 0 <= j < start || end <= j < a.Length ==> old(a[j]) == a[j];\n   ensures 0 <= start <= end < a.Length ==>\n    forall j :: start <= j < end ==> a[j] < a[end];\n   ensures 0 < start <= end <= a.Length ==>\n    forall j :: start <= j < end ==> a[start - 1] <= a[j];\n   decreases end - start;\n{\n   if(end - start > 1)\n   {\n     var pivot := partition(a, start, end);\n     QuickSort(a, start, pivot);\n     QuickSort(a, pivot + 1, end);\n   } else {\n     return;\n   }\n}\npredicate sorted (a: array<int> ,low: int , high :int )\n  requires 0 <= low <= high <= a.Length;\n  reads a;\n{\n  forall j,k ::low <= j < k < high ==> a[j] <= a[k]\n}\nmethod partition(a: array<int>, start: int, end: int) returns (pivot: int)\n   requires a.Length > 0;\n   requires 0 <= start < end <= a.Length;\n   requires 0 <= start <= end < a.Length ==>\n    forall j :: start <= j < end ==> a[j] < a[end];\n   requires 0 < start <= end <= a.Length ==>\n    forall j :: start <= j < end ==> a[start - 1] <= a[j];\n   modifies a;\n   ensures 0 <= start <= pivot < end <= a.Length;\n   ensures forall j :: start <= j < pivot ==> a[j] < a[pivot];\n   ensures forall j :: pivot < j < end ==> a[pivot] <= a[j];\n   ensures forall j :: 0 <= j < start || end <= j < a.Length ==> old(a[j]) == a[j];\n   ensures 0 <= start <= end < a.Length ==>\n    forall j :: start <= j < end ==> a[j] < a[end];\n   ensures 0 < start <= end <= a.Length ==>\n    forall j :: start <= j < end ==> a[start - 1] <= a[j];\n{\n    pivot := start;\n    var index := start + 1; \n      while(index < end)\n         invariant start <= pivot < index <= end;\n         invariant forall j :: start <= j < pivot ==> a[j] < a[pivot];\n         invariant forall j :: pivot < j < index ==> a[pivot] <= a[j];\n         invariant forall j :: 0 <= j < start || end <= j < a.Length ==>\n            old(a[j]) == a[j];\n         invariant 0 <= start <= end < a.Length ==> \n            forall j :: start <= j < end ==> a[j] < a[end];\n         invariant 0 < start <= end <= a.Length ==> \n            forall j :: start <= j < end ==> a[start - 1] <= a[j];\n      {\n         if(a[index] < a[pivot]) \n         {\n          assert 0 < start <= end <= a.Length ==> \n          forall j :: start <= j < end ==> a[start - 1] <= a[j];\n \tvar counter := index - 1;\n \tvar temp := a[index];\n \ta[index] := a[counter];\n \twhile(counter > pivot)\n \t   invariant forall j :: start <= j < pivot ==> a[j] < a[pivot];\n \t   invariant forall j :: pivot < j < index + 1 ==> a[pivot] <= a[j];\n \t   invariant a[pivot] > temp;\n\t   invariant forall j :: 0 <= j < start || end <= j < a.Length ==> old(a[j]) == a[j];\n \t   invariant 0 <= start <= end < a.Length ==> \n                forall j :: start <= j < end ==> a[j] < a[end];\n     \t   invariant 0 < start <= end <= a.Length ==> \n                forall j :: start <= j < end ==> a[start - 1] <= a[j];\n\t{\n \t   a[counter + 1] := a[counter];\n \t   counter := counter - 1;\n \t}\n \ta[pivot + 1] := a[pivot];\n \tpivot := pivot + 1;\n \ta[pivot - 1] := temp;\n       }\n       index := index + 1;\n     }\n}\nmethod Main() {\n  var a := new int[5];\n  a[0] := 2;\n  a[1] := 5;\n  a[2] := 4;\n  a[3] := 1;\n  a[4] := 7;\n  print a[0], \" \", a[1], \" \", a[2], \" \", a[3], \" \", a[4], \"\\n\";\n  QuickSort(a,0,a.Length);\n  print a[0], \" \", a[1], \" \", a[2], \" \", a[3], \" \", a[4], \"\\n\";\n}"
},
{
    "dafny": "class Stack {\n  var a: array<int>;\n  var size:int;\n  function isEmpty():bool \n    reads `size\n  { size == 0 }\n  function RepInv():bool\n    reads `size, `a\n  {\n    0 < a.Length && 0 <= size <= a.Length\n  }\n  constructor() \n    ensures RepInv()\n  {\n    a := new int[1];\n    size := 0;\n  }\n  method push(x:int) \n    requires RepInv()\n    ensures !isEmpty() && RepInv()\n    modifies `a, `size, a\n  {\n    if( size >= a.Length ) { grow(); }\n    a[size] := x;\n    size := size + 1;\n  }\n  method pop() returns (x:int)\n    requires RepInv() && !isEmpty()\n    requires RepInv()\n    modifies `size\n  {\n    size := size - 1;\n    return a[size];\n  }\n  method grow() \n    requires RepInv()\n    ensures RepInv()\n    ensures size < a.Length\n    ensures forall k:int :: 0 <= k < size ==> a[k] == old(a[k])\n    ensures fresh(a)\n    modifies `a\n  {\n    var b := new int[a.Length*2];\n    var i := 0;\n    while i < size \n      decreases size - i \n      invariant 0 <= i <= size\n      invariant forall k :: 0 <= k < i ==> b[k] == a[k]\n      modifies b\n    {\n      b[i] := a[i];\n      i := i + 1;\n    }\n    a := b;\n  }\n}"
},
{
    "dafny": "method Main()\n{\n    var s := [1,2,3,4,5];\n    var vazia: seq<int> := [];\n    assert |s| == 5; \n    assert |vazia| == 0;\n    assert s[0] == 1; \n    assert s[1..3] == [2,3]; \n    assert s[1..] == [2,3,4,5];\n    assert s[..4] == [1,2,3,4];\n    assert [1,2,3] + [2,3] == [1,2,3,2,3]; \n    assert s[2 := 6] == [1,2,6,4,5]; \n    assert 1 in s; \n    assert 0 !in s;\n    assert vazia < s; \n    assert [1] < s;\n    assert [1,2,3,4,5] <= s;\n    assert !([0,1] < s);\n    assert forall i :: i in s ==> 1 <= i < 6;\n    var t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\n    assert |t| == 3;\n    assert t[0] == [3.14];\n    assert t[1] == [];\n    assert t[2] == [2.7, 1.41, 1985.44];\n    assert t[0][0] == 3.14;\n}"
},
{
    "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    assert More(x) == 1; \n  } else {\n    assert More(x) == More(x - 2) + 3; \n    Increasing(x - 2); \n    assert x - 2 < More(x - 2); \n    assert x + 1 < More(x - 2) + 3; \n    assert x + 1 < More(x); \n  }\n}"
},
{
    "dafny": "function Ackermann (m: nat, n : nat) : nat\ndecreases m,n;\n{\n\tif m == 0 then\n\tn + 1\n\telse if n == 0 then\n\tAckermann (m - 1, 1)\n\telse\n\tAckermann (m - 1, Ackermann(m, n-1))\n}\nmethod Hoenicke(x: int, y: int)\n{\n\tvar m := x;\n\tvar n := y;\n\twhile (n > 0 && m < 100)\n\tdecreases 100 - m;\n\t{\n\t\tm := m + n;\n\t}\n}\nmethod Find (a: array<int>, key: int) returns (index: int)\nrequires a != null;\nensures 0 <= index ==> index < a.Length && a[index] == key;\nensures index < 0 ==> forall k :: 0 <= k < a.Length\n==> a[k] != key;\n{\nindex := -1;\nvar i := 0;\nwhile (i < a.Length)\ninvariant 0 <= i <= a.Length;\ninvariant 0 <= index ==>\nindex < a.Length && a[index] == key;\ninvariant index < 0 ==>\nforall k :: 0 <= k < i ==> a[k] != key;\n{\n\tif (a[i] == key) {\n\t\tindex := i;\n\t}\n\ti:= i + 1;\n}\n}\nmethod max (a: array<int>) returns (index:int)\nrequires a != null;\nrequires a.Length >0\n{\n\tindex :=0;\n\tvar i :=0;\n\twhile(i<a.Length)\n\tinvariant 0 <= i <= a.Length;\n\tinvariant 0 <= index < a.Length;\n\t{\n\t\tif(a[index]<a[i]){\n\t\tindex :=i;\n\t\t}\n\t\ti:= i +1;\n\t}\n}\nfunction sorted (a: array<int>) : bool\nrequires a!= null;\nreads a;\n{\nforall k,j :: 0 <= k < j < a.Length ==> a[k] <= a[j]\n}\nmethod smax (a: array<int>) returns (index:int)\nrequires a != null;\nrequires a.Length >0\n{\n\tif(a.Length == 1 )\n\t{\n\t\tindex:=0;\n\t}\n\telse{\n\t\tif ( a [0]>a[1]){\n\t\t\tindex :=0;\n\t\t}\n\t\telse{\n\t\tindex:= a.Length -1;\n\t\t}\n\t }\n}\nfunction distinct (a: array<int>) : bool\nrequires a!= null;\nreads a;\n{\n\tforall k,j :: 0 <= k < j < a.Length ==> a[k] != a[j]\n}\nmethod addCustomer(a: array<int>, v: int) returns (r: array<int>)\nrequires a != null;\nrequires distinct(a);\nensures r != null;\nensures distinct(r);\nensures exists i :: 0 <= i < r.Length && r[i] == v;\n{\n\tvar i:=0;\n\tif (a.Length ==0){\n\t r:= new int [1];\n\t r[0]:=v;\n\t}\n\telse{\n\t\tif (!exists i :: 0 <= i < a.Length && a[i] == v)\n\t\t{\n\t\t\tr :=  new int[a.Length+1];\n\t\t\ti:=0;\n\t\t\twhile (i<a.Length)\n\t\t\tinvariant 0 <= i <= a.Length;\n\t\t\tinvariant forall j :: 0 <=j <i  ==> r[j]==a[j];\n\t\t\t{\n\t\t\t\tr[i]:=a[i];\n\t\t\t\ti:=i+1;\n\t\t\t}\n\t\t\tr[r.Length-1]:=v;\n\t\t}\n\t\telse{\n\t\t\tr:=a;\n\t\t}\n\t}\n}"
},
{
    "dafny": "least predicate P(x: int) {\n  x == 123 || P(x)\n}\nlemma BuildP(x: int) requires x == 123 ensures P(x) {}\ngreatest predicate Q(x: int) {\n  true && Q(x)\n}\ngreatest lemma BuildQ(x: int)\n  ensures Q(x)\n{\n}\nlemma AdvBuildQ(x: int)\n  ensures Q(x)\n{\n  forall k: ORDINAL { AdvBuildQAux(k, x); }\n}\nlemma AdvBuildQAux(k: ORDINAL, x: int) ensures Q#[k](x) {}\ngreatest predicate R(x: bool) {\n  x ==> R(x)\n}\ngreatest lemma BuildR(x: bool) ensures R(true) {}\ntrait Object {}\ngreatest predicate A(x: Object) {\n  B(x)\n}\ngreatest predicate B(x: Object) {\n  A(x)\n}\nlemma BuildA(x: Object) ensures A(x) {\n  forall k: ORDINAL { BuildAAux(k, x); }\n}\nlemma BuildAAux(k: ORDINAL, x: Object) ensures A#[k](x) {\n  forall j: ORDINAL | j < k { BuildBAux(j, x); }\n}\nlemma BuildBAux(k: ORDINAL, x: Object) ensures B#[k](x) {\n  forall j: ORDINAL | j < k { BuildAAux(j, x); }\n}\ntrait TraitA {\n  var b: TraitB\n}\ntrait TraitB {\n  var a: TraitA\n}\ngreatest predicate invA(self: TraitA) reads * {\n  invB(self.b)\n}\ngreatest predicate invB(self: TraitB) reads * {\n  invA(self.a)\n}\nlemma EstablishInvA(self: TraitA)\n  ensures invA(self)\n{\n  forall k: ORDINAL { EstablishInvAuxA(k, self); }\n}\nlemma EstablishInvAuxA(k: ORDINAL, self: TraitA)\n  ensures invA#[k](self)\n{\n  forall j: ORDINAL | j < k { EstablishInvAuxB(j, self.b); }\n}\nlemma EstablishInvB(self: TraitB)\n  ensures invB(self)\n{\n  forall k: ORDINAL { EstablishInvAuxB(k, self); }\n}\nlemma EstablishInvAuxB(k: ORDINAL, self: TraitB)\n  ensures invB#[k](self)\n{\n  forall j: ORDINAL | j < k { EstablishInvAuxA(j, self.a); }\n}\ngreatest lemma AlternativeEstablishInvA(self: TraitA) ensures invA(self) && invB(self.b) {}\ngreatest lemma AlternativeEstablishInvB(self: TraitB) ensures invB(self) && invA(self.a) {}"
},
{
    "dafny": "method Product2 (m: nat, n: nat) returns (res:nat) \n    ensures res == m * n; \n{   \n    var m1: nat := m; \n    var n1: nat; \n    res := 0; \n    while (m1 > 0)\n        invariant m1 >= 0 && res == (m - m1) * n\n    { \n        n1 := n; \n        while (n1 > 0)  \n            invariant n1 >= 0 && res == (m - m1) * n + (n - n1)\n        { \n            res := res + 1;\n            n1 := n1 - 1; \n        } \n        m1 := m1 - 1; \n    } \n }"
},
{
    "dafny": "class BoundedQueue<T(0)>\n{\t\n    ghost var Elements: seq<T>\n    ghost var max: int \n    ghost var Repr: set<object>\n    var wr: nat\n    var rd: nat\n    var data: array<T>\n    ghost predicate Valid()\n        reads this, Repr\n        ensures Valid() ==> this in Repr\n    {\n        this in Repr && data in Repr &&\n        wr <= max && rd <= max && data.Length == max + 1 &&\n        Elements == if rd <= wr then data[rd..wr]\n                    else data[rd..] + data[..wr]\n    }\n}"
},
{
    "dafny": "type T\nfunction f(a: T) : bool\nmethod Select(s1: seq<T>) returns (r: seq<T>) \n  ensures (forall e: T  :: f(e) ==> multiset(s1)[e] == multiset(r)[e])\n  ensures (forall e: T  :: (!f(e)) ==> 0 == multiset(r)[e])\nmethod Main(s1: seq<T>)\n{\n   var r1, r2: seq<T>;\n   r1 := Select(s1);\n   r2 := Select(s1);\n   assert multiset(r1) == multiset(r2);\n}"
},
{
    "dafny": "method test(c: Class) {\n    reveal Class.P();\n    reveal Class.Q();\n    reveal f();\n    assert c.P();\n    assert c.Q();\n    assert f();\n}\nclass Class {\n  opaque function P() : bool { true }\n  opaque twostate function Q() : bool { true }\n}\nopaque function f() : bool { true }"
},
{
    "dafny": "method Test()\n{\n    var res;\n    res := Fibonacci(0);\n    assert res == 0;\n    res := Fibonacci(1);\n    assert res == 1;\n    res := Fibonacci(2);\n    assert res == 1;\n    res := Fibonacci(3);\n    assert res == 2;\n    res := Fibonacci(4);\n    assert res == 3;\n    res := Fibonacci(5);\n    assert res == 5;\n    res := Fibonacci(6);\n    assert res == 8;\n}\nfunction Fib(n: nat): nat\n    decreases n\n{\n    if n == 0 then\n        0\n    else if n == 1 then\n        1\n    else\n        Fib(n - 1) + Fib(n - 2)\n}\nmethod Fibonacci(n: nat) returns (b: nat)\n    ensures b == Fib(n);\n{\n    if n == 0 {\n        return 0;\n    }\n    var a := 0;\n        b := 1;\n    var i := 1;\n    while i < n\n        decreases n - i;\n        invariant 0 < i <= n;\n        invariant a == Fib(i - 1);\n        invariant b == Fib(i);\n    {\n        a, b := b, a + b;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "function exp(n: int, e: int): int\n\trequires e >= 0;\n\t{\n\t\tif e>0 then n*exp(n,e-1) else 1\n\t}\nmethod expon(n: int, e: int) returns(r: int)\n\trequires e >= 0;\n\tensures r == exp(n,e);\n\t{\n\t\tvar b: int := e;\n\t\tr := 1;\n\t\twhile (b>0)\n\t\tinvariant 0 <= b;\n\t\tinvariant exp(n,e) == exp(n,b) * r;\n\t\t{\n\t\t\tr := r * n;\n\t\t\tb := b - 1;\n\t\t}\n\t}"
},
{
    "dafny": "method pqrt(wxyz: string) returns (abcd: bool)\n{\n  abcd := true;\n  for efgh := 0 to |wxyz|\n    invariant abcd <==> (forall ijkl :: 0 <= ijkl < efgh ==> wxyz[ijkl] in \"0123456789\")\n  {\n    if !(wxyz[efgh] in \"0123456789\") {\n      return false;\n    }\n  }\n}"
},
{
    "dafny": "method LinearSearch<T>(a: array<T>, P: T -> bool) returns (n: int)\n    ensures 0 <= n <= a.Length\n    ensures n == a.Length || P(a[n])\n    ensures forall i :: 0 <= i < n ==> !P(a[i])\n{\n    n := 0;\n    while n != a.Length\n        invariant 0 <= n <= a.Length\n        invariant forall i :: 0 <= i < n ==> !P(a[i])\n    {\n        if P(a[n]) {\n            return;\n        }\n        n := n + 1;\n    }\n}"
},
{
    "dafny": "class C {\n  constructor C() { }\n  method Main()  \n  {\n    print \"hello, I'm running ... in C\\n\";\n  }\n}\nclass D {\n  method Main()  \n   modifies this;\n  {\n    print \"hello, I'm running ... in D\\n\";\n  }\n}\nclass E {\n  static method Main()  \n   requires true;\n  {\n    print \"hello, I'm running ... in E\\n\";\n  }\n}"
},
{
    "dafny": "method a_2_26(x: int, y: int)\nrequires 2 * x + y <= 98\nensures 2 * x + y <= 99\n{\n    var x := x + 1;\n    var y := x + y;\n}\nmethod b_2_26(x: int, y: int) returns (z: int)\nrequires 2 * x + y <= 99\nensures z <= 100\n{\n    var y := x + y;\n    var x := x + 1;\n    z := x + y;\n}\nmethod c_2_26(x: int, y: int)\nrequires 2 * x + y <= 99\nensures 2 * x + y <= 99\n{\n    var x, y := x + 1, x + y;\n}\nmethod exerciseA(x: int, y: int)\nrequires x + y < 100\nensures true\n{   \n    var x := 0;\n    var y := 0;\n    x := 32;\n    y := 40;\n}\nmethod exerciseB(x: int, y: int) \nrequires -2 * x + y - 4 < 100\nensures -2 * x + y - 4 < 100\n{\n    var x := 0;\n    var y := 0;\n    x := x + 2;\n    y := y - 3 * x;\n}\nmethod a_2_30(x: int, y: int)\nrequires x < 10\nensures x < 10\n{\n    if x % 2 == 0 { \n        var y := y + 3; \n    } else {\n        var y := 4; \n    }\n}"
},
{
    "dafny": "predicate IsSorted( a: seq<int> )\n{\n    forall p,q | 0 <= p < q < |a| :: a[p] <= a[q]\n}\nlemma Singleton( m: multiset<int>, s: seq<int>, x: int )\n    requires x in m;\n    requires x in s;\n    requires |s| == 1 == |m|;\n    ensures |m-multiset{x}| == 0;\n    ensures s == [x];\n    ensures m == multiset{x};\n    ensures m == multiset(s);\n    ensures IsSorted(s);\n{}\nmethod RemoveOne( a: multiset<int> ) returns( b: multiset<int>, x: int )\n    requires |a| >= 1;\n    ensures a == b+multiset{x};\n{\n    x :| x in a;\n    b := a-multiset{x};\n}\nlemma LomutoLemma   ( a: multiset<int>\n                    , a': seq<int>\n                    , x: int\n                    , b: multiset<int>\n                    , b': seq<int>\n                    , c: seq<int> \n                    )\n    requires a == multiset(a');\n    requires b == multiset(b');\n    requires IsSorted(a');\n    requires IsSorted(b');\n    requires forall z | z in a :: z<=x;\n    requires forall z | z in b :: z>=x;\n    requires c == a'+[x]+b';\n    ensures forall p | 0<=p<|a'| :: a'[p] in a;\n    ensures forall p | 0<=p<|b'| :: b'[p] in b;\n    ensures forall z | z in a' :: z in a && z<=x;\n    ensures forall z | z in b' :: z in b && z>=x;\n    ensures forall z | z in a' :: z in a && z<=x;\n    ensures forall z | z in b' :: z in b && z>=x;\n    ensures IsSorted(c);\n    ensures multiset(c) == a+multiset{x}+b;\n{\n    assert |c| == |a'|+1+|b'|;\n    assert forall p,q | 0<=p<q<|c| :: q<|a'| ==> c[p]<=c[q];\n    assert forall p,q | 0<=p<q<|c| :: q==|a'| ==> c[q]==x && p<|a'| && c[p]==a'[p] && c[p] in a && c[p]<=c[q];\n    assert forall p,q | 0<=p<q<|c| :: p<|a'| && q>|a'| ==> c[p] in a && c[q] in b && c[p]<=c[q];\n    assert forall p,q | 0<=p<q<|c| :: p==|a'| && q>|a'| ==> c[p]==x && c[q] in b && c[p]<=c[q];\n    assert forall p,q | 0<=p<q<|c| :: p>|a'| && q>|a'| ==> c[p]<=c[q];\n}\nmethod Test( m: multiset<int> )\n{\n    var s := Sort(m);\n    assert IsSorted(s);\n    assert m == multiset(s);\n    if |m| > 0\n    {\n        var a,p,b := Partition(m);\n        assert m == a+multiset{p}+b;\n        assert forall z | z in a :: z<=p;\n        assert forall z | z in b :: z>=p;\n    }\n}\nmethod Main()\n{\n    var x := Sort(multiset{0,9,1,8,2,7,3,6,4,5\n                          ,0,9,1,8,2,7,3,6,4,5\n                          }\n                 );\n    print x;    \n}\nmethod Partition( a: multiset<int> ) returns ( b: multiset<int>, p: int, c: multiset<int> )\n    requires |a| >= 1;\n    ensures a == b+multiset{p}+c;\n    ensures forall z | z in b :: z <= p;\n    ensures forall z | z in c :: z >= p;\n    ensures |b|==|b|<|a|;\n    ensures |c|<|a|;\n{\n    var rest := a;\n    p :| p in rest;\n    rest := rest - multiset{p};\n    b := multiset{};\n    c := multiset{};\n    while rest != multiset{}\n        decreases |rest|;\n        invariant a == rest+b+multiset{p}+c;\n        invariant forall z | z in b :: z<=p;\n        invariant forall z | z in c :: z>=p;\n    {\n        var z :| z in rest;\n        if z <= p \n        {\n            b := b+multiset{z};\n        }\n        else \n        { \n            c := c+multiset{z}; \n        }\n        rest := rest - multiset{z};\n    }\n}\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    decreases m;\n    ensures m == multiset(r);\n    ensures IsSorted(r);\n{\n    if |m| == 0\n    {\n        return [];\n    }\n    var b,p,c := Partition(m);\n    var b' := Sort(b);\n    var c' := Sort(c);\n    r :=  b'+[p]+c';\n    LomutoLemma(b,b',p,c,c',r);\n}"
},
{
    "dafny": "class Secret{\n  var secret : int; \n  var known : bool; \n  var count : int;  \n  method Init(x: int)\n    requires 0 < x <= 10\n    ensures secret == x\n    ensures count == 0\n    ensures !known\n    modifies this\n  {\n    known := false;\n    count := 0;\n    secret := x;\n  }\n  method Guess(g : int) returns (result : bool, guesses : int)\n    requires !known\n    ensures count == old(count) + 1\n    ensures g == secret <==> known\n    ensures result <==> known\n    ensures guesses == count\n    modifies `count, `known\n  {\n    count := count + 1;\n    if (g == secret) {\n      known := true;\n    }\n    result := known;\n    guesses := count;\n  }\n  method Main(){\n    var s := new Secret;\n    s.Init(7);\n    assert (!s.known);\n    assert (s.count == 0);\n    var r, g := s.Guess(3);\n    assert (!r);\n    assert (g == 1);\n    r, g := s.Guess(7);\n    assert (r);\n    assert (g == 2);\n  }\n}"
},
{
    "dafny": "class TestingBlood {\n    var id: int;\n    var retrieval: int;\n    var startTest: int;\n    predicate Valid()\n    reads this\n    {\n        startTest > retrieval\n    }\n    constructor (bloodid: int, rdate: int, sdate: int)\n    requires sdate > rdate\n    ensures id == bloodid && rdate == retrieval && sdate == startTest\n    modifies this`id,  this`retrieval, this`startTest\n    ensures Valid()\n    {\n        id := bloodid;\n        retrieval := rdate;\n        startTest := sdate;\n    }\n}"
},
{
    "dafny": "predicate divides(f:nat, i:nat)\n  requires 1<=f\n{\n  i % f == 0\n}\npredicate IsPrime(i:nat)\n{\n  && 1 < i\n  && forall f :: 1 < f < i ==> !divides(f, i)\n}\nmethod Main()\n{\n  assert !IsPrime(0);\n  assert !IsPrime(1);\n  assert IsPrime(2);\n  assert IsPrime(3);\n  assert divides(2, 6);\n  assert !IsPrime(6);\n  assert IsPrime(7);\n  assert divides(3, 9);\n  assert !IsPrime(9);\n}"
},
{
    "dafny": "method aqsw(efgh: seq<int>) returns (wxyz:array<int>, uvwx:bool)\n{\n  uvwx := false;\n  wxyz := new int[|efgh| + 1];\n  var mnoq := 0;\n  wxyz[mnoq] := 0;\n  while mnoq < wxyz.Length\n    invariant 0 <= mnoq <= wxyz.Length\n    invariant wxyz[0]==0\n    invariant wxyz.Length == |efgh| + 1\n    invariant forall y :: 0 <= y < mnoq-1 ==> wxyz[y+1]==wxyz[y]+efgh[y]\n  {\n    if mnoq>0{\n        wxyz[mnoq] := wxyz[mnoq - 1] + efgh[mnoq - 1];\n    }\n    mnoq := mnoq + 1;\n  }\n  mnoq:=0;\n  while mnoq < wxyz.Length\n    invariant 0 <= mnoq <= wxyz.Length\n    invariant forall y :: 0 <= y < mnoq ==> wxyz[y] >= 0\n  {\n    if wxyz[mnoq] < 0 {\n      uvwx := true;\n      return;\n    }\n    mnoq := mnoq + 1;\n  }\n}"
},
{
    "dafny": "datatype Pair = Pair(first: int, second: int)\nfunction make_rat(n: int, d: int): Pair\n    ensures make_rat(n, d) == Pair(n, d)\n{\n    Pair(n, d)\n}\nfunction numer(n: Pair): int\n    ensures numer(n) == n.first\n{\n    n.first \n}\nfunction denom(n: Pair): int\n    ensures denom(n) == n.second\n{\n    n.second\n}\npredicate eq(n1: Pair, n2: Pair)\n{\n    numer(n1) * denom(n2) == numer(n2) * denom(n1)\n}\nfunction add_rat(n1: Pair, n2: Pair): Pair \n    ensures numer(add_rat(n1, n2)) == numer(n1) * denom(n2) + numer(n2) * denom(n1)\n    ensures denom(add_rat(n1, n2)) == denom(n1) * denom(n2)\n{\n    Pair(numer(n1) * denom(n2) + numer(n2) * denom(n1), denom(n1) * denom(n2))\n}\nfunction sub_rat(n1: Pair, n2: Pair): Pair \n    ensures numer(add_rat(n1, n2)) == numer(n1) * denom(n2) + numer(n2) * denom(n1)\n    ensures denom(add_rat(n1, n2)) == denom(n1) * denom(n2)\n{\n    Pair(numer(n1) * denom(n2) + numer(n2) * denom(n1), denom(n1) * denom(n2))\n}"
},
{
    "dafny": "function sumDigits(n: nat) : nat {\n    if n < 10 then n else n%10 + sumDigits(n/10)\n}\nlemma {:induction false} div3Lemma(n: nat)\nensures sumDigits(n)%3 == n%3\n{\n    if (n < 10) {\n    } else {\n        div3Lemma(n/10);\n    }\n}"
},
{
    "dafny": "method Main() {\n    var st1: set<nat> := {};\n    st1 := st1 + {1,2,3};\n    assert 1 in st1;\n    st1 := st1 - {1};\n    assert 1 !in st1;\n    assert st1 == {2, 3};\n    assert st1 <= {2,3,4};\n    assert st1 !! {1,4};\n    var sq1: seq<nat> := [];\n    sq1 := sq1 + [1,2,3];\n    assert sq1[1] == 2;\n    sq1 := sq1[1..];\n    assert sq1 == [2,3];\n    sq1 := sq1[..1];\n    assert sq1 == [2];\n    var m1: map<string,nat> := map[];\n    m1 := m1[\"k1\" := 1];\n    assert m1[\"k1\"] == 1;\n    m1 := m1[\"k2\" := 2];\n    assert \"k2\" in m1;\n    assert \"k1\" in m1;\n    m1 := map k | k in m1 && k != \"k1\" :: m1[k];\n    assert \"k1\" !in m1;\n}"
},
{
    "dafny": "method binarySearch(a: array<int>, x: int) returns (index: int) \n    requires isSorted(a)\n    ensures (0 <= index < a.Length && a[index] == x) || (index == -1 && x !in a[..])\n{   \n    var low, high := 0, a.Length;\n    while low < high \n        decreases high - low\n        invariant 0 <= low <= high <= a.Length\n        invariant x !in a[..low] && x !in a [high..]\n    {\n        var mid := low + (high - low) / 2;\n        if {\n            case a[mid]  < x => low := mid + 1;\n            case a[mid]  > x => high := mid;\n            case a[mid] == x => return mid;\n        }\n    }\n    return -1;\n}\npredicate isSorted(a: array<int>)\n  reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\nmethod testBinarySearch() {\n    var a := new int[] [1, 4, 4, 6, 8];\n    assert a[..]  == [1, 4, 4, 6, 8];\n    var id1 := binarySearch(a, 6);\n    assert a[3] == 6; \n    assert id1 == 3;\n    var id2 := binarySearch(a, 3);\n    assert id2 == -1; \n    var id3 := binarySearch(a, 4);\n    assert a[1] == 4 && a[2] == 4; \n    assert id3 in {1, 2};\n}"
},
{
    "dafny": "method Main() {\n  print \"Hello\\n\";\n  var x, y := Library.LibClass.CallMeInt(30);\n  var z := Library.LibClass.CallMeNative(44, true);\n  var w := Library.LibClass.CallMeInAnotherClass();\n  print x, \" \", y, \" \", z, \" \", w, \"\\n\";\n  Library.AllDafny.M();\n  Library.Mixed.M();\n  print Library.Mixed.F(), \"\\n\";\n  var m := new Library.Mixed();\n  m.IM();\n  print m.IF(), \"\\n\";\n  Library.AllExtern.P();\n  assert Library.AllDafny.Seven() == Library.Mixed.Seven() == Library.AllExtern.Seven();\n  var maybeInt := Library.AllExtern.MaybeInt();\n  print maybeInt, \"\\n\";\n  var intPair := Library.AllExtern.IntPair();\n  print intPair, \"\\n\";\n  var singleton := Library.SingletonOptimization.SingletonTuple((ghost 10, 2));\n  assert singleton.0 == 3;\n  var noWrapper := Library.SingletonOptimization.NoWrapper(Library.ErasableWrapper(2));\n  assert noWrapper.x == 3;\n  var ghostWrapper := Library.SingletonOptimization.GhostWrapper(Library.Something(2));\n  assert ghostWrapper.x == 3;\n  print singleton.0, \" \", noWrapper.x, \" \", ghostWrapper.x, \"\\n\"; \n}\nmodule Wrappers {\n  datatype Option<T> = Some(value: T) | None\n  datatype Pair<A, B> = Pair(first: A, second: B)\n}\nmodule {:extern \"Library\"} Library {\n  newtype MyInt = x | -100 <= x < 0x8000_0000\n  class {:extern \"LibClass\"} LibClass {\n    static method {:extern} CallMeInt(x: int) returns (y: int, z: int)\n    static method {:extern} CallMeNative(x: MyInt, b: bool) returns (y: MyInt)\n    static method {:extern \"Library.OtherClass\", \"CallMe\"} CallMeInAnotherClass() returns (w : object)\n  }\n  class {:extern} AllDafny {\n    static function Seven(): int { 7 }\n    static method M() { print \"AllDafny.M\\n\"; }\n  }\n  class {:extern} Mixed {\n    constructor() { }\n    static function Seven(): int { 7 }\n    static method M() { print \"Extern static method says: \"; P(); }\n    static method {:extern} P()\n    method IM() { print \"Extern instance method says: \"; IP(); }\n    method {:extern} IP()\n    static function F() : int { 1000 + G() }\n    static function {:extern} G() : int\n    function IF() : int { 2000 + IG() }\n    function {:extern} IG() : int\n  }\n  class {:extern} AllExtern {\n    static ghost function Seven(): int { 7 }\n    static method {:extern} P()\n    static function {:extern} MaybeInt(): Option<int>\n    static function {:extern} IntPair(): Pair<int, int>\n  }\n  datatype ErasableWrapper = ErasableWrapper(x: MyInt)\n  datatype Ghost<X> = ghost Uninitialized | Something(x: X)\n  class {:extern} SingletonOptimization {\n    static method {:extern} SingletonTuple(a: (ghost MyInt, MyInt)) returns (b: (MyInt, ghost MyInt, ghost MyInt))\n      requires a.1 < 0x7fff_ffff\n      ensures b.0 == a.1 + 1\n    static method {:extern} NoWrapper(a: ErasableWrapper) returns (b: ErasableWrapper)\n      requires a.x < 0x7fff_ffff\n      ensures b.x == a.x + 1\n    static method {:extern} GhostWrapper(a: Ghost<MyInt>) returns (b: Ghost<MyInt>)\n      requires a.Something? && a.x < 0x7fff_ffff\n      ensures b.Something? && b.x == a.x + 1\n  }\n}"
},
{
    "dafny": "ghost predicate Thing1() {\n    var m := map[0 := 1];\n    forall i :: i in m ==> i == 0\n}\ndatatype Context = Context(foo: map<int, int>)\nghost predicate Thing2(ctx: Context) {\n   var ctx' := ctx.(foo := map[0 := 1]);\n   forall i :: i in ctx'.foo ==> i == 0\n}\nmethod Main() {\n   assert Thing1();\n   assert Thing2(Context(map[2 := 3]));\n}"
},
{
    "dafny": "function Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n{\n    s := 0;\n    var i := 0;\n    while i < xs.Length\n        invariant 0 <= i <= xs.Length\n        invariant s == Sum(xs[..i])\n    {\n        s := s + xs[i];\n        assert xs[..i+1] == xs[..i] + [xs[i]];\n        i := i + 1;\n    }\n    assert xs[..] == xs[..i];\n}"
},
{
    "dafny": "method SwapSimultaneous(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n  x, y := y, x;\n}\nmethod TestSwapSimultaneous(){\n  var x, y := SwapSimultaneous(3, 5);\n  print(\"Test 1: SwapSimultaneous(3,5) = \", x, y, \"\\n\");\n  x, y := SwapSimultaneous(-1, 0);\n  print(\"Test 2: SwapSimultaneous(-1,0) = \",x, y, \"\\n\");\n  x, y := SwapSimultaneous(0, 0);\n  print(\"Test 3: SwapSimultaneous(0,0) = \",x, y,  \"\\n\");\n  x, y := SwapSimultaneous(100, -100);\n  print(\"Test 4: SwapSimultaneous(100,-100) = \", x, y,  \"\\n\");\n  x, y := SwapSimultaneous(123456789, 987654321);\n  print(\"Test 5: SwapSimultaneous(123456789,987654321) = \", x, y,  \"\\n\");\n}\nmethod Main(){\n  TestSwapSimultaneous();\n}"
},
{
    "dafny": "predicate sorted(a:array<int>, min:int, max:int)\n    requires 0<= min <= max <= a.Length\n    reads a\n    {\n      forall j, k :: min <= j < k < max ==> a[j] <= a[k]\n    }\nmethod InsertionSort ( a:array<int> ) \nrequires a.Length >= 1 \nmodifies a \nensures sorted(a, 0 ,  a.Length)\n{    \n       var i ,j, k , t:= 1,0, 0,0;\t      \n\t\t  while ( i < a.Length )\n\t\t  invariant 0 <= i <= a.Length;\n\t\t  invariant sorted(a, 0 , i);\n\t\t  {\n\t\t    j,k := i, a[i];\n\t\t\twhile ( j > 0  && a[j-1] > k ) \n\t\t\tinvariant 0 <= j <= i\n\t\t\tinvariant forall k1, k2 :: 0 <= k1 <= k2 <= i ==> k1 != j ==> k2 != j ==> a[k1] <= a[k2]\n\t\t\tinvariant forall l :: j+1 <= l <= i ==> k <= a[l]\n\t\t\t{\n\t\t\t     a[j] := a[j-1];\n\t\t\t     j := j-1;\n\t\t\t}\n\t\t\ta[j] := k;\n\t\t\ti := i +1;\n\t\t  }\n}"
},
{
    "dafny": "method pick(max: int) returns (result: int)\n  requires max>0\n  ensures 0<=result<max\n{\n  return 0;\n}\npredicate inv_old(st: int, lfork: int, rfork: int)\n{\n  0<=st<=2 && 0<=lfork<=2 && 0<=rfork<=2 && !((st==2 && lfork==1 && rfork==1)||(st==2 && lfork==0 && rfork==1)||(st==2 && lfork==0 && rfork==0)||(st==2 && lfork==1 && rfork==0)||(st==2 && lfork==2 && rfork==1)||(st==2 && lfork==0 && rfork==2)||(st==2 && lfork==2 && rfork==2)||(st==2 && lfork==2 && rfork==0))\n}\npredicate inv(st: int, lfork: int, rfork: int)\n{\n  0<=st<=2 && 0<=lfork<=2 && 0<=rfork<=2 && (st==2 ==> lfork==1) && (st==2 ==> rfork==2)\n}\nlemma claim()\n{\n  assert forall i,j,k: int:: inv(i,j,k) <==> inv_old(i,j,k);\n}\nlemma notEqMod(i: int, n: int)\n  requires 0<=i<n\n  requires n>2\n  ensures forall j {:trigger (j+1)%n}:: (0<=j<n && i!=j) ==> (i+1)%n != (j+1)%n;\n{\n}\nmethod step(phil: array<int>, fork: array<int>, n:int, i: int)\n  requires phil.Length==fork.Length==n\n  requires n > 2\n  requires 0<=i<n\n  requires fork!=phil\n  requires forall j:: 0<=j<n ==> inv(phil[j], fork[j], fork[(j+1)%n])\n  ensures forall j:: 0<=j<n ==>  inv(phil[j], fork[j], fork[(j+1)%n])\n  modifies phil\n  modifies fork\n{\n  if(phil[i]==0)\n  {\n    phil[i] := 1;\n  }\n  else if (phil[i]==1)\n  {\n    if (fork[i]==1 && fork[(i+1) % n] ==2)\n    {\n      phil[i] := 2;\n    }\n    else\n    {\n      var temp := pick(2);\n      if(temp==0)\n      {\n        if(fork[i]==0)\n        {\n          fork[i] := 1;\n        }\n      }\n      else\n      {\n        if(fork[(i+1)%n]==0)\n        {\n          fork[(i+1)%n] := 2;\n        }\n      }\n    }\n  }\n  else\n  {\n    assert forall j {:trigger phil[j]}:: 0<=j<n ==> inv(phil[j], fork[j], fork[(j+1)%n]);\n    notEqMod(i,n);\n    fork[i] := 0;\n    fork[(i+1)%n] := 0;\n    phil[i] := 0;\n  }\n}\nmethod Main(phil: array<int>, fork:array<int>, n:int)\n  modifies phil\n  modifies fork\n  requires fork!=phil\n  requires phil.Length==fork.Length==n\n  requires n>2\n  requires forall j:: 0<=j<n ==> phil[j] == 0\n  requires forall j:: 0<=j<n ==> fork[j] == 0\n{\n  var steps := pick(1000);\n  while(steps>0)\n    decreases steps\n    invariant forall j:: 0<=j<n ==> inv(phil[j], fork[j], fork[(j+1)%n])\n  {\n    steps := steps - 1;\n    var i := pick(n);\n    step(phil, fork, n, i);\n  }\n}"
},
{
    "dafny": "method Reverse(a: seq<int>) returns (r: seq<int>)\n  ensures |a| == |r|\n  ensures forall i :: 0 <= i < |a| ==> r[i] == a[|a| - i - 1]\n{\n  var remainder := a;\n  r := [];\n  while (|remainder| > 1)\n    invariant |remainder| == |a| - |r|\n    invariant forall i :: 0 <= i < |r| ==> r[i] == a[|r| - i - 1]\n    invariant forall i :: 0 <= i < |remainder| ==> remainder[i] == a[|r| + i]\n  {\n    r := [remainder[0]] + r;\n    remainder := remainder[1..];\n  }\n  r := remainder + r;\n}\nmethod Main() {\n  var a := [1, 2, 3];\n  var b := Reverse(a);\n  assert b == [3, 2, 1];\n  print b;\n}"
},
{
    "dafny": "function Potencia(x: nat, y: nat): nat\n{\n    if y == 0\n    then 1\n    else x * Potencia(x, y-1) \n}\nmethod Pot(x: nat, y: nat) returns (r: nat)\nensures r == Potencia(x,y)\n{\n    var b := x;\n    var e := y;\n    r := 1;\n    while e > 0\n    invariant Potencia(b, e) * r == Potencia(x,y)\n    {\n        r := b * r;\n        e := e - 1;\n    }\n    return r;\n}"
},
{
    "dafny": "trait J1{\n  var x: int\n}\ntrait J2{\n  var y: int\n}\nclass C extends J1, J2{\n}\nmethod Main()\n{\n  var c := new C;\n  var j1: J1 := new C;\n  var j2: J2 := new C;\n  c.x := 10;\n  c.y := 20;\n  j1.x := 20;\n  j2.y := 10;\n  print \"c.x + c.y = \" , c.x + c.y, \"\\n\";\n  print \"j1.x + j2.y = \" , j1.x + j2.y, \"\\n\";\n  assert c.x + c.y == j1.x + j2.y;\n}"
},
{
    "dafny": "method Main() {\n  var four := Four();\n  print \"four is \", four, \"\\n\"; \n  print \"Recursive(7) = \", Recursive(7), \"\\n\"; \n  print \"NonCompilableFunction: \", NonCompilableFunction(2), \" \", NonCompilableFunction(4), \"\\n\"; \n  var s, s' := {2, 7, 5}, {2, 0, 2, 1};\n  print \"Sums: \", Sum(s), \" \", Sum(s'), \"\\n\";\n}\nfunction Four(): int {\n  4\n} by method {\n  print \"hello\\n\";\n  return 2 + 2;\n}\nfunction Recursive(n: nat, acc: nat := 0): nat {\n  2 * n + acc\n} by method { \n  if n == 0 {\n    return acc;\n  } else {\n    return Recursive(n - 1, acc + 2);\n  }\n}\nfunction NonCompilableFunction(n: nat): (r: nat) {\n  if P(n) then n + 2 else n + 3\n} by method {\n  AboutP(n);\n  r := if n <= 3 then n + 2 else n + 3;\n}\nleast predicate P(x: int) {\n  x == 3 || P(x + 1)\n}\nlemma AboutP(x: int)\n  ensures P(x) <==> x <= 3\n{\n  if P(x) {\n    Ping(x);\n  }\n  if x <= 3 {\n    Pong(x);\n  }\n}\nleast lemma Ping(x: int)\n  requires P(x)\n  ensures x <= 3\n{\n}\nlemma Pong(x: int)\n  requires x <= 3\n  ensures P(x)\n  decreases 3 - x\n{\n  if x < 3 {\n    Pong(x + 1);\n  }\n}\nfunction Sum(s: set<int>): int {\n  if s == {} then 0 else\n    var x := Pick(s);\n    x + Sum(s - {x})\n} by method {\n  var sum := 0;\n  var s' := s;\n  while s' != {}\n    invariant s' <= s\n    invariant sum + Sum(s') == Sum(s)\n  {\n    var x :| x in s';\n    var s'' := s' - {x};\n    assert s'' + {x} == s';\n    SumLemma(s'', x);\n    sum, s' := sum + x, s'';\n  }\n  return sum;\n}\nghost function Pick(s: set<int>): int\n  requires s != {}\n{\n  var x :| x in s; x\n}\nlemma SumLemma(s: set<int>, y: int)\n  requires y !in s\n  ensures Sum(s + {y}) == Sum(s) + y\n{\n  if s == {} {\n  } else {\n    var sy := s + {y};\n    assert s == sy - {y};\n    var x := Pick(sy);\n    if x == y {\n    } else {\n      var s'x := s - {x};\n      assert s'x + {x} == s;\n      calc {\n        Sum(s + {y});\n      ==\n        Sum(sy);\n      ==  \n        x + Sum(sy - {x});\n      ==  { assert sy - {x} == s'x + {y}; }\n        x + Sum(s'x + {y});\n      ==  { SumLemma(s'x, y); }\n        x + Sum(s'x) + y;\n      ==  { SumLemma(s'x, x); }\n        Sum(s'x + {x}) + y;\n      ==\n        Sum(s) + y;\n      }\n    }\n  }\n}"
},
{
    "dafny": "function OnId(f : (bool -> bool) -> int) : int\n  reads f.reads(x => x)\n  requires f.requires(y => y)\n{\n  f(z => z)\n}\nmethod Equal() {\n  var id1 : bool -> bool := x => x;\n  var id2                := y => y;\n  assert forall x :: id1(x) == id2(x);\n  assert id1 == id2;\n}\nmethod K<A,B>(P : (A -> A) -> bool)\n  requires P.requires(x => x)\n  requires P(y => y)\n{\n  assert P(z => z);\n  assert (x => y => x) == ((a : A) => (b : B) => a);\n}\nmethod Main() {\n  Equal();\n  var p := (x: real -> real) => x(25.0) <= 25.0;\n  K<real,bool>(p);\n  var f := (b: bool -> bool) => if b(true) then 10 else 11;\n  var x := OnId(f);\n  print x, \" \", f(_ => false), \"\\n\";\n}"
},
{
    "dafny": "method BubbleSort(a: array<int>)\n    modifies a;\n    ensures  Sorted(a, 0, a.Length);\n    ensures  multiset(a[..]) == multiset(old(a[..]));\n{\n    var down := a.Length;\n    while down > 0\n        decreases down;\n        invariant 0 <= down <= a.Length;\n        invariant multiset(a[..]) == multiset(old(a[..]));\n        invariant forall i, j | 0 <= i <= down <= j < a.Length :: a[i] <= a[j];\n        invariant Sorted(a, down, a.Length);\n    {\n        var up := 0;\n        while up < down - 1\n            decreases down - up - 1;\n            invariant 0 <= up <= down - 1;\n            invariant multiset(a[..]) == multiset(old(a[..]));\n            invariant forall i | 0 <= i < up :: a[i] <= a[up];\n            invariant forall i, j | 0 <= i <= down <= j < a.Length :: a[i] <= a[j];\n            invariant Sorted(a, down, a.Length);\n        {\n            if a[up] > a[up + 1]\n            {\n                a[up], a[up + 1] := a[up + 1], a[up];\n            }\n            up := up + 1;\n        }\n        down := down - 1;\n    }\n}\npredicate Sorted(a: array<int>, l: int, r: int)\n    reads a;\n    requires 0 <= l <= r <= a.Length;\n{\n    forall i, j | l <= i < j < r :: a[i] <= a[j]\n}"
},
{
    "dafny": "method Abs(x : int) returns (y : int) \n    ensures 0 <= x ==> y == x; \n    ensures x < 0 ==> y == -x;\n    ensures 0 <= y; \n{\n    if (x < 0) { \n        y := -x; \n    } else {\n        y := x; \n    }\n}"
},
{
    "dafny": "method Test()\n{\n    var count;\n    var a1 := new int[][1, 2, 2, 3, 1, 3, 1, 2, 2];\n    assert a1[..] == [1, 2, 2, 3, 1, 3, 1, 2, 2];\n    count := Count(a1, 0);\n    assert count == 0;\n    count := Count(a1, 1);\n    assert count == 3;\n    count := Count(a1, 2);\n    assert count == 4;\n    count := Count(a1, 3);\n    assert count == 2;\n    count := Count(a1, 4);\n    assert count == 0;\n}\nmethod Count(a: array<int>, key: int) returns (count: int)\n    ensures count == multiset(a[..])[key];\n{\n    count := 0;\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length;\n        invariant count == multiset(a[..i])[key]; \n    {\n        if a[i] == key {\n            count := count + 1;\n        }\n        i := i + 1;\n    }\n    assert a[..a.Length] == a[..];\n}"
},
{
    "dafny": "datatype Sex = Masculine | Feminine\ndatatype CivilState = Single | Married | Divorced | Widow | Dead\nclass Person\n{\n    const name: string; \n    const sex: Sex;\n    const mother: Person?; \n    const father: Person?;\n    var spouse: Person?;\n    var civilState: CivilState;\n    predicate Valid()\n        reads this\n        reads spouse\n        reads mother \n        reads father\n    {\n        (civilState == Married <==> spouse != null)\n        && (mother != null ==> mother.sex == Feminine) \n        && (father != null ==> father.sex == Masculine)\n        && (spouse != null ==> sex != spouse.sex)\n        && (spouse != null ==> spouse.spouse == this)\n    }\n    constructor (name: string, sex: Sex, mother: Person?, father: Person?)\n        requires mother != null ==> mother.sex == Feminine\n        requires father != null ==> father.sex == Masculine\n        ensures this.name == name \n        ensures this.sex == sex\n        ensures this.mother == mother \n        ensures this.father == father\n        ensures this.spouse == null\n        ensures this.civilState == Single\n        ensures Valid()\n    {\n        this.name := name;\n        this.sex := sex;\n        this.mother := mother;\n        this.father := father;\n        this.spouse := null;\n        this.civilState := Single;\n    }\n    method marry(spouse: Person)\n        modifies spouse\n        modifies this\n        requires this.spouse == null && spouse.spouse == null\n        requires civilState != Married && civilState != Dead \n        requires spouse.civilState != Married && spouse.civilState != Dead\n        requires spouse.sex != sex\n        requires Valid()\n        ensures spouse.spouse == this && this.spouse == spouse \n        ensures spouse.civilState == Married && this.civilState == Married\n        ensures Valid()\n    {\n        spouse.spouse := this;\n        spouse.civilState := Married;\n        this.spouse := spouse;\n        this.civilState := Married;\n    }\n    method divorce()\n        modifies spouse\n        modifies this \n        requires spouse != null && spouse.spouse != null && spouse.spouse == this\n        requires civilState == Married && spouse.civilState == Married\n        requires Valid()\n        ensures old(spouse).spouse == null && spouse == null \n        ensures old(spouse).civilState == Divorced && civilState == Divorced\n        ensures Valid()\n    {\n        spouse.spouse := null;\n        spouse.civilState := Divorced;\n        this.spouse := null;\n        this.civilState := Divorced;\n    }\n    method die()\n        modifies this \n        modifies spouse \n        requires civilState != Dead\n        requires Valid()\n        ensures old(spouse) != null ==> old(spouse).spouse == null && old(spouse).civilState == Widow\n        ensures spouse == null && civilState == Dead\n        ensures Valid()\n    {\n        if spouse != null\n        {\n            spouse.spouse := null;\n            spouse.civilState := Widow;\n        }\n        this.spouse := null;\n        this.civilState := Dead;\n    }\n}"
},
{
    "dafny": "function fib(n: nat): nat\n    decreases n\n{\n    if n == 0 then 0 else\n    if n == 1 then 1 else\n                   fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (b: nat)\n    ensures b == fib(n)\n{\n    if n == 0 {\n        return 0;\n    }\n    var i: int := 1;\n    b := 0;\n    var c: int := 1;\n    while i < n\n        invariant i > 0\n        invariant i <= n\n        invariant c == fib(i)\n        invariant b == fib(i - 1)\n        decreases n - i\n    {\n        b, c := c, b + c;\n        i := i + 1;\n    }\n    assert i == n;\n    b := c;\n}"
},
{
    "dafny": "method SumMax(x: int, y: int) returns (s: int, m: int)\n    ensures s == x + y\n    ensures x <= m && y <= m\n    ensures m == x || m == y\n{\n    s := x + y ;\n    if x < y{\n        m := y ;\n    }else{\n        m := x ;\n    }\n}"
},
{
    "dafny": "method TestRotateRightOnce()\n{\n    var a := new int[][7, 3, 8, 5, 6];\n    assert a[..] == [7, 3, 8, 5, 6];\n    RotateRightOnce(a);\n    assert a[..] == [6, 7, 3, 8, 5];\n    RotateRightOnce(a);\n    assert a[..] == [5, 6, 7, 3, 8];\n}\nmethod TestRotateRightMany()\n{\n    var a := new int[][7, 3, 8, 5, 6];\n    assert a[..] == [7, 3, 8, 5, 6];\n    RotateRightMany(a, 2);\n    assert a[..] == [5, 6, 7, 3, 8];\n    RotateRightMany(a, 9);\n    assert a[..] == [6, 7, 3, 8, 5];\n}\nmethod RotateRightOnce(a: array<int>)\n    modifies a;\n    ensures  a.Length > 0 ==> a[..] == old([a[a.Length - 1]] + a[..a.Length - 1]);\n{\n    if a.Length == 0 {\n        return;\n    }\n    var temp := a[a.Length - 1];\n    var i := a.Length - 1;\n    while i > 0\n        decreases i;\n        invariant 0 <= i <= a.Length - 1;\n        invariant a[i + 1..] == old(a[i..a.Length - 1]);\n        invariant a[..i + 1] == old(a[..i + 1]);\n    {\n        a[i] := a[i - 1];\n        i := i - 1;\n    }\n    a[0] := temp;\n}\nmethod RotateRightMany(a: array<int>, rot: int)\n    modifies a;\n    ensures  a.Length > 0 ==> a[..] == old(a[a.Length - rot % a.Length..] + a[..a.Length - rot % a.Length]);\n{\n    if a.Length == 0 {\n        return;\n    }\n    var i := 0;\n    while i < rot % a.Length\n        decreases rot % a.Length - i;\n        invariant 0 <= i <= rot % a.Length;\n        invariant a[..] == old(a[a.Length - i..] + a[..a.Length - i]);\n    {\n        RotateRightOnce(a);\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method seqIntoArray<A>(s: seq<A>, a: array<A>, index: nat)\n  requires index + |s| <= a.Length\n  modifies a\n  ensures a[..] == old(a[..index]) + s + old(a[index + |s|..])\n{\n  var i := index;\n  while i < index + |s|\n    invariant index <= i <= index + |s| <= a.Length\n    invariant a[..] == old(a[..index]) + s[..i - index] + old(a[i..])\n  {\n    label A:\n    a[i] := s[i - index];\n    calc {\n      a[..];\n    ==  \n      old@A(a[..])[i := s[i - index]];\n    ==  \n      (old(a[..index]) + s[..i - index] + old(a[i..]))[i := s[i - index]];\n    ==  { assert old(a[..index]) + s[..i - index] + old(a[i..]) == (old(a[..index]) + s[..i - index]) + old(a[i..]); }\n      ((old(a[..index]) + s[..i - index]) + old(a[i..]))[i := s[i - index]];\n    ==  { assert |old(a[..index]) + s[..i - index]| == i; }\n      (old(a[..index]) + s[..i - index]) + old(a[i..])[0 := s[i - index]];\n    == { assert old(a[i..])[0 := s[i - index]] == [s[i - index]] + old(a[i..])[1..]; }\n      (old(a[..index]) + s[..i - index]) + [s[i - index]] + old(a[i..])[1..];\n    ==  { assert old(a[i..])[1..] == old(a[i + 1..]); }\n      (old(a[..index]) + s[..i - index]) + [s[i - index]] + old(a[i + 1..]);\n    ==  \n      old(a[..index]) + (s[..i - index] + [s[i - index]]) + old(a[i + 1..]);\n    ==  { assert s[..i - index] + [s[i - index]] == s[..i + 1 - index]; }\n      old(a[..index]) + s[..i + 1 - index] + old(a[i + 1..]);\n    }\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method Abs1(x: int) returns (y: int)\n   requires x == -1\n   ensures 0 <= y\n   ensures 0 <= x ==> x == y\n   ensures x < 0 ==> y == -x\n{\n   y := x + 2;\n}\nmethod Abs2(x: real) returns (y: real)\nrequires x == -0.5\nensures y >= 0.0\nensures x >= 0.0 ==> y == x\nensures x < 0.0 ==> y == -x\n{\n  y := x + 1.0;\n}"
},
{
    "dafny": "method Main() {\n  LetTest();\n  var m := map[6 := 8, 7 := 3];\n  var n := Rewrite(m);\n  assert m.Keys == n.Keys;\n  print n.Keys, \"\\n\";\n  var u := {\"Alfons\", \"Milla\"};\n  var v := Rewrite2(u);\n  assert u == v.Keys;\n  print v.Keys, \"\\n\";\n}\nfunction F(u: int): int\n  requires u < 2400\n{\n  u\n}\nfunction G(w: int): int\n{\n  var g := w + w;\n  g - w\n}\nmethod LetTest() {\n  var x :=\n    var y := \"unused\"; var y, z := 10, 20; G(F(y)) + z;\n  assert x == G(30);\n  print x, \"\\n\";\n}\nfunction Rewrite(env: map<nat, nat>): map<nat, nat> {\n  var p := map g: nat | g in env :: g;  \n  map n: nat | n in p :: n\n}\nfunction Rewrite_Keys(env: map<nat, nat>): map<nat, nat> {\n  var p := env.Keys;  \n  map n: nat | n in p :: n\n}\nfunction Rewrite2(strs: set<string>): map<string, string> {\n  var p := map g: string | g in strs :: g;  \n  map s: string | s in p :: s\n}\nghost function sum(a: int, b: int): int {\n  a + b\n}\nghost predicate sum_is_sum(b: int, c: int) {\n  var s := a => sum(a, b);\n  forall a: int :: s(a) + c == a + b + c\n}\nlemma TestApply(x: int, y: int)\n  ensures sum_is_sum(x, y)\n{\n}\nmodule Test {\n  datatype A = A1\n  datatype B = B1\n  ghost function Convert_AB(f:A) : B { B1 }\n  ghost function Convert_BA(f:B) : A { A1 }\n  ghost function ConvertMap_AB(m:map<A, int>) : map<B, int>\n  {\n    var dom_B := set a | a in m :: Convert_AB(a);\n    assert forall u :: u in m.Keys ==> u == A1;  \n    map b | b in dom_B :: m[Convert_BA(b)]\n  }\n}"
},
{
    "dafny": "function Fib(n: nat): nat\n{\n    if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\nmethod ComputeFib(n: nat) returns(x: nat)\n    ensures x == Fib(n)\n{\n    x := 0 ;\n    var y := 1;\n    var i := 0 ;\n    while i < n\n        invariant i <= n\n        invariant x == Fib(i) && y == Fib(i + 1)\n    {\n        x, y := y, x + y;\n        i := i + 1 ;\n    }\n}"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} MutableMapDafny {\n  trait {:termination false} MutableMapTrait<K(==),V(==)> {\n    function content(): map<K, V>\n      reads this\n    method Put(k: K, v: V)\n      modifies this\n      ensures this.content() == old(this.content())[k := v]   \n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}\n      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}\n    function Keys(): (keys: set<K>)\n      reads this\n      ensures keys == this.content().Keys\n    predicate HasKey(k: K)\n      reads this\n      ensures HasKey(k) <==> k in this.content().Keys\n    function Values(): (values: set<V>)\n      reads this\n      ensures values == this.content().Values\n    function Items(): (items: set<(K,V)>)\n      reads this\n      ensures items == this.content().Items\n      ensures items == set k | k in this.content().Keys :: (k, this.content()[k])\n    function Select(k: K): (v: V)\n      reads this\n      requires this.HasKey(k)\n      ensures v in this.content().Values\n      ensures this.content()[k] == v\n    method Remove(k: K)\n      modifies this\n      ensures this.content() == old(this.content()) - {k}\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values\n    function Size(): (size: int)\n      reads this\n      ensures size == |this.content().Items|\n  }\n  class MutableMapDafny<K(==),V(==)> extends MutableMapTrait<K,V> {\n    var m: map<K,V>\n    function content(): map<K, V> \n      reads this\n    {\n      m\n    }\n    constructor ()\n      ensures this.content() == map[]\n    {\n      m := map[];\n    }\n    method Put(k: K, v: V)\n      modifies this\n      ensures this.content() == old(this.content())[k := v]   \n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values + {v}\n      ensures k !in old(this.content()).Keys ==> this.content().Values == old(this.content()).Values + {v}\n    {\n      m := m[k := v];\n      if k in old(m).Keys {\n        forall v' | v' in old(m).Values + {v} ensures v' in m.Values + {old(m)[k]} {\n          if v' == v || v' == old(m)[k] {\n            assert m[k] == v;\n          } else {\n            assert m.Keys == old(m).Keys + {k};\n          }\n        }\n      }\n      if k !in old(m).Keys {\n        forall v' | v' in old(m).Values + {v} ensures v' in m.Values {\n          if v' == v {\n            assert m[k] == v;\n            assert m[k] == v';\n            assert v' in m.Values;\n          } else {\n            assert m.Keys == old(m).Keys + {k};\n          }\n        }\n      }\n    }\n    function Keys(): (keys: set<K>)\n      reads this\n      ensures keys == this.content().Keys\n    {\n      m.Keys\n    }\n    predicate HasKey(k: K)\n      reads this\n      ensures HasKey(k) <==> k in this.content().Keys\n    {\n      k in m.Keys\n    }\n    function Values(): (values: set<V>)\n      reads this\n      ensures values == this.content().Values\n    {\n      m.Values\n    }\n    function Items(): (items: set<(K,V)>)\n      reads this\n      ensures items == this.content().Items\n      ensures items == set k | k in this.content().Keys :: (k, this.content()[k])\n    {\n      var items := set k | k in m.Keys :: (k, m[k]);\n      assert items == m.Items by {\n        forall k | k in m.Keys ensures (k, m[k]) in m.Items {\n          assert (k, m[k]) in m.Items;\n        }\n        assert items <= m.Items;\n        forall x | x in m.Items ensures x in items {\n          assert (x.0, m[x.0]) in items;\n        }\n        assert m.Items <= items;\n      }\n      items\n    }\n    function Select(k: K): (v: V)\n      reads this\n      requires this.HasKey(k)\n      ensures v in this.content().Values\n      ensures this.content()[k] == v\n    {\n      m[k]\n    }\n    method Remove(k: K)\n      modifies this\n      ensures this.content() == old(this.content()) - {k}\n      ensures k in old(this.content()).Keys ==> this.content().Values + {old(this.content())[k]} == old(this.content()).Values\n    {\n      m := map k' | k' in m.Keys && k' != k :: m[k'];\n      if k in old(m).Keys {\n        var v := old(m)[k];\n        forall v' | v' in old(m).Values ensures v' in m.Values + {v} {\n          if v' == v {\n          } else {\n            assert exists k' | k' in m.Keys :: old(m)[k'] == v';\n          }\n        }\n      }\n    }\n    function Size(): (size: int)\n      reads this\n      ensures size == |this.content().Items|\n    {\n      |m|\n    }\n  }\n}"
},
{
    "dafny": "predicate Sorted(a: array<int>,start:int,end:int)\n    reads a;\n    requires a != null\n    requires 0 <= start < end <= a.Length\n{\n    forall j, k :: start <= j < k < end ==> a[j] <= a[k]\n}\nmethod Shuffle(a:array<int>)\n    modifies a;\n    requires a != null;\n    requires a.Length > 0;\n    ensures a.Length > 0;\n    ensures Sorted(a,0,a.Length);\n    ensures multiset(a[..]) == multiset(old(a[..]));  \n{\n    if(a.Length > 1){\n        var i := 1;\n        while(i < a.Length)\n        invariant 1 <= i <= a.Length;\n        invariant forall x,y:: 0 <= x < y < i  ==> a[x] <= a[y]; \n        invariant multiset(a[..]) == multiset(old(a[..])); \n        {\n            var end := a[i];\n            var j := i - 1;\n            a[i] := a[j];\n            while(j >= 0 && a[j] > end)\n            invariant -1 <= j < i;\n            invariant forall x,y:: 0 <= x < y < i+1  ==> a[x] <= a[y]; \n            invariant forall x :: j < x < i ==> end < a[x];\n            invariant multiset(a[..]) - multiset([a[j+1]]) + multiset([end]) ==  multiset(old(a[..]));\n            {\n                a[j+1] := a[j];\n                j := j - 1;\n            }\n            a[j+1] := end;\n            i := i + 1;\n        }\n    }\n}\nmethod Main()\n{ \n    var a := new int[2];\n    a[0]:=34; a[1]:=12;\n    assert a[..]==[34,12];\n    ghost var ms := multiset(a[..]);\n    Shuffle(a);\n    assert a[..]==[12,34];\n    assert Sorted(a, 0, a.Length);\n    assert ms == multiset(a[..]);\n    print a[..];\n    var b := new int[4];\n    b[0]:=78; b[1]:=56; b[2]:=34; b[3]:=12;\n    assert b[..]==[78,56,34,12];\n    ms := multiset(b[..]);\n    Shuffle(b);\n    assert b[..]==[12,34,56,78];\n    assert Sorted(a, 0, a.Length);\n    assert ms == multiset(b[..]);\n    print b[..], '\\n';\n}"
},
{
    "dafny": "module stack {\n  datatype stack<T> = EmptyStack | stack(top: T, num_elems: nat, rest: stack<T>)\n  datatype Option<T> = Some(elem: T) | None\n  method push<T>(stk: stack<T>, elem: T) returns (res: stack<T>)\n    ensures res != EmptyStack\n    ensures (stk == EmptyStack) ==> (res == stack(elem, 1, EmptyStack()))\n  {\n    match stk {\n      case EmptyStack => {\n        res := stack(elem, 1, EmptyStack());\n      }\n      case stack(top, num_elems, rest) => {\n        res := stack(elem, num_elems + 1, stack(top, num_elems, rest));\n      }\n    }\n  }\n  method pop<T>(stk: stack<T>) returns (elem: Option<T>, res: stack<T>) {\n    match stk {\n      case EmptyStack => {\n        elem := None();\n        res := EmptyStack;\n      }\n      case stack(top, num_elems, rest) => {\n        elem := Some(top);\n        res := rest;\n      }\n    }\n  }\n}"
},
{
    "dafny": "method main()\n{\n    var x := 0;\n    var y := 0;\n    var i := 0;\n    var j := 0;\n    while(x <= 100000) \n        decreases 100000 - x\n        invariant !( (j - i <= -1) || (1 <= x - y) )\n    && !( ( (1 <= x - y) || (3*x - 3*y + j - i <= -1) )\n    && ( (1 <= x - y) || (x - y + j - i <= -1) )\n    && !( !(1 <= x - y) && !(2*x - 2*y + j - i <= -2) && !(2*x - 2*y + j - i <= -1) ) )\n    {\n        x := x + 1;\n        y := y + 1;\n        i := i + x;\n        j := j + y;\n        if(*) {\n            j := j + 1;\n        }\n    }\n    assert(j >= i);    \n}"
},
{
    "dafny": "method RemoveDuplicates(nums: array<int>) returns (num_length: int)\n  modifies nums\n  requires forall i, j | 0 <= i < j < nums.Length :: nums[i] <= nums[j]\n  ensures nums.Length == old(nums).Length\n  ensures 0 <= num_length <= nums.Length\n  ensures forall i, j | 0 <= i < j < num_length :: nums[i] != nums[j]\n  ensures forall i | 0 <= i < num_length :: nums[i] in old(nums[..])\n  ensures forall i | 0 <= i < nums.Length :: old(nums[i]) in nums[..num_length]\n{\n  if nums.Length <= 1 {\n    return nums.Length;\n  }\n  var last := 0;\n  var i := 1;\n  ghost var nums_before := nums[..];\n  while i < nums.Length\n    invariant 0 <= last < i <= nums.Length\n    invariant nums[i..] == nums_before[i..]\n    invariant forall j, k | 0 <= j < k <= last :: nums[j] < nums[k]\n    invariant forall j | 0 <= j <= last :: nums[j] in nums_before[..i]\n    invariant forall j | 0 <= j < i :: nums_before[j] in nums[..last+1]\n  {\n    if nums[last] < nums[i] {\n      last := last + 1;\n      nums[last] := nums[i];\n      assert forall j | 0 <= j < i :: nums_before[j] in nums[..last];\n      assert forall j | 0 <= j <= i :: nums_before[j] in nums[..last+1];\n    }\n    i := i + 1;\n  }\n  return last + 1;\n}\nmethod Testing() {\n  var nums1 := new int[3];\n  nums1[0] := 1;\n  nums1[1] := 1;\n  nums1[2] := 2;\n  var num_length1 := RemoveDuplicates(nums1);\n  assert forall i, j | 0 <= i < j < num_length1 :: nums1[i] != nums1[j];\n  assert num_length1 <= nums1.Length;\n  print \"nums1: \", nums1[..], \", num_length1: \", num_length1, \"\\n\";\n  var nums2 := new int[10];\n  nums2[0] := 0;\n  nums2[1] := 0;\n  nums2[2] := 1;\n  nums2[3] := 1;\n  nums2[4] := 1;\n  nums2[5] := 2;\n  nums2[6] := 2;\n  nums2[7] := 3;\n  nums2[8] := 3;\n  nums2[9] := 4;\n  var num_length2 := RemoveDuplicates(nums2);\n  assert forall i, j | 0 <= i < j < num_length1 :: nums1[i] != nums1[j];\n  assert num_length2 <= nums2.Length;\n  print \"nums2: \", nums2[..], \", num_length2: \", num_length2, \"\\n\";\n}\nmethod Main() {\n  Testing();\n}"
},
{
    "dafny": "predicate ColourSorted(flag:array?<Colour>)\n  reads flag\n  requires flag != null\n{ forall i::0 <= i < i + 1 < flag.Length ==> (flag[i] == RED ==> (flag[i+1] == RED || flag[i+1] == BLUE)) || (flag[i] == BLUE ==> (flag[i+1] == BLUE || flag[i+1] == YELLOW))\n || (flag[i] == YELLOW ==> (flag[i+1] == YELLOW ||flag[i+1] == GREEN)) || (flag[i] == GREEN ==> flag[i+1] == GREEN)}\ndatatype Colour = RED| BLUE | YELLOW | GREEN\nmethod FlagSort(flag:array?<Colour>)\nrequires flag != null;\nensures ColourSorted(flag);\nensures multiset(flag[..]) == multiset(old(flag[..]));\nmodifies flag;\n{\n  var next := 0;\n  var blue := 0;\n  var green := flag.Length;\n  while(next != green)\n  invariant 0 <= blue <= next <= green <= flag.Length;\n  invariant forall i:: green <= i < flag.Length ==> flag[i]==GREEN;\n  invariant forall i:: blue <= i < next ==> (flag[i] == BLUE || flag[i] == YELLOW);\n  invariant forall i:: 0    <=i<blue       ==> flag[i]==RED;\n  invariant multiset(flag[..]) == multiset(old(flag[..]));\n  {\n    match(flag[next]){\n      case RED => flag[next],flag[blue] := flag[blue],flag[next];\n                    blue := blue + 1;\n                    next := next + 1;\n      case BLUE => next := next + 1;\n      case YELLOW => next := next + 1; \n      case GREEN => green := green - 1; \n                    flag[next],flag[green] := flag[green],flag[next];\n    }\n  }\n  var yellow := blue;\n  var n:= blue;\n  if(blue < green ){\n    while(n != green)\n    invariant 0<= blue <= yellow <= n <= green <= flag.Length;\n    invariant blue == old(blue) && green == old(green);\n    invariant forall i:: blue <= i < green ==> (flag[i] == BLUE || flag[i] == YELLOW);\n    invariant forall i:: 0    <=i<blue       ==> flag[i]==RED;\n    invariant forall i:: blue<= i < yellow ==> flag[i] == BLUE;\n    invariant forall i:: yellow<= i < n ==> flag[i] == YELLOW;\n    invariant forall i:: green <= i < flag.Length ==> flag[i] == GREEN;\n    invariant multiset(flag[..]) == multiset(old(flag[..]));\n    {\n      match(flag[n]){\n        case RED => n := n + 1;\n        case BLUE => flag[n],flag[yellow] := flag[yellow],flag[n];\n                      yellow := yellow + 1;\n                      n := n + 1;\n        case YELLOW => n := n + 1; \n        case GREEN => n := n + 1;\n      } \n    }\n  } \n}\nmethod Main(){\n  var a: array<Colour> := new Colour[5];\n  a[0],a[1],a[2],a[3],a[4] := YELLOW,YELLOW,GREEN,RED,BLUE;\n  FlagSort(a);\n  var i := 0;\n  while(i < a.Length){\n    print a[i];\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method Flip_Flop(C: bool, I: bool, T0: bool) returns (T: bool)\n\tensures T == ((C && I) || (!C && T0))\n{\n\tvar X, Y, Z := false, false, true; \n\tif C { \n\t\tif I {\n\t\t\tX := true;\n\t\t}\n\t\telse {\n\t\t\tY := true;\n\t\t}\n\t}\n\tif !X { \n\t\tif !T0 {\n\t\t\tZ := false;\n\t\t}\n\t}\n\tif !Y { \n\t\tif Z {\n\t\t\tT := true;\n\t\t}\n\t\telse {\n\t\t\tT := false;\n\t\t}\t\n\t}\n\telse {\n\t\tT := false;\n\t}\n\tassert X == (C && I);\n\tassert Y == (C && !I);\n\tassert Z == !(!X && !T0) == X || T0;\n\tassert T == (!Y && Z);\n\tassert T == (!(C && !I) && ((C && I) || T0));\n\tassert T == ((!C || I) && ((C && I) || T0));\n\tassert T == ((C && I) || (!C && T0));\n}\nmethod Flip_Flop_2(C0: bool, I0: bool, C1: bool, I1: bool, T0: bool) returns (T: bool)\n\trequires C0 \n\tensures (!C1 ==> T == I0) && (C1 ==> T == I1) \n{\n\tassert C0 ==> C0 || C1 || T0 == I0;\n\tT := T0;\n\tassert C0 ==> C0 || C1 || T == I0;\n\tassert C0 || C1 || T == I0;\n\tassert C0 || C1 || (T && I0) || (!T && !I0);\n\tassert C1 || (I0 && C0) || (I0 && T) || (!I0 && C0) || (!I0 && !T);\n\tassert C1 || (I0 && (C0 || T)) || (!I0 && (C0 || !T));\n\tassert C1 || (I0 && ((C0 && I0) || (!C0 && T))) \n\t\t|| (!I0 && !((C0 && I0) || (!C0 && T)));\n\tT := Flip_Flop(C0, I0, T);\n\tassert C1 || (I0 && T) || (!I0 && !T);\n\tassert (C1 && I1) \n\t\t|| (C1 && !I1) \n\t\t|| (!C1 && I0 && T)\n\t\t|| (!C1 && !I0 && !T);\n\tassert (C1 && I1 && ((C1 && I1) || (!C1 && T))) \n\t\t|| (C1 && !I1 && !((C1 && I1) || (!C1 && T))) \n\t\t|| (!C1 && I0 && ((C1 && I1) || (!C1 && T))) \n\t\t|| (!C1 && !I0 && !((C1 && I1) || (!C1 && T)));\n\tT := Flip_Flop(C1, I1, T);\n\tassert (C1 && I1 && T) || (C1 && !I1 && !T) || \n\t\t(!C1 && I0 && T) || (!C1 && !I0 && !T);\n\tassert (C1 || T == I0) && (!C1 || T == I1);\n\tassert (!C1 ==> T == I0) && (C1 ==> T == I1); \n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && pre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || pre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\npredicate isSubstringPred(sub:string, str:string)\n{\n  (|sub| <= |str|) && (exists i :: 0 <= i < |str| && isPrefixPred(sub, str[i..]))\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\tforall i :: 0 <= i < |str| ==> isNotPrefixPred(sub, str[i..])\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\texists i :: 0 <= i <= |str1|-k && isSubstringPred(str1[i..][..k], str2)\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\tforall i :: 0 <= i <= |str1|-k ==> isNotSubstringPred(str1[i..][..k], str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==> haveNotCommonKSubstringPred(k,str1,str2)\n{}"
},
{
    "dafny": "function fact(n: nat): nat\n    requires n >= 1\n    decreases n\n{\n    if n == 1 then 1 else n * fact(n - 1)\n}\nmethod ComputeFact(n : nat) returns (res : nat)\n    requires n > 0;\n    ensures res == fact(n);\n{\n    res := 1;\n    var i := 2;\n    while (i <= n)\n        invariant res == fact(i - 1) && (i <= n + 1)\n        decreases n - i\n    {\n        res := res * i;\n        i := i + 1;\n    }\n }"
},
{
    "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  if x <= 0 {\n    calc {\n      x;\n    <=  { assert x <= 0; }\n      0;\n    <  \n      1;\n    ==  \n      More(x);\n    }\n  } else {\n    calc {\n      x < More(x);\n    ==  \n      x < More(x - 2) + 3;\n    ==  \n      x - 3 < More(x - 2);\n    <==  \n      x - 2 < More(x - 2);\n    <==  { Increasing(x - 2); }\n      true;\n    }\n  }\n}"
},
{
    "dafny": "class A {\n  var z1: array<nat>\n  var z2: array<nat>\n  method mm()\n    requires z1.Length > 10 && z1[0] == 7\n    requires z2.Length > 10 && z2[0] == 17\n    modifies z2\n  {\n    var a: array<nat> := z1;\n    assert a[0] == 7;\n    a := z2;\n    assert a[0] == 17;\n    assert old(a[0]) == 17; \n    z2[0] := 27;\n    assert old(a[0]) == 17; \n    assert old(a)[0] == 27; \n  }\n}"
},
{
    "dafny": "predicate sorted(s: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\nmethod findIns(arr: array<int>, val: int, len: nat) returns (r: nat)\n  requires arr != null\n  requires len < arr.Length\n  requires sorted(arr[..len])\n  ensures r <= len\n  ensures forall k: nat :: k < r ==> arr[k] < val\n  ensures sorted( arr[..r] + [val] + arr[r..len] )\n{\n    r := 0;\n    while r < len\n      invariant r <= len\n      decreases len - r\n      invariant forall k: nat :: k < r ==> arr[k] < val\n      invariant arr == old(arr)\n    {\n        if arr[r] >= val\n            { return; }\n        r := r + 1;\n    }\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && \n\tpre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || \n\tpre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n\tensures !res <==> isNotPrefixPred(pre,str)\n\tensures  res <==> isPrefixPred(pre,str)\n{\n\tif (|pre| == 0)\n\t{\n\t\treturn true;\n\t}\n\tif (|str| < |pre|)\n\t{\n\t\treturn false;\n\t}\n\treturn str[..|pre|] == pre;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n\t(exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\t(forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n\tensures  res <==> isSubstringPred(sub, str)\n\tensures !res <==> isNotSubstringPred(sub, str) \n{\n\tres := false;\n\tvar i := 0;\n\twhile (i <= |str| && !res)\n\t\tinvariant 0 <= i <= |str| + 1\n\t\tinvariant !res <==> (forall j :: (0 <= j < i ==> isNotPrefixPred(sub, str[j..])))\n\t\tdecreases |str| - i\n\t{\n\t\tvar prefix := isPrefix(sub, str[i..]);\n\t\tif (prefix) {\n\t\t\tres := true;\n\t\t}\n\t\ti := i + 1;\n\t}\n\treturn res;\n}\npredicate haveCommonKSubstringPred(x:nat, str1:string, str2:string)\n{\n\texists i1, j1 :: 0 <= i1 <= |str1|- x && j1 == i1 + x && isSubstringPred(str1[i1..j1],str2)\n}\npredicate haveNotCommonKSubstringPred(x:nat, str1:string, str2:string)\n{\n\tforall i1, j1 :: 0 <= i1 <= |str1|- x && j1 == i1 + x ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\nlemma commonKSubstringLemma(x:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(x,str1,str2) <==> !haveNotCommonKSubstringPred(x,str1,str2)\n\tensures !haveCommonKSubstringPred(x,str1,str2) <==>  haveNotCommonKSubstringPred(x,str1,str2)\n{}\nmethod haveCommonKSubstring(x: nat, str1: string, str2: string) returns (found: bool)\n\tensures found  <==>  haveCommonKSubstringPred(x, str1, str2)\n\tensures !found <==> haveNotCommonKSubstringPred(x,str1,str2) \n{\n\tif (|str1| < x) {\n\t\treturn false;\n\t}\n\tfound := false;\n\tvar i := 0;\n\twhile (i <= |str1| - x && !found)\n\t\tinvariant |str1| >= x ==> 0 <= i <= |str1| - x + 1\n\t\tinvariant !found <==> forall j, j1 :: (0 <= j < i && j1 == j + x ==> isNotSubstringPred(str1[j..j1], str2))\n\t\tdecreases |str1| - i\n\t{\n\t\tvar index := i + x;\n\t\tvar substring := isSubstring(str1[i..index], str2);\n\t\tif (substring) {\n\t\t\tfound := true;\n\t\t}\n\t\ti := i + 1;\n\t}\n\treturn found;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len: nat)\n\trequires (|str1| <= |str2|)\n\tensures (forall x :: len < x <= |str1| ==> !haveCommonKSubstringPred(x, str1, str2))\n\tensures haveCommonKSubstringPred(len, str1, str2)\n{\n\tlen := |str1|;\n\twhile (len > 0)\n\t\tinvariant forall x :: (len < x <= |str1| ==> !haveCommonKSubstringPred(x, str1, str2))\n\t\tdecreases len\n\t{\n\t\tvar found := haveCommonKSubstring(len, str1, str2);\n\t\tif (found) {\n\t\t\treturn len;\n\t\t}\n\t\tlen := len - 1;\n\t}\n\tassert isPrefixPred(str1[0..0], str2[0..]);\n\treturn len;\n}"
},
{
    "dafny": "method merge(s1:seq<int>, s2:seq<int>) returns(s3: seq<int>)\nrequires sorted(s1) && sorted(s2)\nrequires |s1| > 0 && |s2| > 0\nensures sorted(s3)\nensures |s3| == |s1| + |s2|\n{\n  s3 := [];\n  var j, k;\n  j, k := 0, 0;\n  while j < |s1| && k < |s2|\n  decreases (|s1| + |s2|) - (j + k)\n  invariant sorted(s3)\n  invariant 0 <= j <= |s1| && 0 <= k <= |s2|\n  invariant |s3| == j + k\n  invariant j < |s1| && k < |s2| ==> forall l :: 0 <= l < |s3| ==> s3[l] <= s1[j] && s3[l] <= s2[k]\n  invariant j < |s1| && k < |s2| && s1[j] <= s2[k] ==> forall n, m :: j <= n < |s1| && k <= m < |s2| ==> s1[j] <= s1[n] && s1[j] <= s2[m]\n  invariant j < |s1| && k < |s2| && s2[k] < s1[j] ==> forall n, m :: j <= n < |s1| && k <= m < |s2| ==> s2[k] < s1[n] && s2[k] <= s2[m]\n  invariant j >= |s1| && k < |s2| ==> forall o :: k <= o < |s2| ==> s2[o] >= s3[|s3|-1]\n  invariant k >= |s2| && j < |s1| ==> forall o :: j <= o < |s1| ==> s1[o] >= s3[|s3|-1]\n  {\n    if(s1[j] <= s2[k])\n    {\n      s3 := s3 + s1[j..j+1];\n      j := j + 1;\n    }\n    else\n    {\n      s3 := s3 + s2[k..k+1];\n      k := k + 1;\n    }\n  }\n  if(j >= |s1| && k < |s2|)\n  {\n    s3 := s3 + s2[k..];\n  }\n  if(k >= |s2| && j < |s1|)\n  {\n    s3 := s3 + s1[j..];\n  }\n}\npredicate sorted(s: seq<int>) \n{\n  forall j,k :: 0 <= j < k < |s| ==> s[j] <= s[k]\n}"
},
{
    "dafny": "function Fib(n: nat): nat {\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\nmethod ComputeFib(n: nat) returns (x: nat)\n  ensures x == Fib(n)\n{\n  x := 0;\n  var y := 1;\n  var i := 0;\n  while i != n\n    invariant 0 <= i <= n\n    invariant x == Fib(i) && y == Fib(i + 1)\n  {\n    x, y := y, x + y;\n    i := i + 1;\n  }\n}\nmethod SquareFib(N: nat) returns (x: nat)\n  ensures x == Fib(N) * Fib(N)\n{\n  x := 0;\n  var n := 0;\n  while n != N\n    invariant 0 <= n <= N\n    invariant x == Fib(n) * Fib(n)\n}\nmethod SquareFib'y(N: nat) returns (x: nat)\n  ensures x == Fib(N) * Fib(N)\n{\n  x := 0;\n  var n, y := 0, 1;\n  while n != N\n    invariant 0 <= n <= N\n    invariant x == Fib(n) * Fib(n)\n    invariant y == Fib(n + 1) * Fib(n + 1)\n  {\n    calc {\n      Fib(n + 2) * Fib(n + 2);\n    ==  \n      (Fib(n) + Fib(n + 1)) * (Fib(n) + Fib(n + 1));\n    ==  \n      Fib(n) * Fib(n) + 2 * Fib(n) * Fib(n + 1) + Fib(n + 1) * Fib(n + 1);\n    ==  \n      x + 2 * Fib(n) * Fib(n + 1) + y;\n    }\n    x, y := y, Fib(n + 2) * Fib(n + 2);\n    n := n + 1;\n  }\n}\nmethod SquareFib'k(N: nat) returns (x: nat)\n  ensures x == Fib(N) * Fib(N)\n{\n  x := 0;\n  var n, y, k := 0, 1, 0;\n  while n != N\n    invariant 0 <= n <= N\n    invariant x == Fib(n) * Fib(n)\n    invariant y == Fib(n + 1) * Fib(n + 1)\n    invariant k == 2 * Fib(n) * Fib(n + 1)\n  {\n    calc {\n      2 * Fib(n + 1) * Fib(n + 2);\n    ==  \n      2 * Fib(n + 1) * (Fib(n) + Fib(n + 1));\n    ==  \n      2 * Fib(n + 1) * Fib(n) + 2 * Fib(n + 1) * Fib(n + 1);\n    }\n    x, y, k := y, x + k + y, k + y + y;\n    n := n + 1;\n  }\n}\nmethod SquareFib'final(N: nat) returns (x: nat)\n  ensures x == Fib(N) * Fib(N)\n{\n  x := 0;\n  var n, y, k := 0, 1, 0;\n  while n != N\n    invariant 0 <= n <= N\n    invariant x == Fib(n) * Fib(n)\n    invariant y == Fib(n + 1) * Fib(n + 1)\n    invariant k == 2 * Fib(n) * Fib(n + 1)\n  {\n    x, y, k := y, x + k + y, k + y + y;\n    n := n + 1;\n  }\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && \n\tpre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || \n\tpre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\nmethod isPrefix(pre:string, str:string) returns (res:bool)\n\tensures !res <==> isNotPrefixPred(pre,str)\n\tensures  res <==> isPrefixPred(pre,str)\n{\n\tif |pre| > |str| { return false; }\n\telse { return pre == str[..|pre|]; }\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n\t(exists i :: 0 <= i <= |str| &&  isPrefixPred(sub,str[i..]))\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\t(forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\nmethod isSubstring(sub:string, str:string) returns (res:bool)\n\tensures res <==> isSubstringPred(sub,str)\n{\n\tif (|str| < |sub|) { return false; }\n\tvar i:int := 0;\n\twhile i <= |str|\n\t\tinvariant 0 <= i <= |str| + 1\n\t\tinvariant forall j :: 0 <= j < i ==> isNotPrefixPred(sub,str[j..])\n\t\tdecreases |str| - i\n\t{\n\t\tvar isPre:bool := isPrefix(sub,str[i..]);\n\t\tif isPre { return true; }\n\t\ti := i + 1;\n\t}\n\treturn false;\n}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\texists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\tforall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}\nmethod haveCommonKSubstring(k:nat, str1:string, str2:string) returns (found:bool)\n\tensures found <==> haveCommonKSubstringPred(k,str1,str2)\n{\n\tif |str1| < k || |str2| < k { return false; }\n\tif k == 0 {\n\t\tassert isPrefixPred(str1[0..0],str2[0..]);\n\t\treturn true;\n\t}\n\tvar i:int := 0;\n\twhile i <= |str1| - k\n\t\tinvariant 0 <= i <= |str1| - k + 1\n\t\tinvariant forall j1, j2 :: 0 <= j1 < i && j2 == j1 + k ==> isNotSubstringPred(str1[j1..j2],str2)\n\t\tdecreases |str1| - k - i\n\t{\n\t\tvar isSub:bool := isSubstring(str1[i..(i+k)],str2);\n\t\tif isSub { return true; }\n\t\ti := i + 1;\n\t}\n\treturn false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n\trequires (|str1| <= |str2|)\n\tensures forall k :: len < k <= |str1| ==> haveNotCommonKSubstringPred(k,str1,str2)\n\tensures haveCommonKSubstringPred(len,str1,str2)\n{\n\tvar i:int := |str1|;\n\twhile 0 < i\n\t\tinvariant 0 <= i <= |str1|\n\t\tinvariant forall j :: i < j <= |str1| ==> haveNotCommonKSubstringPred(j,str1,str2)\n\t\tdecreases i\n\t{\n\t\tvar hasSub:bool := haveCommonKSubstring(i,str1,str2);\n\t\tif hasSub { return i; }\n\t\ti := i - 1;\n\t}\n\tassert isPrefixPred(str1[0..0],str2[0..]);\n\treturn i;\n}"
},
{
    "dafny": "datatype Sex = Masculine | Feminine\ndatatype CivilState = Single | Married | Divorced | Widow | Dead\nclass Person\n{\n    const name: string; \n    const sex: Sex;\n    const mother: Person?; \n    const father: Person?;\n    var spouse: Person?;\n    var civilState: CivilState;\n    predicate Valid()\n        reads this,spouse\n    {\n        (this.spouse != null <==> this.civilState == Married)\n        && (this.mother != null ==> this.mother.sex == Feminine)\n        && (this.father != null ==> this.father.sex == Masculine)\n        && (this.spouse != null ==> this.spouse.sex != this.sex)\n        && (this.spouse != null ==> this.spouse.spouse == this)\n    }\n    constructor (name: string, sex: Sex, mother: Person?, father: Person?)\n        requires (father != null ==> father.sex == Masculine)\n        requires (mother != null ==> mother.sex == Feminine)\n        ensures Valid() \n        ensures this.name == name\n        ensures this.sex == sex\n        ensures this.mother == mother\n        ensures this.father == father\n        ensures this.spouse == null\n        ensures this.civilState == Single\n    {\n        this.name := name;\n        this.sex := sex;\n        this.mother := mother;\n        this.father := father;\n        this.spouse := null;\n        this.civilState := Single;\n    }\n    method marry(spouse: Person)\n        modifies this, spouse\n        requires Valid()\n        requires this.civilState == Single\n        requires spouse.sex != this.sex\n        ensures Valid()\n        ensures spouse.spouse == this\n        ensures spouse.civilState == Married\n        ensures this.spouse == spouse\n        ensures this.civilState == Married\n    {\n        spouse.spouse := this;\n        spouse.civilState := Married;\n        this.spouse := spouse;\n        this.civilState := Married;\n    }\n    method divorce()\n        modifies this, spouse\n        requires Valid()\n        requires this.civilState == Married\n        ensures Valid()\n    {\n        spouse.spouse := null;\n        spouse.civilState := Divorced;\n        this.spouse := null;\n        this.civilState := Divorced;\n    }\n    method die()\n        modifies this, spouse\n        requires Valid()\n        requires this.civilState != Dead\n        ensures Valid()\n    {\n        if spouse != null\n        {\n            spouse.spouse := null;\n            spouse.civilState := Widow;\n        }\n        this.spouse := null;\n        this.civilState := Dead;\n    }\n}\nmethod Main() {\n    var person := new Person(\"vitor\", Masculine, null, null);\n    var person2 := new Person(\"catarina\", Feminine, null, null);\n    person.marry(person2);\n    assert person.spouse == person2;\n    assert person2.spouse == person;\n    assert person.sex != person2.sex;\n}"
},
{
    "dafny": "class Node\n{\n    var next: Node?;\n    var value: int;\n    constructor()\n    ensures this.next == null\n    {\n        this.next := null;\n    }\n}\nmethod sum(x: int, y: int)\nreturns (res: int)\n{\n   res := x + y;\n}\nmethod Main()\n{\n    var n1 := new Node();\n    var n2 := new Node();\n    var n3 := new Node();\n    n1.value := 1;\n    n1.next := n2;\n    n2.value := 2;\n    n2.next := n3;\n    n3.value := 3;\n    n3.next := null;\n    var s := n1.value + n2.value;\n    n3.next := null;\n    n3.value := 4;\n    var res:= sum(1, s);\n}"
},
{
    "dafny": "type pos = x | 1 <= x witness 1\nghost predicate IsFactor(p: pos, x: pos) {\n  exists q :: p * q == x\n}\nghost function Factors(x: pos): set<pos> {\n  set p: pos | p <= x && IsFactor(p, x)\n}\nlemma FactorsHasAllFactors(x: pos)\n  ensures forall n :: n in Factors(x) <==> n in iset p: pos | IsFactor(p, x)\n{\n}\nlemma FactorsContains1(x: pos)\n  ensures 1 in Factors(x)\n{\n  assert 1 * x == x;\n}\nlemma FactorsContainsSelf(x: pos)\n  ensures x in Factors(x)\n{\n  assert x * 1 == x;\n}\nghost function Max(s: set<pos>): pos\n  requires s != {}\n{\n  MaxExists(s);\n  var x :| x in s && forall y :: y in s ==> y <= x;\n  x\n}\nlemma MaxExists(s: set<pos>)\n  requires s != {}\n  ensures exists x :: x in s && forall y :: y in s ==> y <= x\n{\n  var x := FindMax(s);\n}\nghost function FindMax(s: set<pos>): (max: pos)\n  requires s != {}\n  ensures max in s && forall y :: y in s ==> y <= max\n{\n  var x :| x in s;\n  if s == {x} then\n    x\n  else\n    var s' := s - {x};\n    assert s == s' + {x};\n    var y := FindMax(s');\n    if x < y then y else x\n}\nghost function Gcd(x: pos, y: pos): pos {\n  var common := Factors(x) * Factors(y);\n  assert 1 in common by {\n    FactorsContains1(x);\n    FactorsContains1(y);\n  }\n  Max(common)\n}\nlemma AboutGcd(x: pos, y: pos)\n  ensures IsFactor(Gcd(x, y), x)\n  ensures IsFactor(Gcd(x, y), y)\n  ensures forall p: pos :: IsFactor(p, x) && IsFactor(p, y) ==> p <= Gcd(x, y)\n{\n  forall p: pos | IsFactor(p, x) && IsFactor(p, y)\n    ensures p <= Gcd(x, y)\n  {\n    assert p in Factors(x) * Factors(y);\n  }\n}\nlemma GcdSymmetric(x: pos, y: pos)\n  ensures Gcd(x, y) == Gcd(y, x)\n{\n  assert Factors(x) * Factors(y) == Factors(y) * Factors(x);\n}\nlemma GcdIdempotent(x: pos)\n  ensures Gcd(x, x) == x\n{\n  FactorsContainsSelf(x);\n  assert x in Factors(x) * Factors(x);\n}\nlemma GcdSubtract(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(x, y) == Gcd(x, y - x)\n{\n  var p := Gcd(x, y);\n  assert IsFactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n  var common := Factors(x) * Factors(y - x);\n  assert p in common;\n  forall q | q in common\n    ensures q <= p\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n    assert IsFactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n    assert q in Factors(x) * Factors(y);\n  }\n}\nmethod EuclidGcd(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x: pos, y: pos := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)\n    decreases x + y\n  {\n    case x < y =>\n      GcdSubtract(x, y);\n      y := y - x;\n    case y < x =>\n      calc {\n        Gcd(x, y);\n      ==  { GcdSymmetric(x, y); }\n        Gcd(y, x);\n      ==  { GcdSubtract(y, x); }\n        Gcd(y, x - y);\n      ==  { GcdSymmetric(y, x - y); }\n        Gcd(x - y, y);\n      }\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\nlemma GcdSubtractAlt(x: pos, y: pos)\n  requires x < y\n  ensures Gcd(y, x) == Gcd(x, y - x) \n{\n  GcdSymmetric(x, y); \n  var p := Gcd(x, y);\n  assert IsFactor(p, y - x) by {\n    var a :| p * a == x;\n    var b :| p * b == y;\n    calc {\n      y - x;\n    ==\n      p * b - p * a;\n    ==\n      p * (b - a);\n    }\n  }\n  var common := Factors(x) * Factors(y - x);\n  assert p in common;\n  forall q | q in common\n    ensures q <= p\n  {\n    var a :| q * a == x;\n    var b :| q * b == y - x;\n    assert IsFactor(q, y) by {\n      calc {\n        y;\n      ==\n        x + (y - x);\n      ==\n        q * a + q * b;\n      ==\n        q * (a + b);\n      }\n    }\n    assert q in Factors(x) * Factors(y);\n  }\n}\nmethod EuclidGcdAlt(X: pos, Y: pos) returns (gcd: pos)\n  ensures gcd == Gcd(X, Y)\n{\n  var x: pos, y: pos := X, Y;\n  while\n    invariant Gcd(x, y) == Gcd(X, Y)\n    decreases x + y\n  {\n    case x < y =>\n      GcdSubtractAlt(x, y);\n      GcdSymmetric(y, x);\n      y := y - x;\n    case y < x =>\n      GcdSymmetric(x - y, y);\n      GcdSubtractAlt(y, x);\n      x := x - y;\n  }\n  GcdIdempotent(x);\n  return x;\n}\nmethod Main() {\n  Test(15, 9);\n  Test(14, 22);\n  Test(371, 1);\n  Test(1, 2);\n  Test(1, 1);\n  Test(13, 13);\n  Test(60, 60);\n}\nmethod Test(x: pos, y: pos) {\n  var gcd := EuclidGcd(x, y);\n  print x, \" gcd \", y, \"  =  \", gcd, \"\\n\";\n}"
},
{
    "dafny": "function fact (n :int) : int\n  requires n > 0;\n{\n  if (n == 1) then 1 else n * fact (n-1)\n}\nmethod factorial_simple (n: int) returns (v:int)\n  requires n > 0;\n  ensures v == fact(n);\n{\n  v := 1;\n  if (n == 1) { return v; }\n  var i := 2;\n  while (i <= n)\n    invariant i <= n+1;\n    invariant v == fact(i-1);\n  {\n    v := i * v;\n    i := i + 1;\n  }\n  return v;\n}\nmethod factorial_turing (n: int) returns (v: int)\n  requires n > 0;\n  ensures v == fact(n);\n{\n  var r := 1;\n  var u := 1;\n  while (true)\n    decreases n - r;\n    invariant u == fact(r);\n    invariant r <= n;\n  {\n    v := u;\n    if (r - n >= 0)\n    { assert (r == n); return v; }\n    var s := 1;\n    while (true)\n      decreases r + 1 - s\n      invariant s <= r < n\n      invariant u == s*fact(r)\n    {\n      u := u + v;\n      s := s + 1;\n      if ((s - (r + 1)) >= 0)\n      {\n        assert (s == r+1);\n        break;\n      }\n    }\n    r := r + 1;\n  }\n}"
},
{
    "dafny": "method abs (x: int) returns (y : int)\n    ensures  0 <= y; \n{\n    if (x < 0) {\n        return -x;\n    } else {\n        return x;\n    }\n}\nmethod max (x: int, y: int) returns (m : int)\nrequires true\nensures m == y || m == x\nensures m >= x && m >= y\n{\n    var r : int;\n    if ( x < y ) {\n        r := y  ;\n    } else {\n        r := x;\n    }\n    m := r;\n    return m;\n}\nmethod ex1 (n: int) returns (i : int)\n    requires n >= 0\n    ensures i == n\n{\n    i := 0;\n    while (i < n)\n        invariant i <= n;\n        decreases n - i;   \n    {\n        i := i + 1;\n        assert( i <= n);\n    } \n}\nmethod find (a: seq<int>, key: int) returns (index : int)\nrequires true\nensures key !in a ==> index == -1 \nensures key in a ==> 0 <= index < |a| \nensures key in a ==> 0 <= index < |a| && a[index] == key\n{\n    index := 0;\n    while (index < |a|) \n        decreases |a| - index\n        invariant 0 <= index <= |a| ;\n        invariant key !in a[..index];\n        {\n            if ( a[index] == key ) { \n                assert( index < |a|);\n                return index ;\n            }\n            index := index + 1;\n        }\n    index := -1;\n}\npredicate sorted (a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\nmethod unique(a: seq<int>) returns (b: seq<int>) \n    requires sorted(a)\n    ensures forall j, k::0 <= j < k < |b|  ==> b[j] < b[k]\n    ensures forall j :: j in a ==> j in b\n{\n    if |a| == 0 {\n        b := [] ;\n    } else \n    {\n        var last := a[0];\n        b := [a[0]];\n        var index := 1;\n        while (index < |a|)\n            decreases |a| - index\n            invariant index <= |a|;\n            invariant |b| >= 1;\n            invariant b[|b| - 1] == last;\n            invariant forall j, k::0 <= j < k < |b|  ==> b[j] < b[k];\n            invariant last in a[..index];   \n            invariant forall j :: j in a[..index] ==> j in b\n        {\n            if ( a[index] != last ) { \n                b := b + [a[index]];\n                last := a[index];\n            }\n            index := index + 1;\n        }\n    }\n}\nmethod Main() {\n    var r := find([], 1);   \n    print r, \"\\n\";\n    r := find([0,3,5,7], 5);   \n    print r, \"\\n\";\n    var s := unique([0,1,3,3,5,5,7]);\n    print s, \"\\n\";\n}"
},
{
    "dafny": "type MyType  \niterator Iter()  \nghost method M()  \nmethod P()  \nclass TestClass {\n  method Q()\n  {\n    if g == 0 {\n      assume true;  \n      assume {:axiom} true;\n    }\n  }\n  ghost var g: int\n}\nghost function F(): int  \nfunction H(): int  \nlemma Lemma() {\n  assume false;  \n  assume {:axiom} true;\n}\nghost method GMethod() {\n  assume false;  \n  assume {:axiom} true;\n}\nghost function MyFunction(): int\n{\n  assume false;  \n  assume {:axiom} true;\n  6\n}\nghost function MyCalcFunction(): int\n{\n  calc <= {\n    2;\n    6;\n    { assume true; \n      assume {:axiom} true; }\n    10;\n  }\n  12\n}\ndatatype Result = Failure {\n  predicate IsFailure() { true }\n  function Extract() : () requires false { () }\n}\nmethod MyResultMethod() returns (r: Result) {\n  var x :- assume Failure(); \n  var y :- assume {:axiom} Failure();\n}\nmethod MyAssignSuchThat() {\n  var x: int :| assume false; \n  var y: int :| assume {:axiom} true;\n}\nmethod BodyLessLoop_NonGhost(y: int)\n  requires y <= 100\n  ensures false\n{\n  var x := y;\n  while true  \n    invariant x <= 100\n  for i := 0 to 100  \n    invariant x <= 100\n}\nmethod BodyLessLoop_Ghost(ghost y: int)\n  requires y <= 100\n  ensures false\n{\n  if y == y {  \n    var x := y;\n    while true  \n      invariant x <= 100\n    for i := 0 to 100  \n      invariant x <= 100\n  }\n}"
},
{
    "dafny": "method abs(x : int) returns (r : int)\nensures 0 <= r\nensures 0 <= x ==> r == x\nensures 0 > x ==> r == -x\n{\n    if( x >= 0 ) \n       { return x; }\n    else\n       { return -x; }\n}\nmethod test()\n{\n    var v := abs(3);\n    assert v == 3;\n}"
},
{
    "dafny": "function sortedI(a:array<int>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ forall i, j:: (0 <= i < j < n) ==> a[i] <= a[j] }\nmethod sortedInsertion(a:array<int>, na:int, e:int) returns (z:array<int>, nz:int, pos:int)\n  requires 0 <= na < a.Length\n  requires sortedI(a, na)\n  ensures sortedI(a, na+1)\n  ensures 0 <= pos <= na && a[pos] == e\n  ensures forall k :: 0 <= k < pos ==> a[k] == old(a[k])\n  ensures forall k :: pos < k < na ==> a[k] == old(a[k-1])\n  modifies a\n{\n  var i := na;\n  if( na > 0 ) \n  { a[na] := a[na-1]; }\n  while 0 < i && e < a[i-1] \n    decreases i\n    invariant 0 <= i <= na\n    invariant sortedI(a, na+1)\n    invariant forall k :: i < k < na+1 ==> e <= a[k] \n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[k])\n    invariant forall k :: i < k < na ==> a[k] == old(a[k-1])\n  {\n    a[i] := a[i-1];\n    i := i - 1;\n  }\n  a[i] := e;\n  return a, na+1, i;\n}\nfunction sortedRange(a:array<int>, s:int, e:int) : bool \nrequires 0 <= s <= e <= a.Length\nreads a\n{\n    forall i,j :: s <= j <= i < e ==> a[j] <= a[i]\n}\nmethod sortedInsertion2(a:array<int>, na:int, e:int) returns (z:array<int>, nz:int, pos:int)\nrequires 0 <= na < a.Length - 1 \nrequires sortedRange(a, 0, na)\nensures a == z\nensures nz == na + 1\nensures 0 <= pos < nz\nensures sortedRange(a, 0, nz)\nensures forall i :: 0 <= i < pos ==> a[i] == z[i]\nensures z[pos] == e\nensures forall i :: pos <= i < na ==> old(a[i]) == a[i + 1]\nmodifies a\n{\n    if(na == 0) {\n        a[0] := e;\n        return a, 1, 0;\n    }\n    assert na > 0;\n    var x:int := 0;\n    while(x < na && a[x] <= e)\n    decreases na - x\n    invariant 0 <= x <= na\n    invariant forall i :: (0 <= i < x) ==> a[i] <= e\n    {\n        x := x + 1;\n    }\n    if(x == na) {\n        a[na] := e;\n        return a, na + 1, na;\n    }\n    a[na] := a[na - 1];\n    var y := na;\n    while (y > x)\n    decreases y\n    invariant x <= y <= na\n    invariant sortedRange(a, 0, na + 1)\n    invariant forall i :: 0 <= i < x ==> a[i] <= e\n    invariant forall i :: x <= i < na ==> a[i] >= e\n    invariant a[x .. y] == old(a[x .. y])\n    invariant forall i :: y < i <= na ==> old(a[i - 1]) == a[i]\n    {\n        a[y] := a[y-1];\n        y := y - 1;\n    }\n    a[x] := e;\n    return a, na + 1, x;\n}"
},
{
    "dafny": "class Person {\n    var bd:DataBase?;\n    var id: int;\n    var age: int;\n    var name: string;\n    var gender: string;\n    function RepInv():bool\n        reads this\n    { id >= -1}\n    function Transient():bool\n        reads this\n    { \n        RepInv() && id == -1 && bd == null\n    }\n    function Persistent():bool\n        reads this, this.bd\n    { \n        RepInv() && id != -1 && bd != null && bd.RepInv()\n    }\n    function Detached():bool\n        reads this\n    { \n        RepInv() && id != -1 && bd == null\n    }\n    constructor(id:int)\n        ensures Transient()\n    {\n        bd := null;\n        this.id := -1;\n    }\n    method delete(index:int)\n        modifies this`bd, this`id, bd`size,bd.collection\n        requires Persistent() && bd.RepInv() && index > 0\n        ensures Transient() \n    {\n        bd.Delete(index);\n        this.id := -1;\n        this.bd := null;\n    }\n     method save(bd:DataBase)\n        modifies this`bd, this`id, bd`size, bd.collection\n        requires Transient() && bd.RepInv()\n        ensures Persistent() && bd.RepInv()\n        ensures bd.collection == old (bd.collection)\n        ensures this.bd.collection == old (bd.collection)\n    {  \n        this.bd := bd;      \n        this.id := bd.size;\n        bd.Save(this);\n    }\n    method update(bd:DataBase)\n        modifies this`bd\n        requires Detached() && bd.RepInv()\n        ensures Persistent() && bd.RepInv()\n    {\n        this.bd := bd;\n    }\n    method close()\n        modifies this`bd\n        requires Persistent()\n        ensures Detached()\n    {\n        this.bd := null;\n    }\n}\nclass DataBase {\n    var collection:array<Person?>;\n    var size:int;\n    function RepInv():bool\n        reads this`size,this`collection\n    { 0 <= this.size < collection.Length }\n    constructor ()\n        ensures RepInv()\n        ensures fresh(collection)\n    {\n        collection := new Person?[10];\n        size := 0;\n    }\n    method Delete(id:int)\n        modifies collection, this`size\n        requires RepInv() \n        ensures RepInv()\n    {       \n        if( 0 <= id < collection.Length && this.size > 0) {\n            collection[id] := null;\n            this.size := this.size - 1;\n        }\n    }\n    method Save(p:Person)\n        modifies collection, this`size\n        requires RepInv() && this.size < collection.Length\n        ensures RepInv() \n    {\n        if( 0 <= this.size < collection.Length - 1 ) {\n            collection[this.size] := new Person(this.size);\n            this.size := this.size + 1;\n        }\n    }\n     method Find(id: int) returns (p: Person?)\n        requires 0 <= id < collection.Length && RepInv() \n        ensures RepInv()\n    {\n        return collection[id];\n    }\n}"
},
{
    "dafny": "method abs (x: int) returns (y : int)\n    ensures true; \n{\n    if (x < 0) {\n        y := -x;\n    } else {\n        y :=  x;\n    }\n}\nmethod max (x: int, y: int) returns (m : int)\nrequires true;\nensures true;\n{\n    var r : int;\n    if ( x > y ) {\n        r := 0;\n    } else {\n        r := 1;\n    }\n    m := r;\n}\nmethod ex1 (n: int)\n    requires true\n    ensures true\n    decreases *\n{\n    var i := 0;\n    while (i < n)\n        invariant true;\n        decreases *;    \n    {\n        i := i + 1;\n    }\n}\nmethod find (a: seq<int>, key: int) returns (index : int)\nrequires true;\nensures true\n{\n    index := 0;\n    while (index < |a|)\n        invariant true ;\n        {\n            if ( a[index] == key ) { \n                return 0;\n            }\n            index := index + 2;\n        }\n    index := -10;\n}\nmethod isPalindrome(a: seq<char>) returns (b: bool) \n{\n    return true;\n}\npredicate sorted (a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\nmethod unique(a: seq<int>) returns (b: seq<int>) \n    requires sorted(a)\n    ensures true\n{\n  return a;\n}\nmethod Main() {\n    var r := find([], 1);   \n    print r, \"\\n\";\n    r := find([0,3,5,7], 5);  \n    print r, \"\\n\";\n    var s1 := ['a'];\n    var r1 := isPalindrome(s1);\n    print \"is [\", s1, \"]\", \" a isPalindrome? \", r1, \" \\n\";\n    s1 := [];\n    r1 := isPalindrome(s1);\n    print \"is [\", s1, \"]\", \" a isPalindrome? \", r1, \" \\n\";\n    s1 := ['a', 'b'];\n    r1 := isPalindrome(s1);\n    print \"is [\", s1, \"]\", \" a isPalindrome? \", r1, \" \\n\";\n    s1 := ['a', 'b', 'a'];\n    r1 := isPalindrome(s1);\n    print \"is [\", s1, \"]\", \" a isPalindrome? \", r1, \" \\n\";\n    var i := [0,1,3,3,5,5,7];\n    var s := unique(i);\n    print \"unique applied to \", i, \" is \", s, \"\\n\";\n}"
},
{
    "dafny": "method StatementsInCompiledMethod() {\n  assume false;  \n  calc {\n    100;\n  ==  { assume false; }  \n    100;\n  }\n  assert true by {\n    assume false;  \n  }\n  ghost var b := true;\n  if b {\n    assume false;  \n  }\n}\nghost method StatementsInGhostMethod() {\n  assume false;  \n  calc {\n    100;\n  ==  { assume false; }  \n    100;\n  }\n  assert true by {\n    assume false;  \n  }\n  ghost var b := true;\n  if b {\n    assume false;  \n  }\n}\nmethod ExpressionsInCompiledMethod() {\n  var a :=\n    assume false;  \n    5;\n  var b :=\n    calc {\n      100;\n    ==  { assume false; }  \n      100;\n    }\n    5;\n  var c :=\n    assert true by {\n      assume false;  \n    }\n    5;\n  var d :=\n    ghost var g := 5;\n    assume false;  \n    5;\n  ghost var x :=\n    assume false;  \n    5;\n  ghost var y :=\n    calc {\n      100;\n    ==  { assume false; }  \n      100;\n    }\n    5;\n  ghost var z :=\n    assert true by {\n      assume false;  \n    }\n    5;\n  ghost var w :=\n    ghost var g := 5;\n    assume false;  \n    5;\n}\nghost method ExpressionsInGhostMethod() {\n  var a :=\n    assume false;  \n    5;\n  var b :=\n    calc {\n      100;\n    ==  { assume false; }  \n      100;\n    }\n    5;\n  var c :=\n    assert true by {\n      assume false;  \n    }\n    5;\n  var d :=\n    ghost var g := 5;\n    assume false;  \n    5;\n  ghost var x :=\n    assume false;  \n    5;\n  ghost var y :=\n    calc {\n      100;\n    ==  { assume false; }  \n      100;\n    }\n    5;\n  ghost var z :=\n    assert true by {\n      assume false;  \n    }\n    5;\n  ghost var w :=\n    ghost var g := 5;\n    assume false;  \n    5;\n}\nfunction CompiledFunction(): int {\n  assume false;  \n  calc {\n    100;\n  ==  { assume false; }  \n    100;\n  }\n  assert true by {\n    assume false;  \n  }\n  ghost var g := 5;\n  assume false;  \n  5\n}\nghost function GhostFunction(): int {\n  assume false;  \n  calc {\n    100;\n  ==  { assume false; }  \n    100;\n  }\n  assert true by {\n    assume false;  \n  }\n  ghost var g := 5;\n  assume false;  \n  5\n}\nmethod SpecificationOfCompiledMethod()\n  requires assume false; true  \n  modifies assume false; {}  \n  ensures assume false; true  \n  decreases assume false; 5  \n{\n}\nghost method SpecificationOfGhostMethod()\n  requires assume false; true  \n  modifies assume false; {}  \n  ensures assume false; true  \n  decreases assume false; 5  \n{\n}\nfunction SpecificationOfCompiledFunction(): int\n  requires assume false; true  \n  reads assume false; {}  \n  ensures assume false; true  \n  decreases assume false; 5  \n{\n  5\n}\nghost function SpecificationOfGhostFunction(): int\n  requires assume false; true  \n  reads assume false; {}  \n  ensures assume false; true  \n  decreases assume false; 5  \n{\n  5\n}\nmethod SpecificationOfCompiledMethodWithoutBody()  \n  requires assume false; true  \n  modifies assume false; {}  \n  ensures assume false; true  \n  decreases assume false; 5  \nghost method SpecificationOfGhostMethodWithoutBody()  \n  requires assume false; true  \n  modifies assume false; {}  \n  ensures assume false; true  \n  decreases assume false; 5  \nfunction SpecificationOfCompiledFunctionWithoutBody(): int  \n  requires assume false; true  \n  reads assume false; {}  \n  ensures assume false; true  \n  decreases assume false; 5  \nghost function SpecificationOfGhostFunctionWithoutBody(): int  \n  requires assume false; true  \n  reads assume false; {}  \n  ensures assume false; true  \n  decreases assume false; 5  \nleast predicate ExtremePredicate()\n  requires assume false; true  \n{\n  assume false;  \n  true\n}\nleast lemma ExtremeLemma()\n  requires assume false; true  \n  ensures assume false; true  \n  decreases assume false; 5  \n{\n  assume false;  \n}\nleast predicate ExtremePredicateWithoutBody()  \n  requires assume false; true  \nleast lemma ExtremeLemmaWithoutBody()  \n  requires assume false; true  \n  ensures assume false; true  \n  decreases assume false; 5  \nnewtype NewType = x | x % 2 == 1\n  witness assume false; 5  \ntype SubsetType = x | x % 2 == 1\n  witness assume false; 5  \nnewtype NewTypeGhostWitness = x | x % 2 == 1\n  ghost witness assume false; 5  \ntype SubsetTypeGhostWitness = x | x % 2 == 1\n  ghost witness assume false; 5  \nconst CompiledConst := assume false; 5  \nghost const GhostConst := assume false; 5  \nclass C {\n  const InstanceCompiledConst := assume false; 5  \n  ghost const InstanceGhostConst := assume false; 5  \n}\ndatatype D = D {\n  const InstanceCompiledConst := assume false; 5  \n  ghost const InstanceGhostConst := assume false; 5  \n}\nnewtype T = int {\n  const InstanceCompiledConst := assume false; 5  \n  ghost const InstanceGhostConst := assume false; 5  \n}\nfunction F(x: int, ghost y: int): int { 5 }\nghost function G(x: int): int { 5 }\nmethod M(x: int, ghost y: int) { }\nlemma N(x: int) { }\ndatatype Dt = Dt(x: int, ghost y: int)\nmethod CompiledMethodCaller() {\n  var a := F(assume false; 5, assume false; 6);  \n  ghost var b := G(assume false; 5);  \n  M(assume false; 5, assume false; 6);  \n  N(assume false; 5);  \n  var d := Dt(assume false; 5, assume false; 6);  \n  ghost var e := Dt(assume false; 5, assume false; 6);  \n}\nghost method GhostMethodCaller() {\n  var a := F(assume false; 5, assume false; 6);  \n  ghost var b := G(assume false; 5);  \n  N(assume false; 5);  \n  var d := Dt(assume false; 5, assume false; 6);  \n  ghost var e := Dt(assume false; 5, assume false; 6);  \n}\nfunction CompiledFunctionCaller(): int {\n  var a := F(assume false; 5, assume false; 6);  \n  ghost var b := G(assume false; 5);  \n  N(assume false; 5);  \n  var d := Dt(assume false; 5, assume false; 6);  \n  ghost var e := Dt(assume false; 5, assume false; 6);  \n  100\n}\nghost function GhostFunctionCaller(): int {\n  var a := F(assume false; 5, assume false; 6);  \n  ghost var b := G(assume false; 5);  \n  N(assume false; 5);  \n  var d := Dt(assume false; 5, assume false; 6);  \n  ghost var e := Dt(assume false; 5, assume false; 6);  \n  100\n}\nclass A {\n  method StatementsInCompiledMethod() {\n    assume false;  \n    calc {\n      100;\n    ==  { assume false; }  \n      100;\n    }\n    assert true by {\n      assume false;  \n    }\n    ghost var b := true;\n    if b {\n      assume false;  \n    }\n  }\n  ghost method StatementsInGhostMethod() {\n    assume false;  \n    calc {\n      100;\n    ==  { assume false; }  \n      100;\n    }\n    assert true by {\n      assume false;  \n    }\n    ghost var b := true;\n    if b {\n      assume false;  \n    }\n  }\n}"
},
{
    "dafny": "function power(n:nat, e:nat) : int\nlemma lemma_power()\n    ensures forall n:nat, e:nat :: 0 <= n * e && power(n, e) == 5;\n{\n    forall n:nat, e:nat\n        ensures 0 <= n * e && power(n, e) == 5;\n    {\n        assume false;\n    }\n}"
},
{
    "dafny": "method Max(a: int, b:int) returns (c: int)\n\tensures a < b  ==> c == b\n\tensures b <= a ==> c == a\n{\n\tif (a < b) {\n\t\treturn b;\n\t} else {\n\t\treturn a;\n\t}\n}"
},
{
    "dafny": "datatype Direction = North() | East() | South() | West()\nfunction TurnRight(direction:Direction) : Direction\n{\n  if direction.North?\n    then East\n  else if direction.East?\n    then South\n  else if direction.South?\n    then West\n  else  \n    North\n}\nlemma Rotation()\n{\n  assert TurnRight(North) == East;\n}\nfunction TurnLeft(direction:Direction) : Direction\n{\n  match direction {\n    case North => West\n    case West => South\n    case South => East  \n    case East => North\n  }\n}"
},
{
    "dafny": "datatype List = Nil | Cons(int, List)\nfunction Len(l:List): (v:int)\n{\n  match l\n  case Nil => 0\n  case Cons(hd, tl) => Len(tl) + 1\n}\nfunction isEmpty(l:List): bool\n{\n    match l\n    case Nil => true\n    case Cons(hd, tl) => false\n}\nfunction Exists_eq(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd == x || Exists_eq(tl, x)\n}\nfunction Exists_neq(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd != x || Exists_neq(tl, x)\n}\nfunction Exists_lt(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd < x || Exists_lt(tl, x)\n}\nfunction Exists_gt(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd > x || Exists_gt(tl, x)\n}\nfunction Forall_eq(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd == x || Forall_eq(tl, x)\n}\nfunction Forall_neq(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd != x || Forall_neq(tl, x)\n}\nfunction Forall_le(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd <= x || Forall_le(tl, x)\n}\nfunction Forall_ge(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd >= x || Forall_ge(tl, x)\n}\nfunction Forall_lt(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd < x || Forall_lt(tl, x)\n}\nfunction Forall_gt(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd > x || Forall_gt(tl, x)\n}\nfunction Delete(l:List, v:int): (lout: List)\n  ensures l == lout || Len(l) >= Len(lout) + 1\n  ensures Forall_neq(l, v)\n  ensures Exists_lt(l, v) || Forall_gt(lout, v)  \n  ensures Exists_eq(l, v) || l == lout\n  ensures Exists_gt(l, v) || Forall_lt(lout, v)\n  ensures Forall_le(l, v) || Exists_gt(lout, v)\n  ensures Forall_ge(l, v) || Exists_lt(lout, v)\n{\n  match l\n  case Nil => Nil\n  case Cons(hd, tl) =>\n    if (hd == v) then Delete(tl, v) else Cons(hd, Delete(tl, v))\n}"
},
{
    "dafny": "method isPrefix(pre: string, str: string) returns (res:bool)\n\trequires |pre| > 0 && |str| > 0;\n{\t\n\tif (|pre| <= |str|)\t{\n\t\tif (pre == str[..|pre|])\n\t\t\t{return true; }\n\t\telse\n\t\t\t{return false; }\n\t}\n\treturn false;\n}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n\trequires |sub| > 0 && |str| > 0;\n{\n\tvar i := 0;\n\tvar diff := |str| - |sub|;\n\tvar check : bool;\n\twhile i <= diff {\n\t\tcheck := isPrefix(sub, str[i..]);\n\t\tif (check == true)\n            {return true; }\n        i := i+1;\n\t}\n\treturn false;\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool) {\n    if (k == 0) {\n        return true;\n\t}\n    if (|str1| > 0 && |str2| > 0) {\n        var check := false;\n        var i := 0;\n        while (i+k <= |str1|) {\n            check := isSubstring(str1[i..(i+k)], str2);\n            if (check == true) {\n                return true;\n            }\n            i := i+1;\n        }\n        return false;\n    }\n    return false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat) {\n    if (|str1| > 0 && |str2| > 0) {\n        var check := false;\n        var length, maxLength := 0, 0;\n        while (length <= |str1| && length <= |str2|) {\n            check := haveCommonKSubstring(length, str1, str2);\n            if (check == true) {\n                maxLength := length;\n                length := length + 1;\n            }\n            else {\n                return maxLength;\n            }\n            return maxLength;\n        }\n    }\n    return 0;\n}"
},
{
    "dafny": "datatype List = Nil | Cons(int, List)\nfunction Len(l:List): int\n{\n  match l\n  case Nil => 0\n  case Cons(hd, tl) => Len(tl) + 1\n}\nfunction isEmpty(l:List): bool\n{\n    match l\n    case Nil => true\n    case Cons(hd, tl) => false\n}\nfunction Forall_eq(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd == x && Forall_eq(tl, x)\n}\nfunction Replicate(v:int, n:int): (lout: List)\n  requires n >= 0\n  ensures Forall_eq(lout, v)\n  ensures Len(lout) == n\n{\n  if n > 0 then Cons(v, Replicate(v, n-1)) else Nil\n}"
},
{
    "dafny": "method add5(x: nat) returns (r: nat)\n    requires 0 <= x <= 10;\n    ensures  r == (x + 5);\n{\n    r := x + 5;\n}\nmethod use_add5()\n{\n    var v;\n    v := add5(7);\n    assert(v == 12);\n}"
},
{
    "dafny": "datatype State = State(num: nat, player1: bool)\ndatatype Step = Step(take: nat)\nghost predicate ValidMove(step: Step, s: State) {\n  && 1 <= step.take <= 10\n  && step.take <= s.num\n}\nghost predicate NextStep(s: State, s': State, step: Step) {\n  && ValidMove(step, s)\n  && s'.num == s.num - step.take\n  && s'.player1 == !s.player1\n}\nghost predicate Next(s: State, s': State) {\n  exists step: Step :: NextStep(s, s', step)\n}\nghost predicate GameOver(s: State) {\n  s.num == 0\n}\nghost predicate Player1Win(s: State) {\n  && GameOver(s)\n  && !s.player1\n}\nghost predicate CurrentPlayerWins(s: State) {\n  s.num % 11 != 0\n}\nghost predicate CurrentPlayerLoses(s: State) {\n  !CurrentPlayerWins(s)\n}\nlemma WinnerAtEnd(s: State)\n  requires GameOver(s)\n  ensures CurrentPlayerLoses(s) && !CurrentPlayerWins(s)\n  ensures Player1Win(s) <==> !s.player1\n{}\nlemma CurrentPlayerWins_Next(s: State) returns (move: Step)\n  requires CurrentPlayerWins(s)\n  ensures ValidMove(move, s);\n  ensures forall s' :: NextStep(s, s', move) ==> CurrentPlayerLoses(s')\n{\n  move := Step(s.num % 11);\n}\nlemma CurrentPlayerLoses_Next(s: State, s': State)\n  requires CurrentPlayerLoses(s)\n  requires Next(s, s')\n  ensures CurrentPlayerWins(s')\n{}\nlemma HundredStart()\n  ensures CurrentPlayerWins(State(100, true))\n{}"
},
{
    "dafny": "class Key \n{\n    var value: nat;\n    constructor(v:nat)\n    ensures value == v\n    {\n        value := v;\n    }\n}\nclass Card {\n    var guests: seq<Guest>;\n    var fst: Key;\n    var snd: Key;\n    constructor(key1: nat, key2: nat)\n    ensures fst.value == key1 && snd.value == key2\n    ensures fresh(fst) && fresh(snd)\n    {\n        fst := new Key(key1);\n        snd := new Key(key2);\n        guests := [];\n    }\n }\nclass Guest \n{\n    var cards: seq<Card>;\n    constructor(c: seq<Card>)\n    requires |c| > 0\n    {\n        cards := c;\n    }\n}\nclass Desk \n{\n    var issued: seq<Key>;\n    var prv: Room;\n    constructor(p: Room)\n    {\n        issued := [];\n        prv := p;\n    }\n}\nclass Room\n{\n    var key: Key\n    constructor(key: Key)\n    {\n        this.key := key;\n    }\n    method Checkin(g: Guest)\n    {\n    }\n    method Enter(g: Guest, d: Desk) \n    requires |g.cards| > 0\n    requires exists i :: 0 <= i < |g.cards| && (g.cards[i].fst == key || g.cards[i].snd == key)\n    ensures exists i :: 0 <= i < |g.cards| && g.cards[i].snd == key\n    ensures d.issued == old(d.issued)\n    ensures g.cards == old(g.cards)\n    modifies this\n    {\n        var i := 0;\n        var count := |g.cards|;\n        while(i < count)\n        {\n            if (g.cards[i].fst == key)             \n            {\n                key := g.cards[i].snd;\n                break;\n            }\n            i := i + 1;\n        }\n        assume exists i :: 0 <= i < |g.cards| && g.cards[i].snd == key;\n    }\n}\nclass Payment\n{\n    var value: nat\n}\nclass RoomService\n{\n    var servicePayment: Payment?\n    method Pay(c: Card, g: Guest, p: Payment) \n    requires servicePayment == null\n    requires exists i :: 0 <= i < |g.cards| && (g.cards[i] == c)\n    ensures servicePayment != null\n    modifies this\n    {\n        servicePayment := p;\n    }\n}"
},
{
    "dafny": "function add (x: nat, y: nat): nat\n{\n  if (y == 0) then x\n  else add (x, y-1) + 1\n}\nlemma zero_add_lemma (x: nat)\n  ensures add (0, x) == x\n{\n  assume (false);\n}\nlemma add_zero_lemma (x: nat)\n  ensures add (x, 0) == x\n{\n  assume (false);\n}\nlemma add_plus_one (x: nat, y: nat)\n  ensures add(x, y) + 1 == add(x, y+1);\n{\n  assume(false);\n}\nlemma one_plus_add (x: nat, y: nat)\n  ensures add(x, y) + 1 == add (x+1, y)\n{\n  assume(false);\n}\nlemma add_comm_lemma (x: nat, y: nat)\n  ensures add (x, y) == add (y, x);\n{\n  assume (false);\n}"
},
{
    "dafny": "method BubbleSort(arr: array<int>)\n  modifies arr\n  requires arr != null\n  requires arr.Length >= 1\n  ensures forall m, n :: 0  <= m <= n <= arr.Length-1 < arr.Length ==> arr[m] <= arr[n]\n  {\n    var last := arr.Length - 1;\n    while(last > 0)\n      invariant  0 <= last <= arr.Length-1\n      invariant forall m, n :: 0 <= last <= m <= n <= arr.Length-1 < arr.Length ==> arr[m] <= arr[n]\n      invariant forall c, c' :: 0 <= c <= last < c' < arr.Length ==> arr[c] <= arr[c']\n      {\n        var index := 0;\n        while (index < last)\n          invariant 0 < last < arr.Length && 0 <= index <= last\n          invariant forall m, n :: 0 <= last <= m <= n <= arr.Length-1 < arr.Length ==> arr[m] <= arr[n]\n          invariant forall c, c' :: 0 <= c <= last < c' < arr.Length ==> arr[c] <= arr[c']\n          invariant forall c :: 0 <= c <= index ==> arr[c] <= arr[index]\n          {\n            if(arr[index] > arr[index+1])\n              {\n                var tmp := arr[index];\n                arr[index] := arr[index+1];\n                arr[index+1] := tmp;\n              }\n              index := index + 1;\n          }\n          last := last -1;\n      }\n }"
},
{
    "dafny": "method Mult(x:nat, y:nat) returns (r: nat)\nensures r == x * y\n{\n    var m := x;\n    var n := y;\n    r:=0;\n    while m > 0\n    invariant m >= 0\n    invariant m*n+r == x*y\n    {\n        r := r + n;\n        m := m - 1;\n    }\n    return r;\n}"
},
{
    "dafny": "predicate isClean(a: array<int>, key: int)\nreads a\n{\n    if a == null then true else forall i :: 0<=i<a.Length ==> a[i] != key\n}\nmethod IsClean(a: array<int>, key: int) returns (clean: bool)\n    ensures clean == isClean(a, key)\n{\n    clean := true;\n    if a == null {return;}\n    var i := 0;\n    while i < a.Length\n    invariant 0<=i <=a.Length\n    invariant clean == forall j :: 0<= j < i ==> a[j] != key\n    decreases a.Length-i\n    {\n        if a[i] == key \n        {\n            clean := false;\n            break;\n        }\n        i := i+1;\n    }\n}\nmethod Main(){\n    var a := new int[5];\n    a[0],a[1],a[2],a[3],a[4]:=1,2,2,2,3;\n    var cl := IsClean(a, 1);\n    assert a[0]==1;\n    assert a[1] == 2;\n    assert a[2]==2;\n    assert a[3]==2;\n    assert a[4]==3;\n    assert !cl;\n    cl := IsClean(a, 2);\n    assert !cl;\n    cl := IsClean(a, 3);\n    assert !cl;\n    cl := IsClean(a, 4);\n    assert cl;\n    var b := new int[1];\n    b[0]:=1;\n    cl:=IsClean(b, 1);\n    assert b[0]==1;\n    assert !cl;\n    cl:=IsClean(b, 2);\n    assert cl;\n    var c := new int[0];\n    cl:=IsClean(c, 1);\n    assert cl;\n}"
},
{
    "dafny": "method m ()\n{\n    var i := 20;\n    while 0 < i\n        invariant 0 <= i\n        decreases i\n    {\n        i := i - 1;\n    }\n}\nmethod m2()\n{\n    var i, n := 0, 20;\n    while i < n\n        invariant 0 <= i <= n\n        decreases n - i\n    {\n        i := i + 1;\n    }\n}\nmethod m3()\n{\n    var i, n := 0, 20;\n    while i != n\n        invariant (n - i) >= 0      \n        decreases n - i\n    {\n        i := i + 1;\n    }\n}\nfunction fib(n: nat): nat\n    decreases n\n{\n    if n == 0 then 0\n    else if n == 1 then 1\n    else fib(n - 1) + fib(n - 2)\n}"
},
{
    "dafny": "method addArrays(a : array<int>, b : array<int>) returns (c : array<int>) \nrequires a.Length == b.Length\nensures b.Length == c.Length\nensures forall i:int :: 0 <= i <c.Length ==> c[i] == a[i] + b[i]\n{\n     c := new int[a.Length];\n     var j := 0;\n     while (j < a.Length) \n       invariant 0 <= j <= c.Length\n       invariant forall i :: (0 <= i < j) ==> c[i] == a[i] + b[i];\n     {    \n          c[j] := a[j] + b[j];\n          j := j + 1;      \n    }\n}"
},
{
    "dafny": "function fact(n: nat): nat\n{\n\tif n <= 1 then 1\n\t\telse n * fact(n - 1) \n}\nmethod computeFactorial(n: int) returns (f: int)\n\trequires n >= 1\n  ensures f == fact(n)\n{\n  var i := 0;\n\tf := n;  \n  while i < n - 1\n\t\tinvariant 0 <= i < n\n\t\tinvariant f * fact(n - i - 1) == fact(n)\n\t{\n\t\ti := i + 1;\n\t\tf := f * (n - i);\n\t}\n}"
},
{
    "dafny": "module P {\n  predicate m() reads {}\n  predicate p() reads []\n  predicate q() reads multiset{}\n  predicate k(o: object) reads (() => {o})\n  predicate l(o: object) reads ((x: int) => [o])\n  predicate n(o: object) reads ((y: real, z: real) => multiset{o})\n  predicate k'() reads (() => {})\n  predicate l'() reads ((x: int) => [])\n  predicate n'() reads ((y: real, z: real) => multiset{})\n} \nmodule Q refines P {\n  predicate m() { true }\n  predicate p() { true }\n  predicate q() { true }\n  predicate k(o: object) { true }\n  predicate l(o: object) { true }\n  predicate n(o: object) { true }\n  predicate k'() { true }\n  predicate l'() { true }\n  predicate n'() { true }\n}\nmodule EmptySet {\n    predicate m()\n      reads {}\n    {\n      m'({}, 0)\n    }\n    predicate m'(s: set<object?>, j: nat)\n      reads {}\n      decreases s, j \n    {\n      if s == {} then true else m()\n    }\n}"
},
{
    "dafny": "method CheckArr0(A: array<int>) returns (unique: bool) \nrequires A.Length > 0\nensures unique <==> forall i :: 0 < i < A.Length ==> A[i] != A[0]\n{\n    unique := true;\n    if A.Length > 1 {\n      var i:= 1;\n      while i < A.Length && unique\n      decreases A.Length - i\n      invariant i <= A.Length\n      invariant unique <==> (forall j :: (0 < j < i) ==> A[j] != A[0]) \n      {\n        if (A[i] == A[0]) {\n            unique := false;\n        }\n        i := i+1;\n      }\n    }\n    return unique;\n}\nmethod CheckArr1(A: array<int>) returns (unique: bool)\nensures unique <==> forall i, j :: 0 <= i < A.Length && 0 <= j < A.Length && i != j ==> A[i] != A[j] {\n    unique := true;\n    if (A.Length > 1){\n        var i := 0;\n        while i < A.Length && unique\n        decreases A.Length - i\n        invariant 0 <= i <= A.Length\n        invariant unique <==> forall x, y :: 0 <= x < i && x < y < A.Length ==> A[x] != A[y]\n        {\n            var j := i+1;\n            while j < A.Length && unique\n            decreases  A.Length - j\n            invariant i < j <= A.Length\n            invariant unique <==> forall x :: i < x < j ==> A[x] != A[i] \n            {\n                if (A[i] == A[j]) {\n                    unique := false;                    \n                }\n                j := j+1;\n            }\n            i := i+1;\n        }\n    }\n    return unique;\n}\nmethod CheckM0(M: array2<int>) returns (unique: bool) \nrequires 0 < M.Length1 && 0 < M.Length0\nensures unique <==> forall i,j :: 0 <= i < M.Length0 && 0 <= j < M.Length0 && i != j ==> M[i,0] != M[j,0]\n{\n  unique := true;\n    if (M.Length0 > 1){\n        var i := 0;\n        while i < M.Length0 && unique\n        decreases M.Length0 - i\n        invariant 0 <= i <= M.Length0\n        invariant unique <==> forall x, y :: 0 <= x < i && x < y < M.Length0 ==> M[x, 0] != M[y, 0]\n        {\n            var j := i+1;\n            while j < M.Length0 && unique\n            decreases  M.Length0 - j\n            invariant i < j <= M.Length0\n            invariant unique <==> forall x :: i < x < j ==> M[x,0] != M[i, 0] \n            {\n                if (M[i,0] == M[j,0]) {\n                    unique := false;                    \n                }\n                j := j+1;\n            }\n            i := i+1;\n        }\n    }\n  return unique;\n}\nmethod CheckCols(M: array2<int>) returns (unique: bool)\nensures unique <==> forall i,j,k :: 0 <= i < M.Length0 && 0 <= j < M.Length0 && 0 <= k < M.Length1 &&  j != i  ==> M[i,k] != M[j,k]\n{\n  unique := true;\n    var k := 0;\n    while k < M.Length1 && unique \n    decreases  M.Length1 - k\n    invariant 0 <= k <= M.Length1\n    invariant unique <==> forall x, y, z :: 0 <= x <= M.Length0 && x < y < M.Length0 && 0 <= z < k ==> M[x, z] != M[y, z]\n    {\n      if (M.Length0 > 1){\n          var i := 0;\n          while i < M.Length0 && unique\n          decreases M.Length0 - i\n          invariant 0 <= i <= M.Length0\n          invariant unique <==> forall x, y :: 0 <= x < i && x < y < M.Length0 ==> M[x, k] != M[y, k]\n          {\n              var j := i+1;\n              while j < M.Length0 && unique\n              decreases  M.Length0 - j\n              invariant i < j <= M.Length0\n              invariant unique <==> forall x :: i < x < j ==> M[x,k] != M[i, k] \n              {\n                  if (M[i,k] == M[j,k]) {\n                      unique := false;                    \n                  }\n                  assert unique ==> M[i,k] != M[j,k];\n                  assert !unique ==> M[i,k] == M[j, k];\n                  j := j+1;\n              }\n              i := i+1;\n          }\n      }\n      k := k+1;\n  }\n  return unique;\n}\nmethod CheckRows(M: array2<int>) returns (unique: bool)\nensures unique <==> forall i,j,k :: 0 <= i < M.Length1 && 0 <= j < M.Length1 && 0 <= k < M.Length0 &&  j != i  ==> M[k,i] != M[k,j]\n{\n  unique := true;\n    var k := 0;\n    while k < M.Length0 && unique \n    decreases  M.Length0 - k\n    invariant 0 <= k <= M.Length0\n    invariant unique <==> forall x, y, z :: 0 <= x <= M.Length1 && x < y < M.Length1 && 0 <= z < k ==> M[z, x] != M[z, y]\n    {\n      if (M.Length1 > 1){\n          var i := 0;\n          while i < M.Length1 && unique\n          decreases M.Length1 - i\n          invariant 0 <= i <= M.Length1\n          invariant unique <==> forall x, y :: 0 <= x < i && x < y < M.Length1 ==> M[k, x] != M[k, y]\n          {\n              var j := i+1;\n              while j < M.Length1 && unique\n              decreases  M.Length1 - j\n              invariant i < j <= M.Length1\n              invariant unique <==> forall x :: i < x < j ==> M[k, x] != M[k, i] \n              {\n                  if (M[k, i] == M[k, j]) {\n                      unique := false;                    \n                  }\n                  j := j+1;\n              }\n              i := i+1;\n          }\n      }\n      k := k+1;\n  }\n  return unique;\n}\nmethod CheckMatrix(M: array2<int>) returns (unique: bool)\nensures unique ==> (forall i,j,k :: 0 <= i < M.Length1 && 0 <= j < M.Length1 && 0 <= k < M.Length0 &&  j != i  ==> M[k,i] != M[k,j]) && (forall i,j,k :: 0 <= i < M.Length0 && 0 <= j < M.Length0 && 0 <= k < M.Length1 &&  j != i  ==> M[i,k] != M[j,k]) {\n  var rowsUnique:bool;\n  rowsUnique := CheckRows(M);\n  var colsUnique:bool;\n  colsUnique := CheckCols(M);\n  return colsUnique && rowsUnique;\n}"
},
{
    "dafny": "type pair = s:seq<int> | |s| == 2 witness [0,0]\nghost function id<T>(x: T): T { x }\nghost function fst(p: pair): int\n{\n  id(p)[0] \n}\nghost function pair_id(p: pair): seq<int>\n{\n  id(p)[0..2] \n}\nghost function pair_to_seq(p: pair): seq<int> { p }\nmethod stuff_that_works(p: pair)\n{\n  var _: int := p[0];\n  var _: seq<int> := p[0..1];\n  var _: seq<int> := id(p);\n  var _: int := pair_to_seq(p)[1];\n  var _: seq<int> := pair_to_seq(p)[0..1];\n}\ntype subString = x: seq<char> | 0 <= |x| < 0x8000_0000\nfunction foo(s: subString): subString { \"0\" }\nmethod goo(s: subString) returns (eq: bool)\n{\n  if s != [] {\n    ghost var s' := foo(s[0..]);\n    assert s'[1..] == []; \n  }\n  return true;\n}"
},
{
    "dafny": "method maxarr(a: array?<int>) returns (max:int)\n  requires a != null \n  ensures forall i :: 0 <= i < a.Length ==> max >= a[i] \n{ \n  max := 0; \n  if (a.Length == 0) { return ;}\n  var i := 0;\n  while (i < a.Length)\n    decreases a.Length - i \n    invariant 0 <= i <= a.Length \n    invariant forall j :: 0 <= j < i ==> max >= a[j] \n  {\n    if (a[i] > max) \n      { max := a[i]; } \n    i := i + 1;\n  }\n}"
},
{
    "dafny": "function add (x: nat, y: nat): nat\n{\n  if (y == 0) then x\n  else add (x, y-1) + 1\n}\nlemma add_zero_lemma (x: nat)\n  ensures add (x, 0) == x;\n{\n  assume(false);\n}\nlemma zero_add_lemma (x: nat)\n  ensures add (0, x) == x;\n{\n  assume(false);\n}\nlemma add_plus_one (x: nat, y: nat)\n  ensures add(x, y) + 1 == add(x, y+1);\n{\n  assume(false);\n}\nlemma one_plus_add (x: nat, y: nat)\n  ensures add(x, y) + 1 == add (x+1, y)\n{\n  assume(false);\n}\nlemma add_comm_lemma (x: nat, y: nat)\n  ensures add(x, y) == add(y, x);\n{\n  assume(false);\n}"
},
{
    "dafny": "datatype Tree = Empty | Node(int,Tree,Tree)\nmethod Main() {\n\tvar tree := Node(5, Node(2, Empty, Empty), Node(8, Node(7, Empty, Empty), Node(8, Empty, Empty)));\n\tassert NumbersInTree(tree) == multiset([2,5,7,8,8]);\n\tassert NumbersInTree(tree)[2] == 1; \n\tassert NumbersInTree(tree)[5] == 1; \n\tassert NumbersInTree(tree)[7] == 1; \n\tassert NumbersInTree(tree)[8] == 2; \n\tassert NumbersInTree(tree)[9] == 0; \n\tassert BST(tree);\n\tvar count8 := CountOccurrences(tree, 8);\n\tprint \"The number of occurrences of 8 in the tree \";\n\tprint tree;\n\tprint \" is \";\n\tprint count8;\n\tassert count8 == 2;\n}\nfunction NumbersInTree(t: Tree): multiset<int>\ndecreases t\n{\n\tmatch t {\n\t\tcase Empty => multiset([])\n\t\tcase Node(n,l,r) => multiset([n])+NumbersInTree(l)+NumbersInTree(r)\n\t}\n}\npredicate BST(t: Tree)\ndecreases t\n{\n\tmatch t {\n\t\tcase Empty => true\n\t\tcase Node(n,l,r) =>\n\t\t\tBST(l) && BST(r) &&\n\t\t\t(forall x :: x in NumbersInTree(l) ==> x < n) &&\n\t\t\t(forall x :: x in NumbersInTree(r) ==> x >= n)\n\t}\n}\nmethod CountOccurrences(t: Tree, key: int) returns (count: nat)\n\trequires BST(t)\n\tensures count == NumbersInTree(t)[key]\n  {\n    count := CountOccurrences'(t,key);\n  }\n  method CountOccurrences'(t: Tree, key: int) returns (count: nat)\n\trequires BST(t)\n\tensures count == NumbersInTree(t)[key]\n  decreases t, 3\n  {\n      match t {\n        case Empty =>\n          count := CountOccurrencesTree1a(t, key);\n        case Node(n1, nt1, nt2) =>\n          assert t == t && 2 < 3;\n          assert nt1 < t;\n\t        assert nt2 < t;\n          count := CountOccurrencesTree1b(t, n1, nt1, nt2, key);\n          assert count == NumbersInTree(t)[key];\n      }\n  }\nmethod CountOccurrencesTree1a(t: Tree, key:int) returns (count: nat)\n\trequires BST(t)\n\trequires t == Empty\n\tensures count == NumbersInTree(t)[key]\n{\n\tLemma1a(t, key);\n\tcount := 0;\n}\nlemma Lemma1a(t: Tree, key:int)\n\trequires t == Empty\n\tensures 0 == NumbersInTree(t)[key]\n{}\nmethod CountOccurrencesTree1b(t: Tree, n1: int, nt1: Tree, nt2: Tree, key:int) returns (count: nat)\n\trequires BST(t)\n\trequires t == Node(n1, nt1, nt2)\n\tensures count == NumbersInTree(t)[key]\n\tdecreases t, 2\n{\n\tassert t == t && 1 < 2;\n\tcount := CountOccurrencesTree2(t, n1, nt1, nt2, key);\n}\nmethod CountOccurrencesTree2(t: Tree, n1: int, nt1: Tree, nt2: Tree, key:int) returns (count: nat)\n\trequires BST(t)\n\trequires t == Node(n1, nt1, nt2)\n\tensures count == NumbersInTree(t)[key]\n  decreases t, 1\n{\n\tvar tmp1, tmp2;\n  assert t == t && 0 < 1;\n  assert nt1 < t;\n\tassert nt2 < t;\n  tmp1,tmp2:=0,0;\n  if key < n1{\n    tmp1 := CountOccurrencesTree3a(t, n1, nt1, nt2, key);\n  }\n  if n1 == key {tmp1:=tmp1+1;}\n  if key >= n1{\n    tmp2 := CountOccurrencesTree3b(t, n1, nt1, nt2, tmp1, key);\n  }\n\tcount := tmp1+tmp2;\n}\nmethod CountOccurrencesTree3a(nt: Tree, n1: int, nt1: Tree, nt2: Tree, key:int) returns (tmp1: nat)\n\trequires BST(nt)\n\trequires nt == Node(n1, nt1, nt2)\n\tensures tmp1 == NumbersInTree(nt1)[key] && nt == Node(n1, nt1, nt2)\n\tdecreases nt1\n{\n\tassert nt1 < nt; \n\ttmp1 := CountOccurrences'(nt1, key);\n\tLemma3a(nt, n1, nt1, nt2, tmp1, key);\n}\nlemma Lemma3a(t: Tree, n1: int, nt1: Tree, nt2: Tree, tmp1: nat, key:int)\n\trequires tmp1 == NumbersInTree(nt1)[key]\n\trequires t == Node(n1, nt1, nt2) \n\tensures tmp1 == NumbersInTree(nt1)[key] && t == Node(n1, nt1, nt2)\n{}\nmethod CountOccurrencesTree3b(nt: Tree, n1: int, nt1: Tree, nt2: Tree, tmp1: nat, key:int) returns (tmp2: nat)\n\trequires BST(nt)\n\trequires tmp1 == NumbersInTree(nt1)[key] + (if n1 == key then 1 else 0) && nt == Node(n1, nt1, nt2)\n\tensures tmp1+tmp2 == NumbersInTree(nt)[key]\n\tdecreases nt2\n{\n\tassert nt2 < nt; \n\ttmp2 := CountOccurrences'(nt2, key);\n\tLemma3b(nt, n1, nt1, nt2, tmp1, tmp2, key);\n}\nlemma Lemma3b(nt: Tree, n1: int, nt1: Tree, nt2: Tree, tmp1: nat, tmp2: nat, key:int)\n\trequires tmp2 == NumbersInTree(nt2)[key]\n\trequires tmp1 == NumbersInTree(nt1)[key] + (if n1 == key then 1 else 0)  && nt == Node(n1, nt1, nt2)\n\tensures tmp1+tmp2 == NumbersInTree(nt)[key]\n{}\nmethod RecEffective(tree: Tree, key: int) returns (count: nat)\n\trequires BST(tree)\n\tdecreases tree\n\tensures count == NumbersInTree(tree)[key]\n  {\n  var leftAcc := 0;\n  var rightAcc := 0;\n\tmatch tree {\n\tcase Empty =>\n\t\tassert tree == Empty;\n\t\tassert 0 == NumbersInTree(tree)[key];\n\t\tcount := 0;\n\t\tassert count == NumbersInTree(tree)[key];\n\tcase Node(val,left,right) =>\n\t\tassert tree == Node(val,left,right);\n\t\tassert left < tree;\n\t\tassert right < tree;\n    if key < val{\n      leftAcc := RecEffective(left, key);\n    }else{\n\t\t\trightAcc:= RecEffective(right, key);\n    }\n\t\tassert (if val == key then 1 else 0) +  leftAcc + rightAcc == NumbersInTree(tree)[key];\n    count := (if val == key then 1 else 0) +  leftAcc + rightAcc;\n\t\tassert count == NumbersInTree(tree)[key];\n\t}\n\tassert count == NumbersInTree(tree)[key];\n}"
},
{
    "dafny": "predicate Sorted(a: array<int>, low:int, high:int)\n\trequires a != null\n\trequires 0<=low<=high<=a.Length\n\treads a\n{\n\tforall j,k:: low<=j<k<high ==> a[j]>=a[k]\n}\nmethod sortByScore(bList: array<int>)\n\trequires bList != null\n\trequires bList.Length > 1\n\tensures Sorted(bList, 0, bList.Length);\n\tensures multiset(bList[..]) == multiset(old(bList[..]));\n\tmodifies bList;\n{\n\tvar i:=1;\n\twhile (i < bList.Length)\n\t\tinvariant 1 <= i <= bList.Length;\n\t\tinvariant Sorted(bList, 0, i);\n\t\tinvariant multiset(bList[..]) == multiset(old(bList[..]));\n\t{\n\t\tvar j := i;\n\t\twhile (j >= 1 && bList[j-1] < bList[j])\n\t\t\tinvariant 0 <= j <= i;\n\t\t\tinvariant forall x,y:: (0<=x<y<=i && y!=j) ==> bList[x]>=bList[y];\n\t\t\tinvariant multiset(bList[..]) == multiset(old(bList[..]));\n\t\t{\n\t\t\tbList[j-1], bList[j] := bList[j], bList[j-1];\n\t\t\tj:=j-1;\n\t\t}\n\t\ti:=i+1;\n\t}\n}"
},
{
    "dafny": "method FindMax(a: array<int>) returns (idx: int)\n  requires a != null && a.Length > 0;\n  ensures 0 <= idx < a.Length;\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[idx];\n{\n  var i := 0;\n  idx := 0;\n  while (i < a.Length)\n    invariant 0 <= i <= a.Length;\n    invariant 0 <= idx <= i;\n    invariant 0 <= idx < a.Length;\n    invariant forall k :: 0 <= k < i ==> a[k] <= a[idx];\n  {\n    if (a[i] > a[idx])\n    {\n      idx := i;\n    }\n    i := i + 1;\n  }\n  return idx;\n}"
},
{
    "dafny": "datatype Option<T> = Some(v: T) | None\npredicate sorted(s: seq<int>) {\n  forall i, j | 0 <= i < j < |s| :: s[i] < s[j]\n}\nfunction BinarySearch(s: seq<int>, x: int): Option<nat> {\n  if |s| == 0 then None\n  else (var mid := |s|/2;\n        None \n       )\n}\npredicate SearchSpec(s: seq<int>, x: int, res: Option<nat>) {\n  res.Some? ==>\n    && res.v < |s|\n    && s[res.v] == x\n}\nlemma BinarySearch_ok(s: seq<int>, x: int)\n  requires sorted(s)\n  ensures SearchSpec(s, x, BinarySearch(s, x))\n{\n}"
},
{
    "dafny": "function F(n: nat): nat \n    decreases n\n{ \n    if n <= 2 then n else F(n-1) + F(n-3)\n}\nmethod calcF(n: nat) returns (res: nat)  \n    ensures res == F(n) \n{\n    var a, b, c := 0, 1, 2;\n    var i := 0;\n  assert 0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2);\n    while i < n \n        decreases n - i\n        invariant 0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2)\n    {\n      ghost var V0 := n - i;\n      assert 0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2) && i < n && n - i == V0;\n        a, b, c := b, c, a + c;        \n        i := i + 1;\n      assert 0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2) && 0 <= n - i < V0;\n    }\n  assert 0 <= i <= n && a == F(i) && b == F(i+1) && c == F(i+2) && i >= n;\n    res := a;\n}"
},
{
    "dafny": "datatype tree = nil | node(int, tree, tree)\nfunction max(x: int, y: int): int\n{\n\tif x < y then y else x\n}\nfunction F1(s: (int, int), t: tree): (int, int)\n\tdecreases t\n{\n\tmatch t \n\tcase nil => s\n\tcase node(x, l, r) => \n\t\tvar (sum1, m1) := F1(s, l);\n\t\tF1((sum1 + x, max(sum1 + x, m1)), r)\n}\nfunction F(t: tree): (int, int)\n{\n\tF1((0,0), t)\n}\nfunction G(t: tree): (int, int)\n{\n\tmatch t\n\tcase nil => whenNull()\n\tcase node(x, l, r) => \n\t\tvar r1, r2 := G(l), G(r);\n\t\tcombine(x, r1, r2)\n}\nfunction whenNull(): (int, int)\n{\n\t(0, 0)\n}\nfunction combine(lbl: int, r1: (int, int), r2: (int, int)): (int, int)\n{\n\tvar (sum1, m1) := r1;\n\tvar (sum2, m2) := r2; \n\tvar msum := sum1 + lbl + sum2;\n\tvar m := max(max(m1, sum1 + lbl), sum1 + lbl + m2);\n\t(msum, m)\n}\nlemma SumBehaviour(s: (int, int), t: tree)\n\tensures F1(s, t).0 == s.0 + F1((0,0), t).0 \n\tdecreases t\n{}\nlemma MaxBehaviour(s: (int, int), t: tree)\n\trequires s.1 >= s.0\n\tensures F1(s, t).1 == max(s.1, s.0 + F1((0,0), t).1)\n\tdecreases t\n{\n\tmatch t \n\tcase nil => {} \n\tcase node(x, l, r) => {\n\t\tSumBehaviour(s, l);\n\t}\n}\nfunction conc(x: int, l: tree, r: tree): tree\n{\n\tnode(x, l, r)\n}\nlemma FHom(x: int, l: tree, r: tree)\n\tensures F(conc(x,l,r)) == combine(x, F(l),  F(r))\n{\n\tvar (sum1, m1) := F(l);\n\tvar s := (sum1 + x, max(sum1 + x, m1));\n\tSumBehaviour(s, r);\n\tMaxBehaviour(s, r);\n}\nlemma EquivalentSchemes(t: tree)\n\tensures F(t) == G(t)\n{\n\tmatch t \n\tcase nil => {}\n\tcase node(x, l, r) => {\n\t\tFHom(x, l, r);\n\t}\n}"
},
{
    "dafny": "method SumMax(x:int, y:int) returns (s:int, m:int)\n    requires x >= 0 && y >= 0\n    ensures s == x + y\n    ensures m >= x && m >= y\n    ensures m == x || m ==y\n{\n    s := x + y;\n    if ( x > y ) {\n        m := x;\n    }\n    else {\n        m := y;\n    }\n}"
},
{
    "dafny": "method insertionSort(a: array<int>) \n    modifies a \n    ensures isSorted(a, 0, a.Length)\n    ensures multiset(a[..]) ==  multiset(old(a[..]))\n{\n    var i := 0;\n    while i < a.Length \n        invariant 0 <= i <= a.Length\n        invariant isSorted(a, 0, i)\n        invariant multiset(a[..]) ==  multiset(old(a[..]))\n    {\n        var j := i;\n        while j > 0 && a[j-1] > a[j] \n            invariant 0 <= j <= i\n            invariant multiset(a[..]) ==  multiset(old(a[..]))\n            invariant forall l, r :: 0 <= l < r <= i &&  r!= j ==> a[l] <= a[r]\n        {\n            a[j-1], a[j] := a[j], a[j-1];\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n}\nmethod testInsertionSort() {\n  var a := new int[] [ 9, 4, 3, 6, 8];\n  assert a[..] == [9, 4, 3, 6, 8];\n  insertionSort(a);\n  assert a[..] == [3, 4, 6, 8, 9];\n}\npredicate isSorted(a: array<int>, from: nat, to:nat)\n    requires 0 <= from <= to <= a.Length\n    reads a\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j]\n}\npredicate isSortedExcluding(a: array<int>, from: nat, to:nat, k:nat)\n    requires 0 <= from <= to <= a.Length\n    reads a\n{\n    forall i, j :: from <= i < j < to && i !=k && j != k ==> a[i] <= a[j]\n}"
},
{
    "dafny": "class Token {\n    var fingerprint : int;\n    var clearance : int;\n    var valid : bool;\n    method Init(init_fingerprint : int, init_clearance : int)\n        modifies this;\n        requires init_fingerprint != 0;\n        requires 1 <= init_clearance <=3;\n        ensures fingerprint == init_fingerprint;\n        ensures clearance == init_clearance;\n        ensures valid == true;\n    {\n        fingerprint := init_fingerprint;\n        clearance := init_clearance;\n        valid := true;\n    }\n    method invalidate()\n        modifies this`valid;\n        ensures !valid;\n    {\n        valid := false;\n    }\n}"
},
{
    "dafny": "function F(x: nat, ghost y: nat): nat\n{\n  if x == 0 then\n    0\n  else if y != 0 then\n    F(x, y - 1) \n  else\n    F(x - 1, 60) + 13\n}\nlemma AboutF(x: nat, y: nat)\n  ensures F(x, y) == 13 * x\n{\n}\nfunction G(x: nat, ghost y: nat): nat\n{\n  if x == 0 then\n    0\n  else if y != 0 then\n    var z := x + x;\n    var a, b, c := 100, if x < z then G(x, y - 1) else G(x, y - 1), 200;\n    assert a + b + c == G(x, y - 1) + 300;\n    b \n  else\n    G(x - 1, 60) + 13\n}\nfunction H(x: int, ghost y: nat): int {\n  if y == 0 then\n    x\n  else\n    H(x, y - 1)\n}\nfunction J(x: int): int {\n  if true then\n    x\n  else\n    J(x)\n}\nfunction {:verify false} K(x: int, ghost y: nat): int {\n  K(x, y - 1)\n}\nmethod Main() {\n  print F(5, 3), \"\\n\"; \n  print G(5, 3), \"\\n\"; \n  print H(65, 3), \"\\n\"; \n  print J(65), \"\\n\"; \n}"
},
{
    "dafny": "method M(x: int) returns (seven: int)\n  ensures seven==7\n{\n  seven := 7;\n}\nmethod TestMethod(){\n  var test1 := M(5);\n  print(\"Test 1: M(5) = \", test1, \"\\n\");\n  var test2 := M(10);\n  print(\"Test 2: M(10) = \", test2, \"\\n\");\n  var test3 := M(0);\n  print(\"Test 3: M(0) = \", test3, \"\\n\");\n  var test4 := M(-5);\n  print(\"Test 4: M(-5) = \", test4, \"\\n\");\n  var test5 := M(100);\n  print(\"Test 5: M(100) = \", test5, \"\\n\");\n}\nmethod Main(){\n  TestMethod();\n}"
},
{
    "dafny": "method mulitplicationRusse(x:nat,y:nat) returns (m:nat)\nensures m==x*y{\n    var a := x;\n    var b := y;\n    var r := 0;\n    while(a>0)\n        invariant a>=0\n        invariant r+a*b == x*y\n        decreases a\n    {\n        if(a%2 == 0){\n            b:=2*b;\n            a:=a/2;\n        }else{\n            r:=r+b;\n            a:=a-1;\n        }\n    }\n    m:=r;\n}"
},
{
    "dafny": "function More(x: int): int {\n  if x <= 0 then 1 else More(x - 2) + 3\n}\nlemma {:induction false} Increasing(x: int)\n  ensures x < More(x)\n{\n  assert true;\n  if x <= 0 {\n    assert x <= 0;\n    assert x <= 0 && More(x) == 1; \n    assert x < More(x);\n  } else {\n    assert 0 < x;\n    assert 0 < x && More(x) == More(x - 2) + 3; \n    Increasing(x - 2); \n    assert 0 < x && More(x) == More(x - 2) + 3 &&\n           x - 2 < More(x - 2);\n    assert More(x) == More(x - 2) + 3 &&\n           x + 1 < More(x - 2) + 3;\n    assert x + 1 < More(x);\n    assert x < More(x);\n  }\n  assert x < More(x);\n}"
},
{
    "dafny": "class dishwasher{\n    var isLoaded : bool;\n    var isAddedDtgt : bool;\n    var isWashed: bool;\n    predicate Valid()\n    reads this;\n    {\n        (!isLoaded&&isWashed)||(!isAddedDtgt && isWashed) ==>false\n    }\n    constructor()\n    modifies this;\n    ensures Valid();\n    ensures this.isLoaded == false && this.isAddedDtgt == false && isWashed==false;\n    {\n        this.isLoaded:=false;\n        this.isAddedDtgt := false;\n        this.isWashed:=false;\n    }\n    method Load()\n    modifies this;\n    ensures Valid();\n    ensures this.isWashed == false;\n    ensures this.isLoaded == true;\n    ensures this.isAddedDtgt == old(this.isAddedDtgt);\n    {\n        this.isLoaded := true;\n        this.isWashed := false;\n    }\n    method AddDtgt()\n    modifies this;\n    ensures Valid();\n    ensures this.isWashed == false;\n    ensures this.isAddedDtgt == true;\n    ensures this.isLoaded == old(this.isLoaded)\n    {\n        this.isAddedDtgt := true;\n        this.isWashed := false;\n    }\n    method Wash()\n    modifies this;\n    requires Valid();\n    requires this.isAddedDtgt == true;\n    requires this.isLoaded == true;\n    ensures this.isWashed == true;\n    ensures this.isAddedDtgt == false;\n    ensures this.isLoaded == false;\n    {\n        this.isWashed := true;\n        this.isAddedDtgt := false;\n        this.isLoaded := false;\n    }\n    method Unload()\n    modifies this;\n    requires this.isWashed == true;\n    ensures Valid();\n    ensures this.isLoaded == false;\n    ensures this.isWashed == false;\n    {\n        this.isLoaded := false;\n        this.isWashed := false;\n    }\n}\nmethod Test1()\n{\n    var dw := new dishwasher();\n    dw.Load();\n    dw.AddDtgt();\n    dw.Wash();\n    dw.Unload();\n}"
},
{
    "dafny": "method RYTX<T(0)>(FHTJ: array<T>) returns (IRZY: array<T>)\n{\n  IRZY := new T[FHTJ.Length];\n  var WQDK:= 0;\n  while (WQDK < FHTJ.Length)\n    invariant 0 <= WQDK <= FHTJ.Length\n    invariant forall XNYP :: 0 <= XNYP < WQDK ==> FHTJ[XNYP] == IRZY[XNYP]\n  {\n    IRZY[WQDK] := FHTJ[WQDK];\n    WQDK:=WQDK+1;\n  }\n}"
},
{
    "dafny": "datatype Tree = Empty | Node(left: Tree, value: int, right: Tree)\npredicate BinarySearchTree(tree: Tree)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(_,_,_) =>\n    (tree.left == Empty || tree.left.value < tree.value)\n    && (tree.right == Empty || tree.right.value > tree.value)\n    && BinarySearchTree(tree.left) && BinarySearchTree(tree.right)\n    && minValue(tree.right, tree.value) && maxValue(tree.left, tree.value)\n}\npredicate maxValue(tree: Tree, max: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (max > v) && maxValue(left, max) && maxValue(right, max)\n}\npredicate minValue(tree: Tree, min: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (min < v) && minValue(left, min) && minValue(right, min)\n}\nmethod GetMin(tree: Tree) returns (res: int)\n{\n  match tree {\n    case Empty => res := 0;\n    case Node (Empty, value, Empty) => res := tree.value;\n    case Node (Empty, value, right) => res := tree.value;\n    case Node (left, value, right) =>\n      var minval := tree.value;\n      minval := GetMin(tree.left);\n      var tmp := Node(tree.left, minval, tree.right);\n      res := tmp.value;\n  }\n}\nmethod GetMax(tree: Tree) returns (res: int){\n  match tree {\n    case Empty => res := 0;\n    case Node (Empty, value, Empty) => res := tree.value;\n    case Node (left, value, Empty) => res := tree.value;\n    case Node (left, value, right) =>\n      var minval := tree.value;\n      minval := GetMax(tree.right);\n      var tmp := Node(tree.left, minval, tree.right);\n      res := tmp.value;\n  }\n}\nmethod insert(tree: Tree, value : int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures BinarySearchTree(res)\n{\n  res := insertRecursion(tree, value);\n}\nmethod insertRecursion(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures res != Empty ==> BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n{\n  match tree {\n    case Empty => res := Node(Empty, value, Empty);\n    case Node(_,_,_) =>\n      var temp: Tree;\n      if(value == tree.value) {\n        return tree;\n      }\n      if(value < tree.value){\n        temp := insertRecursion(tree.left, value);\n        res := Node(temp, tree.value, tree.right);\n      }else if (value > tree.value){\n        temp := insertRecursion(tree.right, value);\n        res := Node(tree.left, tree.value, temp);\n      }\n  }\n}\nmethod delete(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n{\n  match tree {\n    case Empty => return tree;\n    case Node(_,_ ,_) =>\n      var temp: Tree;\n      if (value < tree.value){\n        temp := delete(tree.left, value);\n        res := Node(temp, tree.value, tree.right);\n      } else if (value > tree.value){\n        temp := delete(tree.right, value);\n        res := Node(tree.left, tree.value, temp);\n      } else {\n        if (tree.left == Empty){\n          return tree.right;\n        } else if (tree.right == Empty) {\n          return tree.left;\n        }\n        var minVal := GetMin(tree.right);\n        temp := delete(tree.right, minVal);\n        res := Node(tree.left, minVal, temp);\n      }\n  }\n}\nmethod Inorder(tree: Tree)\n{\n  match tree {\n    case Empty =>\n    case Node(left, value, right) =>\n      Inorder(tree.left);\n      print tree.value, \", \";\n      Inorder(tree.right);\n  }\n}\nmethod Postorder(tree: Tree)\n{\n  match tree {\n    case Empty =>\n    case Node(left, value, right) =>\n      Postorder(tree.left);\n      Postorder(tree.right);\n      print tree.value, \", \";\n  }\n}\nmethod Main() {\n  var tree := insert(Empty, 3);\n  var u := insert(tree, 2);\n  u := insert(u, 7);\n  u := insert(u, 6);\n  u := insert(u, 9);\n  print \"This is Inorder: \";\n  Inorder(u);\n  print \"\\n\";\n  print \"This is Postorder: \";\n  Postorder(u);\n  print \"\\n\";\n  print \"tree before delete: \", u, \"\\n\";\n  u := delete(u, 7);\n  print \"tree after delete: \", u, \"\\n\";\n  print \"This is Inorder: \";\n  Inorder(u);\n  print \"\\n\";\n  print \"This is Postorder: \";\n  Postorder(u);\n}"
},
{
    "dafny": "predicate contains(A:array<int>, v:int)\n  reads A\n{\n  contains_upto(A, A.Length, v)\n}\npredicate contains_upto(A:array<int>, hi:int, v:int)\n  requires hi <= A.Length\n  reads A\n{\n  exists j :: 0 <= j < hi && v == A[j]\n}\nmethod maxarray (A:array<int>) returns (r:int)\n  requires 0 < A.Length\n  ensures contains(A,r)\n  ensures forall j :: 0 <= j < A.Length ==> r >= A[j]\n{\n  r := A[0];\n  var i := 1;\n  while i < A.Length \n    invariant 1 <= i <= A.Length\n    invariant contains_upto(A,i,r)\n    invariant forall j :: 0 <= j < i ==> r >= A[j]\n    decreases A.Length - i\n  {\n    if r < A[i] {\n      r := A[i];\n    }\n    i := i+1;\n  }\n}\nmethod max(x:int, y:int) returns (r:int)\n  ensures r >= x \n  ensures r >= y\n  ensures r == x || r == y\n{\n  if x < y {\n    return y;\n  } else {\n    return x;\n  }\n}\nmethod Main() {\n  var m:int := max(3,5);\n  print m, \"\\n\";\n}"
},
{
    "dafny": "predicate sorted (a: array<int>, lo: int, hi: int) \nreads a;\nrequires 0 <= lo <= hi <= a.Length;\n{\n\tforall i, j :: (lo <= i <= j < hi) ==> a[i] <= a[j]\n}\nmethod QuickSort (a: array<int>, start: int, end: int) \nrequires 0 <= start <= end <= a.Length;\nrequires 0 <= start <= end < a.Length ==> forall j :: start <= j < end ==> a[j] <= a[end] \nrequires 0 < start <= end <= a.Length ==> forall j :: start <= j < end ==> a[start-1] <= a[j]\nmodifies a;\nensures sorted (a, start, end);\nensures 0 <= start <= end < a.Length ==> forall j :: start <= j < end ==> a[j] <= a[end] \nensures 0 < start <= end <= a.Length ==> forall j :: start <= j < end ==> a[start-1] <= a[j]\nensures forall j :: (0 <= j < start || end <= j < a.Length) ==> old(a[j]) == a[j];\nensures multiset (old(a[..])) == multiset (a[..]);\ndecreases end - start;\n{\n\tif (end <= start || a.Length <= 1) {\n\t\treturn;\n\t} else {\n\t\tvar pivot := Partition (a, start, end);\n\t\tQuickSort (a, start, pivot);\n\t\tQuickSort (a, pivot + 1, end);\n\t} \n}\nmethod Partition (a: array<int>, start: int, end: int) returns (pivot: int)\nrequires a.Length >= 1;\nrequires 0 <= start < end <= a.Length;\nrequires 0 <= start <= end < a.Length ==> forall j :: start <= j < end ==> a[j] <= a[end]\nrequires 0 < start <= end <= a.Length ==> forall j :: start <= j < end ==> a[start-1] <= a[j]\nmodifies a;\nensures 0 <= start <= pivot < end <= a.Length;\nensures 0 <= start <= end < a.Length ==> forall j :: start <= j < end ==> a[j] <= a[end] \nensures 0 < start <= end <= a.Length ==> forall j :: start <= j < end ==> a[start-1] <= a[j]\nensures forall i :: (start <= i < pivot) ==> a[i] <= a[pivot];\nensures forall i :: (pivot < i < end) ==> a[i] >= a[pivot];\nensures forall j :: (0 <= j < start || end <= j < a.Length) ==> old(a[j]) == a[j];\nensures multiset (old(a[..])) == multiset (a[..]);\n{\n\tif (end <= start) {\n\t\tpivot := start;\n\t} else {\n\t\tpivot := start;\n\t\tvar i := start + 1;\n\t\twhile (i < end) \n\t\tinvariant start <= pivot < i <= end;\n\t\tinvariant 0 <= start <= end < a.Length ==> forall j :: start <= j < end ==> a[j] <= a[end]\n\t\tinvariant 0 < start <= end <= a.Length ==> forall j :: start <= j < end ==> a[start-1] <= a[j]\n\t\tinvariant forall j :: (start <= j <= pivot) ==> a[j] <= a[start];\n\t\tinvariant forall j :: (pivot < j < i) ==> a[j] >= a[start];\n\t\tinvariant forall j :: (0 <= j < start || end <= j < a.Length) ==> old(a[j]) == a[j];\n\t\tinvariant multiset (old(a[..])) == multiset (a[..]);\n\t\t{\n\t\t\tif (a[i] < a[start]) {\n\t\t\t\tpivot := pivot + 1;\n\t\t\t\ta[i], a[pivot] := a[pivot], a[i];\n\t\t\t}\n\t\t\ti := i + 1;\n\t\t}\n\t\ta[start], a[pivot] := a[pivot], a[start];\n\t\tassert (start <= pivot < i <= end);\n\t}\n}\nmethod Main()\n{\n\tvar a := new int[][];\n\tvar msa := multiset (a[..]);\n\tQuickSort (a, 0, a.Length);\n\tassert (sorted (a, 0, a.Length));\n\tvar msa' := multiset (a[..]);\n\tassert (msa == msa');\n\tvar b:= new int[][0,1,2,3,4,5,6,7,8,9,10];\n\tvar msb := multiset (b[..]);\n\tQuickSort (b, 0, b.Length);\n\tassert (sorted(b, 0, b.Length));\n\tvar msb' := multiset (b[..]);\n\tassert (msb == msb');\n\tvar c:= new int[][10,9,8,7,6,5,4,3,2,1,0];\n\tvar msc := multiset (c[..]);\n\tQuickSort (c, 0, c.Length);\n\tassert (sorted (c, 0, c.Length));\n\tvar msc' := multiset (c[..]);\n\tassert (msc == msc');\n\tvar d:= new int[][6,3,4,5,8,9,10,2,1,0,7];\n\tvar msd := multiset (d[..]);\n\tQuickSort (d, 0 , d.Length);\n\tassert (sorted (d, 0, d.Length));\n\tvar msd' := multiset (d[..]);\n\tassert (msd == msd');\n}"
},
{
    "dafny": "method Main() {\n  var i := 0;\n  while i < 2\n  invariant 0 <= i\n  decreases  2 - i\n  {\n    i := i + 1;\n  }\n  assert 1 < 2;\n  assert 2 < 3;\n  assert 3 < 4;\n}"
},
{
    "dafny": "abstract module ShardedStateMachine {\n  type Shard\n  predicate valid_shard(a: Shard)\n  function glue(a: Shard, b: Shard) : Shard\n  lemma glue_commutative(a: Shard, b: Shard)\n  ensures glue(a, b) == glue(b, a)\n  lemma glue_associative(a: Shard, b: Shard, c: Shard)\n  ensures glue(glue(a, b), c) == glue(a, glue(b, c))\n  function unit() : Shard\n  ensures valid_shard(unit())\n  lemma glue_unit(a: Shard)\n  ensures glue(a, unit()) == a\n  predicate Inv(s: Shard)\n  predicate Next(shard: Shard, shard': Shard)\n  lemma NextPreservesValid(s: Shard, s': Shard)\n  requires valid_shard(s)\n  requires Next(s, s')\n  ensures valid_shard(s')\n  lemma NextAdditive(s: Shard, s': Shard, t: Shard)\n  requires Next(s, s')\n  requires valid_shard(glue(s, t))\n  requires Next(glue(s, t), glue(s', t))\n  lemma NextPreservesInv(s: Shard, s': Shard)\n  requires Inv(s)\n  requires Next(s, s')\n  ensures Inv(s')\n}"
},
{
    "dafny": "method InSeq<T>(ts: seq<T>) returns (f: T --> bool)\n  ensures forall t <- ts :: f.requires(t)\n{\n  ghost var pre := t => t in ts;\n  f := t requires pre(t) => true;\n}\nmethod InSeq2<T>(ghost ts: seq<T>) returns (f: T --> bool)\n  ensures forall t <- ts :: f.requires(t)\n{\n  f := t requires (ghost var b := t in ts; b) => true;\n}\nmethod Main() {\n  var f := InSeq([1, 2]);\n  print \"2 in seq? \", f(2),\"\\n\";\n  var g := InSeq2([1, 2]);\n  print \"2 in seq? \", g(2),\"\\n\";\n  print \"All right\";\n}"
},
{
    "dafny": "abstract module Interface {\n  class Node {\n    var next: set<Node>;\n  }\n  predicate graph(G:set<Node>)\n    reads G\n  predicate Path(G: set<Node>,x:Node,y:Node,p:seq<Node>)\n    reads G, p\n    requires graph(G)\n  predicate Acyclic(G: set<Node>)\n    reads G\n    requires graph(G)\n  predicate AcyclicFrom(G: set<Node>, ns: set<Node>, rs: set<Node>)\n    reads G\n    requires graph(G)\n    requires forall n :: n in ns ==> n in G\n    requires forall r :: r in rs ==> r in G \n    requires ns !! rs\n    requires forall n :: n in ns ==> forall m :: m in n.next ==> m !in ns\n    decreases |rs|\n  method foldNext(G: set<Node>, ns: set<Node>) returns (ms: set<Node>)\n    requires graph(G)\n    requires forall n :: n in ns ==> n in G\n    ensures forall m :: m in ms ==> exists n :: n in ns && m in n.next\n    decreases ns\n}"
},
{
    "dafny": "method FindMax(a: array<int>) returns (max:int)\n  requires a.Length >= 1;\n  ensures 0 <= max < a.Length;\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= a[max];\n{ \n  var m := a[0]; \n  var r := 0;\n  var i := 1;\n  while (i < a.Length)\n    invariant 1 <= i <= a.Length;\n    invariant 0 <= r < a.Length;\n    invariant m == a[r];\n    invariant forall j :: 0 <= j < i ==> a[j] <= a[r];\n  {\n    if (a[i] > m) {\n      r := i;\n      m := a[i];\n    }\n    i := i + 1;\n  }\n  max := r; \n}"
},
{
    "dafny": "datatype Result<T> = Success(value: T) | Failure(error: string)\n{\n  predicate IsFailure() {\n    Failure?\n  }\n  function PropagateFailure<U>(): Result<U>\n    requires Failure?\n  {\n    Failure(this.error)\n  }\n}\nmethod mn() returns (r: Result<int>, out: int)\n  ensures out == -2 && r.Failure?\n{\n  var o :- m(1);\n  assert o == 3;\n  print \"OK\\n\";\n  out :- m(-1); \n  return Success(0), 4;\n}\nmethod mn1() returns (r: Result<int>)\n  ensures r.Failure?\n{\n  :- m1(1);\n  print \"OK\\n\";\n  :- m1(-1); \n  return Success(0);\n}\nmethod m(i: int) returns (r: Result<int>, o: int)\n  ensures 0 <= i ==> r.Success? && r.value == i && o == i+i+i\n  ensures i < 0 ==> r.Failure? && o == i+i\n{\n  if i < 0 { return Failure(\"negative\"), i+i; }\n  return Success(i), i+i+i;\n}\nmethod m1(i: int) returns (r: Result<int>)\n  ensures 0 <= i ==> r.Success? && r.value == i\n  ensures i < 0 ==> r.Failure?\n{\n  if i < 0 { return Failure(\"negative\"); }\n  return Success(i);\n}\nmethod mexp() returns (r: Result<int>, k: int)\n  ensures r.IsFailure() && k == 100\n{\n  k :- Result<int>.Failure(\"always\"), 100;\n  k := 101; \n  return Success(0), k;\n}\nmethod mstar() returns (r: Result<int>, k: int)\n  ensures r.IsFailure()\n{\n  k :- Result<int>.Failure(\"always\"), *;\n  k := 101; \n  return Success(0), k;\n}\nmethod Main() {\n  var x := mn1();\n  print x.Failure?, \" \";\n  var out;\n  x, out := mn();\n  print x.Failure?, \" \", out, \"\\n\";\n  x, out := mexp();\n  print x.Failure?, \" \", out, \"\\n\";\n  print \"End\\n\";\n}"
},
{
    "dafny": "function IsEven(a : int) : bool\n    requires a >= 0\n{\n    if a == 0 then      true \n    else if a == 1 then false \n    else                IsEven(a - 2)\n}\nlemma {:induction x} EvenPlus(x: int, y: int)\n    requires x >= 0\n    requires y >= 0\n    requires IsEven(x)\n    requires IsEven(y)\n    ensures IsEven(x + y)\n{ }\nlemma {:induction y} EvenPlus2(x: int, y: int)\n    requires x >= 0\n    requires y >= 0\n    requires IsEven(x)\n    requires IsEven(y)\n    ensures IsEven(x + y)\n{ }\nlemma {:induction false} EvenPlus3(x: int, y: int)\n    requires x >= 0\n    requires y >= 0\n    requires IsEven(x)\n    requires IsEven(y)\n    ensures IsEven(x + y)\n{\n    EvenPlus4(x, y, x + y);\n}\nlemma EvenPlus4(x: int, y: int, z: int)\n    requires x >= 0\n    requires y >= 0\n    requires IsEven(x)\n    requires IsEven(y)\n    requires z == x + y\n    ensures IsEven(z)\n{ }"
},
{
    "dafny": "method Compare<T(==)>(a: T, b: T) returns (eq: bool)\n  ensures a==b ==> eq==true\n  ensures a!=b ==> eq==false\n{\n  if a == b { eq := true; } else { eq := false; }\n}\nmethod TestCompare(){\n  var test1 := Compare<int>(1,1);\n  print(\"Test 1: Compare<int>(1,1) = \", test1, \"\\n\");\n  var test2 := Compare<int>(2,3);\n  print(\"Test 2: Compare<int>(2,3) = \", test2, \"\\n\");\n  var test3 := Compare<string>(\"test\",\"test\");\n  print(\"Test 3: Compare<string>(\\\"test\\\",\\\"test\\\") = \", test3, \"\\n\");\n  var test4 := Compare<string>(\"test\",\"dafny\");\n  print(\"Test 4: Compare<string>(\\\"test\\\",\\\"dafny\\\") = \", test4, \"\\n\");\n  var test5 := Compare<bool>(true,false);\n  print(\"Test 5: Compare<bool>(true,false) = \", test5, \"\\n\");\n}\nmethod Main(){\n  TestCompare();\n}"
},
{
    "dafny": "module NonlinearLemmas {\n  lemma mul_assoc(a: int, b: int, c: int)\n  ensures (a * b) * c == a * (b * c)\n  {\n  }\n  lemma mul_comm(a: int, b: int)\n  ensures a * b == b * a\n  {\n  }\n  lemma mul_ge_0(a: int, b: int)\n  requires a >= 0\n  requires b >= 0\n  ensures a*b >= 0\n  {\n  }\n  lemma mul_gt_0(a: int, b: int)\n  requires a > 0\n  requires b > 0\n  ensures a*b > 0\n  {\n  }\n  lemma div_mul_plus_mod(a: int, b: int)\n  requires b > 0\n  ensures (a / b) * b + (a % b) == a\n  {\n  }\n  lemma distributive_right(a: int, b: int, c: int)\n  ensures (a + b) * c == a*c + b*c\n  {\n  }\n  lemma distributive_left(a: int, b: int, c: int)\n  ensures a * (b + c) == a*b + a*c\n  {\n  }\n  lemma distributive_left_sub(a: int, b: int, c: int)\n  ensures a * (b - c) == a*b - a*c\n  {\n  }\n  lemma distributive_right_sub(a: int, b: int, c: int)\n  ensures (a - b) * c == a*c - b*c\n  {\n  }\n  lemma div_eq_0(a: int, b: int)\n  requires b > 0\n  requires 0 <= a < b\n  ensures a / b == 0\n  {\n  }\n  lemma div_ge_0(a: int, b: int)\n  requires a >= 0\n  requires b > 0\n  ensures a / b >= 0\n  {\n  }\n  lemma mod_ge_0(a: int, b: int)\n  requires b > 0\n  ensures a % b >= 0\n  {\n  }\n  lemma a_mod_b_eq_a(a: int, b: int)\n  requires 0 <= a < b\n  ensures a % b == a\n  {\n  }\n  lemma mul_le_left(a: int, b: int, c: int)\n  requires 0 <= c\n  requires a <= b\n  ensures a*c <= b*c\n  {\n  }\n  lemma mul_le_right(a: int, b: int, c: int)\n  requires 0 <= a\n  requires b <= c\n  ensures a*b <= a*c\n  {\n  }\n  lemma div_invert(a: int, b: int, c: int)\n  requires 0 < b\n  requires a % b == 0\n  ensures a / b == c <==> a == b * c\n  {\n  }\n  lemma mod_bound(a: int, b: int)\n  requires b > 0\n  ensures 0 <= a % b <= b - 1\n  {\n  }\n}"
},
{
    "dafny": "method abcd(efgh: set<int>, ijkl: int) returns (mnop: int)\n{\n  mnop := 0;\n  var rstu := efgh;\n  var vwxy := {};\n  while |rstu| > 0\n    decreases rstu\n    invariant rstu + vwxy == efgh\n    invariant vwxy !! rstu\n    invariant mnop == |set opqr | opqr in vwxy && opqr < ijkl|\n  {\n    var zabc: int :| zabc in rstu;\n    rstu := rstu - {zabc};\n    var cdef := vwxy + {zabc};\n    assert (set opqr | opqr in cdef && opqr < ijkl) ==\n           (set opqr | opqr in vwxy && opqr < ijkl) + if zabc < ijkl then {zabc} else {};\n    vwxy := vwxy + {zabc};\n    if zabc < ijkl {\n      mnop := mnop + 1;\n    }\n  }\n}"
},
{
    "dafny": "method Max(a: int, b: int) returns (m: int)\nrequires a != b\nensures a > b ==> a == m && a < b ==> b == m\n{\n    if(a > b){\n        m:= a;\n    } else {\n        m:= b;\n    }\n}"
},
{
    "dafny": "predicate ReverseSorted(a:array<int>, low:int, high:int)\n\treads a\n{\n\t0 <= low <= high <= a.Length &&\n\tforall i,j :: low <= i < j < high ==> a[i] >= a[j]\n}\nmethod InsertionSortShuffle(a:array<int>)\n\tmodifies a\n\trequires a.Length>1\n\tensures ReverseSorted(a, 0, a.Length)\n\tensures multiset(a[..]) == multiset(old(a[..]))\n{\n\tvar curr := 1;\n\twhile (curr < a.Length)\n\t\tinvariant 1 <= curr <= a.Length\n\t\tinvariant ReverseSorted(a, 0, curr);\n\t\tinvariant multiset(a[..]) == multiset(old(a[..]))\n\t{\n\t\tvar num := a[curr];\n\t\tvar prev := curr - 1;\n\t\ta[curr] := a[prev];\n\t\twhile (prev >= 0 && a[prev] < num)\n\t\t\tinvariant -1 <= prev < curr\n\t\t\tinvariant forall i :: prev < i < curr ==> a[i] <= num\n\t\t\tinvariant ReverseSorted(a, 0, curr + 1)\n\t\t\tinvariant multiset(a[..]) + multiset([num]) - multiset([a[prev + 1]]) == multiset(old(a[..]))\n\t\t{\n\t\t\ta[prev + 1] := a[prev];\n\t\t\tprev := prev - 1;\n\t\t}\n\t\ta[prev + 1] := num;\n\t\tcurr := curr + 1;\n\t}\n}"
},
{
    "dafny": "abstract module Interface {\n    type T\n    function F(): T\n    predicate P(x: T)\n    lemma FP()\n        ensures P(F())\n}\nmodule Implementation refines Interface {\n    predicate P(x: T) {\n        false\n    }\n}\nabstract module User {\n    lemma Main()\n        ensures I.P(I.F());\n    {\n        I.FP();\n        assert I.P(I.F());\n    }\n}\nmodule Main refines User {\n    lemma Main()\n        ensures I.P(I.F())\n    {\n        I.FP();\n        assert false;\n    }\n}"
},
{
    "dafny": "type Process(==) \ndatatype CState = Thinking | Hungry | Eating\nclass TicketSystem {\n    var ticket: int\n    var serving: int\n    const P: set<Process>\n    var cs: map<Process, CState> \n    var t: map<Process, int> \n    predicate Valid() \n        reads this \n    {\n        P <= cs.Keys && P <= t.Keys && serving <= ticket && \n        (forall p :: p in P && cs[p] != Thinking ==> serving <= t[p] < ticket) && \n        (forall p,q :: \n            p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking ==> t[p] != t[q] \n        ) && \n        (forall p :: p in P && cs[p] == Eating ==> t[p] == serving) \n    }\n    constructor (processes: set<Process>)\n        ensures Valid() \n    {\n        P := processes;\n        ticket, serving := 0,  0;\n        cs := map p | p in processes :: Thinking; \n        t := map p | p in processes :: 0;\n    }\n    method Request(p: Process)\n        requires Valid() && p in P && cs[p] == Thinking\n        modifies this\n        ensures Valid()\n    {\n        t, ticket := t[p := ticket], ticket + 1; \n        cs := cs[p := Hungry]; \n    }\n    method Enter(p: Process)\n        requires Valid() && p in P && cs[p] == Hungry\n        modifies this\n        ensures Valid()\n    {\n        if t[p] == serving {\n            cs := cs[p := Eating]; \n        }\n    }\n    method Leave(p: Process)\n        requires Valid() && p in P && cs[p] == Eating\n        modifies this\n        ensures Valid()\n    {\n        assert t[p] == serving;\n        serving := serving + 1;\n        cs := cs[p := Thinking];\n    }\n    lemma MutualExclusion(p: Process, q: Process)\n        requires Valid() && p in P && q in P \n        requires cs[p] == Eating && cs[q] == Eating \n        ensures p == q \n}"
},
{
    "dafny": "class Acceptor<T(==)>\n{\n  var promise:  int;\n  var accepted: Accepted<T>;\n  constructor (value: T)\n    modifies this;\n    ensures valid();\n  {\n    promise  := -1;\n    accepted := new Accepted(value);\n  }\n  method Prepare(round: int, value: T) returns (ok: bool, acp: Accepted<T>)\n    requires valid();\n    modifies this;\n  ensures valid() && promise >= round;\n  {\n    acp := accepted;\n    ok  := false;\n    if round >= promise && round != accepted.round {\n      promise := round;\n      assert promise > accepted.round;\n      ok := true;\n    }\n  }\n  method Accept(round: int, value: T) returns (ok: bool, acp: Accepted<T>)\n    requires valid();\n    modifies this, accepted;\n  ensures valid() && promise >= round;\n  {\n    acp := accepted;\n    ok  := false;\n    if round >= promise {\n      promise         := round;\n      accepted.round  := round;\n      accepted.value  := value;\n      ok := true;\n    }\n  }\n  method Get() returns (rnd: int, acp: int, val: T)\n    requires valid();\n  {\n    rnd := promise;\n    acp := accepted.round;\n    val := accepted.value;\n  }\n  predicate valid()\n    reads this, accepted;\n  { accepted != null && promise >= accepted.round }\n}\nclass Accepted<T(==)>\n{\n  var round: int;\n  var value: T;\n  constructor (val: T)\n    modifies this;\n    ensures round == -1; \n  { round := -1; value := val; }\n}"
},
{
    "dafny": "method Min2(x: int, y: int) returns (m:int)\n    ensures m <= x && m <= y\n    ensures m == x || m == y \n{\n    if x < y{ m := x;}\n    else{ m := y; }\n}\nmethod Min3(x: int, y: int, z: int) returns (m:int)\n    ensures m <= x && m <= y && m <= z\n    ensures m == x || m == y || m == z \n{\n    if x < y {\n        if x < z {\n            m := x;\n        }else{\n            m := z;\n        }  \n    }else{\n        if y < z{\n            m := y;\n        }else{\n            m := z;\n        }\n    }\n}\nmethod Min3_bis(x: int, y: int, z: int) returns (m:int)\n    ensures m <= x && m <= y && m <= z\n    ensures m == x || m == y || m == z \n{\n    var min_xy := Min2(x,y);\n    m := Min2(min_xy, z);\n}"
},
{
    "dafny": "function truncate(x: real): real\n    requires x >= 0.0\n    ensures truncate(x) >= 0.0\n    ensures x - truncate(x) < 1.0\n    ensures x - truncate(x) >= 0.0\n{\n    if x < 1.0 then 0.0 else 1.0 + truncate(x - 1.0)\n}\nfunction truncate_number(x: real): real\n    requires x >= 0.0\n    ensures truncate_number(x) < 1.0 && truncate_number(x) >= 0.0\n    ensures truncate_number(x) + truncate(x) == x\n{\n    x - truncate(x)    \n}"
},
{
    "dafny": "method FindMax(a: array<int>) returns (i: int) \n    requires 0 < a.Length \n    ensures forall k :: 0 <= k < a.Length ==> a[k] <= i\n{\n    i := a[0];\n    var k := 0;\n    while k < a.Length\n        invariant 0 <= k <= a.Length\n        invariant forall j :: 0 <= j < k ==> a[j] <= i\n        decreases  a.Length - k\n  {\n        if i < a[k] {i := a[k]; }\n        k := k + 1;\n    }\n}\nmethod SetExample()\n{\n    var s1: set<int> := {};\n    var s2 := {1, 2, 3};\n    assert s2 == {1,1,2,3,3,3,3};\n    var s3, s4 := {1,2}, {1,4};\n    assert s2 + s4 == {1,2,3,4};\n    assert s2*s3 == {1,2} && s2*s4 == {1};\n    assert s2 - s3 == {3};\n    assert s3 - s4 == {2};\n    assert {1} <= {1,2} && {1,2} <= {1,2};\n    assert {} < {1,2} && !({1} < {1});\n    assert !({1,2} <= {1,4}) && !({1,4} <= {1,2});\n    assert {1,2} == {1,2} && {1,2} != {1,3};\n    assert 5 in {1,5};\n}\npredicate sorted2(s: seq<int>)\n  decreases s\n{\n   0 < |s| ==> (forall i :: 0 < i < |s| ==> s[0] <= s[i]) &&\n               sorted2(s[1..])\n}\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n   requires 0 <= i < |s|\n   ensures update(s, i, v) == s[i := v]\n{\n   s[..i] + [v] + s[i+1..]\n}\nmethod maps()\n{\n    var m := map[3 := 5, 4 := 6, 1 := 4];\n    var l := map i | i in m && i != 3 :: m[i];\n    assert l == map[4:= 6, 1 := 4];\n}"
},
{
    "dafny": "class Foo {}\ntrait InputStream {\n  var x: int\n  ghost predicate Valid() reads this\n  method read(b: Foo)\n    requires Valid()\n}\nclass ToyInputStream extends InputStream {\n  ghost predicate Valid() reads this {\n    x == 7\n  }\n  method read(b: Foo)\n    requires Valid()\n  { }\n}"
},
{
    "dafny": "method Q2_t3(x : int, y : int) returns (big : int, small : int)\n    requires x != y;\n    ensures big > small;\n{\n    if (x > y)\n        {big, small := x, y;}\n    else\n        {big, small := y, x;}\n}\nmethod Q2_t4(x : int, y : int) returns (big : int, small : int) \n  ensures big >= small;\n{\n    if (x > y)\n        {big, small := x, y;}\n    else\n        {big, small := y, x;}\n}"
},
{
    "dafny": "method Q3(n0 : int, m0 : int) returns (res : int)\nensures res == n0 * m0;\n{\n  var n, m : int;\n  res := 0;\n  if (n0 >= 0) \n       {n,m := n0, m0;} \n  else \n       {n,m := -n0, -m0;}\n  while (0 < n)\n  invariant n >= 0;\n  invariant n0 >= 0 ==> res == (n0 - n) * m;\n  invariant n0 < 0 ==> res == (-n0 - n) * m;\n  decreases n;\n  { \n    res := res + m; \n    n := n - 1; \n  }\n}"
},
{
    "dafny": "method FindMax(a: array<int>) returns (i: int)\n  requires a != null && a.Length >= 1\n  ensures 0 <= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n{\n  i := 0;\n  var j := 1;\n  while j < a.Length\n    invariant 0 <= i < j <= a.Length\n    invariant forall k :: 0 <= k < j ==> a[k] <= a[i]\n  {\n    if a[j] > a[i] {\n      i := j;\n    }\n    j := j + 1;\n  }\n}"
},
{
    "dafny": "method Main()\n{\n  var a := SingleValued(67);\n  PrintArray(a);\n  var mx := NewMatrix();\n  PrintMatrix(mx);\n  var c := InitArray(F);\n  PrintArray(c);\n  var s := InitArray(_ => 12);\n  PrintArray(s);\n  var t := new TrickyLets(0, null);\n  t.RegressionTests();\n  t.Do();\n  t.DoDisplay();\n  t.DoDefault();\n  SubsetType();\n  Display(98);\n}\nmethod SingleValued(d: int) returns (a: array<int>)\n  ensures a.Length == 8\n{\n  a := new int[8](_ => d);\n}\nfunction F(x: int): char\n{\n  if x % 2 == 0 then 'O' else '.'\n}\nmethod InitArray<D>(f: int -> D) returns (a: array<D>)\n  requires forall x :: 0 <= x < 12 ==> f.requires(x)\n{\n  a := new D[12](f);\n}\nmethod NewMatrix() returns (m: array2<int>)\n{\n  m := new int[5, 4]((x,y) => x+y);\n}\nmethod PrintMatrix(m: array2<int>)\n{\n  var i := 0;\n  while i < m.Length0\n  {\n    var j := 0;\n    while j < m.Length1\n    {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n    print \"\\n\";\n    i := i + 1;\n  }\n}\nmethod PrintArray<D>(a: array<D>)\n{\n  var i := 0;\n  while i < a.Length\n  {\n    print a[i], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}\nclass TrickyLets\n{\n  var next: TrickyLets?\n  var arr: array<char>\n  constructor (n: nat, w: TLWrapper?)\n    modifies w\n    ensures w != null ==> w.data == null\n  {\n    if w != null {\n      w.data := null;\n    }\n    if n != 0 {\n      next := new TrickyLets(n-1, null);\n    }\n  }\n  method RegressionTests()\n  {\n    var t := new TrickyLets(0, null);\n    var w := new TLWrapper;\n    w.data := t;\n    w.data, w.data.next := null, null;\n    t := new TrickyLets(0, null);\n    w := new TLWrapper;\n    w.data := t;\n    w.data.next, w.data := null, null;\n    t := new TrickyLets(0, null);\n    w := new TLWrapper;\n    w.data := t;\n    w.data.next := new TrickyLets(0, w);\n    assert t.next != null;\n    assert w.data == null;\n  }\n  method Do()\n    modifies this\n  {\n    this.arr := new char[20](_ => 'D');\n    assert arr[12] == 'D';\n    print arr[12], \" \";\n    (var u := this; u).arr := new char[var n := 20; n](var fn := _ => 'E'; fn);\n    assert arr[13] == 'E';\n    print arr[13], \"\\n\";\n  }\n  method DoDisplay()\n    modifies this\n  {\n    this.arr := new char[3] ['x', 'y', 'z'];\n    assert arr[1] == 'y';\n    print arr[1], \" \";\n    (var u := this; u).arr := new char[var n := 3; n] [var x := 'x'; x, var y := 'y'; y, var z := 'z'; z];\n    assert arr[2] == 'z';\n    print arr[2], \"\\n\";\n  }\n  method DoDefault()\n    modifies this\n  {\n    this.arr := new char[4];\n    assert arr.Length == 4;\n    print arr.Length, \" \";\n    (var u := this; u).arr := new char[var n := 3; n];\n    assert arr.Length == 3;\n    print arr.Length, \"\\n\";\n  }\n}\nclass TLWrapper\n{\n  var data: TrickyLets?\n}\ntype Six = x | 6 <= x witness 7\nnewtype int32 = x | -0x8000_0000 <= x < 0x8000_0000\nmethod SubsetType()\n{\n  var a := new Six[12];\n  assert 6 <= a[6];\n  print a[6], \"\\n\";\n}\nmethod Display(n: nat)\n{\n  var b := new nat[4] [100, 75, n, 25];\n  var d := new char[0][];\n  var s := new string[4][\"looks\", \"like\", \"this\", \"rocks\"];\n  var i := new int32[7][-2, -1, 0, 1, 2, 3, 4];\n  PrintArray(b);\n  PrintArray(d);\n  PrintArray(s);\n  PrintArray(i);\n}"
},
{
    "dafny": "module TwoPhaseCommit\n{\n  datatype Message = Init | Commit | Abort\n  method TwoPhase( Ps : set<nat>\n                 , c  : nat\n                 )\n  {\n    var proposal := *;\n    var committed := false;\n    var abort    := false;\n    var reply    := Abort;\n    var cMsg;\n    var Id       := map i | i in Ps :: 0;\n    var Val      := map i | i in Ps :: 0;\n    var Value    := map i | i in Ps :: 0;\n    var Msg      := map i | i in Ps :: Init;\n    var Decision := map i | i in Ps :: Init;\n    var WL;\n    WL := Ps;\n    while WL != {}\n    invariant forall p :: p in WL ==> p in Ps;\n    invariant forall p :: p in Ps <==> p in Val \n    invariant forall p :: p in Ps && p !in WL ==> Val[p] == proposal\n    decreases |WL|\n    {\n      var p := *; assume (p in WL && p in Ps);\n      Id    := Id[p := c];\n      Val   := Val[p := proposal];\n      WL := WL - {p};\n    }\n    WL := Ps;\n    while WL != {}\n    decreases |WL|\n    {\n      var p := *; assume (p in WL && p in Ps);\n      if * {\n        cMsg := Commit;\n        Msg := Msg[p := cMsg];\n      } else {\n        abort := true;\n        cMsg := Abort;\n        Msg := Msg[p := cMsg];\n      }\n      WL := WL - {p};\n    }\n    if abort {\n      reply := Abort;\n    } else{\n      reply := Commit;\n      committed := true;\n    }\n    WL := Ps;\n    while WL != {}\n    invariant (forall p :: p in Ps <==> p in Value)\n    invariant (forall p :: p in Ps && p !in WL && committed ==> Value[p] == Val[p])\n    decreases |WL|\n    {\n      var p := *; assume (p in WL && p in Ps);\n      Decision := Decision[p := reply];\n      if Decision[p] == Commit {\n        Value := Value[p := Val[p]];\n      }\n      WL := WL - {p};\n    }\n    assert (forall p :: p in Ps && committed ==> Value[p] == proposal);\n  }\n}"
},
{
    "dafny": "module Contract {\n    trait address{\n        var balance: nat\n        var msg: Message\n        var block: Block\n        method transfer(payer: address)\n            requires payer.msg.value < payer.balance\n            requires payer != this\n            modifies payer\n            ensures balance == old(balance) + payer.msg.value\n            ensures payer.balance == old(payer.balance) - payer.msg.value\n        method send(amount: nat, sender: address)\n            requires sender.balance > amount\n            ensures this.balance == old(this.balance) + amount;\n    }\n    trait Message{\n        var sender: address\n        var value: nat\n        var data: nat\n    }\n    trait Block{\n        var timestamp: nat\n    }\n}"
},
{
    "dafny": "predicate IsSorted( s: seq<int> )\n{\n    forall p,q | 0<=p<q<|s| :: s[p]<=s[q]\n}\nmethod InsertionSort( s: seq<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == multiset(s);\n    ensures IsSorted(r);\n{\n    r := [];\n    var rest := s;\n    while rest != []\n        decreases rest;\n        invariant multiset(s) == multiset(r)+multiset(rest);\n        invariant IsSorted(r);\n    {\n        var x := rest[0];\n        assert rest == rest[0..1]+rest[1..];\n        rest := rest[1..];\n        var k := |r|;\n        while k>0 && r[k-1]>x\n            invariant 0 <= k <= |r|;\n            invariant forall p | k<=p<|r| :: r[p]>x;\n        {\n            k := k-1;\n        }\n        assert r == r[..k]+r[k..];\n        r := r[..k]+[x]+r[k..];\n    }\n}"
},
{
    "dafny": "predicate CorrectBlood(s: seq<int>, val: int)\n{\n    forall k ::0<= k < |s| ==> s[k] == val\n}\nmethod GetExactBloodAmount(a:array<int>,val:int) returns (r : seq<int>)\nrequires a != null\nensures CorrectBlood(r[..],val);\nensures |r| == multiset(a[..])[val];\n{ \nvar temp := new int[a.Length];\nvar i := 0;\nvar j := 0;\nwhile (i < a.Length && j < temp.Length) \ninvariant 0 <= i <= a.Length\ninvariant 0 <= j <= a.Length\ninvariant CorrectBlood(temp[..j],val)\ninvariant j == multiset(a[..i])[val]\n{\n  if (a[i] == val) {\n    temp[j] := a[i];\n    j := j + 1;\n  }\n  i := i + 1;\n}\nassert a[..] == a[..a.Length];\nassert j == multiset(a[..])[val];\nr := temp[..j];\n}\nmethod Main()\n{\n    var a : array<int> := new int[5];\n    a[0]:= 500;a[1]:= 750;a[2] := 250;a[3]:=1000;a[4]:=250;\n    var k := GetExactBloodAmount(a,250);\n    assert |k| == multiset(a[..])[250];\n    assert CorrectBlood(k,250);\n    var a2 : array<int> := new int[1];\n    a2[0]:= 500;\n    k := GetExactBloodAmount(a2,250);\n    assert |k| == 0;\n    assert CorrectBlood(k,250);\n}"
},
{
    "dafny": "lemma lemma_mul_le(x: int, y: int, z: int)\n    requires 0 <= z\n    requires x <= y\n    ensures x * z <= y * z\n{}\nmethod foo(input: array<int>, rows:int, cols:int)\nrequires input != null \nrequires rows > 0 && cols > 0\nrequires rows * cols == input.Length\n{\n   var i := 0;\n   while i < rows\n   {\n     var j := 0;\n     while j < cols\n     {\n       lemma_mul_le(i, rows-1, cols);\n       var s := input[i*cols + j];\n       j := j + 1;\n     }\n     i := i + 1;\n   }\n}"
},
{
    "dafny": "method ComputeFact(n : nat) returns (res : nat)\n  requires n > 0;\n  ensures res == fact(n);\n {\n  res := 1;\n  var i := 2;\n  while (i <= n)\n  invariant fact(i) == res * i && i-2 <n \n   decreases  n - i\n  {\n    res := res * i;\n    i := i + 1;\n  }\n }\n function fact( n : nat): nat\n decreases  n\n requires n >0\n {\n if n==1 then 1\n else n * fact(n-1)\n }"
},
{
    "dafny": "predicate sorted(a: array?<int>)\n    reads a\n{\n    if a == null then\n        false\n    else\n        forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}\nmethod BinarySearch(a: array?<int>, key: int) returns (index: int)\n    requires a != null\n    requires sorted(a)\n{\n    var lo: int := 0;\n    var hi: int := a.Length;\n    while lo < hi\n        decreases hi - lo\n        invariant 0 <= lo <= hi <= a.Length\n        invariant forall i ::\n            0 <= i < a.Length && !(lo <= i < hi) ==> a[i] != key\n    {\n        var mid: int := (lo + hi) / 2;\n        if a[mid] < key\n        {\n            lo := mid + 1;\n        }\n        else if key < a[mid]\n        {\n            hi := mid;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}"
},
{
    "dafny": "module A {\n  type {:extern \"MyCollection\"} Container<A>\n  class MyCollection<X> {\n  }\n  datatype Node = Leaf | Node(children: Container<Node>)\n  method Test(node: Node)\n    requires node.Node?\n  {\n    var Node(ch) := node; \n  }\n}\nmodule B {\n  datatype InnerT<X> = Inner(x: X)\n  datatype Node<X, Y> = Leaf | Node(children: Y)\n  method Test(node: Node<int, InnerT<real>>)\n    requires node.Node?\n  {\n    var Node(Inner(z)) := node; \n  }\n}\nmodule C {\n  datatype InnerT<X> = Inner(x: X)\n  datatype Node<X> = Leaf | Node(children: InnerT<X>)\n  method Test(node: Node<int>)\n    requires node.Node?\n  {\n    var Node(Inner(z)) := node; \n  }\n}"
},
{
    "dafny": "lemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n    decreases a, b\n    ensures count(a + b) == count(a) + count(b)\n{\n    if a == []\n    {\n        assert a + b == b;\n    }\n    else\n    {\n        DistributiveLemma(a[1..], b);\n        assert a + b == [a[0]] + (a[1..] + b);\n    }\n}\nfunction count(a: seq<bool>): nat\n    decreases a\n{\n    if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\nmethod Testing()\n{\n    var a := [true, true, false];\n    var b := [false];\n    DistributiveLemma(a, b);\n    assert count(a + b) == count(a) + count(b);\n}"
},
{
    "dafny": "function gcd(m: nat, n: nat): nat\n  requires m > 0 && n > 0;\n  decreases m + n;\n{\n  if (m == n) then m\n  else if (m > n) then gcd(m - n, n)\n  else gcd(m, n - m)\n}\nmethod GcdCalc(m: nat, n: nat) returns (res: nat)\n  requires m > 0 && n > 0;\n  ensures res == gcd(m, n);\n{\n  var n1, m1 := n, m;\n  while (n1 != m1)\n    decreases m1 + n1;\n    invariant m1 > 0 && n1 > 0;\n    invariant gcd(m, n) == gcd(m1, n1);\n  {\n    if (m1 < n1) {\n     n1 := n1 - m1;\n    } else {\n     m1 := m1 - n1;\n    }\n  }\n  assert(m1 == n1);\n  return n1;\n}"
},
{
    "dafny": "method Skippy(limit: nat)\n{\n    var skip := 7;\n    var index := 0;\n    while index<=limit\n    invariant 0 <= index <= (limit/7+1)*7 && (index %7 == 0);\n    decreases limit - index;\n    { index := index+skip; }\n    assert index == (limit/7+1)*7;\n}"
},
{
    "dafny": "method test(x:int) returns (y:int)\nrequires true\nensures y == 2*x\n{\n    assert 10 == 10;\n    return 2*x;\n}\nmethod abs(x:int) returns (y:int)\n    requires true;\n    ensures y == x || y == -x;\n    ensures y >= 0;\n{\n    if x >= 0 { return x; } else { return -x; }\n}\nmethod max(x:int, y:int) returns (z:int)\n    requires true\n    ensures z == x || z == y;\n    ensures z >= x && z >= y;\n{\n    if x >= y { return x; } else { return y; }\n}\nmethod min(x:int, y:int) returns (z:int)\nmethod div(x:int, y:int) returns (z:int)\n    requires y != 0\n    ensures z == x/y\n{\n    return x/y;\n}\nmethod m() {\n    var a := div(1,2);\n}\nmethod square(x:int) returns (z:int)\nrequires true\nensures z == x*x && z >= 0\n{\n    return x*x;\n}\nmethod modulo(x:int, y:int) returns (z:int)\n    requires y != 0;\n    ensures x/y * y + z == x;\n{\n    return x % y;\n}\nmethod quotient(x:int, y:int) returns (q:int, r:int)\n    requires y != 0;\n    ensures q * y + r == x;\n{\n    q := x / y;\n    r := x % y;\n}\nmethod sign(x:int) returns (z:int)\n    requires true\n    ensures z == 0 <==> x >= 0\n    ensures z == 1 <==> x < 0\n{\n    if x < 0 { return 1; } else { return 0; }\n}\nfunction sumAllPositive(n:int) : int\ndecreases n\nrequires n >= 0\n{\n    if (n == 0) then 0 else n + sumAllPositive(n - 1)\n}\nmethod computeSumAllPositive(n:int) returns (z:int)\n    requires n >= 0\n    ensures z == sumAllPositive(n)\n{\n    var i := 0;\n    var sum := 0;\n    assert sum == sumAllPositive(i);\n    while i < n \n        decreases n - i\n        invariant 0 <= i <= n\n        invariant sum == sumAllPositive(i)\n    {\n        assert sum == sumAllPositive(i);\n        i := i + 1;\n        assert sum == sumAllPositive(i-1);\n        sum := i + sum;\n        assert sum == i + sumAllPositive(i-1);\n        assert sumAllPositive(i) == i + sumAllPositive(i-1);\n        assert sum == sumAllPositive(i);\n    }\n    assert i >= n;\n    assert i == n;\n    return sum;\n}\nmethod computeSumAllPositive2(n:int) returns (z:int)\n    requires n >= 0\n    ensures z == n * (n+1) / 2\n{\n    var i := 0;\n    var sum := 0;\n    assert sum == i * (i+1) / 2;\n    while i < n \n        decreases n - i\n        invariant 0 <= i <= n\n        invariant sum == i * (i+1) / 2\n    {\n        assert sum == i * (i+1) / 2;\n        i := i + 1;\n        assert sum == (i-1) * (i) / 2;\n        sum := i + sum;\n        assert sum == i + (i-1) * (i) / 2;\n        assert i * (i+1) / 2 == i + (i-1) * (i) / 2;\n        assert sum == i * (i+1) / 2;\n    }\n    assert i >= n;\n    assert i == n;\n    return sum;\n}\nmethod computeSumAllPositive3(n:int) returns (z:int)\n    requires n >= 0\n    ensures z == n * (n+1) / 2\n{\n    var i := 0;\n    var sum := 0;\n    while i <= n \n        decreases n - i\n        invariant 0 <= i <= n+1\n        invariant sum == i * (i-1) / 2\n    {\n        sum := i + sum;\n        i := i + 1;\n    }\n    return sum;\n}\nmethod computeSumAllPositive4(n:int) returns (z:int)\n    requires n >= 0\n    ensures z == sumAllPositive(n)\n{\n    var i := 1;\n    var sum := 0;\n    while i <= n \n        decreases n - i\n        invariant 1 <= i <= n+1\n        invariant sum == sumAllPositive(i-1)\n    {\n        sum := i + sum;\n        i := i + 1;\n    }\n    return sum;\n}"
},
{
    "dafny": "predicate SuppressNoTriggerWarning<X>(x: X) { true }\ntrait Tr {\n  var x: int\n}\nclass C extends Tr {\n  var y: int\n}\nclass D extends Tr {\n  var z: int\n}\nmethod M(t: Tr)\n  modifies t\n{\n  print \"t.x=\", t.x, \"  \";\n  var s: set<C> := set c: C | c == t && SuppressNoTriggerWarning(c);  \n  if s == {} {\n    print \"The given Tr is not a C\\n\";\n  } else {\n    var c :| c in s;\n    print \"The given Tr is a C, and c.y=\", c.y, \"\\n\";\n    c.y := c.y + 10;\n  }\n}\nmethod Main() {\n  var c := new C;\n  var d := new D;\n  c.x, c.y := 5, 6;\n  d.x, d.z := 100, 102;\n  M(c);\n  M(d);\n  M(c);\n}"
},
{
    "dafny": "method MaxSum(x: int, y: int) returns (s: int, m: int)\n    ensures s == x + y\n    ensures m >= x && m >= y && (m == x || m == y)\n{\n    s := x + y;\n    if (x > y) {\n        m := x;\n    } else {\n        m := y;\n    }\n    return s, m;\n}"
},
{
    "dafny": "function{:opaque} f(x:int):int { x }\nlemma L()\n    ensures forall x:int :: f(x) == x\n{\n    forall x:int\n        ensures f(x) == x\n    {\n        reveal f();\n    }\n    assert forall x:int :: f(x) == x;\n}"
},
{
    "dafny": "method SquareRoot(N:nat) returns (r:nat)\n  ensures r*r <= N < (r+1)*(r+1)\n{\n  r:=0;\n  while (r+1)*(r+1)<=N\n    invariant r*r<=N\n  {\n    r:=r+1;\n  }\n}"
},
{
    "dafny": "method FindMax(a:array<int>) returns (maxIndex:nat)\n    requires a.Length > 0\n    ensures maxIndex<a.Length\n    ensures forall j:nat | j<a.Length :: a[j] <= a[maxIndex]\n{\n    var j:nat := 0;\n    var max := a[0];\n    maxIndex := 0;\n    while(j < a.Length) \n        invariant j <= a.Length\n        invariant maxIndex < a.Length\n        invariant forall k:nat | k<j :: max >= a[k]\n        invariant max == a[maxIndex]\n    {\n        if(a[j] > max) {\n            maxIndex := j;   \n            max := a[j];\n        }\n        j := j+1;\n    }\n}"
},
{
    "dafny": "predicate sorted (a: array<int>, lo: int, hi: int) \nreads a;\nrequires 0 <= lo <= hi <= a.Length;\n{\n\tforall i, j :: (lo <= i <= j < hi) ==> a[i] <= a[j]\n}\nmethod BubbleSort (a: array<int>) \nrequires a.Length >= 0;\nmodifies a;\nensures sorted (a, 0, a.Length);\nensures multiset (a[..]) == multiset (old(a[..]));\n{\n\tvar outer := a.Length;\n\twhile (outer > 0) \n\tinvariant outer >= 0;\n\tinvariant sorted (a, outer, a.Length);\n\tinvariant forall j, k :: 0 <= j < outer <= k < a.Length ==> a[j] <= a[k] \n\tinvariant multiset (old(a[..])) == multiset (a[..]);\n\tdecreases outer;\n\t{\n\t\tvar inner := 1;\n\t\twhile (inner < outer) \n\t\tinvariant 1 <= inner <= outer <= a.Length;\n\t\tinvariant sorted (a, outer, a.Length);\n\t\tinvariant forall j, k :: 0 <= j < outer <= k < a.Length ==> a[j] <= a[k] \n\t\tinvariant forall j :: 0 <= j < inner ==> a[j] <= a[inner-1];\n\t\tinvariant multiset (old(a[..])) == multiset (a[..]);\n\t\t{\n\t\t\tif (a[inner-1] > a[inner]) {\n\t\t\t\ta[inner], a[inner-1] := a[inner-1], a[inner];\n\t\t\t} \n\t\t\tinner := inner + 1;\n\t\t}\n\t\tassert (inner == outer);\n\t\touter := outer - 1;\n\t}\n}\nmethod Main()\n{\n\tvar a := new int[][];\n\tvar msa := multiset (a[..]);\n\tBubbleSort (a);\n\tassert (sorted (a, 0, a.Length));\n\tvar msa' := multiset (a[..]);\n\tassert (msa == msa');\n\tvar b:= new int[][0,1,2,3,4,5,6,7,8,9,10];\n\tvar msb := multiset (b[..]);\n\tBubbleSort (b);\n\tassert (sorted(b, 0, b.Length));\n\tvar msb' := multiset (b[..]);\n\tassert (msb == msb');\n\tvar c:= new int[][10,9,8,7,6,5,4,3,2,1,0];\n\tvar msc := multiset (c[..]);\n\tBubbleSort (c);\n\tassert (sorted (c, 0, c.Length));\n\tvar msc' := multiset (c[..]);\n\tassert (msc == msc');\n\tvar d:= new int[][6,3,4,5,8,9,10,2,1,0,7];\n\tvar msd := multiset (d[..]);\n\tBubbleSort (d);\n\tassert (sorted (d, 0, d.Length));\n\tvar msd' := multiset (d[..]);\n\tassert (msd == msd');\n}"
},
{
    "dafny": "function f(x: int): int { 10 - x * x }\nfunction BindingGuardTestStmt(): int {\n  var x: nat := 1;\n  assert true by {\n    if i :| 0 <= i < 10 && (f(i) == f(i+1) || f(i) == f(i+2)) {\n    }\n  }\n  2\n}\nfunction BindingGuardTestExpr(): int {\n  var x: nat := 1;\n  assert true by {\n    var x := if i :| 0 <= i < 10 && (f(i) == f(i+1) || f(i) == f(i+2)) then 1 else 0;\n  }\n  2\n}"
},
{
    "dafny": "predicate EOSorted(a: array?<int>)\n      reads a\n{\n    (a == null) || (a!= null && forall j :: 0 <= j < j + 2 < a.Length ==> a[j] <= a[j+2])\n} \nmethod Test(){\n  var a: array<int> := new int[6];\n  a[0],a[1],a[2],a[3],a[4],a[5] := 2,1,4,2,6,3;\n  assert a[0] == 2 && a[1] == 1 && a[2] == 4 && a[3] == 2 && a[4] == 6 && a[5] == 3;\n  assert EOSorted(a);\n  var a1: array<int> := new int[2];\n  a1[0],a1[1] := 1,2;\n  assert a1[0] == 1 && a1[1] == 2;\n  assert EOSorted(a1);\n  var a2: array<int> := new int[2];\n  a2[0],a2[1] := 2,1;\n  assert a2[0] == 2 && a2[1] == 1;\n  assert EOSorted(a2);\n  var a3 :array?<int>:= null;\n  assert a3 == null;\n  assert EOSorted(a3);\n  var a4 :array<int> := new int[][1,2,3,1];\n  assert a4[0] == 1 && a4[1] ==2 && a4[2] == 3 && a4[3] == 1;\n  assert !EOSorted(a4);\n}"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} Math {\n  function Min(a: int, b: int): int\n  {\n    if a < b\n    then a\n    else\n      b\n  }\n  function Max(a: int, b: int): int\n  {\n    if a < b\n    then b\n    else\n      a\n  }\n  function Abs(a: int): (a': int)\n    ensures a' >= 0\n  {\n    if a >= 0 then a else -a\n  }\n}"
},
{
    "dafny": "function Factorial(n: nat): nat {\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\nmethod IterativeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 1;\n  while i <= n\n    invariant i <= n + 1\n    invariant result == Factorial(i - 1)\n  {\n    result := result * i;\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "function sum(s:seq<int>, i:int, j:int) : int \n\trequires 0 <= i <= j <= |s|\n{\n\tif i == j then 0\n\telse sum(s, i, j-1) + s[j-1]\n}\nlemma sumL(s:seq<int>, i:int, j:int)\n\trequires 0 <= i <= j < |s|\n\tensures sum(s, i, j) + s[j] == sum(s, i, j+1)\n{\n}\npredicate isPrefixSumPred(s: seq<int>, n:int) {\n\texists j :: 0 <= j <= |s| && n == sum(s, 0, j)\n}\nmethod isPrefixSum(s: seq<int>, n: int) returns (found:bool)\n\tensures found ==> isPrefixSumPred(s, n)\n\tensures !found ==> !isPrefixSumPred(s, n)\n{\n\tvar j := 0;\n\tvar tentativeSum := 0;\n\tfound := (n == tentativeSum);\n\twhile (j < |s| && !found)\n\t\tdecreases |s| - j + (if found then 0 else 1)\n\t\tinvariant 0 <= j <= |s|\n\t\tinvariant tentativeSum == sum(s, 0, j)\n\t\tinvariant found ==> isPrefixSumPred(s, n)\n\t\tinvariant !found ==> forall j' :: 0 <= j' <= j ==> n != sum(s, 0, j')\n\t{\n\t\ttentativeSum := tentativeSum + s[j];\n\t\tj := j + 1;\n\t\tif (n == tentativeSum) {\n\t\t\tfound := true;\n\t\t} \n\t}\n}\npredicate isSubstringPred(s: seq<int>, n: int) {\n\texists l:: \t0 <= l <=|s| && isPrefixSumPred(s[l..], n)\n}\npredicate isNotSubstringPred(s: seq<int>, n: int) {\n\tforall i :: 0 <= i <=|s| ==> !isPrefixSumPred(s[i..], n)\n}\nlemma SubstringSumNegationLemma(s: seq<int>, n: int)\n\tensures isSubstringPred(s, n) <==>  !isNotSubstringPred(s,n)\n\t{}\nmethod isSubstringSum(s: seq<int>, n: int) returns (found:bool)\n\tensures found ==> isSubstringPred(s,n)\n\tensures !found ==> isNotSubstringPred(s,n)\n{\n\tif (n == 0) { \n\t\tassert n == sum(s, 0, 0);\n\t\tassert 0 <= 0 <=|s| && isPrefixSumPred(s[0..],n);\n\t\treturn true; \n\t}\n\tvar k := 0;\n\tfound := false;\n\twhile (k < |s| && !found)\n\t\tdecreases |s| - k + (if found then 0 else 1)\n\t\tinvariant 0 <= k <= |s|\n\t\tinvariant found ==> isPrefixSumPred(s[k..], n)\n\t\tinvariant !found ==> forall i :: 0 <= i < k ==> !isPrefixSumPred(s[i..], n)\n\t{\n\t\tfound := isPrefixSum(s[k..],n);\n\t\tif (!found) { k := k + 1; }\n\t}\n}"
},
{
    "dafny": "predicate isSortedRanged(a: array<int>, x1: nat, x2: nat)\n  requires 0 <= x1 <= x2 <= a.Length\n  reads a\n{\n    forall i, j :: x1 <= i < j < x2 ==> a[i] <= a[j] \n}\npredicate isSorted(a: array<int>)\n  reads a\n{\n    isSortedRanged(a, 0, a.Length)\n}\nmethod selectionSort(a: array<int>)\n    modifies a\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    ensures isSortedRanged(a, 0, a.Length) \n{\n    var i := 0; \n    while i < a.Length \n        decreases a.Length - i\n        invariant multiset(a[..]) == multiset(old(a[..]))\n        invariant 0 <= i <= a.Length\n        invariant isSortedRanged(a, 0, i)\n        invariant forall l, r :: 0 <= l < i <= r < a.Length ==> a[l] <= a[r] \n    {\n        var min_index := findMin(a, i, a.Length);\n        a[i], a[min_index] := a[min_index], a[i];\n        i := i + 1;\n    }\n}\nmethod findMin(a: array<int>, x1: nat, x2: nat) returns(index: nat)\n  requires 0 <= x1 < x2 <= a.Length\n  ensures x1 <= index < x2\n  ensures forall i :: x1 <= i < x2 ==> a[i] >= a[index]\n{\n    index := x1;\n    var i := x1;\n    while i < x2\n      decreases a.Length - i\n      invariant x1 <= i <= x2\n      invariant x1 <= index < x2\n      invariant forall x :: x1 <= x < i ==> a[x] >= a[index]  \n    {\n        if a[i] < a[index] {\n            index := i;\n        }\n        i := i + 1;\n    }\n}\nmethod Main() {\n  var a := new int[5];\n  a[0], a[1], a[2], a[3], a[4] := 5, 12, 4, 0, 4;\n  selectionSort(a);\n  assert isSorted(a);\n}"
},
{
    "dafny": "method Main() {\n\tvar a: array<int> := new int[4];\n\ta[0] := 7;\n\ta[1] := -2;\n\ta[2] := 3;\n\ta[3] := -2;\n\tassert a[..] == [7,-2,3,-2];\n\tvar s, p, c := SumProdAndCount(a, -2);\n\tassert a[0] == 7 && a[1] == -2 && a[2] == 3 && a[3] == -2;\n\tassert s == RecursiveSum(a, 0); \n\tassert p == RecursivePositiveProduct(a, 0); \n\tassert c == RecursiveCount(-2, a, 0); \n\tprint \"\\nThe sum of all elements in [7,-2,3,-2] is \";\n\tprint s;\n\tprint \"\\nThe product of all positive elements in [7,-2,3,-2] is \";\n\tprint p;\n\tprint \"\\nThe number of occurrences of -2 in [7,-2,3,-2] is \";\n\tprint c;\n}\nfunction RecursiveSum(a: array<int>, from: nat) : int\n\treads a\n\trequires a != null\n\trequires from <= a.Length\n\tdecreases a.Length-from\n{\n\tif from == a.Length then 0\n\telse a[from] + RecursiveSum(a, from+1)\n}\nfunction RecursivePositiveProduct(a: array<int>, from: nat) : int\n\treads a\n\trequires a != null\n\trequires from <= a.Length\n\tdecreases a.Length-from\n{\n\tif from == a.Length then 1\n\telse if a[from] <= 0 then RecursivePositiveProduct(a, from+1)\n\telse a[from] * RecursivePositiveProduct(a, from+1)\n}\nfunction RecursiveCount(key: int, a: array<int>, from: nat) : int\n\treads a\n\trequires a != null\n\trequires from <= a.Length\n\tdecreases a.Length-from\n{\n\tif from == a.Length then 0\n\telse if a[from] == key then 1+RecursiveCount(key, a, from+1)\n\telse RecursiveCount(key, a, from+1)\n}\nmethod SumProdAndCount(a: array<int>, key: int) returns (s: int, p: int, c: nat)\n\trequires a != null\n\tensures s == RecursiveSum(a, 0)\n\tensures p == RecursivePositiveProduct(a, 0)\n\tensures c == RecursiveCount(key, a, 0)\n  {\n    assert a != null;\n    var i : int := 0;\n    s,p,c:= 0, 1, 0;\n    assert Inv(a,key,i,s,p,c);\n    while (i < a.Length)\n    invariant Inv(a,key,i,s,p,c);\n    {\n      s:= s +a[i];\n      if a[i] == key\n      {\n        assert a[i] == key;\n        c:= c+1;\n      }\n      else\n      { \n      }\n      if a[i] > 0\n      {\n        assert a[i] > 0;\n        p:=p*a[i];\n      }\n      else\n      {\n      }\n      i:= i+1;\n      assert Inv(a,key,i,s,p,c);\n    }\n    assert i == a.Length;\n    assert Inv(a,key,i,s,p,c);\n    assert s == RecursiveSum(a, 0);\n    assert p == RecursivePositiveProduct(a, 0);\n    assert c == RecursiveCount(key, a, 0);\n  }\n  predicate Inv(a: array<int>, key: int, i: nat,s: int, p: int, c: nat)\n\treads a\n  requires a != null;\n{\n\t0 <= i <= a.Length &&\n  s +  RecursiveSum(a, i) == RecursiveSum(a, 0) &&\n  p*RecursivePositiveProduct(a, i) == RecursivePositiveProduct(a, 0) &&\n  c + RecursiveCount(key, a, i) == RecursiveCount(key, a, 0)\n}"
},
{
    "dafny": "method Q3(n0 : int, m0 : int) returns (res : int)\n  ensures res == n0 * m0;\n{\n  var n, m : int;\n  res := 0;\n  if (n0 >= 0) \n       {n,m := n0, m0;} \n  else \n       {n,m := -n0, -m0;}\n  while (0 < n)\n    invariant res + n * m == n0 * m0;\n    decreases n;\n  { \n    res := res + m; \n    n := n - 1; \n  }\n}"
},
{
    "dafny": "method Triple(x:int) returns (r:int)\n  ensures r>=3*x\n{\n  if(0 <= x)\n  {\n    var y := Double(x);\n    r := x + y;\n  } else {\n    var y := Double(-x);\n    r := x + y;\n  }\n}\nmethod Double(x:int) returns (r:int)\n  requires 0 <= x\n  ensures r >= 2*x\n{\n  r := x + x;\n}\nfunction Sum(x:nat): nat\nrequires x >= 0\ndecreases x - 1\n{\n  if x == 0 then 0 else x + Sum (x - 1)\n}\nmethod ComputeBigger(x:int, y:int) returns (b:int)\nrequires x != y\nensures b == y ==> y > x && b == x ==> x > y\n{\n  if x > y\n  {\n    b := x;\n  }\n  else\n  {\n    b := y;\n  }\n}\nmethod ComputeSum(x: nat) returns (s: nat)\nensures s == Sum(x)\n{\n  s := 0;\n  var cnt := 0;\n  while cnt != x\n    decreases x - cnt\n    invariant 0 <= cnt <= x\n    invariant s == Sum(cnt)\n  {\n    cnt := cnt + 1;\n    s := s + cnt;\n  }\n}"
},
{
    "dafny": "predicate bug(a: array<int>)\n  reads a\n{\n  forall i, j | 0 <= i <= j < a.Length :: a[i] <= a[j]\n}\nmethod Main() {\n  var a := new int[25](i => 2*i + 3);\n  var b := new int[25](i => var u := 2*i + 3; if i == 7 then 2 else u);\n  var c0 := bug(a);\n  var c1 := bug(b);\n  print c0, \" \", c1, \"\\n\"; \n}"
},
{
    "dafny": "ghost predicate Bit(k: nat, n: nat)\n{\n  if k == 0 then n % 2 == 1\n  else Bit(k-1, n / 2)\n}\nghost function BitSet(n: nat): set<nat>\n{\n  set i | 0 <= i < n && Bit(i, n)\n}\nlemma BitSize(i: nat, n: nat)\n  requires Bit(i, n)\n  ensures i < n\n{\n}\nghost predicate EVEN(n: nat)\n{\n  n % 2 == 0\n}\nghost function binom(a: nat, b: nat): nat\n{\n  if b == 0 then 1\n  else if a == 0 then 0\n  else binom(a-1, b) + binom(a-1, b-1)\n}\nlemma Lucas_Binary''(a: nat, b: nat)\n  ensures binom(a, b) % 2 == if EVEN(a) && !EVEN(b) then 0 else binom(a / 2, b / 2) % 2\n{\n  if a == 0 || b == 0 {\n  } else {\n    Lucas_Binary''(a - 1, b);\n    Lucas_Binary''(a - 1, b - 1);\n  }\n}\nghost function Suc(S: set<nat>): set<nat>\n{\n  set x | x in S :: x + 1\n}\nlemma SucElements(S: set<nat>)\n  ensures forall x :: x in S <==> (x+1) in Suc(S)\n{\n}\nlemma BitSet_Property(n: nat)\n  ensures BitSet(n) - {0} == Suc(BitSet(n / 2))\n{\n  if n == 0 {\n  } else {\n    forall x: nat {\n      calc {\n        x in BitSet(n) - {0};\n      ==\n        x != 0 && x in BitSet(n);\n      ==  \n        0 < x < n && Bit(x, n);\n      ==  \n        0 < x < n && Bit(x-1, n / 2);\n      ==  { if 0 < x && Bit(x-1, n / 2) { BitSize(x-1, n / 2); } }\n        0 <= x-1 < n / 2 && Bit(x-1, n / 2);\n      ==  \n        (x-1) in BitSet(n / 2);\n      ==  { SucElements(BitSet(n / 2)); }\n        x in Suc(BitSet(n / 2));\n      }\n    }\n  }\n}\nlemma Lucas_Theorem'(m: nat, n: nat)\n  ensures BitSet(m) <= BitSet(n) <==> !EVEN(binom(n, m))\n{\n  if m == 0 && n == 0 {\n  } else if EVEN(n) && !EVEN(m) {\n    calc {\n      !EVEN(binom(n, m));\n    ==  { Lucas_Binary''(n, m); }\n      false;\n    ==  { assert 0 in BitSet(m) && 0 !in BitSet(n); }\n      BitSet(m) <= BitSet(n);\n    }\n  } else {\n    var m', n' := m/2, n/2;\n    calc {\n      !EVEN(binom(n, m));\n    ==  { Lucas_Binary''(n, m); }\n      !EVEN(binom(n', m'));\n    ==  { Lucas_Theorem'(m', n'); }\n      BitSet(m') <= BitSet(n');\n    ==  { SucElements(BitSet(m')); SucElements(BitSet(n')); }\n      Suc(BitSet(m')) <= Suc(BitSet(n'));\n    ==  { BitSet_Property(m); BitSet_Property(n); }\n      BitSet(m) - {0} <= BitSet(n) - {0};\n    ==  { assert 0 !in BitSet(m) ==> BitSet(m) == BitSet(m) - {0};\n          assert 0 in BitSet(n) ==> BitSet(n) - {0} <= BitSet(n); }\n      BitSet(m) <= BitSet(n);\n    }\n  }\n}"
},
{
    "dafny": "method ComputeAvg(a: int, b: int) returns (avg:int)\n  ensures avg == (a+b)/2\n{\n  avg:= (a + b) / 2;\n}\nmethod TestComputeAvg(){\n  var test1 := ComputeAvg(2, 2);\n  print(\"Test 1: ComputeAvg(2, 2) = \", test1, \"\\n\");\n  var test2 := ComputeAvg(7, 3);\n  print(\"Test 2: ComputeAvg(7, 3) = \", test2, \"\\n\");\n  var test3 := ComputeAvg(100, 200);\n  print(\"Test 3: ComputeAvg(100, 200) = \", test3, \"\\n\");\n  var test4 := ComputeAvg(0, 0);\n  print(\"Test 4: ComputeAvg(0, 0) = \", test4, \"\\n\");\n  var test5 := ComputeAvg(-7, -2);\n  print(\"Test 5: ComputeAvg(-7, -2) = \", test5, \"\\n\");\n}\nmethod Main(){\n  TestComputeAvg();\n}"
},
{
    "dafny": "class Blood {\n    var add_time: int;\n    var use_by: int; \n    var state: int;\n    var test_state: int;\n    var blood_type: string;\n    var id: int;\n    predicate Valid()\n    reads this\n    {\n        state >= 1 && state <= 4 && test_state >=1 && test_state <= 3\n    }\n    constructor(id: int)\n    ensures Valid();\n    modifies this;\n    ensures use_by == -1 && state == 1 && test_state == 1 && id == this.id;\n    {\n        use_by := -1;\n        state := 1;\n        test_state := 1;\n        this.id := id;\n    }\n}"
},
{
    "dafny": "predicate sorted(a: array<int>)\n    reads a\n{\n    forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod m()\n{\n    var a: array<int> := new int[] [1, 2, 3, 4];\n    assert sorted(a);\n}"
},
{
    "dafny": "method filter(a:seq<array<int>>, attribute: int, value: int) returns (filtered: seq<array<int>>)\n  requires a != [] && |a| > 0;\n  requires forall k :: 0 <= k < |a| ==> a[k] != null && a[k].Length == 5;\n  requires 0 <= attribute < 5;\n  ensures forall k: int :: (0 <= k < |a| ==> ((a[k][attribute] == value) ==> a[k] in filtered));\n  ensures forall k: int :: (0 <= k < |filtered| ==> (filtered[k] != null && filtered[k].Length == 5));\n  ensures forall k: int :: (0 <= k < |filtered| ==> filtered[k] in multiset(a[..]));\n{\n  var i : int := 0;\n  filtered := [];\n  while (i < |a|)\n    invariant 0 <= i <= |a|;\n    invariant forall k: int :: (0 <= k < i ==> ((a[k][attribute] == value) ==> a[k] in filtered));\n    invariant forall k: int :: (0 <= k < |filtered| ==> (filtered[k] != null && filtered[k].Length == 5));\n    invariant forall k: int :: (0 <= k < |filtered| ==> filtered[k] in multiset(a[..]));\n  {\n    if (a[i][attribute] == value) \n    { \n      filtered := filtered + [a[i]];\n    }\n    i := i + 1;\n  }\n}\nmethod Main() {\n  var a1: array<int> := new int[5];\n  a1[0], a1[1], a1[2], a1[3], a1[4] := 0, 10, 20, 30, 40;\n  var a2: array<int> := new int[5];\n  a2[0], a2[1], a2[2], a2[3], a2[4] := 1, 11, 23, 31, 41;\n  var a3: array<int> := new int[5];\n  a3[0], a3[1], a3[2], a3[3], a3[4] := 2, 11, 22, 32, 42;\n  var a4: array<int> := new int[5];\n  a4[0], a4[1], a4[2], a4[3], a4[4] := 3, 11, 23, 33, 43;\n  var deposits: seq<array<int>> := [];\n  deposits := deposits + [a1] + [a2] + [a3] + [a4];\n  var i: seq<array<int>> := filter(deposits,1,11);\n  var j : int := 0;\n  while (j < |i|) {\n    var k : int := 0;\n    while (k < i[j].Length) {\n      print i[j][k];\n      print ' ';\n      k := k + 1;\n    }\n    print '\\n';\n    j := j + 1;\n  }\n}"
},
{
    "dafny": "method LinearSearch(a: array<int>, key: int) returns (n: nat)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || a[n] == key\n{\n  n := 0;\n  while n < a.Length\n    invariant n <= a.Length \n  {\n    if a[n] == key {\n      return;\n    }\n    n := n + 1;\n  }\n}\nmethod PrintArray<A>(a: array?<A>) {\n  if (a == null) {\n    print \"It's null\\n\";\n  } else {\n    var i := 0;\n    while i < a.Length {\n      print a[i], \" \";\n      i := i + 1;\n    }\n    print \"\\n\";\n  }\n}\nmethod Main() {\n  var a := new int[23];\n  var i := 0;\n  while i < 23 {\n    a[i] := i;\n    i := i + 1;\n  }\n  PrintArray(a);\n  var n := LinearSearch(a, 17);\n  print n, \"\\n\";\n  var s : seq<int> := a[..];\n  print s, \"\\n\";\n  s := a[2..16];\n  print s, \"\\n\";\n  s := a[20..];\n  print s, \"\\n\";\n  s := a[..8];\n  print s, \"\\n\";\n  a[0] := 42;\n  print s, \"\\n\";\n  MultipleDimensions();\n}\nmethod PrintMatrix<A>(m: array2<A>) {\n  var i := 0;\n  while i < m.Length0 {\n    var j := 0;\n    while j < m.Length1 {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n   print \"\\n\";\n   i := i + 1;\n  }\n}\nmethod MultipleDimensions() {\n  var matrix := new int[2,8];\n  PrintMatrix(matrix);\n  var jagged := new array<int>[5];\n  var i := 0;\n  while i < 5 {\n    jagged[i] := new int[i];\n    i := i + 1;\n  }\n  PrintArrayArray(jagged);\n}\nmethod PrintArrayArray<A>(a: array<array<A>>) {\n  var i := 0;\n  while i < a.Length {\n    print a[i][..], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}"
},
{
    "dafny": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  if {\n    case x<18 =>\n      var a,b := 2*x, 4*x;\n      r:=(a+b)/2;\n    case 0<=x =>\n      var y:=2*x;\n      r:= x+y;\n  }\n}\nmethod TestTriple() {\n  var test1 := Triple(1);\n  print(\"Test 1: Triple(1) = \", test1, \"\\n\");\n  var test2 := Triple(2);\n  print(\"Test 2: Triple(2) = \", test2, \"\\n\");\n  var test3 := Triple(-2);\n  print(\"Test 3: Triple(-2) = \", test3, \"\\n\");\n  var test4 := Triple(0);\n  print(\"Test 4: Triple(0) = \", test4, \"\\n\");\n  var test5 := Triple(100);\n  print(\"Test 5: Triple(100) = \", test5, \"\\n\");\n}\nmethod Main() {\n  TestTriple();\n}"
},
{
    "dafny": "module ackermann{ \nmethod Ackermann(m: int, n: int)returns (y:int)\n\tdecreases m, n{\n\tif m <= 0 {\n\t\ty := n + 1;\n\t\treturn y;\n\t} else if n <= 0 {\n\t\ty := Ackermann(m-1, 1);\n\t\treturn y;\n\t} else {\n\t\tvar x := Ackermann(m, n-1);\n\t\ty := Ackermann(m-1, x);\n\t\treturn y;\n\t}\n}\n}"
},
{
    "dafny": "method Main() {\n  print(\"start\\n\");\n  var p : Publisher := new Publisher(100);\n  var a : Advertise := new Advertise();\n  print(p);\n  print(\"\\n\");\n  print(a.ads);\n  print(\"\\n\");\n  print(p.payment);\n  print(\"\\n\");\n  print(p !in a.ads);\n  print(\"\\n\");\n  print(\"end\\n\");\n}\nclass Advertise {\n  var availableWebsites: seq<Website>;\n  var ads: map <Publisher, Website>; \n  constructor()\n  modifies this;\n  {\n    availableWebsites := [];\n    ads := map[];\n  }\n  method startPublish(publisher: Publisher) \n  modifies this; \n  requires publisher !in ads; \n  {\n    if (availableWebsites != []) {\n      ads := ads[publisher := availableWebsites[0]]; \n      availableWebsites := availableWebsites[1..]; \n    }\n    else {\n    }\n  }\n  method stopPublish(publisher: Publisher)\n  modifies this;\n  requires publisher in ads; \n  {\n    availableWebsites := availableWebsites + [ads[publisher]]; \n    ads:= map p | p in ads && p != publisher :: ads[p]; \n  }\n  method addWebsite (website: Website)\n  modifies this;\n  {\n    availableWebsites := availableWebsites + [website];\n  }\n  method removeWebsite(website: Website)\n  modifies this;\n  {\n  }\n}\nclass Publisher \n{  \n  var payment : int;\n  constructor(p : int)\n  modifies this;\n  {\n    payment := p;\n  }\n}\nclass Website \n{\n}"
},
{
    "dafny": "newtype int32 = x | -0x80000000 <= x < 0x80000000\nfunction double1(x: int): int\n{\n    x * 2\n}\nfunction double2(x: int): int\n{\n    x + x\n}\nmethod Testing()\n{\n    assert forall x: int :: double1(x) == double2(x);\n}"
},
{
    "dafny": "method M()\n{\n  if (*)\n  {\n  }\n  else\n  {\n    assert 0 == 0;\n  }\n}"
},
{
    "dafny": "module Utils {\n  class Assertions<T> {\n    static method {:extern} assertEquals(expected : T, actual : T)\n    requires expected == actual\n    static method {:extern} expectEquals(expected : T, actual : T)\n    ensures expected == actual\n    static method {:extern} assertTrue(condition : bool)\n    requires condition\n    static method {:extern} expectTrue(condition : bool)\n    ensures condition\n    static method {:extern} assertFalse(condition : bool)\n    requires !condition\n    static method {:extern} expectFalse(condition : bool)\n    ensures !condition\n  }\n}"
},
{
    "dafny": "function numNeg(xs: seq<int>): nat\n{\n\tif xs == [] then\n\t\t0\n\telse\n\t\t(if xs[0] < 0 then 1 else 0) + numNeg(xs[1..])\n}\nmethod shortestPath(graph: array2<bool>, src: int, dst: int) returns (dist: int)\n\trequires graph != null && graph.Length0 == graph.Length1\n\trequires 0 <= src < graph.Length0\n\trequires 0 <= dst < graph.Length0\n{\n\tvar numVerts := graph.Length0;\n\tvar dists := new int[numVerts];\n\tvar i := 0;\n\twhile i < numVerts\n\t{\n\t\tdists[i] := -1;\n\t\ti := i + 1;\n\t}\n\tvar queue := [src];\n\tdists[src] := 0;\n\twhile queue != []\n\t\tinvariant forall i | 0 <= i < |queue| :: 0 <= queue[i] < numVerts && dists[queue[i]] >= 0\n\t\tdecreases numNeg(dists[..]), |queue|\n\t{\n\t\tghost var nn := numNeg(dists[..]);\n\t\tghost var queueLen := |queue|;\n\t\tvar v1 := queue[0];\n\t\tqueue := queue[1..];\n\t\tvar v2 := 0;\n\t\twhile v2 < numVerts\n\t\t\tinvariant dists[v1] >= 0\n\t\t\tinvariant forall i | 0 <= i < |queue| :: 0 <= queue[i] < numVerts && dists[queue[i]] >= 0\n\t\t\tinvariant (|queue| == queueLen - 1 && numNeg(dists[..]) == nn) || numNeg(dists[..]) < nn\n\t\t{\n\t\t\tif graph[v1, v2] && (dists[v2] == -1 || dists[v1] < dists[v2])\n\t\t\t{\n\t\t\t\tif (dists[v2] == -1)\n\t\t\t\t{\n\t\t\t\t\tlemma1(dists[..], v2, dists[v1] + 1);\n\t\t\t\t\tqueue := [v2] + queue;\n\t\t\t\t\tdists[v2] := dists[v1] + 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlemma2(dists[..], v2, dists[v1] + 1);\n\t\t\t\t\tdists[v2] := dists[v1] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv2 := v2 + 1;\n\t\t}\n\t}\n\treturn dists[dst];\n}\nlemma lemma1(xs: seq<int>, i: int, v: int)\n\trequires 0 <= i < |xs| && xs[i] == -1 && v >= 0\n\tensures numNeg(xs[i := v]) < numNeg(xs)\n{\n\tif i == 0\n\t{\n\t\tassert numNeg(xs[i := v]) == numNeg(xs) - 1;\n\t}\n\telse\n\t{\n\t\tassert numNeg(xs[i := v]) == (if xs[0] < 0 then 1 else 0) + numNeg(xs[i := v][1..]);\n\t\tassert numNeg(xs[i := v]) == (if xs[0] < 0 then 1 else 0) + numNeg(xs[1..][i - 1 := v]);\n\t\tlemma1(xs[1..], i - 1, v);\n\t\tassert numNeg(xs[1..][i - 1 := v]) < numNeg(xs[1..]);\n\t\tassert numNeg(xs[i := v][1..]) < numNeg(xs[1..]);\n\t\tassert numNeg(xs[i := v]) < numNeg(xs);\n\t}\n}\nlemma lemma2(xs: seq<int>, i: int, v: int)\n\trequires 0 <= i < |xs| && xs[i] >= 0 && v >= 0\n\tensures numNeg(xs[i := v]) == numNeg(xs)\n{\n\tif i == 0\n\t{\n\t\tassert numNeg(xs[i := v]) == numNeg(xs);\n\t}\n\telse\n\t{\n\t\tassert numNeg(xs[i := v]) == (if xs[0] < 0 then 1 else 0) + numNeg(xs[i := v][1..]);\n\t\tassert numNeg(xs[i := v]) == (if xs[0] < 0 then 1 else 0) + numNeg(xs[1..][i - 1 := v]);\n\t\tlemma2(xs[1..], i - 1, v);\n\t\tassert numNeg(xs[1..][i - 1 := v]) == numNeg(xs[1..]);\n\t\tassert numNeg(xs[i := v][1..]) == numNeg(xs[1..]);\n\t\tassert numNeg(xs[i := v]) == numNeg(xs);\n\t}\n}"
},
{
    "dafny": "type G(==)\nghost predicate IsFilter(f: set<set<G>>, S: set<G>)\n{\n  (forall A, B :: A in f && A <= B ==> B in f) &&\n  (forall C, D :: C in f && D in f ==> C * D in f) &&\n  S in f &&\n  {} !in f\n}\nghost predicate IsUltraFilter(f: set<set<G>>, S: set<G>)\n{\n  IsFilter(f, S) &&\n  (forall g :: IsFilter(g, S) && f <= g ==> f == g)\n}\nlemma Theorem(f: set<set<G>>, S: set<G>, M: set<G>, N: set<G>)\n  requires IsUltraFilter(f, S)\n  requires M + N in f\n  ensures M in f || N in f\n{\n  if M !in f {\n    var h := H(f, S, M);\n    Lemma_HIsFilter(h, f, S, M);\n    Lemma_FHOrdering(h, f, S, M);\n  }\n}\nlemma H(f: set<set<G>>, S: set<G>, M: set<G>) returns (h: set<set<G>>)\n  ensures forall X :: X in h <==> M + X in f\n{\n  h := set X,Y | Y in f && X <= Y && M + X == Y :: X;\n  forall X {\n    calc {\n      X in h;\n      exists Y :: Y in f && X <= Y && M + X == Y;\n      M + X in f;\n    }\n  }\n}\nlemma Lemma_HIsFilter(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)\n  requires IsFilter(f, S)\n  requires forall X :: X in h <==> M + X in f\n  requires M !in f\n  ensures IsFilter(h, S)\n{\n  forall A, B | A in h && A <= B\n    ensures B in h\n  {\n    assert M + A <= M + B;\n  }\n  forall C, D | C in h && D in h\n    ensures C * D in h\n  {\n    assert (M + C) * (M + D) == M + (C * D);\n  }\n  Lemma_H2(h, f, S, M);\n  Lemma_H3(h, f, S, M);\n}\nlemma Lemma_H2(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)\n  requires IsFilter(f, S)\n  requires forall X :: X in h <==> M + X in f\n  ensures S in h\n{\n  assume M <= S;\n  assert M + S == S;\n}\nlemma Lemma_H3(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)\n  requires IsFilter(f, S)\n  requires forall X :: X in h <==> M + X in f\n  requires M !in f\n  ensures {} !in h\n{\n  assert M + {} == M;\n}\nlemma Lemma_FHOrdering(h: set<set<G>>, f: set<set<G>>, S: set<G>, M: set<G>)\n  requires IsFilter(f, S)\n  requires forall X :: X in h <==> M + X in f\n  requires IsFilter(h, S)\n  ensures f <= h\n{\n  forall Y | Y in f\n    ensures Y in h\n  {\n  }\n}"
},
{
    "dafny": "class Score{\n  var highestScore: int;\n   predicate Valid() \n   reads this;\n  { highestScore >= 0 }\n  constructor()\n    ensures Valid();\n    ensures highestScore == 0;\n  {\n    highestScore := 0;\n  }\n  method NewScore(s: int)returns(b: bool,current: int)\n  modifies this;\n  requires s >= 0 && Valid();\n  ensures Valid();\n  ensures ((s > old(highestScore)) ==> (b == true && current == highestScore == s)) && ((s <= old(highestScore)) ==> (b == false && current == old(highestScore) == highestScore));\n  {\n    if( s > highestScore){\n      this.highestScore:= s;\n      b:= true;\n      current:= this.highestScore;\n      return b,current;\n    }\n    else{\n      current:= highestScore;\n      b:= false;\n      return b,current;\n    }\n  }\n}\nmethod TestScore(){\n  var s := new Score();\n  var s1 := 0;\n  assert s1 == 0;\n  var b,current := s.NewScore(s1);\n  assert b == false && current == 0; \n  var s2 := 2;\n  assert s2 == 2;\n  var b1,current1 := s.NewScore(s2);\n  assert b1 == true && current1 == 2;\n  assert s1 == 0;\n  var b2,current2 := s.NewScore(s1);\n  assert b2 == false && current2 == 2;\n  var s3 := 4;\n  assert s3 == 4;\n  var b3,current3 := s.NewScore(s3);\n  assert b3 == true && current3 == 4;\n  var b4,current4 := s.NewScore(s3);\n  assert b4 == false && current4 == 4;\n  var s4 := 6;\n  var b5,current5 := s.NewScore(s4);\n  assert b5 == true && current5 == 6;\n  assert s.highestScore == 6;\n}"
},
{
    "dafny": "function f(n: nat): int\n{\n    if n <= 1 then 1-n else 2*f(n-1) + f(n-2) + n\n}\nmethod computeF(n: nat) returns (a: int)\nensures a == f(n)\n{\n    var x := 0;\n    var y := 1;\n    var k := 0;\n    while k < n\n    invariant x == f(k+1) && y == f(k)\n    invariant 0 <= k <= n\n    decreases n-k\n    {\n        assert f(k+2) == 2*f(k+1) + f(k) + k+2;\n        assert x == f(k+1) && y == f(k);\n        assert f(k+2) == 2*x + y + k+2;\n        x, y := 2*x+y+k+2, x;\n        assert x == f(k+2) && y == f(k+1);\n        k := k + 1;\n        assert x == f(k+1) && y == f(k);\n    }\n    assert k == n;\n    assert x == f(n+1) && y == f(n);\n    a := y;\n}"
},
{
    "dafny": "method Main()\n{\n    var a := new int[5];\n    a[0] := 0;\n    a[1] := 1;\n    a[2] := 2;\n    a[3] := 3;\n    a[4] := 4;\n    assert 5 !in a[..]; \n    var s := a[..]; \n    assert a[..] == [0,1,2,3,4];\n    assert a[1..3] == [1,2];\n    assert a[2..] == [2,3,4];\n    assert a[..2] == [0,1];\n}"
},
{
    "dafny": "module DafnyPatches_s {\nlemma setSizeRelation<T>(a:set<T>, b:set<T>)\n    requires a <= b;\n    ensures |a| <= |b|;\n{\n    assume false;\n}\nlemma singletonExtensionality<T>(t:T, s:set<T>)\n    requires t in s\n    requires |s| == 1\n    ensures s == {t}\n{\n    var v := {t};\n    forall u: T\n        ensures (u in s) == (u in v);\n    {\n        if (u != t) {\n            if (u in s) {\n                setSizeRelation({t,u}, s);\n            }\n        }\n    }\n}\nlemma functionExtensionality<T,U>(f:T->U, g:T->U)\n    requires forall t :: f(t) == g(t)\n    ensures f == g\n{\n    assume false;\n}\nlemma notExists<T>(P : T -> bool)\n    ensures !(forall j :: !P(j)) == exists j :: P(j);\n{\n}\n}"
},
{
    "dafny": "module Math__mul_nonlinear_i {\nlemma lemma_mul_strictly_positive(x:int, y:int)\n    ensures (0 < x && 0 < y) ==> (0 < x*y);\n{}\nlemma lemma_mul_nonzero(x:int, y:int)\n    ensures x*y != 0 <==> x != 0 && y != 0;\n{}\nlemma lemma_mul_is_associative(x:int, y:int, z:int)\n    ensures x * (y * z) == (x * y) * z;\n{}\nlemma lemma_mul_is_distributive_add(x:int, y:int, z:int)\n    ensures x*(y + z) == x*y + x*z;\n{}\nlemma lemma_mul_ordering(x:int, y:int)\n    requires 0 < x;\n    requires 0 < y;\n    requires 0 <= x*y;\n    ensures x <= x*y && y <= x*y;\n{ }\nlemma lemma_mul_strict_inequality(x:int, y:int, z:int)\n    requires x < y;\n    requires z > 0;\n    ensures  x*z < y*z;\n{}\n}"
},
{
    "dafny": "module {:options \"--function-syntax=4\"} Stacks {\n  export\n    reveals Stack\n    provides Stack.Valid, Stack.Repr, Stack.Elements\n    reveals Stack.Count\n    provides Stack.Push, Stack.Pop\n  datatype MaybeInitialized<T> = ghost Uninitialized | Initialized(value: T)\n  class Stack<T> {\n    ghost var Repr: set<object>\n    ghost var Elements: seq<T>\n    ghost predicate Valid()\n      reads this, Repr\n      ensures Valid() ==> this in Repr\n    {\n      this in Repr &&\n      arr in Repr &&\n      n == |Elements| <= arr.Length != 0 &&\n      forall i :: 0 <= i < n ==>\n        arr[i].Initialized? && arr[i].value == Elements[i]\n    }\n    var arr: array<MaybeInitialized<T>>\n    var n: nat\n    constructor ()\n      ensures Valid() && fresh(Repr) && Elements == []\n    {\n      Elements, n := [], 0;\n      arr := new [20];\n      Repr := {this, arr};\n    }\n    function Count(): nat\n      requires Valid()\n      reads Repr\n    {\n      |Elements|\n    } by method {\n      return n;\n    }\n    method Push(t: T)\n      requires Valid()\n      modifies Repr\n      ensures Valid() && fresh(Repr - old(Repr))\n      ensures Elements == old(Elements) + [t]\n    {\n      if n == arr.Length {\n        var a := new [2 * n];\n        forall i | 0 <= i < n {\n          a[i] := arr[i];\n        }\n        arr := a;\n        Repr := Repr + {a};\n      }\n      arr[n] := Initialized(t);\n      Elements, n := Elements + [t], n + 1;\n    }\n    method Pop() returns (t: T)\n      requires Valid() && Elements != []\n      modifies Repr\n      ensures Valid() && fresh(Repr - old(Repr))\n      ensures var last := |old(Elements)| - 1;\n        t == old(Elements)[last] &&\n          Elements == old(Elements)[..last]\n    {\n      n := n - 1;\n      Elements := Elements[..n];\n      t := arr[n].value;\n    }\n  }\n}\ntype Empty = x: int | false witness *\nmethod Main() {\n  var s := new Stacks.Stack();\n  s.Push(10);\n  s.Push(12);\n  s.Push(11);\n  var x := s.Pop();\n  assert s.Elements == [10, 12] && x == 11;\n  var count := s.Count();\n  assert count == 2;\n  print x, \" \", count, \"\\n\"; \n  var s' := new Stacks.Stack<Empty>();\n  count := s'.Count();\n  assert count == 0;\n  print count, \"\\n\"; \n  EnumerationTests.Test();\n  DestructorTests.Test();\n  Arrays.Test();\n}\nmodule {:options \"/functionSyntax:4\"} EnumerationTests {\n  datatype Enum = ghost EnumA | EnumB\n  {\n    const N := 13\n    predicate Is(n: nat) {\n      N == n\n    }\n  }\n  datatype AllGhost = ghost Ctor0 | ghost Ctor1\n  {\n    const N := 13\n    predicate Is(n: nat) {\n      N == n\n    }\n    method CheckIs(n: nat) returns (r: bool) {\n      r := N == n;\n    }\n  }\n  method Test() {\n    var e := PickEnumValue();\n    var s: seq<Enum>;\n    s := [e];\n    print |s|, \"\\n\"; \n    var g, sg;\n    g := PickAllGhostValue();\n    sg := [g];\n    print |sg|, \"\\n\"; \n  }\n  method PickEnumValue() returns (r: Enum) {\n    if e: Enum :| e.Is(13) {\n      r := e;\n    } else {\n      r := *;\n    }\n  }\n  method PickAllGhostValue() returns (r: AllGhost) {\n    if ag: AllGhost :| ag.Is(13) {\n      r := ag;\n    } else {\n      r := *;\n    }\n  }\n}\nmodule {:options \"/functionSyntax:4\"} DestructorTests {\n  datatype WithCommonDestructors<A, B> =\n    | CtorA(a: A, x: int)\n    | ghost CtorAB(a: A, b: B)\n    | CtorB(b: B, y: int, ghost z: int)\n  method Test() {\n    var wcd := CtorA(true, 7);\n    print wcd.a, \" \"; \n    wcd := wcd.(a := false);\n    print wcd.a, \" \", wcd.x, \"\\n\"; \n    wcd := CtorB(2.11, 9, 100);\n    print wcd.b, \" \"; \n    wcd := wcd.(b := 2.13);\n    print wcd.b, \" \", wcd.y, \"\\n\"; \n    wcd := wcd.(y := 11, z := 101);\n    print wcd.y, \" \"; \n    wcd := wcd.(z := 102, y := 12);\n    print wcd.y, \" \"; \n    wcd := wcd.(z := 103);\n    print wcd.y, \"\\n\"; \n  }\n}\nmodule {:options \"/functionSyntax:4\"} WhiteBoxTests {\n  datatype List = Nil | Nilly(x: int) | Konstig(ghost head: int, tail: List)\n  type RestrictedList = xs: List | xs == Nilly(2) witness *\n  method M(xs: RestrictedList) returns (b: bool) {\n    b := xs == Nilly(2);\n  }\n}\nmodule ConstraintsAreGhost {\n  datatype A = ghost MakeA(x: int)\n  type B = a: A | a.x == 0 ghost witness MakeA(0)\n  datatype R = R(ghost x: int)\n  type S = r: R | r.x == 0 witness R(0)\n  datatype List = Nil | ghost Konstig(ghost head: int, tail: List)\n  type RestrictedList = xs: List | xs.Konstig? ghost witness Konstig(0, Nil)\n}\nmodule Arrays {\n  datatype MaybeInitialized<T> = ghost Uninitialized | Initialized(value: T)\n  datatype Singleton<X> = Single(X)\n  type Synonym = MaybeInitialized<Class>\n  class Class { }\n  method Test() {\n    M<bv5>();\n    var st := new Stack(5 as bv5);\n    st.U(6);\n    Print(st.arr, \" | \");\n    Print(st.trr, \" | \");\n    Print(st.brr, \"\\n\");\n  }\n  method M<T>() {\n    var arr := new MaybeInitialized<T>[20]; \n    var srr := new Singleton<MaybeInitialized<T>>[20]; \n    var yrr := new Synonym[20]; \n    var trr := new (ghost bool, ghost real, Singleton<MaybeInitialized<T>>, ghost int)[20]; \n    print arr.Length + srr.Length + yrr.Length + trr.Length, \"\\n\"; \n  }\n  method Print<X>(x: array<X>, suffix: string) {\n    if x.Length != 0 {\n      print x[x.Length / 2], suffix;\n    }\n  }\n  class Stack<T> {\n    var arr: array<MaybeInitialized<T>>\n    var trr: array<T>\n    var brr: array<bool>\n    var arr2: array2<MaybeInitialized<T>>\n    var trr2: array2<T>\n    var brr2: array2<bool>\n    constructor (t: T)\n      ensures fresh(arr) && fresh(trr) && fresh(brr)\n    {\n      arr := new [20];\n      trr := new [20](_ => t);\n      brr := new [20];\n    }\n    method U(t: T)\n      modifies this, arr, trr, brr\n    {\n      arr := Update(arr, Initialized(t));\n      trr := Update(trr, t);\n      brr := Update(brr, true);\n    }\n  }\n  method Update<T>(a: array<T>, t: T) returns (r: array<T>)\n    modifies a\n  {\n    if a.Length != 0 {\n      a[a.Length / 2] := t;\n    }\n    r := a;\n  }\n}"
},
{
    "dafny": "abstract module M0 {\n  class Counter {\n    ghost var N: int\n    ghost var Repr: set<object>\n    ghost predicate Valid()\n      reads this, Repr\n      ensures Valid() ==> this in Repr\n    constructor Init()\n      ensures N == 0\n      ensures Valid() && fresh(Repr)\n    {\n      Repr := {};\n      new;\n      ghost var repr :| {this} <= repr && fresh(repr - {this});\n      N, Repr := 0, repr;\n      assume Valid();  \n    }\n    method Inc()\n      requires Valid()\n      modifies Repr\n      ensures N == old(N) + 1\n      ensures Valid() && fresh(Repr - old(Repr))\n    {\n      N := N + 1;\n      modify Repr - {this};\n      assume Valid();  \n    }\n    method Get() returns (n: int)\n      requires Valid()\n      ensures n == N\n    {\n      n :| assume n == N;\n    }\n  }\n}\nmodule M1 refines M0 {\n  class Cell {\n    var data: int\n    constructor (d: int)\n      ensures data == d\n    { data := d; }\n  }\n  class Counter ... {\n    var c: Cell\n    var d: Cell\n    ghost predicate Valid...\n    {\n      this in Repr &&\n      c in Repr &&\n      d in Repr &&\n      c != d &&\n      N == c.data - d.data\n    }\n    constructor Init...\n    {\n      c := new Cell(0);\n      d := new Cell(0);\n      new;\n      ghost var repr := Repr + {this} + {c,d};\n      ...;\n      assert ...;\n    }\n    method Inc...\n    {\n      ...;\n      modify ... {\n        c.data := c.data + 1;\n      }\n      assert ...;\n    }\n    method Get...\n    {\n      n := c.data - d.data;\n    }\n  }\n}\nmethod Main() {\n  var mx := new M1.Counter.Init();\n  var my := new M1.Counter.Init();\n  assert mx.N == 0 && my.N == 0;\n  mx.Inc();\n  my.Inc();\n  mx.Inc();\n  var nx := mx.Get();\n  var ny := my.Get();\n  assert nx == 2 && ny == 1;\n  print nx, \" \", ny, \"\\n\";\n}"
},
{
    "dafny": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures n==a.Length ==> forall i::0<=i<a.Length ==> e!=a[i]\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j::0<=j<i ==> a[j] != e\n  {\n    if a[i] == e {\n      return i;\n    }\n    i := i + 1;\n  }\n  return a.Length;\n}"
},
{
    "dafny": "function Factorial(n: int): int\n  requires n >= 0\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}\nmethod LoopyFactorial(n: int) returns (u: int)\n  requires n >= 0\n  ensures u == Factorial(n)\n  {\n    u := 1;\n    var r := 0;\n    while (r < n) \n      invariant u == Factorial(r)\n      invariant r <= n\n      decreases n-r\n    {\n      var v := u;\n      var s := 1;\n      while (s<=r) \n        invariant u == v*s\n        invariant s <= r+1\n        decreases r-s\n      {\n        u:=u+v;\n        s:=s+1;\n      }\n      r:=r+1;\n      assert u == Factorial(r) && r == s;\n    }\n  }"
},
{
    "dafny": "module Utils \n{\n    method floorSqrt(x: nat) returns (y: nat) \n        ensures x >= y * y && x < (y + 1) * (y + 1)\n    {\n        if (x == 0 || x == 1) \n        { \n            y := x; \n        }\n        var i := 1;\n        var res := 1;\n        while (res <= x)\n            invariant res <= x ==> res == i * i\n            invariant res > x ==> x >= (i - 1) * (i - 1) && x < i * i\n            decreases  x - res\n        {\n            i := i + 1;\n            res := i * i;\n        }\n        y := i - 1;\n    }\n}\nmodule Sudoku \n{\n    method isSafe(board: array2<int>, row: int, col: int, num: int) returns (v: bool)\n        requires 1 < board.Length0 == board.Length1\n        requires 0 <= row < board.Length0 && 0 <= col < board.Length1\n    {\n        var d := 0;\n        var r := 0;\n        var len := board.Length0;\n        while (d < len)\n            invariant 0 <= d <= len;\n            decreases  len - d\n        {\n            if(board[row, d] == num) {   return false;  }\n            d := d + 1;\n        }\n        while (r < len)\n            invariant 0 <= r <= len;\n            decreases  len - r\n        {\n            if(board[r, col] == num) {   return false;   }\n            r := r + 1;\n        }\n        var sqrt := Utils.floorSqrt(board.Length0);\n        var boxRowStart := row - row % sqrt;\n        var boxColStart := col - col % sqrt;\n        r := boxRowStart;\n        while (r < boxRowStart + sqrt && r < len)\n            invariant boxRowStart <= r <= boxRowStart + sqrt\n            decreases boxRowStart + sqrt - r\n        {   \n            d := boxColStart;\n            while (d < boxColStart + sqrt && d < len)\n                invariant boxColStart <= d <= boxColStart + sqrt\n                decreases boxColStart + sqrt - d\n            {\n                if(board[r, d] == num) {   return false;   }\n                d := d + 1;\n            }\n            r := r + 1;\n        }\n        return true;\n    }\n    method solveSudoku(board: array2<int>, numZeros: nat) returns (v: bool) \n        requires 1 < board.Length0 == board.Length1 \n        modifies board\n        decreases numZeros\n    {\n        var n := board.Length0;\n        var row := -1;\n        var col := -1;\n        var isEmpty := true;\n        var i := 0;\n        var j := 0;\n        while (i < n)\n            decreases n - i\n        {\n            while (j < n) \n                decreases  n - j\n            {\n                if (board[i, j] == 0)\n                {\n                    row := i;\n                    col := j;\n                    isEmpty := false;\n                    break;\n                }\n                j := j + 1;\n            }\n            if !isEmpty { break; }\n            i := i + 1;\n        }\n        if (isEmpty || numZeros == 0) {  return true;    }\n        var num := 1;\n        while (num <= n)\n            decreases n - num\n        {\n            var temp1 := isSafe(board, row, col, num);\n            if(temp1) \n            {\n                board[row, col] := num;\n                var temp2 := solveSudoku(board, numZeros - 1);\n                if(temp2) {\n                    return true;\n                } else {\n                    board[row, col] := 0;\n                }\n            }\n            num := num + 1;\n        }\n        return false;\n    }\n    method printBoard(board: array2<int>) \n    { \n        var r := 0;\n        while r < board.Length0\n            decreases board.Length0 - r\n        { \n            var d := 0;\n            while d < board.Length1\n                decreases board.Length1 - d\n            { \n                print board[r,d]; \n                print \" \"; \n                d := d + 1;\n            } \n            print \"\\n\" ; \n            r := r + 1; \n        } \n    } \n    method Main() \n    { \n        var board := new int[9, 9];\n        var filler := [ \n                [3, 0, 6, 5, 0, 8, 4, 0, 0], \n                [5, 2, 0, 0, 0, 0, 0, 0, 0], \n                [0, 8, 7, 0, 0, 0, 0, 3, 1], \n                [0, 0, 3, 0, 1, 0, 0, 8, 0], \n                [9, 0, 0, 8, 6, 3, 0, 0, 5], \n                [0, 5, 0, 0, 9, 0, 6, 0, 0], \n                [1, 3, 0, 0, 0, 0, 2, 5, 0], \n                [0, 0, 0, 0, 0, 0, 0, 7, 4], \n                [0, 0, 5, 2, 0, 6, 3, 0, 0] \n        ];\n        var r := 0;\n        while r < board.Length0\n            decreases board.Length0 - r\n        { \n            var d := 0;\n            while d < board.Length1\n                decreases board.Length1 - d\n            { \n                board[r,d] := filler[r][d];\n                d := d + 1;\n            } \n            r := r + 1; \n        }\n        var numZeros := 0;\n        r := 0;\n        while r < board.Length0\n            decreases board.Length0 - r\n        { \n            var d := 0;\n            while d < board.Length1\n                decreases board.Length1 - d\n            { \n                if board[r,d] == 0\n                {\n                    numZeros := numZeros + 1;\n                }\n                d := d + 1;\n            } \n            r := r + 1; \n        } \n        var solved := solveSudoku(board, numZeros);\n        if solved\n        { \n            printBoard(board); \n        }  \n        else\n        { \n            print \"No solution\"; \n        } \n    } \n}"
},
{
    "dafny": "datatype aexp = ANum(int) | APlus(aexp, aexp) | AMinus(aexp, aexp) | AMult(aexp, aexp)\ndatatype bexp = BTrue | BFalse | BEq(aexp, aexp) | BLe(aexp, aexp) | BNot(bexp) | BAnd(bexp, bexp)\nfunction aeval(e: aexp): int\n{\n  match e\n  case ANum(n) => n\n  case APlus(a1, a2) => aeval(a1) + aeval(a2)\n  case AMinus(a1, a2) => aeval(a1) - aeval(a2)\n  case AMult(a1, a2) => aeval(a1) * aeval(a2)\n}\nfunction beval(e: bexp): bool\n{\n  match e\n  case BTrue => true\n  case BFalse => false\n  case BEq(a1, a2) => aeval(a1) == aeval(a2)\n  case BLe(a1, a2) => aeval(a1) < aeval(a2)\n  case BNot(b1) => !beval(b1)\n  case BAnd(b1, b2) => beval(b1) && beval(b2)\n}\nfunction optimize_0plus(e: aexp): aexp\n  ensures aeval(optimize_0plus(e)) == aeval(e)\n{\n  match e\n  case ANum(n) => ANum(n)\n  case APlus(e1, e2) =>\n    if (e1 == ANum(0)) then optimize_0plus(e2)\n    else APlus(optimize_0plus(e1), optimize_0plus(e2))\n  case AMinus(e1, e2) => AMinus(optimize_0plus(e1), optimize_0plus(e2))\n  case AMult(e1, e2) => AMult(optimize_0plus(e1), optimize_0plus(e2))\n}"
},
{
    "dafny": "function sorted(a:array<char>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ forall i, j:: (0 <= i < j < n) ==> a[i] <= a[j] }\nfunction partitioned(a:array<char>,i:int,n:int):bool\n    requires 0 <= n <= a.Length\n    reads a;\n{ forall k, l :: 0 <= k < i <= l < n ==> (a[k] <= a[l]) }\nmethod selectSmaller(a:array<char>, i:int, n:int) \n  requires 0 <= i < n <= a.Length\n  requires sorted(a, i)\n  requires partitioned(a, i, n)\n  modifies a\n  ensures sorted(a, i+1)\n  ensures partitioned(a, i+1, n)\n{\n  var j := i+1;\n  while j < n \n    decreases n - j\n    invariant i < j <= n\n    invariant a[..i] == old(a[..i])\n    invariant forall k :: i < k < j ==> a[i] <= a[k]\n    invariant sorted(a, i)\n    invariant partitioned(a, i, n)\n  {\n    if a[j] < a[i]\n    { \n      a[i], a[j] := a[j], a[i];\n    }\n    j := j + 1;\n  }\n  assert sorted(a, i);\n  assert partitioned(a, i, n);\n  assert forall k :: i < k < n ==> a[i] <= a[k];\n  assert sorted(a, i+1);\n  assert partitioned(a, i+1, n);\n}\nmethod selectionSort(a:array<char>, n:int)\n  requires 0 <= n <= a.Length\n  modifies a\n{\n  var i := 0;\n  while i < n \n    decreases n - i\n    invariant 0 <= i <= n\n    invariant sorted(a, i)\n    invariant partitioned(a, i, n)\n  {\n    selectSmaller(a, i, n);\n    assert sorted(a, i+1);\n    assert partitioned(a, i+1, n);\n    i := i + 1;\n  }\n}\nfunction sortedRange(a:array<char>, l:int, h:int):bool\n    requires 0 <= l <= h <= a.Length\n    reads a\n{ forall i, j:: (l <= i < j < h) ==> a[i] <= a[j] }"
},
{
    "dafny": "method max(a:array?<int>) returns(max:int) \n  requires a!=null;\n  ensures (forall j :int :: (j >= 0 && j < a.Length ==> max >= a[j]));\n  ensures (a.Length > 0)==>(exists j : int :: j>=0 && j < a.Length && max==a[j]);\n {\n  if (a.Length == 0)  { max := 0;} \n  else {\n    max:=a[0];\n    var i:int :=1;\n    while(i < a.Length)\n      invariant (i<=a.Length) && (forall j:int :: j>=0 && j<i ==> max >= a[j])\n         && (exists j:int :: j>=0 && j<i && max==a[j]);\n      decreases (a.Length-i); \n    {\n      if(a[i] > max){max := a[i];}\n      i := i + 1;\n    }\n  }\n}\nmethod Main() {\n  var a := new int[5];\n  a[0] := 12;\n  a[1] := 3;\n  a[2] := 44;\n  a[3] := 44;\n  a[4] := 1;\n  var b := max(a);\n  print \"Index: \", b;\n}"
},
{
    "dafny": "module ModOpaque {\n    function {:opaque} Hidden(x:int) : (int, int)\n    {\n        (5, 7)\n    }\n    function Visible(x:int) : (int, int)\n    {\n        Hidden(x)\n    }\n    lemma foo(x:int, y:int, z:int)\n        requires (y, z) == Visible(x);\n    {\n        assert (y, z) == Hidden(x);\n    }\n    lemma bar(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Visible(x);\n    }\n    lemma baz(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Hidden(x);\n    }\n}\nmodule ModVisible {\n    function Hidden(x:int) : (int, int)\n    {\n        (5, 7)\n    }\n    function Visible(x:int) : (int, int)\n    {\n        Hidden(x)\n    }\n    lemma foo(x:int, y:int, z:int)\n        requires (y, z) == Visible(x);\n    {\n        assert (y, z) == Hidden(x);\n    }\n    lemma bar(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Visible(x);\n    }\n    lemma baz(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Hidden(x);\n    }\n}\nmodule ModFuel {\n    function {:fuel 0,0} Hidden(x:int) : (int, int)\n    {\n        (5, 7)\n    }\n    function Visible(x:int) : (int, int)\n    {\n        Hidden(x)\n    }\n    lemma foo(x:int, y:int, z:int)\n        requires (y, z) == Visible(x);\n    {\n        assert (y, z) == Hidden(x);\n    }\n    lemma bar(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Visible(x);\n    }\n    lemma baz(x:int, y:int, z:int)\n        requires y == Visible(x).0;\n        requires z == Visible(x).1;\n    {\n        assert (y, z) == Hidden(x);\n    }\n}"
},
{
    "dafny": "type Process(==)\ndatatype CState = Thinking | Hungry | Eating\nclass TicketSystem\n{\nvar ticket: int\nvar serving: int\nvar cs: map<Process, CState>\nvar t: map<Process, int>\nconst P: set<Process>\npredicate Valid()\nreads this\n{\n    cs.Keys == t.Keys == P &&\n    serving <= ticket && \n    (forall p :: p in P && cs[p] != Thinking ==> serving <= t[p] < ticket) &&\n    (forall p, q :: p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking ==> t[p] != t[q]) &&\n    (forall p :: p in P && cs[p] == Eating ==> t[p] == serving)\n}\nconstructor(processes: set<Process>) \nensures Valid()\n{\n    P := processes;\n    ticket, serving := 0, 0;\n    cs := map p | p in processes :: Thinking;\n    t := map p | p in processes :: 0;\n}\nmethod Request(p: Process)\nrequires Valid() && p in P && cs[p] == Thinking\nmodifies this\nensures Valid()\n{\n        t, ticket := t[p := ticket], ticket + 1; \n        cs := cs[p := Hungry];\n}\nmethod Enter(p : Process)\nrequires Valid() && p in P && cs[p] == Hungry\nmodifies this\nensures Valid()\n{\n    if t[p] == serving {\n        cs := cs[p := Eating];\n    }\n}\nmethod Leave(p : Process) \nrequires Valid() && p in P && cs[p] == Eating\nmodifies this\nensures Valid()\n{\n    serving := serving + 1;\n    cs := cs[p := Thinking];\n}\nlemma MutualExclusion(p: Process, q: Process)\nrequires Valid() && p in P && q in P\nrequires cs[p] == Eating && cs[q] == Eating\nensures p == q\n{\n}\n}"
},
{
    "dafny": "const i: bv4 := 9\nconst j: bv4 := 3\nmethod m() {\n  assert (i & j) == (1 as bv4);\n  assert (i | j) == (11 as bv4);\n  assert (i ^ j) == (10 as bv4);\n  assert !i == (6 as bv4);\n  assert -i == (7 as bv4);\n  assert (i + i) == (2 as bv4);\n  assert (j - i) == (10 as bv4);\n  assert (i * j) == (11 as bv4);\n  assert (i as int) / (j as int) == 3;\n  assert (j << 1) == (6 as bv4);\n  assert (i << 1) == (2 as bv4);\n  assert (i >> 1) == (4 as bv4);\n  assert i == 9; \n  assert i * 4 == j + 8 + 9; \n  assert i + j >> 1 == (i + j) >> 1; \n  assert i + j ^ 2 == i + (j^2);\n  assert i * j & 1 == i * (j&1); \n}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n    ensures index >= 0 ==> index < a.Length && a[index] == key\n    ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n    index := 0;\n    while index < a.Length\n        decreases a.Length - index\n        invariant 0 <= index <= a.Length\n        invariant forall k :: 0 <= k < index ==> a[k] != key\n    {\n        if a[index] == key {\n            return;\n        }\n        index := index + 1;\n    }\n    index := -1;\n}"
},
{
    "dafny": "method ComputeIsEven(x:int) returns (is_even:bool)\n  ensures (x % 2 == 0)==is_even\n{\n  is_even:=false;\n  if x%2==0{\n    is_even:=true;\n  }\n}\nmethod TestComputeIsEven(){\n  var test1 := ComputeIsEven(2);\n  print(\"Test 1: ComputeIsEven(2) = \", test1, \"\\n\");\n  var test2 := ComputeIsEven(3);\n  print(\"Test 2: ComputeIsEven(3) = \", test2, \"\\n\");\n  var test3 := ComputeIsEven(0);\n  print(\"Test 3: ComputeIsEven(0) = \", test3, \"\\n\");\n  var test4 := ComputeIsEven(-1);\n  print(\"Test 4: ComputeIsEven(-1) = \", test4, \"\\n\");\n  var test5 := ComputeIsEven(-2);\n  print(\"Test 5: ComputeIsEven(-2) = \", test5, \"\\n\");\n}\nmethod Main(){\n  TestComputeIsEven();\n}"
},
{
    "dafny": "class Data { }\nclass Node {\n  var list: seq<Data>;\n  var footprint: set<Node>;\n  var data: Data;\n  var next: Node?;\n  function Valid(): bool\n    reads this, footprint\n  {\n    this in footprint &&\n    (next == null ==> list  == [data]) &&\n    (next != null ==> next in footprint &&\n                      next.footprint <= footprint &&\n                      !(this in next.footprint) &&\n                      list == [data] + next.list &&\n                      next.Valid())\n  }\n  constructor(d: Data)\n    ensures Valid() && fresh(footprint - {this})\n    ensures list == [d]\n  {\n    data := d;\n    next := null;\n    list := [d];\n    footprint := {this};\n  }\n  method SkipHead() returns (r: Node?)\n    requires Valid()\n    ensures r == null ==> |list| == 1\n    ensures r != null ==> r.Valid() && r.footprint <= footprint\n  {\n    return next;\n  }\n  method Prepend(d: Data) returns (r: Node)\n    requires Valid()\n    ensures r.Valid() && fresh(r.footprint - old(footprint))\n    ensures r.list == [d] + list\n  {\n    r := new Node(d);\n    r.data := d;\n    r.next := this;\n    r.footprint := {r} + footprint;\n    r.list := [r.data] + list;\n  }\n  method ReverseInPlace() returns (reverse: Node)\n    requires Valid()\n    modifies footprint\n    ensures reverse.Valid()\n    ensures fresh(reverse.footprint - old(footprint))\n    ensures |reverse.list| == |old(list)|\n    ensures forall i | 0 <= i < |old(list)| :: old(list)[i] == reverse.list[|old(list)| - 1 - i]\n  {\n    var current: Node?;\n    current := next;\n    reverse := this;\n    reverse.next := null;\n    reverse.footprint := {reverse};\n    reverse.list := [data];\n    while current != null\n      invariant reverse.Valid()\n      invariant reverse.footprint <= old(footprint)\n      invariant current == null ==> |old(list)| == |reverse.list|\n      invariant current != null ==>\n          current.Valid()\n      invariant current != null ==>\n          current in old(footprint) && current.footprint <= old(footprint)\n      invariant current != null ==>\n          current.footprint !! reverse.footprint\n      invariant current != null ==>\n          |old(list)| == |reverse.list| + |current.list|\n      invariant current != null ==>\n          forall i | 0 <= i < |current.list| ::\n              current.list[i] == old(list)[|reverse.list| + i]\n      invariant forall i | 0 <= i < |reverse.list| ::\n          old(list)[i] == reverse.list[|reverse.list| - 1 - i]\n      decreases |old(list)| - |reverse.list|\n    {\n      var nx: Node?;\n      nx := current.next;\n      assert nx != null ==>\n          forall i | 0 <= i < |nx.list| ::\n              current.list[i + 1] == nx.list[i];\n      assert current.data == current.list[0];\n      current.next := reverse;\n      current.footprint := {current} + reverse.footprint;\n      current.list := [current.data] + reverse.list;\n      reverse := current;\n      current := nx;\n    }\n  }\n}"
},
{
    "dafny": "module Misc {\n  function flatten_clear<T>(nested: set<set<T>>) : set<T>\n  {\n    set x, y | y in nested && x in y :: x\n  }\n  lemma lemma_set_union_commute_once<T>(a:set<T>, b:set<T>)\n    ensures a + b == b + a\n  {}\n  lemma lemma_set_union_commutes<T>()\n    ensures forall a : set<T>, b : set<T> {:trigger a + b} :: a + b == b + a\n  {}\n  lemma lemma_set_union_associate_once<T>(a:set<T>, b:set<T>, c:set<T>)\n    ensures (a + b) + c == a + (b + c)\n  {}\n  lemma lemma_set_union_associates<T>()\n    ensures forall a : set<T>, b : set<T>, c : set<T> {:trigger ((a + b) + c), (a + (b + c))} :: (a + b) + c == a + (b + c)\n  {}\n  lemma lemma_set_facts<T>()\n    ensures forall a : set<T>, b : set<T> {:trigger a + b} :: a + b == b + a\n    ensures forall a : set<T>, b : set<T>, c : set<T> {:trigger ((a + b) + c), (a + (b + c))} :: (a + b) + c == a + (b + c)\n  {}\n}"
},
{
    "dafny": "method Triple(x: int) returns (r: int)\n    ensures r == 3 * x\n{\n    if x >= 0 {\n        var y := Double(x);\n        r := x + y;\n    } else {\n        var y := Double(-x);\n        r := x - y;\n    }\n}\nmethod Double(x: int) returns (r: int)\n    requires x >= 0\n    ensures r == 2 * x"
},
{
    "dafny": "method Product (m: nat, n: nat) returns (res:nat)\n  ensures res == m * n;\n{\n  var m1: nat := m; res := 0;\n  while (m1 != 0) \n  invariant m1 >= 0\n  invariant res == m*n - m1*n\n  {\n     var n1: nat := n;\n     while (n1 != 0) \n\t invariant n1 >= 0\n\t invariant res == (m-m1+1)*n - n1 {\n       res := res + 1;\n       n1 := n1 - 1;\n     }\n     m1 := m1 - 1;\n  }\n}"
},
{
    "dafny": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(N: int) returns (y: nat) requires N >= 0\n    ensures y == Power(N)\n{\n    y := 1;\n    var x := 0; \n    while x != N\n        invariant 0 <= x <= N \n        invariant y == Power(x) \n        decreases N - x\n    {\n        x, y := x + 1, y + y;\n    } \n}"
},
{
    "dafny": "method LinearSearch(a: array<int>, key: int) returns (n: nat)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || a[n] == key\n{\n  n := 0;\n  while n < a.Length\n    invariant n <= a.Length\n  {\n    if a[n] == key {\n      return;\n    }\n    n := n + 1;\n  }\n}\nmethod PrintArray<A>(a: array?<A>) {\n  if (a == null) {\n    print \"It's null\\n\";\n  } else {\n    var i := 0;\n    while i < a.Length {\n      print a[i], \" \";\n      i := i + 1;\n    }\n    print \"\\n\";\n  }\n}\nmethod Main() {\n  var a := new int[23];\n  var i := 0;\n  while i < 23 {\n    a[i] := i;\n    i := i + 1;\n  }\n  PrintArray(a);\n  var n := LinearSearch(a, 17);\n  print n, \"\\n\";\n  print a[..], \"\\n\";\n  print a[2..16], \"\\n\";\n  print a[20..], \"\\n\";\n  print a[..8], \"\\n\";\n  InitTests();\n  MultipleDimensions();\n  PrintArray<int>(null);\n}\ntype lowercase = ch | 'a' <= ch <= 'z' witness 'd'\nmethod InitTests() {\n  var aa := new lowercase[3];\n  PrintArray(aa);\n  var s := \"hello\";\n  aa := new lowercase[|s|](i requires 0 <= i < |s| => s[i]);\n  PrintArray(aa);\n}\nmethod MultipleDimensions() {\n  var matrix := new int[2,8];\n  PrintMatrix(matrix);\n  matrix := new int[3, 5]((x,y) => if x==y then 1 else 0);\n  PrintMatrix(matrix);\n  var cube := new int[3,0,4]((_,_,_) => 16);\n  print \"cube dims: \", cube.Length0, \" \", cube.Length1, \" \", cube.Length2, \"\\n\";\n}\nmethod PrintMatrix(m: array2<int>) {\n  var i := 0;\n  while i < m.Length0 {\n    var j := 0;\n    while j < m.Length1 {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n    print \"\\n\";\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "predicate nonnull <T> (arr : array<T>)\n{\n  arr != null\n}\npredicate nonempty <T> (arr : array<T>)\n  requires nonnull(arr)\n{\n  0 < arr.Length\n}\npredicate contains <T(==)> (ele : T, arr : array<T>)\n  reads arr\n  requires nonnull(arr)\n{\n  exists idx :: 0 <= idx < arr.Length && arr[idx] == ele\n}\npredicate same_size <S, T> (arr1 : array<S>, arr2 : array<T>)\n  requires nonnull(arr1)\n  requires nonnull(arr2)\n{\n  arr1.Length == arr2.Length\n}\npredicate valid_idx <T> (idx : int, arr : array<T>)\n  requires nonnull(arr)\n{\n  0 <= idx < arr.Length\n}\npredicate valid_slice <T> (start : int, size : int, arr : array<T>)\n  requires nonnull(arr)\n{\n  size == 0 || (valid_idx(start, arr) && valid_idx(start + size - 1, arr))\n}\npredicate slice_eq <T(==)> (start1 : int, arr1 : array<T>, start2 : int, arr2 : array<T>, size : int)\n  reads arr1\n  reads arr2\n  requires nonnull(arr1)\n  requires nonnull(arr2)\n{\n  valid_slice(start1, size, arr1) &&\n  valid_slice(start2, size, arr2) &&\n  forall offset :: 0 <= offset < size ==> arr1[start1 + offset] == arr2[start2 + offset]\n}\npredicate z_zero_correct (zs : array<int>)\n  reads zs\n  requires nonnull(zs)\n  requires nonempty(zs)\n{\n  zs[0] == 0\n}\npredicate z_slices_valid (zs : array<int>)\n  reads zs\n  requires nonnull(zs)\n{\n  nonempty(zs) &&\n  forall idx :: 1 <= idx < zs.Length ==> valid_slice(idx, zs[idx], zs)\n}\npredicate z_nonzero_correct (str : array<char>, zs : array<int>)\n  reads str\n  reads zs\n  requires nonnull(str)\n  requires nonnull(zs)\n{\n  forall idx :: 1 <= idx < zs.Length ==> forall k :: 0 <= k <= str.Length - idx ==>\n    (zs[idx] >= k <==> slice_eq(0, str, idx, str, k))\n}\npredicate z_correct (str : array<char>, zs : array<int>)\n  reads str\n  reads zs\n  requires nonnull(str)\n  requires nonnull(zs)\n  requires nonempty(str)\n  requires nonempty(zs)\n  requires same_size(str, zs)\n{\n  z_zero_correct(zs) &&\n  z_slices_valid(zs) &&\n  z_nonzero_correct(str, zs)\n}\nmethod z_algorithm_naive(str : array<char>) returns (zs : array<int>)\n  requires nonnull(str)\n  requires nonempty(str)\n  ensures nonnull(zs)\n  ensures same_size(str, zs)\n  ensures z_correct(str, zs)\n{\n  zs := new int[str.Length];\n  zs[0] := 0;\n  var i := 1;\n  while (i < zs.Length)\n    invariant 1 <= i <= zs.Length\n    invariant z_zero_correct(zs)\n    invariant forall idx :: 1 <= idx < i ==> valid_slice(idx, zs[idx], zs)\n    invariant forall idx :: 1 <= idx < i ==> forall k :: 0 <= k <= str.Length - idx ==>\n      (zs[idx] >= k <==> slice_eq(0, str, idx, str, k))\n  {\n    var j := 0;\n    while (j < zs.Length - i)\n      invariant 0 <= j <= zs.Length - i\n      invariant slice_eq(0, str, i, str, j)\n    {\n      if str[j] != str[i + j] {\n        break;\n      }\n      j := j + 1;\n    }\n    zs[i] := j;\n    i := i + 1;\n  }\n}\nmethod z_algorithm(str : array<char>) returns (zs : array<int>)\n  requires nonnull(str)\n  requires nonempty(str)\n  ensures nonnull(zs)\n  ensures same_size(str, zs)\n  ensures z_correct(str, zs)\n{\n  zs := new int[str.Length];\n  zs[0] := 0;\n  var i := 1;\n  var j := 0;\n  while (i< zs.Length)\n    invariant 1 <= i <= zs.Length\n    invariant z_zero_correct(zs)\n    invariant j < i\n    invariant forall idx :: 1 <= idx < i ==> valid_slice(idx, zs[idx], str)\n    invariant forall idx :: 1 <= idx < i ==> slice_eq(0, str, idx, str, zs[idx])\n    invariant forall idx :: 1 <= idx < i ==> forall k :: 0 <= k <= str.Length - idx ==>\n      (zs[idx] >= k ==> slice_eq(0, str, idx, str, k))\n    invariant forall idx :: 1 <= idx < i ==> (idx + zs[idx] < str.Length ==> str[zs[idx]] != str[idx + zs[idx]])\n    invariant forall idx :: 1 <= idx < i ==> forall k :: 0 <= k <= str.Length - idx ==>\n      (slice_eq(0, str, idx, str, k) ==> zs[idx] >= k)\n  {\n    if (j + zs[j] < i) { \n      var l := 0;\n      while (l < str.Length - i)\n        invariant 0 <= l <= str.Length - i\n        invariant valid_slice(i, l, str)\n        invariant slice_eq(0, str, i, str, l)\n      {\n        if (str[l] != str[i + l]) {\n          break;\n        }\n        l := l + 1;\n      }\n      zs[i] := l;\n      j := i;\n    } else {\n      var k := i - j;\n      if (k + zs[k] < zs[j]) {\n        zs[i] := zs[k];\n      } else if (k + zs[k] > zs[j]) {\n        zs[i] := j + zs[j] - i;\n      } else {\n        var tmp := j + zs[j];\n        var l := 0;\n        while (l < str.Length - tmp)\n          invariant 0 <= l <= str.Length - i\n          invariant valid_slice(i, tmp - i + l, str)\n          invariant slice_eq(0, str, i, str, tmp - i + l)\n        {\n          if (str[tmp - i + l] != str[tmp + l]) {\n            break;\n          }\n          l := l + 1;\n        }\n        zs[i] := tmp - i + l;\n        j := i;\n      }\n    }\n    i := i + 1;\n  }\n}\nmethod print_arr <T> (arr : array<T>)\n  requires nonnull(arr)\n{\n  var i := 0;\n  print \"[\";\n  if (arr.Length == 0)\n  {\n    print \"[]\";\n    return;\n  }\n  while (i < arr.Length - 1)\n    invariant 0 <= i <= arr.Length - 1\n  {\n    print arr[i];\n    print \" \";\n    i := i + 1;\n  }\n  print arr[i];\n  print \"]\\n\";\n}\nmethod array_of_string (str : string) returns (ret : array<char>)\n  requires 0 < |str|\n  ensures nonnull(ret)\n  ensures nonempty(ret)\n  ensures |str| == ret.Length\n  ensures forall idx :: 0 <= idx < |str| ==> str[idx] == ret[idx]\n{\n  ret := new char[|str|];\n  var i := 0;\n  while (i < |str|)\n  invariant 0 <= i <= |str|\n  invariant forall k :: 0 <= k < i ==> str[k] == ret[k]\n  {\n    ret[i] := str[i];\n    i := i + 1;\n  }\n}\nmethod matches(pattern : array<char>, text : array<char>) returns (ret : seq<int>)\n  requires nonnull(pattern)\n  requires nonnull(text)\n  requires !contains('$', pattern)\n  requires !contains('$', text)\n  ensures forall idx :: 0 <= idx < text.Length ==> (slice_eq(0, pattern, idx, text, pattern.Length) <==> idx in ret)\n{\n  ret := [];\n  var conc := new char[pattern.Length + text.Length + 1];\n  var i := 0;\n  while (i < conc.Length)\n    invariant 0 <= i <= conc.Length\n    invariant forall k :: 0 <= k < i ==> if k < pattern.Length then conc[k] == pattern[k] else if k == pattern.Length then conc[k] == '$' else conc[k] == text[k - (pattern.Length + 1)]\n  {\n    if (i < pattern.Length) {\n      conc[i] := pattern[i];\n    } else if (i == pattern.Length) {\n      conc[i] := '$';\n    } else {\n      conc[i] := text[i - (pattern.Length + 1)];\n    }\n    i := i + 1;\n  }\n  print_arr(conc);\n  var zs := z_algorithm(conc);\n  print_arr(zs);\n  i := 0;\n  while (i < text.Length)\n    invariant 0 <= i <= text.Length\n\t\tinvariant forall i' :: i'>=i ==> (i' !in ret)\n    invariant forall idx :: 0 <= idx < i ==> (slice_eq(0, pattern, idx, text, pattern.Length) <==> slice_eq(0, conc, idx + (pattern.Length + 1), conc, pattern.Length))\n    invariant forall idx :: 0 <= idx < i ==> (zs[idx + (pattern.Length + 1)] >= pattern.Length <==> idx in ret)\n  {\n    if (zs[i + (pattern.Length + 1)] >= pattern.Length) {\n      ret := ret + [i];\n    } \n\t\ti := i+1;\n  }\n}\nmethod Main() {\n  var pattern := \"ana\";\n  var text := \"banana\";\n  var pattern' := array_of_string(pattern);\n  var text' := array_of_string(text);\n  var b := matches(pattern', text');\n  print b;\n  print \"\\n\";\n}"
},
{
    "dafny": "method Main() { }\ndatatype Maybe<T> = Nothing | Just(T)\nfunction fromJust<T>(x: Maybe<T>): T\n    requires x.Just?\n{\n    match x case Just(v) => v\n}\ntype mem = int\ntype AbsPTable = seq<Maybe<AbsL2PTable>>\ntype AbsL2PTable = seq<Maybe<AbsPTE>>\ndatatype AbsPTE = AbsPTE(phys: mem, write: bool, exec: bool)\nghost function WritablePagesInTable(pt:AbsPTable): set<mem>\n{\n    (set i, j | 0 <= i < |pt| && pt[i].Just? && 0 <= j < |fromJust(pt[i])|\n        && fromJust(pt[i])[j].Just? && fromJust(fromJust(pt[i])[j]).write\n        :: fromJust(fromJust(pt[i])[j]).phys)\n}\nmethod G(pt:AbsPTable, i: int, j: int)\n  requires 0 <= i < |pt| && pt[i].Just? && 0 <= j < |fromJust(pt[i])|\n{\n  var s := pt[i];\n  var aa := fromJust(s);\n  var z := aa[j];\n}"
},
{
    "dafny": "method MaxSum(x: int, y: int) returns (s: int, m: int)\n    ensures m == x || m == y\n    ensures m >= x && m >= y\n    ensures s == x + y\n{\n    s := x + y;\n    if x > y\n    {\n        m := x;\n    }\n    else\n    {\n        m := y;\n    }\n}\nmethod Caller() {\n    var s, m: int;\n    s, m := MaxSum(1928, 1);\n    assert s == 1929;\n    assert m == 1928;\n}"
},
{
    "dafny": "predicate P()\nmethod TestMapMethod(s0: set<int>, s1: set<int>) {\n  var m;\n  m := map key | key in (s0 + s1) && P() :: true;\n  m := map key | key in (s0 + s1) :: true;\n  m := map key | key in s0 + s1 && P() :: true;\n  m := map key | key in s0 + s1 :: true;\n  assert true;\n}\nghost function TestMap(s0: set<int>, s1: set<int>): bool {\n  var m0 := map key | key in (s0 + s1) && P() :: true;\n  var m1 := map key | key in (s0 + s1) :: true;\n  var m2 := map key | key in s0 + s1 && P() :: true;\n  var m3 := map key | key in s0 + s1 :: true;\n  true\n}\nghost function TestSet(s0: set<int>, s1: set<int>): bool {\n  var t0 := set key | key in (s0 + s1) && P() :: key;\n  var t1 := set key | key in (s0 + s1) :: key;\n  var t2 := set key | key in s0 + s1 && P() :: key;\n  var t3 := set key | key in s0 + s1 :: key;\n  true\n}\nghost function TestInMultiset(s0: multiset<int>, s1: multiset<int>): bool {\n  var t0 := set key | key in (s0 + s1) && P() :: key;\n  var t1 := set key | key in (s0 + s1) :: key;\n  var t2 := set key | key in s0 + s1 && P() :: key;\n  var t3 := set key | key in s0 + s1 :: key;\n  true\n}\nclass Cell { var data: int }\nmethod ModifiesClauses(S: set<object>, T: set<object>, p: Cell, q: Cell, n: int)\n  requires p in S + T\n  requires q in S\n  modifies S + T\n{\n  p.data := n;\n  q.data := n;\n}\nghost function Id(S: set<object>): set<object> { S }\nmethod Fresh0(p: Cell, q: Cell, n: int) returns (S: set<object>, T: set<object>)\n  ensures fresh(S - T)\n{\n  S, T := {p}, {p};\n}\nmethod Fresh1(p: Cell, q: Cell, n: int) returns (S: set<object>, T: set<object>)\n  ensures fresh(Id(S) - Id(T))\n{\n  S, T := {p}, {p};\n}\nmethod Fresh2(p: Cell, q: Cell, n: int) returns (S: set<object>, T: set<object>)\n  ensures fresh(Id(S - T))\n{\n  S, T := {p}, {p};\n}\nghost function ReadsClauses(S: set<object>, T: set<object>, p: Cell, q: Cell, n: int): int\n  requires p in S + T\n  requires q in S\n  reads S + T\n{\n  p.data + q.data + n\n}\ntwostate predicate FreshInFunction(S: set<object>, T: set<object>)\n{\n  fresh(S + T)\n}"
},
{
    "dafny": "module A {\n  const a := 10\n}\nmodule B refines A { \n  module A {\n    const a := 30\n  }\n  method Main() {\n    assert a == 10; \n    expect a == 10; \n    print \"OK\\n\";\n  }\n}"
},
{
    "dafny": "datatype List = Nil | Cons(int, List)\nfunction Len(l:List): int\n{\n  match l\n  case Nil => 0\n  case Cons(hd, tl) => Len(tl) + 1\n}\nfunction Exists_eq(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd == x || Exists_eq(tl, x)\n}\nfunction Forall_neq(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd != x || Forall_neq(tl, x)\n}\nfunction Elem(l:List, x:int): (b: bool)\n  ensures !b || Exists_eq(l, x)\n  ensures Forall_neq(l, x) || b\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => (x == hd) || Elem(tl, x)\n}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n  requires a != null;\n  ensures 0 <= index < a.Length ==> a[index] == key;\n  ensures index == -1 ==> forall z :: 0 <= z < a.Length ==> a[z] != key;\n{\n  var i := 0;\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant forall k :: 0 <= k < i ==> a[k] != key;\n  {\n    if (a[i] == key) { return i;}\n    i := i + 1;\n  }\n  return -1;\n}"
},
{
    "dafny": "method getEven(arr: array?<int>)\nmodifies arr;\nrequires arr != null;\nensures forall i:int :: 0 <= i < arr.Length ==> arr[i] % 2 == 0;\n{\n    var i := 0;\n    var j := arr.Length;\n    while i < j\n    invariant i <= j;\n    invariant forall k :: 0 <= k < i  ==> arr[k] % 2 == 0;\n    decreases j - i\n    {\n        if (arr[i] % 2 == 1) {\n            arr[i] := arr[i] + 1;\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method SearchRecursive( a: seq<real>, i: int, j: int, x: real ) returns ( k: int )\n    decreases j-i;\n    requires 0 <= i <= j <= |a|;\n    requires forall p, q :: i <= p < q < j ==> a[p] >= a[q];\n    ensures i <= k <= j\n    ensures forall r | i <= r < k :: a[r] >= x;\n    ensures forall r | k <= r < j :: a[r] < x;\n{\n    if i == j\n    {\n        return i;\n    }\n    var m := i + (j-i)/2;\n    if a[m] < x\n    {\n        k := SearchRecursive(a,i,m,x);\n    }\n    else\n    {\n        k := SearchRecursive(a,m+1,j,x);\n    }\n}\nmethod SearchLoop( a: seq<real>, i: int, j: int, x: real ) returns ( k: int )\n    requires 0 <= i <= j <= |a|;\n    requires forall p, q :: i <= p < q < j ==> a[p] >= a[q];\n    ensures i <= k <= j;\n    ensures forall r | i <= r < k :: a[r] >= x;\n    ensures forall r | k <= r < j :: a[r] < x;\n{\n    if i == j\n    {\n        return i;\n    }\n    var p := i;\n    var q := j;\n    while p != q\n        decreases q-p;\n        invariant i <= p <= q <= j;\n        invariant forall r | i <= r < p :: a[r] >= x;\n        invariant forall r | q <= r < j :: a[r] < x;\n    {\n        var m := p + (q-p)/2;\n        if a[m] < x\n        {\n            q := m;\n        }\n        else\n        {\n            p := m+1;\n        }\n    }\n    return p;\n}\nmethod Test( a: seq<real>, x: real )\n    requires forall p,q | 0 <= p < q < |a| :: a[p] >= a[q];\n{\n    var k1 := SearchLoop(a,0,|a|,x);\n    assert forall r | 0 <= r < k1 :: a[r] >= x;\n    assert forall r | k1 <= r < |a| :: a[r] < x;\n    var k2 := SearchRecursive(a,0,|a|,x);\n    assert forall r | 0 <= r < k2 :: a[r] >= x;\n    assert forall r | k2 <= r < |a| :: a[r] < x;\n}"
},
{
    "dafny": "newtype Byte = x | 0 <= x < 256\npredicate GoodByte(b: Byte) {\n  b % 3 == 2\n}\npredicate GoodInteger(i: int) {\n  i % 5 == 4\n}\nmethod Main() {\n  assert GoodByte(11) && GoodInteger(24);\n  var b: Byte :| GoodByte(b);\n  var i: int :| 0 <= i < 256 && GoodInteger(i);\n  print \"b=\", b, \"  i=\", i, \"\\n\";\n  var m0 := new MyClass;\n  var m17 := new M17.AnotherClass();\n}\nclass MyClass { }\nmodule M17 {\n  class AnotherClass {\n    constructor () { }\n  }\n}"
},
{
    "dafny": "method FindMax (a:array<int>)  returns (max : int)\n  requires a != null \n  requires 0<a.Length\n  ensures exists k:int :: 0 <= k < a.Length && max == a[k]\n  ensures forall k:int :: 0 <= k < a.Length ==> a[k] <= max     \n{\n  max:=a[0];\n  var i:int :=1;\n  while(i < a.Length)\n    invariant (i<=a.Length) && (forall k:int :: 0<=k<i ==> a[k]<=max) && (exists k:int :: 0<=k<i && max==a[k]) \n    decreases (a.Length-i); \n  {\n    if(a[i] > max){max := a[i];}\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "datatype Tree = Empty | Branch(int, Tree, Tree)\nfunction Size(t:Tree): int\n{\n  match t\n  case Empty => 0\n  case Branch(_, t1, t2) => 1 + Size(t1) + Size(t2)\n}\nfunction isEmpty(t:Tree): bool\n{\n    match t\n    case Empty => true\n    case Branch(_, _, _) => false\n}\nfunction Exists_eq(t:Tree, v:int): bool\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) => x == v || Exists_eq(t1, v) || Exists_eq(t2, v)\n}\nfunction Forall_neq(t:Tree, v:int): bool\n{\n    match t\n    case Empty => true\n    case Branch(x, t1, t2) => x != v && Forall_neq(t1, v) && Forall_neq(t2, v)\n}\nfunction Elem(t:Tree, v:int): (b: bool)\n    ensures !b || Exists_eq(t, v)\n    ensures b || Forall_neq(t, v)\n{\n    match t\n    case Empty => false\n    case Branch(x, t1, t2) => x == v || Elem(t1, v) || Elem(t2, v)\n}"
},
{
    "dafny": "datatype Nat = Zero | Succ(Pred: Nat)\nlemma Disc(n: Nat)\nensures n.Succ? || n.Zero?\n{\n}\nlemma LPred(n: Nat)\nensures Succ(n).Pred == n\n{\n}\nfunction add(m: Nat, n: Nat) : Nat\ndecreases m\n{\n    match m\n    case Zero => n\n    case Succ(m') => Succ(add(m', n))\n}\nlemma AddZero(m: Nat)\nensures add(m, Zero) == m\n{\n}\nlemma AddAssoc(m: Nat, n: Nat, p: Nat)\nensures add(m, add(n, p)) == add(add(m, n), p)\n{\n}\nlemma AddComm(m: Nat, n: Nat)\nensures add(m, n) == add(n, m)\n{\n    match m\n    case Zero => AddZero(n);\n    case Succ(m') => AddComm(m', n);\n}\npredicate lt(m: Nat, n: Nat)\n{\n    (m.Zero? && n.Succ?) ||\n    (m.Succ? && n.Succ? && lt(m.Pred, n.Pred))\n}\nlemma Test1(n:Nat)\nensures lt(n, Succ(Succ(n)))\n{\n}\nlemma Test2(n: Nat)\nensures n < Succ(n)\n{\n}\nlemma LtTrans(m: Nat, n: Nat, p: Nat)\nrequires lt(m, n)\nrequires lt(n, p)\nensures lt(m, p)\n{\n}\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\nlemma Disc2<T>(l: List<T>, a: T)\nensures Cons(a, l).head == a && Cons(a, l).tail == l\n{\n}\nfunction size<T>(l: List<T>): nat\n{\n    match l\n    case Nil => 0\n    case Cons(x, l') => size<T>(l') + 1\n}\nfunction app<T>(l1: List<T>, l2: List<T>) : List<T>\n{\n    match l1\n    case Nil => l2\n    case Cons(x, l1') => Cons(x, app(l1', l2))\n}\nlemma LenApp<T>(l1: List<T>, l2: List<T>)\nensures size(app(l1, l2)) == size(l1) + size(l2)\n{\n}\nfunction rev<T> (l: List<T>) : List<T>\n{\n    match l\n    case Nil => Nil\n    case Cons(x, l') => app(rev(l'), Cons(x, Nil))\n}\nlemma AppNil<T>(l: List<T>)\nensures app(l, Nil) == l\n{\n}\nlemma LR1<T> (l: List<T>, x: T)\nensures rev(app(l, Cons(x, Nil))) == Cons(x, rev(l))\n{\n}\nlemma RevRev<T>(l: List<T>)\nensures rev(rev(l)) == l\n{\n    match l\n    case Nil => assert true;\n    case Cons(x, l') => {\n        assert rev(rev(l)) == rev(app(rev(l'), Cons(x, Nil)));\n        LR1(rev(l'), x);\n    }\n}"
},
{
    "dafny": "class MyClass {\n  method M0(S: set<int>) {\n    forall s | s in S ensures s < 0;\n  }\n  method M1(x: int)\n  {\n    var i := x;\n    while (0 < i)\n      invariant i <= x;\n  }\n  method M2(x: int)\n  {\n    var i := x;\n    while (0 < i)\n      invariant i <= x;\n      decreases i;\n  }\n  var f: int;\n  method M3(x: int)\n    requires f <= x;\n    modifies `f;\n  {\n    while (0 < f)\n      invariant f <= x;\n      decreases f;\n      modifies `f;\n  }\n  predicate P(y: int)\n  method M4() {\n    forall y: int  \n      ensures P(y)\n    forall x: int  \n  }\n}"
},
{
    "dafny": "class Token{\n  var fp : int;\n  var cl : int;\n  method Init(fingerPrint : int, clearance : int)\n  modifies this;\n  requires validClearance(clearance);\n  ensures fp == fingerPrint && cl == clearance;\n  {\n    fp := fingerPrint;\n    cl := clearance;\n  }\n  method InvalidateToken()\n  modifies this`cl;\n  requires this != null;\n  ensures cl == -1;\n  {\n    cl := -1;\n  }\n}\nclass EnrollmentStn {\n  var fpSet : set<int>;\n  method Init()\n  modifies this;\n  ensures fpSet == {};\n  {\n    fpSet := {};\n  }\n  method IssueToken(fingerPrint : int, clearance : int) returns (t : Token)\n  modifies this`fpSet;\n  requires validClearance(clearance)\n  requires fingerPrint !in fpSet;\n  ensures fingerPrint in fpSet && t != null;\n  ensures fresh(t) && fingerPrint == t.fp && clearance == t.cl;\n  ensures fpSet == old(fpSet) + {fingerPrint};\n  {\n    t := new Token;\n    t.Init(fingerPrint, clearance);\n    fpSet := fpSet + {fingerPrint};\n    return t;\n  }\n}\nclass IDStn {\n  var clearanceLevel : int;\n  var alarm : bool;\n  var doorOpen : bool;\n  method Init(clearance : int)\n  modifies this;\n  requires validClearance(clearance);\n  ensures clearanceLevel == clearance && alarm == false && doorOpen == false;\n  {\n    clearanceLevel := clearance;\n    alarm := false;\n    doorOpen := false;\n  }\n  method TryOpenDoor(fingerPrint : int, t : Token)\n  modifies this`alarm, this`doorOpen, t`cl;\n  requires t != null && !alarm && !doorOpen;\n  ensures t.fp == fingerPrint && old(t.cl) >= clearanceLevel ==> doorOpen && !alarm;\n  ensures t.fp != fingerPrint || old(t.cl) < clearanceLevel ==> !doorOpen && alarm && t.cl == -1;\n  {\n    if(t.fp == fingerPrint && t.cl >= clearanceLevel){\n      doorOpen := true;\n      alarm := false;\n    } else {\n      t.InvalidateToken();\n      alarm := true;\n      doorOpen := false;\n    }\n  }\n  method CloseDoor()\n  modifies this`doorOpen;\n  ensures doorOpen == false;\n  {\n    doorOpen := false;\n  }\n}\npredicate validClearance(clearance : int)\n{\n   0 <= clearance <= 2\n}\nmethod TestMain()\n{\n  var enrStn := new EnrollmentStn;\n  enrStn.Init();\n  var idStn := new IDStn;\n  idStn.Init(0);\n  var t1 := enrStn.IssueToken(1,2);\n  idStn.TryOpenDoor(1, t1);\n  assert idStn.doorOpen;\n  assert !idStn.alarm;\n  idStn.CloseDoor();\n  assert !idStn.doorOpen;\n  var idStn2 := new IDStn;\n  idStn2.Init(2);\n  var t2 := enrStn.IssueToken(2,1);\n  idStn2.TryOpenDoor(2,t2);\n  assert !idStn2.doorOpen;\n  assert idStn2.alarm;\n  assert t2.cl == -1;\n  var idStn3 := new IDStn;\n  idStn3.Init(1);\n  var t3 := enrStn.IssueToken(3,2);\n  var t4 := enrStn.IssueToken(4,0);\n  idStn3.TryOpenDoor(4,t3);\n  assert !idStn3.doorOpen;\n  assert idStn3.alarm;\n  assert t3.cl == -1;\n}"
},
{
    "dafny": "class LimitedStack{\nvar capacity : int; \nvar arr : array<int>; \nvar top : int; \npredicate Valid()\nreads this, this.arr;\n{\n      arr != null && capacity > 0 && arr.Length == capacity && top >= -1 && top < capacity  \n}\npredicate Empty()\nreads this;\n{\n  top == -1\n}\npredicate Full()\nreads this;\n{\n  top == capacity -1 \n}\nmethod Init(c : int)\nmodifies this;\nrequires c > 0;\nensures fresh(arr);\nensures arr.Length == c;\nensures Empty();\nensures Valid();\n{\ncapacity := c;\narr := new int[c];\ntop := -1;\n}\nmethod isEmpty() returns (res : bool)\nensures Empty() ==> res;\n{\n  return top == -1;\n}\nmethod Peek() returns (elem : int)\nrequires this.Valid();\nrequires !Empty();\nensures elem == arr[top];\n{\n  return arr[top];\n}\nmethod Push(elem : int)\nmodifies arr, `top;\nrequires Valid();\nrequires !Full();\nensures Valid();\nensures top == old(top)+1;\nensures arr[top] == elem;\nensures forall k : int :: 0 <= k < top ==> arr[k] == old(arr[k]);\n{\n  top := top + 1;\n  arr[top] := elem;\n}\nmethod Pop() returns (elem : int)\nmodifies `top;\nrequires Valid();\nrequires !Empty();\nensures Valid();\nensures top == old(top)-1;\nensures elem == old(arr[top]);\nensures !Full();\n{\n  top := top -1;\n  return arr[top + 1];\n}\nmethod Shift()\nrequires Valid() && !Empty();\nensures Valid();\nensures forall i : int :: 0 <= i < capacity - 1 ==> arr[i] == old(arr[i + 1]);\nensures top == old(top) - 1;\nmodifies this.arr, this`top;\n{\nvar i : int := 0;\nwhile (i < capacity - 1 )\ninvariant 0 <= i < capacity;\ninvariant top == old(top);\ninvariant forall j : int :: 0 <= j < i ==> arr[j] == old(arr[j + 1]);\ninvariant forall j : int :: i <= j < capacity ==> arr[j] == old(arr[j]);\n{\narr[i] := arr[i + 1];\ni := i + 1;\n}\ntop := top - 1;\n}\nmethod Push2(elem : int)\nmodifies `arr;\n      requires Valid();\n      requires Full();\n      ensures Valid();\n      ensures Full();\n      ensures arr.Length == old(arr).Length;\n      ensures forall k : int :: 0 <= k < capacity - 1 ==> arr[k] == old(arr)[k+1];\n      ensures arr[top] == elem;\n{\n   var temp := new int[capacity];\n          forall(i | 0 <= i < arr.Length - 1)\n          {\n              temp[i] := arr[i+1];\n          }\n          temp[top] := elem;\n          arr := temp;\n}\nmethod Main(){\nvar s := new LimitedStack;\ns.Init(3);\nassert s.Empty() && !s.Full();\ns.Push(27);\nassert !s.Empty();\nvar e := s.Pop();\nassert e == 27;\ns.Push(5);\ns.Push(32);\ns.Push(9);\nassert s.Full();\nvar e2 := s.Pop();\nassert e2 == 9 && !s.Full();\nassert s.arr[0] == 5;\ns.Push(e2);\ns.Push2(99);\nvar e3 := s.Peek();\nassert e3 == 99;\nassert s.arr[0] == 32;\n}\n}"
},
{
    "dafny": "method Main()\n{\n    var a := new int[5];\n    var i := 0;\n    while i < a.Length\n      invariant 0 <= i <= a.Length\n      invariant forall j :: 0 <= j < i ==> a[j] == 0\n    {\n        a[i] := 0;\n        i := i + 1;\n    }\n    var v := a[3];\n    assert v == 0;\n}"
},
{
    "dafny": "class List {\n  var a: array<int>;\n  var size: nat;\n  predicate Valid()\n  reads a, this;\n  {\n    a != null &&\n    size <= a.Length &&\n    0 < a.Length && size >= 0 \n  }\n  constructor init(len:int)\n  requires len > 0 ;\n  ensures Valid();\n  ensures fresh(a);\n  ensures size == 0;\n  ensures a.Length == len ;\n  modifies this;    \n  {\n    a := new int[len];\n    size := 0;\n  }\n  method snoc(e: int)\n    requires Valid() && size < a.Length ;\n    ensures Valid();        \n    ensures size == old(size) + 1;\n    ensures a[old(size)] == e ;   \n    ensures forall i :: 0 <= i < old(size) ==> a[i] == old(a[i])\n    modifies a, `size;    \n  {\n    a[size] := e;    \n    size := size + 1;    \n  }\n  method tail()    \n    requires Valid() && size > 0;\n    ensures Valid();    \n    ensures size == old(size) - 1 ;\n    ensures forall i :: 0 <= i < size-1 ==> a[i] == old(a[i+1]) ;\n    modifies `size, a;\n  {    \n    forall (i | 0 <= i < size-1 ) {\n      a[i] := a[i + 1];  \n    }\n    size := size - 1;\n  }\n  method head() returns (h:int)\n  requires Valid() && size > 0;\n  ensures Valid();\n  ensures h == a[0] ; \n  {\n    h := a[0] ;\n  }\n  method Main() \n  {\n    var list := new List.init(4);\n    var aux : int;  \n    list.snoc(2);\n    aux := list.head();\n    assert (aux == 2) ;    \n    list.snoc(3);    \n    list.snoc(4);\n    aux := list.head();    \n    assert (aux == 2) ;\n    list.tail() ;\n    aux := list.head();\n    assert aux == 3 ;\n  }\n}"
},
{
    "dafny": "class Node\n{\n    var next: Node?;\n    var value: int;\n    constructor()\n    ensures this.next == null\n    {\n        this.next := null;\n    }\n}\nmethod Main() {\n    var node := new Node();\n    node.value := 5;\n    var x: int := 22 + node.value + -(2*7) + 1 + 7;\n    var y := node.value;\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && \n\tpre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || \n\tpre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n\tensures !res <==> isNotPrefixPred(pre,str)\n\tensures  res <==> isPrefixPred(pre,str)\n{\n    if(|pre| == 0){\n        return true;\n    }\n    if (|pre| > |str|){\n        return false;\n    }\n    res := pre == str[..|pre|];\n    return res;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n\t(exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\t(forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n\tensures !res <==> isNotSubstringPred(sub, str) \n{\n    res := false;\n    if (|str| < |sub|){\n        return res;\n    }\n    assert(|str| >= |sub|);\n    var i:= 0;\n    var substr: string;\n    while (i <= |str| && res == false)\n        decreases |str| - i\n        invariant 0 <= i < |str| + 2 && ((forall j :: 0 <= j < i ==> isNotPrefixPred(sub, str[j..])) <==> res == false) \n    {\n        substr := str[i..];\n        res := isPrefix(sub, substr);\n        i := i + 1; \n    }\n    return res;\n}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\texists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\tforall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n\tensures found  <==> haveCommonKSubstringPred(k,str1,str2)\n    ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) \n{\n    if (k > |str1| || k > |str2|){\n        return false;\n    }\n    var i := 0;\n    found := false;\n    while(i <= |str1| - k && found == false)\n        decreases |str1| - i \n        invariant 0 <= k <= |str1|\n        invariant 0 <= i <= |str1| - k + 1  && (found == false <==> forall j, l :: 0 <= j < i && l == j + k ==> isNotSubstringPred(str1[j..l], str2))\n    {\n        var substr : string := str1[i..i+k];\n        found := isSubstring(substr, str2);\n        i := i + 1;\n    }\n    return found;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n\trequires (|str1| <= |str2|)\n\tensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n\tensures haveCommonKSubstringPred(len,str1,str2)\n{\n    assert(|str1| <= |str2|);\n    assert(0 <= |str1|);\n    assert(0 <= |str2|);\n    len := |str1|;\n    var res : bool := true;\n    while(len > 0)\n        decreases |str1| - (|str1| - len)\n        invariant 0 <= len <= |str1| + 1\n        invariant forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2)\n    {\n        res := haveCommonKSubstring(len, str1, str2);\n        if(res){\n            break;\n        }\n       len := len - 1;\n    }\n    assert isPrefixPred(str1[|str1|..|str1|], str2[0..]);\n    return len;\n}"
},
{
    "dafny": "datatype Status = Shelf | Patron(name: string)\ndatatype Book = Book(title: string)\ndatatype Variables = Variables(library: map<Book, Status>)\n{\n  ghost predicate WellFormed()\n  {\n    forall b: Book :: b.title == \"\" ==> b !in this.library\n  }\n}\nghost predicate Init(v: Variables)\n{\n  && v.WellFormed()\n  && forall b :: b in v.library ==> v.library[b].Shelf?\n}\ndatatype Step = Checkout(b: Book, to: string) | Return(b: Book)\nghost predicate CheckoutStep(v: Variables, v': Variables, step: Step)\n  requires step.Checkout?\n{\n  && v.WellFormed()\n  && step.b in v.library\n  && v.library[step.b].Shelf?\n  && v' == v.(library := v.library[step.b := Patron(step.to)])\n}\nghost predicate ReturnStep(v: Variables, v': Variables, step: Step)\n  requires step.Return?\n{\n  && v.WellFormed()\n  && step.b in v.library\n  && v.library[step.b].Patron?\n  && v' == v.(library := v.library[step.b := Shelf])\n}\nghost predicate NextStep(v: Variables, v': Variables, step: Step)\n{\n  match step {\n    case Checkout(_, _) => CheckoutStep(v, v', step)\n    case Return(_) => ReturnStep(v, v', step)\n  }\n}\nghost predicate Next(v: Variables, v': Variables)\n{\n  exists step :: NextStep(v, v', step)\n}\nlemma NextStepDeterministicGivenStep(v:Variables, v':Variables, step: Step)\n  requires NextStep(v, v', step)\n  ensures forall v'' | NextStep(v, v'', step) :: v' == v''\n{}\nlemma ExampleExec() {\n  var e := [\n    Variables(library := map[Book(\"Snow Crash\") := Shelf, Book(\"The Stand\") := Shelf]),\n    Variables(library := map[Book(\"Snow Crash\") := Patron(\"Jon\"), Book(\"The Stand\") := Shelf]),\n    Variables(library := map[Book(\"Snow Crash\") := Patron(\"Jon\"), Book(\"The Stand\") := Patron(\"Tej\")]),\n    Variables(library := map[Book(\"Snow Crash\") := Shelf, Book(\"The Stand\") := Patron(\"Tej\")])\n  ];\n  assert Init(e[0]);\n  var steps := [\n    Checkout(Book(\"Snow Crash\"), \"Jon\"),\n    Checkout(Book(\"The Stand\"), \"Tej\"),\n    Return(Book(\"Snow Crash\"))\n  ];\n  assert forall n: nat | n < |e|-1  :: NextStep(e[n], e[n+1], steps[n]);\n  assert forall n: nat | n < |e|-1  :: Next(e[n], e[n+1]);\n}"
},
{
    "dafny": "method insertionSort(a : array<nat>)\n    modifies a\n{\n    var i := 0;\n    while (i < a.Length)\n    {\n        var j := i - 1;\n        while (j >= 0 && a[j] > a[j + 1])\n        {\n            a[j], a[j + 1] := a[j + 1], a[j];\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n}\ndatatype InputSpace = InputSpace(a:array<nat>)\ndatatype StateSpace = StateSpace(a:array<nat>, idx:nat)\npredicate sorted(state: StateSpace, begin: int, end: int)\n    reads state.a\n    requires state.a.Length > 0\n{\n    forall i, j :: 0 <= begin <= i <= j <= end < state.a.Length ==> state.a[i] <= state.a[j]\n}\nmethod insertionSortTransitionSystem(initialState : StateSpace) returns (terminalState:StateSpace)\n    modifies initialState.a\n    requires initialState.a.Length > 0\n    ensures terminalState.a.Length > 0\n    ensures multiset(initialState.a[..]) == multiset(terminalState.a[..])\n    ensures sorted(terminalState, 0, terminalState.a.Length - 1)\n{\n    var i := 0;\n    while (i < initialState.a.Length)\n        decreases initialState.a.Length - i\n        invariant 0 <= i <= initialState.a.Length\n        invariant sorted(initialState, 0, i - 1)\n    {\n        var j := i - 1;\n        while (j >= 0 && initialState.a[j] > initialState.a[j + 1])\n            invariant -1 <= j <= i - 1\n            invariant forall k :: j + 1 < k <= i ==> initialState.a[j + 1] < initialState.a[k]\n            invariant forall m, n :: 0 <= m <= j && j + 2 <= n <= i ==> initialState.a[m] <= initialState.a[n]\n            invariant sorted(initialState, 0, j)\n            invariant sorted(initialState, j + 2, i)\n            decreases j\n        {\n            initialState.a[j], initialState.a[j + 1] := initialState.a[j + 1], initialState.a[j];\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n    assert sorted(initialState, 0, initialState.a.Length - 1);\n    terminalState := initialState;\n}\nmethod Main()\n{\n    var arr := new nat[10];\n    arr[0] := 9;\n    arr[1] := 8;\n    arr[2] := 7;\n    arr[3] := 6;\n    arr[4] := 5;\n    arr[5] := 4;\n    arr[6] := 3;\n    arr[7] := 2;\n    arr[8] := 1;\n    arr[9] := 0;\n    var inputParameters := InputSpace(arr);\n    var initialState := StateSpace(arr, 4);\n    var terminalState := insertionSortTransitionSystem(initialState);\n    var output := terminalState.a;\n    assert sorted(StateSpace(output, output.Length - 1), 0, output.Length - 1);\n    insertionSort(arr);\n    var x := 0;\n    while(x < output.Length)\n    {\n        print(output[x]);\n        x := x + 1;\n    }\n    print(\"\\n\");\n    x := 0;\n    while(x < arr.Length)\n    {\n        print(arr[x]);\n        x := x + 1;\n    }\n}"
},
{
    "dafny": "predicate isSorted(a: array<int>)\n    reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\nmethod insertionSort(a: array<int>)\n    modifies a\n    ensures isSorted(a)\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    var i := 0;\n    while i < a.Length \n        decreases a.Length - i\n        invariant 0 <= i <= a.Length\n        invariant a.Length == 0 || 0 <= i <= a.Length\n        invariant forall l, r :: 0 <= l < r < i <= a.Length ==> a[l] <= a[r]\n        invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n        var j := i;\n        while j > 0 && a[j-1] > a[j]\n            decreases j\n            invariant forall l, r :: (0 <= l < r <= i  && j != r) ==> a[l] <= a[r]\n            invariant multiset(a[..]) == multiset(old(a[..]))\n        {\n            a[j-1], a[j] := a[j], a[j-1];\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "module Libraries__ModField {\nnewtype modulo = x : nat | 0 < x witness 1\ndatatype ModField = ModField(\n    val: int,\n    mod: modulo\n)\npredicate members_of_same_field(m: ModField, n: ModField) {\n    m.mod == n.mod  \n}\nfunction canonical(m: ModField) : ModField {\n    ModField(m.val % m.mod as nat, m.mod)\n}\npredicate congruent(m: ModField, n: ModField) {\n    members_of_same_field(m, n)\n    && canonical(m) == canonical(n)\n}\nfunction add(m: ModField, n: ModField) : ModField \n    requires members_of_same_field(m, n);\n{\n    assert m.mod == n.mod;\n    ModField(m.val + n.val, m.mod)\n}\nfunction additiveInverse(m: ModField) : ModField \n{\n    ModField(-m.val, m.mod)\n}\n}"
},
{
    "dafny": "datatype Colour = RED | WHITE | BLUE\nmethod FlagSort(flag: array?<Colour>) returns (white: int, blue: int)\nrequires flag!=null\nensures 0 <= white<=blue <= flag.Length\nensures forall i:: 0     <=i <white       ==> flag[i]==RED\nensures forall i:: white <=i <blue        ==> flag[i]==WHITE\nensures forall i:: blue  <=i <flag.Length ==> flag[i]==BLUE\nensures multiset(flag[..])== multiset(old(flag[..]))\nmodifies flag;\n{\n    var next := 0;\n    white := 0;\n    blue := flag.Length;    \n    while (next != blue)    \n    invariant 0 <= white<=next<=blue <= flag.Length\n    invariant forall i:: 0    <=i<white       ==> flag[i]==RED\n    invariant forall i:: white<=i<next        ==> flag[i]==WHITE\n    invariant forall i:: blue <=i<flag.Length ==> flag[i]==BLUE\n    invariant multiset(flag[..])== multiset(old(flag[..]))\n    {\n            match (flag[next])\n            {\n            case WHITE => next:=next+1;\n            case BLUE  => blue:=blue-1;\n                          flag[next], flag[blue] := flag[blue], flag[next];\n            case RED   => flag[next], flag[white] := flag[white], flag[next];\n                          next:=next+1;\n                          white:=white+1;\n            }\n    }\n}\nmethod Main(){\n  var a: array<Colour> := new Colour[6];\n  a[0],a[1],a[2],a[3],a[4] := RED,WHITE,BLUE,RED,WHITE;\n  var w,b := FlagSort(a);\n  print w,\" \",b ,\"\\n\";\n  var i := 0;\n  while(i < a.Length){\n    print a[i];\n    i := i + 1;\n  }\n  var x := 5/3;\n  print \"\\n\",x;\n}"
},
{
    "dafny": "method Swap(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n  var tmp := x;\n  x := y;\n  y := tmp;\n  assert x == Y && y == X;\n}"
},
{
    "dafny": "method Main() {\n\tvar l, n := FindLog(1);\n\tl, n := FindLog(8);\n\tprint(\"\\nlog of 8 is \");\n\tprint l; \n}\nfunction PowersOfTwo(d: nat) : nat { if d == 0 then 1 else 2*PowersOfTwo(d-1) }\nmethod FindLog(N: nat) returns (l: nat, n: nat)\n\trequires 1 <= N\n\tensures PowersOfTwo(l) <= N < PowersOfTwo(l+1)\n{\n\tn := N;\n\tassert 1 <= N == n;\n\tassert  1 <= N;\n\tl,n := FL1(N,n);\n\tassert Inv(l,n,N);\n\tL1(N,l,n);\n\tassert PowersOfTwo(l) <= N < PowersOfTwo(l+1);\n}\nmethod FL1(N: nat ,n0: nat) returns (l: nat, n: nat)\n\trequires 1 <= N\n\trequires n0 == N\n\tensures Inv(l,n,N)\n{\n\tn := n0;\n\tassert n==N && 1 <= N && 0==0;\n\tl := 0;\n\tassert l == 0;\n\tl,n := FL2(N,n,l);\n\tassert Inv(l,n,N);\n}\nmethod FL2(N: nat ,n0: nat, l0: nat) returns (l: nat, n: nat)\n\trequires 1 <= N\n\trequires n0 == N\n\trequires l0 == 0\n\tensures Inv(l,n,N)\n{\n\tl := l0;\n\tn := n0;\n\tassert 1<=N && n == N == n0 && l == 0 == l0;\n\tl,n := FL22(N,n,l);\n\tassert Inv(l,n,N) && n==1;\n}\nmethod FL22(N: nat ,n0: nat, l0: nat) returns (l: nat, n: nat)\n\trequires 1 <= N\n\trequires n0 == N\n\trequires l0 == 0\n\tensures Inv(l,n,N) && n==1\n{\n\tl,n := l0,n0;\n\tassert 1 <=N && n==N && l == 0;\n\tassert Inv(l,n,N);\n\twhile(2 <= n )\n\t\tinvariant Inv(l,n,N)\n\t\tdecreases n\n\t{\n\t\tghost var n1: nat := n;\n\t\tghost var l1: nat := l;\n\t\tassert Inv(l,n,N) && 2 <= n == n1 <= N && l1 == l;\n\t\tl,n := FL3(N,n,l);\n\t\tassert  Inv(l,n,N) && 0 < n == n1/2 && 0 < l==l1+1;\n\t}\n\tassert n == 1 && Inv(l,n,N);\n}\n method FL3(N: nat ,n0: nat, l0: nat) returns (l: nat, n: nat)\n\trequires Inv(l0,n0,N) \n\trequires 1 < N\n\trequires 2 <= n0 <= N\n\tensures Inv(l,n,N) && 0 < n == n0/2 && 0 < l == l0+1\n{\n\tl,n := l0,n0;\n\tassert l0 == l;\n\tassert 2 <= n == n0;\n\tassert Inv(l,n,N) && 1 < N ;\n\tl,n := FL4(N,n,l);\n\tassert Inv(l+1,n/2,N) && l == l0 && n == n0;\n\tl:= l0 +1;\n\tn:= n0/2;\n\tassert  Inv(l,n,N) && 0 < n == n0/2 && 0 < l==l0+1 ;\n}\n\tmethod FL4(N: nat ,n0: nat, l0: nat) returns (l: nat, n: nat)\n\trequires Inv(l0,n0,N) && 1 < N && 2 <= n0 \n\tensures Inv(l+1,n/2,N) && l0==l && n0==n\n{\n\tl,n := l0,n0;\n\tassert l0 == l;\n\tassert n0 == n;\n\tassert 2 <= n;\n\tassert Inv(l,n,N) && 1 < N;\n\tL4(N,l,n);\n\tassert Inv(l+1,n/2,N) && l0==l && n0==n;\n}\nlemma L4(N: nat ,l: nat, n: nat)\n\trequires  1 < N \n\trequires n>=2 \n\trequires Inv(l,n,N) \n\tensures  Inv(l+1,n/2,N) \nlemma L1(N: nat ,l: nat, n: nat)\n\trequires 1 <= N\n\trequires Inv(l,n,N)\n\tensures PowersOfTwo(l) <= N < PowersOfTwo(l+1)\npredicate Inv(l: nat, n: nat, N: nat)\n{\n\tn * PowersOfTwo(l) <= N < (n + 1) * PowersOfTwo(l) && 1 <= n\n}"
},
{
    "dafny": "predicate hasPrefix(token: string, str: string)\n{\n   (|token| == 0) || ((|token| <= |str|) && (token == str[..|token|]))\n}\npredicate hasNoPrefix(token:string, str:string)\n{\n\t(|token| > |str|) || (token != str[..|token|])\n}\npredicate hasSubstring(token:string, str:string)\n{\n\t(exists n : int :: (0 <= n < |str| + 1) && hasPrefix(token, str[n..]))\n}\npredicate hasNoSubstring(token:string, str:string)\n{\n\t(forall n : int | (0 <= n < |str| + 1) :: hasNoPrefix(token,str[n..]))\n}\nmethod isPrefix(token: string, str: string) returns (r:bool)\n   requires |token| >= 0 && |str| >= 0\n\tensures (r == true) <==> hasPrefix(token,str)\n\tensures (r == false) <==> hasNoPrefix(token,str)\n{\n\tif (|token| == 0)\n\t{\n\t\tr:=true;\n\t}\n   if (|str| < |token|)\n\t{\n\t\tr:=false;\n\t}\n   else \n   {\n      r:=(str[..|token|] == token);\n   }\n}\nmethod isSubstring(token: string, str: string) returns (r:bool)\n   requires |token| >= 0\n   requires |str| >= 0\n   requires |token| <= |str|\n\tensures (r == true) ==> (|token| == 0) || hasSubstring(token, str)\n\tensures (r == false) <==> hasNoSubstring(token, str)\n{\n   var m;\n\tvar i := 0;\n\tr := false;\n\twhile ((i < (|str| + 1)) && (r == false))\n\t\tinvariant 0 <= i <= |str|+1\n\t\tinvariant (r == true) ==> hasSubstring(token, str)\n\t\tinvariant (r == false) <==> (forall l :: 0 <= l < i ==> hasNoPrefix(token, str[l..]))\n\t\tdecreases |str| - i\n\t{\n\t\tm := isPrefix(token, str[i..]);\n\t\tif (m == true) {\n\t\t\tr := true;\n\t\t}\n\t\ti := i + 1;\n\t}\n}\nmethod Main()\n{\n   var s:string:=\"Hell\";\n   var t:string:=\"Hello World\";\n   assert s[..] == \"Hell\";\n   assert t[..] == \"Hello World\";\n   var r:bool:=isPrefix(s,t);\n   assert r;\n}"
},
{
    "dafny": "method isPrefix(pre: string, str: string) returns (res:bool)\n    requires |pre| > 0\n    requires |str| > 0\n    requires |pre| <= |str|\n{\n    if pre == str[..|pre|]\n        { return true; }\n    else\n        { return false; }\n}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    requires |sub| <= |str|\n    requires 0 < |sub|\n    requires 0 < |str|\n{\n    var i := 0;\n    var j := |str|-|sub|;\n    var temp : bool;\n    while i <= j\n        invariant i >= 0\n        decreases j - i\n    {\n        temp := isPrefix(sub, str[i..]);\n        if temp\n            { return true; }\n        else\n            { i := i+1; }\n    }\n    return false;\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    requires |str1| > 0\n    requires |str2| > 0\n    requires k > 0\n    requires k <= |str1|\n    requires k <= |str2|\n{\n   var i := 0;\n   var endIndex := |str1| - k;\n   var temp : bool;\n    while i < endIndex\n        invariant i >= 0\n        decreases endIndex - i\n    {\n        temp := isSubstring(str1[i..i+k], str2);\n        if temp\n            { return true; }\n        else\n            { i := i+1; }\n    }\n    return false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires |str1| > 0\n    requires |str2| > 0\n{\n    var commonSubstrLength := 0;\n    var hasCommonSubstring := false;\n    var i := 1;\n    while(i <= |str1| && i <= |str2|)\n        decreases |str1| - i\n    {\n        hasCommonSubstring := haveCommonKSubstring(i, str1, str2);\n        if hasCommonSubstring == false\n            { return commonSubstrLength; }\n        else \n            { i := i +1; }\n    }\n    return commonSubstrLength;\n}"
},
{
    "dafny": "method wxyz(efgh:array<int>, ijkl:int) returns (mnop:array<int>)\n{\n  mnop := new int[efgh.Length+1];\n  var opqr:= 0;\n  while (opqr < efgh.Length)\n    invariant 0 <= opqr <= efgh.Length\n    invariant forall rstu::0<=rstu<opqr ==> mnop[rstu]==efgh[rstu]\n  {\n    mnop[opqr] := efgh[opqr];\n    opqr:=opqr+1;\n  }\n  mnop[efgh.Length]:=ijkl;\n}"
},
{
    "dafny": "datatype channelType = epsilon| req_shared| req_exclusive\ndatatype cacheType = invalid| shared| exclusive\ntype client=nat\ntype boolean=bool\nmethod n_t3inv__1_0(cache:array<cacheType>,     home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv0:nat,p__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires p__Inv0!=p__Inv2&&p__Inv2<N0&& p__Inv0<N0\nrequires i==p__Inv2\nrequires ((home_current_command[0] == req_exclusive) && (home_sharer_list[i] == true)) \nensures   (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := invalid;\n  home_sharer_list[i] := false;\n}\nmethod n_t3inv__1_1(cache:array<cacheType>,     home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv0:nat,p__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires p__Inv0!=p__Inv2&&p__Inv2<N0&& p__Inv0<N0\nrequires i==p__Inv0\nrequires ((home_current_command[0] == req_exclusive) && (home_sharer_list[i] == true)) \nensures   (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := invalid;\n  home_sharer_list[i] := false;\n}\nmethod n_t3inv__1_2(cache:array<cacheType>,     home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv0:nat,p__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires p__Inv0!=p__Inv2&&p__Inv2<N0&& p__Inv0<N0\nrequires i!=p__Inv0&&i!=p__Inv2\nrequires (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nrequires ((home_current_command[0] == req_exclusive) && (home_sharer_list[i] == true)) \nensures   (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := invalid;\n  home_sharer_list[i] := false;\n}\nmethod n_t4inv__1_0(cache:array<cacheType>,     home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv0:nat,p__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires p__Inv0!=p__Inv2&&p__Inv2<N0&& p__Inv0<N0\nrequires i==p__Inv2\nrequires ((home_current_command[0] == req_shared) && (home_exclusive_granted[0] == true) && (home_sharer_list[i] == true)) \nensures   (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := shared;\n  home_sharer_list[i] := true;\n}\nmethod n_t4inv__1_1(cache:array<cacheType>,     home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv0:nat,p__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires p__Inv0!=p__Inv2&&p__Inv2<N0&& p__Inv0<N0\nrequires i==p__Inv0\nrequires ((home_current_command[0] == req_shared) && (home_exclusive_granted[0] == true) && (home_sharer_list[i] == true)) \nensures   (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := shared;\n  home_sharer_list[i] := true;\n}\nmethod n_t4inv__1_2(cache:array<cacheType>,     home_current_command:array<channelType>,  home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv0:nat,p__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires p__Inv0!=p__Inv2&&p__Inv2<N0&& p__Inv0<N0\nrequires i!=p__Inv0&&i!=p__Inv2\nrequires (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nrequires ((home_current_command[0] == req_shared) && (home_exclusive_granted[0] == true) && (home_sharer_list[i] == true)) \nensures   (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nmodifies cache\nmodifies home_exclusive_granted\nmodifies home_sharer_list\n{\n  home_exclusive_granted[0] := false;\n  cache[i] := shared;\n  home_sharer_list[i] := true;\n}\nmethod n_t5inv__1_0(cache:array<cacheType>,     home_current_client:array<client>,  home_current_command:array<channelType>, home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv0:nat,p__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_client.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_sharer_list.Length==N0\nrequires forall i,j::0<=i<cache.Length&&0<=j<cache.Length==>cache[i]!=cache[j]\nrequires forall i,j::0<=i<home_current_client.Length&&0<=j<home_current_client.Length==>home_current_client[i]!=home_current_client[j]\nrequires forall i,j::0<=i<home_current_command.Length&&0<=j<home_current_command.Length==>home_current_command[i]!=home_current_command[j]\nrequires forall i,j::0<=i<home_exclusive_granted.Length&&0<=j<home_exclusive_granted.Length==>home_exclusive_granted[i]!=home_exclusive_granted[j]\nrequires forall i,j::0<=i<home_sharer_list.Length&&0<=j<home_sharer_list.Length==>home_sharer_list[i]!=home_sharer_list[j]\nrequires 0<=i<N0\nrequires p__Inv0!=p__Inv2&&p__Inv2<N0&& p__Inv0<N0\nrequires i==p__Inv2\nrequires ((home_current_client[0] == i) && (home_current_command[0] == req_shared) && (home_exclusive_granted[0] == false)) \nensures   (!((cache[p__Inv2] == exclusive) && (cache[p__Inv0] == exclusive)))\nmodifies cache\nmodifies home_current_command\nmodifies home_sharer_list\n{\n  home_current_command[0] := epsilon;\n  home_sharer_list[i] := true;\n  cache[i] := shared;\n}\nmethod n_t5inv__1_1(cache:array<cacheType>,     home_current_client:array<client>,  home_current_command:array<channelType>, home_exclusive_granted:array<boolean>, home_sharer_list:array<boolean>,\nN0:nat,i:nat,\np__Inv0:nat,p__Inv2:nat)\nrequires N0>0\nrequires cache.Length==N0\nrequires home_current_client.Length==N0\nrequires home_current_command.Length==N0\nrequires home_exclusive_granted.Length==N0\nrequires home_share"
},
{
    "dafny": "function fib(n: nat): nat\ndecreases n;\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n      fib(n - 1) + fib(n - 2)\n}\nmethod ComputeFib(n: nat) returns (f: nat)\nrequires n > 0;\nensures f == fib(n);\n{\n  if (n ==0)\n   { f := 0; }\n  else\n  {\n    var i, f_1, f_2: int;\n    i := 1;\n    f := 1;    f_1 := 0;    f_2 := 0;\n    while (i < n)\n    decreases n - i\n    invariant i <= n;\n    invariant f_1 == fib(i-1);\n    invariant f == fib(i);\n   {\n      f_2 := f_1;\n      f_1 := f;\n      f  := f_1 + f_2;\n      i := i + 1;\n    }\n  }\n}"
},
{
    "dafny": "method MaxSum(x:int, y:int) returns (s:int, m:int)\n    ensures s == x+y\n    ensures (m == x || m == y) && x <= m && y <= m\n{\n    s := x+y;\n    if x > y{\n      m := x;\n    } else if y > x{\n      m := y;\n    } else {\n      m := x;\n    }\n    assert  m >= y;\n}\nmethod Main() \n{\n  var m, n := 4,5;\n  var a,b := MaxSum(m,n);\n  print \"Search return a is \", a,\",,,,, b is \", b, \"\\n\";\n}"
},
{
    "dafny": "function sum(A: array<int>, Length:int): int\n  decreases Length\n  requires 0 <= Length <= A.Length\n  reads A\n{\n  if Length == 0 then 0 else\n  if A[Length-1] % 2 == 0 then sum(A, Length-1) + A[Length-1] else sum(A, Length-1)\n}\nfunction product(A: array<int>, Length:int): int\n  decreases Length\n  requires 0 <= Length <= A.Length\n  reads A\n{\n  if Length == 0 then 1 else\n  if A[Length-1] % 2 == 1 then product(A, Length-1) * A[Length-1] else product(A, Length-1)\n}\nmethod compute(A: array<int>) returns (E: int, O: int, M: int)\n  requires 0 < A.Length\n  ensures E == sum(A, A.Length)\n  ensures O == product(A, A.Length)\n\tensures forall k :: 0 < k < A.Length ==> M >= A[k]\n\tensures exists k :: 0 < k < A.Length ==> M == A[k]\n{ \n  var index := 0;\n  E := 0;\n  O := 1;\n  M := 8;\n  if A.Length == 0{\n    return;\n  }\n  M := A[0];\n\twhile index < A.Length\n    decreases A.Length - index\n\t\tinvariant 0 <= index <= A.Length\n\t\tinvariant forall k :: 0 <= k < index ==> M >= A[k]\n    invariant E == sum(A, index)\n    invariant O == product(A, index)\n\t{\n    if A[index] % 2 == 0 {\n      E := E + A[index];\n    }\n    else{\n      O := O*A[index];\n    }\n\t\tif A[index] >= M { M := A[index]; }\n\t\tindex := index + 1;\n\t}\n  return E, O, M;\n}"
},
{
    "dafny": "ghost predicate even(n: nat) {\n  match n {\n    case 0 => true\n    case 1 => false\n    case _ => even(n - 2)\n  }\n}\nlemma a0() ensures even(4) {}\nlemma a1() ensures !even(3) {}\nlemma a2(n: nat) requires even(n) ensures even(n + 2) {}\nlemma a3(n: nat) requires even(n + 2) ensures even(n) {}\ndatatype EvenRule =\n  | ev_0\n  | ev_SS(r: EvenRule)\n{\n  ghost function apply(): nat {\n    match this {\n      case ev_0 => 0\n      case ev_SS(r) => r.apply() + 2\n    }\n  }\n}\nghost predicate Even(n: nat) {\n  exists r: EvenRule :: r.apply() == n\n}\nlemma b0() ensures Even(4) {\n  assert ev_SS(ev_SS(ev_0)).apply() == 4;\n}\nlemma b1() ensures !Even(3) {\n  if r: EvenRule :| r.apply() == 3 {\n    assert r.ev_SS? && r.r.apply() == 1;\n  }\n}\nlemma b2(n: nat) requires Even(n) ensures Even(n + 2) {\n  var r: EvenRule :| r.apply() == n;\n  assert ev_SS(r).apply() == n + 2;\n}\nlemma b3(n: nat) requires Even(n + 2) ensures Even(n) {\n  var r: EvenRule :| r.apply() == n + 2;\n  assert r.ev_SS? && r.r.apply() == n;\n}\ntype P = nat -> bool\nghost predicate Ev(ev: P) {\n  && ev(0)\n  && (forall n: nat | ev(n) :: ev(n + 2))\n}\nghost predicate Minimal(Ev: P -> bool, ev: P) {\n  && Ev(ev)\n  && (forall ev': P, n: nat | Ev(ev') :: ev(n) ==> ev'(n))\n}\nlemma c0(ev: P) requires Minimal(Ev, ev) ensures ev(4) {\n  assert ev(2);\n}\nlemma c1(ev: P) requires Minimal(Ev, ev) ensures !ev(3) {\n  var cex := (n: nat) => ( \n    n != 1 && n != 3\n  );\n  assert Ev(cex);\n}\nlemma c2(ev: P, n: nat) requires Minimal(Ev, ev) && ev(n) ensures ev(n + 2) {}\nlemma c3(ev: P, n: nat) requires Minimal(Ev, ev) && ev(n + 2) ensures ev(n) {\n  if !ev(n) {\n    var cex := (m: nat) => (\n      m != n + 2 && ev(m)\n    );\n    assert Ev(cex);\n  }\n}\nlemma a_implies_b(n: nat) requires even(n) ensures Even(n) {\n  if n == 0 {\n    assert ev_0.apply() == 0;\n  } else {\n    a_implies_b(n - 2);\n    var r: EvenRule :| r.apply() == n - 2;\n    assert ev_SS(r).apply() == n;\n  }\n}\nlemma b_implies_c(ev: P, n: nat) requires Minimal(Ev, ev) && Even(n) ensures ev(n) {\n  var r: EvenRule :| r.apply() == n;\n  if r.ev_SS? {\n    assert r.r.apply() == n - 2;\n    b_implies_c(ev, n - 2);\n  }\n}\nlemma c_implies_a(ev: P, n: nat) requires Minimal(Ev, ev) && ev(n) ensures even(n) {\n  if n == 1 {\n    var cex := (m: nat) => (\n      m != 1\n    );\n    assert Ev(cex);\n  } else if n >= 2 {\n    c3(ev, n - 2);\n    c_implies_a(ev, n - 2);\n  }\n}"
},
{
    "dafny": "method Main() {\n  var x: int := 2 + 1;\n  var z: int := 3 + 3*x;\n  if (x == x)\n  {\n    var x: int := 5;\n    x:= x + 1;\n  }\n  assert z == 4*x;\n}"
},
{
    "dafny": "datatype Option<T> =\n| Some(getSome: T)\n| None\ntrait K {}\ntrait V {}\ntrait Map {}\nfunction get(m: Map, k: K): Option<V>\nfunction putmany(m1: Map, m2: Map): Map\npredicate split(m: Map, m1: Map, m2: Map)\nlemma test(m: Map, mKeep: Map, mGive: Map, frame: Map, m2: Map, mL: Map, mStack: Map)\nrequires forall M, A, B :: split(M, A, B) <==> (forall k :: \n            (exists v :: get(M, k) == Some(v) &&\n                         ((get(A, k) == Some(v) && get(B, k) == None) ||\n                          (get(B, k) == Some(v) && get(A, k) == None))) ||\n            (get(M, k) == None && get(A, k) == None && get(B, k) == None))\nrequires forall m1, m2, k ::\n            (exists v :: get(putmany(m1, m2), k) == Some(v) &&\n                         (get(m2, k) == Some(v) || (get(m2, k) == None && get(m1, k) == Some(v)))) ||\n            (get(putmany(m1, m2), k) == None && get(m2, k) == None && get(m1, k) == None)\nrequires split(m, mKeep, mGive)\nrequires split(m2, m, mL)\nrequires split(mL, mStack, frame)\nensures split(m2, putmany(mKeep, mL), mGive)\n{}"
},
{
    "dafny": "module RussianMultiplication {\n    export provides mult\n    method mult(n0 : int, m0 : int) returns (res : int)\n    ensures res == (n0 * m0);\n    {\n        var n, m : int;\n        res := 0;\n        if (n0 >= 0) {\n            n,m := n0, m0;\n        } \n        else {\n            n,m := -n0, -m0;\n        }\n        while (0 < n)\n        invariant (m * n + res) == (m0 * n0);\n        decreases n; \n        { \n            res := res + m; \n            n := n - 1; \n        }\n    }\n}"
},
{
    "dafny": "predicate permutation (a:seq<int>, B: seq<int>)\n{multiset (a) == multiset (B)}\npredicate partOrdered (a:array<int>, lo:int, hi:int)\n    requires a != null\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\nforall i,j:: lo <= i < j < hi ==> a[j] <= a[i]\n}\npredicate ordered (a:array<int>)\n    requires a != null\n    reads a\n    {\n        partOrdered (a, 0, a.Length)\n    }\nmethod findMaxIndex(a:array<int>,i:int) returns (m:int)\n    requires a != null\n    requires 0 <= i < a.Length\n    ensures i <= m < a.Length\n    ensures forall k:: i <= k < a.Length ==> a[k] <= a[m]\n{\n    var j := i;\n    m := i;\n    while (j < a.Length)\n        invariant i <= j <= a.Length;\n        invariant i <= m < a.Length;\n        invariant forall k :: i <= k < j ==> a[k] <= a[m];\n        {\n            if(a[j] > a[m]){m := j;}\n            j := j + 1;\n        }\n}\nmethod selectionSort(a:array<int>)\n    requires a != null\n    modifies a\n    requires a.Length > 0\n    ensures ordered(a)\n    ensures permutation (a[..], old(a[..]))\n{\n    var m := 0;\n    var i := 0;\n    while(i < a.Length)\n        invariant 0 <= i <= a.Length;\n        invariant partOrdered(a,0,i);\n        invariant forall k, l :: 0 <= k < i <= l < a.Length ==> a[l] <= a[k];\n        invariant permutation (a[..], old(a[..]));\n    {\n            var t;\n            var m := findMaxIndex(a,i);\n            assert forall k :: i <= k < a.Length ==> a[k] <= a[m];\n            t := a[i];\n            a[i] := a[m];\n            a[m] := t;\n            i := i+1;\n    }\n}\nmethod Main ()\n{\n    var A := new int[10];\n    A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], A[8], A[9] := 4, 8, 8, 3, 5, 10, 9, 9, 4, 7;\n    print \"A= \", A[..], \"\\n\";\n    selectionSort (A);\n    print \"A= \", A[..], \"\\n\";\n}"
},
{
    "dafny": "method Main() \n{\n     var a := new int[6]; \n\t var p :nat;\n     a[0], a[1], a[2], a[3], a[4], a[5] := 8, 6, 4 , 10 ,-2 ,7;\n     qSort(a);\n     print a[0];\n\t print \" \";\n\t print a[1];\n\t print \" \";\n\t print a[2];\n\t print \" \";\n     print a[3];\n\t print \" \";\n     print a[4];\n\t print \" \";\n     print a[5];\n}\npredicate Sorted(a: array<int>)\n\trequires a != null\n\trequires a.Length > 0\n\treads a\n{\n\tSorted2(a,0,a.Length - 1)\n}\nmethod qSort(a: array<int>)\nrequires a != null\nrequires a.Length > 0\nmodifies a\nensures Sorted(a)\n{\n\tquickSort(a,0,a.Length - 1);\n}\npredicate Sorted2(a: array<int>, from: nat, to: nat)\n\trequires a != null\n\trequires from <= a.Length\n\treads a\n{\n\tforall i,j: nat :: from <= i < j <= to < a.Length ==> a[i] <= a[j]\n}\nmethod quickSort(a: array<int>, lo: nat, hi: nat)\n\trequires a != null\n\trequires 0 <= lo <= hi < a.Length\n\trequires 0 <= lo <= hi < a.Length-1 ==> forall j :: lo <= j <= hi ==> a[j] <= a[hi +1];\n    requires 0 < lo <= hi <= a.Length-1 ==> forall j :: lo <= j <= hi ==> a[lo - 1] <= a[j];\n\tmodifies a\n\tensures Sorted2(a,lo,hi)\n\tensures 0 <= lo <= hi < a.Length-1 ==> forall j :: lo <= j <= hi ==> a[j] <= a[hi +1];\n    ensures 0 < lo <= hi <= a.Length-1 ==> forall j :: lo <= j <= hi ==> a[lo - 1] <= a[j];\n    ensures forall x :: 0 <= x < lo || hi < x < a.Length ==> a[x] == old(a[x])\n\tdecreases hi - lo\n{\n\tif( hi > lo){\n\t\tvar p:= Partition(a,lo,hi);\n\t\tif( p == lo)\n\t\t{\n\t\t\tquickSort(a,p+1,hi);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif( p == hi )\n\t\t\t{\n\t\t\t\tquickSort(a,lo,p-1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tquickSort(a,lo,p-1);\n\t\t\t\tassert Sorted2(a,lo,p-1);\n\t\t\t\tquickSort(a,p+1,hi);\n\t\t\t\tassert Sorted2(a,p+1,hi);\n\t\t\t}\n\t\t}\n\t}\n}\npredicate Swapped(q0: seq<int>, q1: seq<int>, i: nat, j: nat)\n\trequires 0 <= i < |q0| == |q1|\n\trequires 0 <= j < |q1|\n{\n\tq0[i] == q1[j] && q0[j] == q1[i] && (forall k :: 0 <= k < |q0| && k != i && k != j ==> q0[k] == q1[k])\n}\nmethod Swap(a: array<int>, i: nat, j: nat)\n\trequires a != null\n\trequires 0 <= i < a.Length\n\trequires 0 <= j < a.Length\n\tmodifies a\n\tensures Swapped(a[..], old(a[..]), i, j)\n{\n\ta[i], a[j] := a[j], a[i];\n\tassert Swapped(a[..], old(a[..]), i, j);\n}\nmethod Partition(a: array<int>, lo: nat, hi: nat) returns (pivot: nat)\n\trequires a!=null && 0 < a.Length \n\trequires 0 <= lo <= hi < a.Length\n\trequires 0 <= lo <= hi < a.Length-1 ==> forall j :: lo <= j <= hi ==> a[j] <= a[hi +1];\n    requires 0 < lo <= hi <= a.Length-1 ==> forall j :: lo <= j <= hi ==> a[lo - 1] <= a[j];\n\tmodifies a\n\tensures 0 <= lo <= pivot <= hi < a.Length\n    ensures forall x :: lo <= x < pivot ==> a[x] <= a[pivot]\n    ensures forall x ::  pivot < x <= hi ==> a[x] >= a[pivot]\n\tensures forall x :: 0 <= x < lo || hi < x < a.Length ==> a[x] == old(a[x])\n\tensures 0 <= lo <= hi < a.Length -1==> forall j :: lo <= j <= hi ==> a[j] <= a[hi +1];\n    ensures 0 < lo <= hi <= a.Length-1 ==> forall j :: lo <= j <= hi ==> a[lo - 1] <= a[j];\n{ \n\tpivot := lo;\n\tvar j:nat := lo;\n\tassert j==lo && pivot == lo;\n\tassert a!=null && 0 < a.Length && 0 <= lo <= hi < a.Length;\n\twhile(j < hi)\n\t\tinvariant lo <= pivot <= j <= hi\n\t    invariant  forall x :: lo <= x < pivot ==> a[x] <= a[hi] \n\t\tinvariant forall x :: pivot <= x < j ==> a[x] >= a[hi]\n\t\tinvariant forall x :: 0 <= x < lo || hi < x < a.Length ==> a[x] == old(a[x])\n\t\tinvariant 0 <= lo <= hi < a.Length-1 ==> forall j :: lo <= j <= hi ==> a[j] <= a[hi +1];\n\t\tinvariant 0 < lo <= hi <= a.Length-1 ==> forall j :: lo <= j <= hi ==> a[lo - 1] <= a[j];\n\t\tdecreases hi - j\n\t{\n\t\tassert j < hi;\n\t    ghost var j1:nat;\n\t\tj1 := j;\n\t\tassert j == j1;\n\t\tif(a[j] <= a[hi]){\n\t\t\tSwap(a,pivot,j);\n\t\t\tpivot := pivot + 1;\n\t\t\tj := j + 1;\n\t\t}\n\t\telse{\n\t\t\tassert a[j] > a[hi];\n\t\t\tj := j + 1;\n\t\t\tassert a[j-1] > a[hi];\n\t\t} \n\t\tassert forall x :: lo <= x < pivot ==> a[x] <= a[hi] ;\n\t\tassert forall x :: pivot <= x < j ==> a[x] >= a[hi];\n\t\tassert hi - j1 > hi - j;\n\t}\n\tassert j == hi;\n\tSwap(a,hi,pivot);\n\tassert forall x :: pivot <= x < hi ==> a[x] >= a[pivot];\n\tassert forall x :: lo <= x < pivot ==> a[x] <= a[pivot];\n    assert forall x :: lo <= x < pivot <= hi ==> a[x] <= a[pivot];\n    assert forall x :: lo <= pivot < x <= hi ==> a[x] >= a[pivot];\n}"
},
{
    "dafny": "datatype Tree = Leaf | Node(x: int, left: Tree, right: Tree)\nfunction Insert(t: Tree, y: int): Tree\n{\n  match t\n  case Leaf => Node(y, Leaf, Leaf)\n  case Node(x, left, right) =>\n    if y < x then\n      Node(y, Insert(right, x), left)\n    else\n      Node(x, Insert(right, y), left)\n}\nghost function Elements(t: Tree): multiset<int>\n{\n  match t\n  case Leaf =>  multiset {}\n  case Node(x, left, right) => multiset {x} + Elements(left) + Elements(right)\n}\nghost predicate IsBalanced(t: Tree)\n{\n  match t\n  case Leaf => true\n  case Node(_, left, right) =>\n    IsBalanced(left) && IsBalanced(right) &&\n    var L, R := |Elements(left)|, |Elements(right)|;\n    L == R || L == R+1\n}\nlemma InsertBalanced_A(t: Tree, y: int)\n  requires IsBalanced(t)\n  ensures var t' := Insert(t, y);\n    Elements(\n      Insert(t, y)  \n    ) == Elements(t) + multiset {y} &&\n    IsBalanced(t')\n{\n}\nlemma InsertBalanced_B(t: Tree, y: int)\n  requires IsBalanced(t)\n  ensures var t' := Insert(t, y);\n    Elements(\n      t'  \n    ) == Elements(t) + multiset {y} &&\n    IsBalanced(t')  \n{\n}"
},
{
    "dafny": "function Pot(x: nat, y:nat):nat\ndecreases y\n{\n    if y == 0\n    then 1\n    else x * Pot(x, y-1)\n}\n method Potencia(x:nat, y:nat) returns (a:nat)\n ensures a == Pot(x,y)\n {\n     var b := x;\n     var p := y;\n    a := 1;\n    while p > 0\n    invariant Pot(b,p)*a == Pot(x,y)\n    decreases p\n    {\n        a := a * b;\n        p := p-1;\n    }\n }"
},
{
    "dafny": "method add_by_inc_vc(n: nat, m: nat) returns (r: nat)\n  ensures r == m + n;\n{\n  assume (true); \n  r := n;\n  var i := 0;\n  assert (i <= m && r == n + i); \n  i, r := *, *;\n  assume (i <= m && r == n + i);\n  if ( i < m )\n  {\n    ghost var rank0 := m - i;\n    i := i + 1;\n    r := r + 1;\n    assert(i <= m && r == n + i);\n    assert(m - i < rank0);\n    ghost var rank1 := m - i;\n    assert(rank1 < rank0);\n    assert(rank1 >= 0);\n    assume(false);\n  }\n  assert(r == m + n);\n  return r;\n}"
},
{
    "dafny": "function powerset<T(==)>(items: set<T>): set<set<T>> {\n    set xs: set<T> | xs <= items\n}\nmethod one_one<T(==)>() {\n    var A: set<set<set<set<T>>>> := {{},{{}},{{},{{}}}};\n    assert {} <= A;\n    assert {} in A;\n    assert {{}} in A;\n    assert {{}} <= A;\n    assert {{{}}} <= A;\n    assert {{{}}, {}} <= A;\n    var test := {1,2};\n    var pset := powerset(test);\n    assert {} <= pset;\n    assert {{1}} <= pset;\n    assert {{2}} <= pset;\n    assert {{1,2}} <= pset;\n}"
},
{
    "dafny": "method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n    requires y > 0\n    ensures less < x && x < more\n{\n   more := x + y;\n   less := x - y;\n}\nmethod Abs(x: int) returns (y: int)\n    ensures 0 <= y\n    ensures 0 <= x ==> x == y\n    ensures x < 0 ==> y == -x\n{\n   if x < 0\n      { return -x; }\n   else\n      { return x; }\n}\nmethod Max(x: int, y: int) returns (max: int)\n    ensures x >= y ==> max == x\n    ensures x < y ==> max == y\n{\n   if x >= y\n      { return x; }\n   else\n      { return y; }\n}\nmethod Testing()\n{\n    var v := Abs(3);\n    assert v == 3;\n}\nmethod TestingMax()\n{\n    var x := 1;\n    var y := 2;\n    var max := Max(x, y);\n    assert max == 2;\n}"
},
{
    "dafny": "predicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}\nmethod isPrefix(pre: string, str: string) returns (res: bool)\n  ensures |pre| > |str| ==> !res\n  ensures res == isPrefixPredicate(pre, str)\n{\n  if |pre| > |str|\n    {return false;}\n  var i := 0;\n  while i < |pre|\n    decreases |pre| - i\n    invariant 0 <= i <= |pre|\n    invariant forall j :: 0 <= j < i ==> pre[j] == str[j]\n  {\n    if pre[i] != str[i]\n    {\n        return false;\n    } \n    i := i + 1;\n  }\n return true;\n}\npredicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\nensures res == isSubstringPredicate(sub, str)\n{\n    if |sub| > |str| {\n        return false;\n    }\n    var i := |str| - |sub|;\n    while i >= 0 \n    decreases i\n    invariant i >= -1\n    invariant forall j :: i <  j <= |str|-|sub| ==> !(isPrefixPredicate(sub, str[j..]))\n    {\n        var isPref := isPrefix(sub, str[i..]);\n        if isPref\n        {\n            return true;\n        }\n        i := i-1;\n    }\n    return false;\n}\npredicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n  ensures |str1| < k || |str2| < k ==> !found\n  ensures haveCommonKSubstringPredicate(k,str1,str2) == found\n{\n    if( |str1| < k || |str2| < k){\n        return false;\n    }\n    var i := |str1| - k;\n    while i >= 0\n      decreases i\n      invariant i >= -1 \n      invariant forall j :: i < j <= |str1| - k ==> !isSubstringPredicate(str1[j..][..k], str2)\n    {\n        var isSub := isSubstring(str1[i..][..k], str2);\n        if isSub \n        {\n            return true;\n        }\n        i := i-1;\n    }\n    return false;\n}\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\nensures len <= |str1| && len <= |str2|\nensures len >= 0\nensures maxCommonSubstringPredicate(str1, str2, len)\n{\n  var i := |str1|;\n  while i > 0\n  decreases i\n  invariant i >= 0\n  invariant forall j :: i < j <= |str1| ==> !haveCommonKSubstringPredicate(j, str1, str2)\n  {\n    var ans := haveCommonKSubstring(i, str1, str2);\n    if ans {\n       return i;\n    }\n    i := i -1;\n  }\n  assert i == 0;\n  return 0;\n}"
},
{
    "dafny": "function sumInts( n: int ): int\n    requires n >= 0;\n{\n    if n == 0 then\n        0\n    else\n        sumInts(n-1)+n\n}\nmethod SumIntsLoop( n: int ) returns ( s: int )\n    requires n >= 0;\n    ensures s == sumInts(n)\n    ensures s == n*(n+1)/2;\n{\n    s := 0;\n    var k := 0;\n    while k != n\n        decreases n-k;\n        invariant 0 <= k <= n;\n        invariant s == sumInts(k)\n        invariant s == k*(k+1)/2;\n    {\n        k := k+1;\n        s := s+k;\n    }\n}\nmethod Main()\n{\n    var x := SumIntsLoop(100);\n    print x;\n}"
},
{
    "dafny": "method Triple(x: int) returns (r : int)\n    ensures r == 3*x\n    requires x % 2 == 0\n{\n    var y := x / 2;\n    r := 6 * y;\n}\nmethod Caller(){\n    var i := Triple(18);\n    print(i);\n}"
},
{
    "dafny": "function Abs(x: int):int\n{\n    if x<0 then -x else x\n}\nmethod IncDec(x: int, y: int) returns (sum: int)\nensures sum == x+y;\n{\n    sum := 0;\n    var k, j:= x, y;\n    while k!= 0 || j!=0\n    invariant x + y == sum + k + j\n    decreases Abs(k)\n    decreases Abs(j)\n    {\n        if k < 0{\n            sum:=sum-1;\n            k:=k+1;\n        }\n        else if k > 0{\n            sum:=sum+1;\n            k:=k-1;\n        }\n        if j < 0{\n            sum:=sum-1;\n            j:=j+1;\n        }\n        else if j > 0{\n            sum:=sum+1;\n            j:=j-1;\n        }\n    }\n}\nmethod Test(){\n    var sum := IncDec(5, 15);\n    assert sum == 20;\n    sum := IncDec(5, -15);\n    assert sum == -10;\n    sum := IncDec(5, 0);\n    assert sum == 5;\n    sum := IncDec(-5, 15);\n    assert sum == 10;\n    sum := IncDec(-5, -15);\n    assert sum == -20;\n    sum := IncDec(-5, 0);\n    assert sum == -5;\n}"
},
{
    "dafny": "method Abs(x: int) returns (y: int)\n\trequires x == -1\n\tensures 0 <= y\n\tensures 0 <= x ==> x == y\n\tensures x < 0 ==> y == -x\n{\n\ty := x + 2;\n}\nmethod Abs2(x: int) returns (y: int)\n    requires x > 0\n\tensures 0 <= y\n\tensures x < 0 ==> y == -x\n{\n\ty := x + 1;\n}"
},
{
    "dafny": "predicate G<X(!new)>(f:X~>bool)\n  reads f.reads;\n  requires forall x :: f.requires(x) && f(x);\n{\n  true\n}\npredicate H()\n{\n  G((x:int) => true)\n}\npredicate P1<X>(m:map<X,bool>)\n  requires forall x :: x in m ==> m[x];\n{\n  true\n}\npredicate P2(m:map<int,bool>)\n  requires forall x :: x in m ==> m[x];\n{\n  P1(map x:int | x in m :: true)\n}"
},
{
    "dafny": "datatype Alt = A(int) | B(int)\ndatatype MyOption = Some(v: Alt) | None\ndatatype MyPair = Pair(x: Alt, y: Alt)\ndatatype List<T> = Nil | Cons(head: T, tail: List)\nmethod NestingTest(xs: List<int>) returns (r: int)\n{\n  match xs {\n    case Cons(y, Cons(z, zs)) => return z;\n    case Cons(y, Nil) => return y;\n    case Nil => return 0;\n  }\n}\nmethod NestedVariableTest(x: List<int>) returns (r: int)\n{\n  match x {\n    case Cons(a, Cons(b, tl1)) => r := 0;\n    case Cons(c, tl2) => r := 1;\n    case d => r := 2;\n  }\n}\nmethod OrderedTest(x: MyOption ) returns (r: int)\n  ensures x == None ==> r == 2\n  ensures x != None ==> r < 2\n{\n  match x {\n    case Some(A(i)) => r := 0;\n    case Some(_) => r := 1;\n    case None => r := 2;\n  }\n}\nmethod VariableTest(x: List<int>) returns (r: int)\n{\n  match x {\n    case a => assert a == x; r := 1;\n  }\n}\nmethod ConstantTest(x: List<int>) returns (r: int)\n{\n  match x {\n    case Cons(1, tl1) => r := 0;\n    case Cons(c, Cons(2, tl2)) => r := 1;\n    case d => r := 2;\n  }\n}\nlemma SortedInv(z: int, l: List<int>)\n{\n  match l {\n    case Nil =>\n    case Cons(a, Cons(b, Cons(c, Nil))) =>\n    case Cons(a, b) =>\n  }\n}\nmethod BoolTest(x: bool) returns (r: int)\n{\n  match x {\n    case true => r := 0;\n    case false => r := 1;\n  }\n}\nmethod IntTest(x: int) returns (r: int)\n{\n  match x {\n    case 1 => r := 0;\n    case 2 => r := 1;\n    case n => r := n;\n  }\n}\nmethod StringTest(x: string) returns (r: int)\n ensures r == 2 || x == \"zero\" || x == \"one\"\n{\n  match x {\n    case \"zero\" => r := 0;\n    case \"one\" => r := 1;\n    case \"one\" => r := 3;  \n    case c => r := 2;\n  }\n}\nmethod CharTest(x: char) returns (r: int)\n{\n  match x {\n    case 'a' => r := 0;\n    case 'b' => r := 1;\n    case n => r := 2;\n  }\n}\nmethod RealTest(x: real) returns (r: int)\n{\n  match x {\n    case 1.0 => r := 0;\n    case 1609.344 => r := 1;\n    case c => r := 2;\n  }\n}\nnewtype N = x | x == 0 || x == 3 || x == 7\nmethod NewTypeTest() returns (r: int)\n  ensures r == 1\n{\n  var u: N := 3;\n  match u {\n    case 0 => r := 0;\n    case 3 => r := 1;\n    case 7 => r := 2;\n  }\n  return;\n}\ndatatype PairOfNumbers = P(0:int, 1:int)\nmethod M(p: PairOfNumbers) returns (r:int)\n  ensures p.0 == 11 && p.1 == 10 ==> r == 0\n  ensures p.0 == 11 && p.1 != 10 ==> r == 1\n  ensures p.0 == 11 || p.1 == 11 || r == 3\n{\n  match p\n  case P(11, 10) => assert p.0 != 10; r := 0;\n  case P(11, a) => r := 1;\n  case P(10, 11) => assert p.1 == 11; r := 2;\n  case _ => r := 3;\n}\ndatatype Tree = Leaf | Branch(left:Tree, b:bool, right: Tree)\nmethod MultipleNestedMatch(x: Alt, y: Tree, z: List<nat>) returns (r: nat)\n{\n  match x {\n    case A(i) =>\n      match y {\n        case Branch(_, _, Branch(_, b, _)) =>\n\t  match (b, z) {\n\t    case (true, Cons(n, _)) => r := n;\n\t    case (_, Nil) => r := 1;\n\t    case (false, Cons(n, _)) => r := n+1;\n\t  }\n\tcase Branch(Branch(_, b, _), _, _) =>\n\t  match (b, z) {\n\t    case (true, Cons(n, _)) => r := n;\n\t    case (false, Cons(n, _)) => r := n+1;\n\t    case (_, Nil) => r := 2;\n\t  }\n\tcase _ => r := 0;\n      }\n    case B(i) => r := 3;\n  }\n}\nmethod Main() {\n  var aa := Cons(6, Nil);\n  var bb := Cons(5, aa);\n  var cc := Cons(4, bb);\n  var dd := Cons(4, cc);\n  var ee := Cons(3, dd);\n  var ff := Cons(2, ee);\n  var gg := Cons(1, ff);\n  var r:int;\n  r := NestingTest(aa);\n  print \"NestingTest([6]) = \", r, \", should return 6\\n\";\n  r := NestedVariableTest(ff);\n  print \"NestedVariableTest([2::3::4::5::6]) = \", r, \", should return 0\\n\";\n  r := ConstantTest(ee);\n  print \"ConstantTest([3::4::5::6]) = \", r, \", should return 2\\n\";\n  r := M(P(11,10));\n  print \"M(P(11,10)) = \", r, \", should return 0\\n\";\n  r := M(P(-1,10));\n  print \"M(P(-1,10)) = \", r, \", should return 3\\n\";\n  var t1 := Branch(Leaf, true, Leaf);\n  var t2 := Branch(t1, false, Leaf);\n  var t3 := Branch(t2, true, t2);\n  var t4 := Branch(Leaf, false, t3);\n  var r0 := MultipleNestedMatch(A(0), t1, gg);\n  var r1 := MultipleNestedMatch(A(0), t3, Nil);\n  var r2 := MultipleNestedMatch(A(0), t2, Nil);\n  var r3 := MultipleNestedMatch(B(0), t3, ff);\n  var r4 := MultipleNestedMatch(A(0), t3, ee);\n  var r5 := MultipleNestedMatch(A(0), t4, bb);\n  print \"Testing MultipleNestedMatch: \", r0, r1, r2, r3, r4, r5, \", should return 012345\\n\";\n}"
},
{
    "dafny": "method CardinalitySubsetLt<T>(A: set<T>, B: set<T>)\n  requires A < B\n  ensures |A| < |B|\n  decreases B\n{\n  var b :| b in B && b !in A;\n  var B' := B - {b};\n  assert |B| == |B'| + 1;\n  if A < B' {\n    CardinalitySubsetLt(A, B');\n  } else {\n    assert A == B';\n  }\n}\nmethod strategy<T>(P: set<T>, Special: T) returns (count: int)\n  requires |P| > 1 && Special in P\n  ensures count == |P| - 1\n  decreases *\n{\n  count := 0;\n  var I := {};\n  var S := {};\n  var switch := false;\n  while count < |P| - 1\n    invariant count <= |P| - 1\n    invariant count > 0 ==> Special in I\n    invariant Special !in S && S < P && S <= I <= P\n    invariant if switch then |S| == count + 1 else |S| == count\n    decreases *\n  { \n    var p :| p in P;\n    I := I + {p};\n    if p == Special {\n      if switch {\n        switch := false;\n        count := count + 1;\n      }\n    } else {\n      if p !in S && !switch {\n        S := S + {p};\n        switch := true;\n      }\n    }\n  }  \n  CardinalitySubsetLt(S, I);\n  if I < P {\n    CardinalitySubsetLt(I, P);\n  }\n  assert P <= I;\n  assert I == P;\n}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key && (forall i :: 0 <= i < index ==> a[i] != key)\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n{\n  index := 0;\n  while index < a.Length\n    invariant 0<=index<=a.Length\n    invariant (forall i::0 <= i < index==>a[i] != key)\n  {\n    if a[index] == key { return; }\n    index := index + 1;\n  }\n  if index >= a.Length  {\n    index := -1;\n  }\n}"
},
{
    "dafny": "datatype List<T> = Nil | Cons(T, List<T>)\nfunction reverse(xs: List): List \ndecreases xs\n{\n    match xs\n    case Nil => Nil\n    case Cons(x, xrest) => append(reverse(xrest), Cons(x, Nil))\n}\nfunction append(xs: List, ys: List) : List \ndecreases xs\n{\n    match xs\n    case Nil => ys\n    case Cons(x, xrest) => Cons(x, append(xrest, ys))\n}\nghost method LemmaReverseTwice(xs: List) \ndecreases xs;\nensures reverse(reverse(xs)) == xs\n{\n    match xs\n    case Nil =>\n    case Cons(x, xrest) =>\n    assert reverse(reverse(xs)) == reverse(append(reverse(xrest), Cons(x, Nil)));  \n    LemmaReverseDistAppend(reverse(xrest), Cons(x,Nil)); \n    assert reverse(append(reverse(xrest), Cons(x,Nil))) == append(reverse(Cons(x,Nil)), reverse(reverse(xrest)));\n    LemmaReverseTwice(xrest);\n    assert append(reverse(Cons(x,Nil)), reverse(reverse(xrest))) == append(reverse(Cons(x, Nil)), xrest);\n    assert append(reverse(Cons(x,Nil)), xrest) == append(Cons(x,Nil), xrest);\n    assert append(Cons(x,Nil), xrest) == Cons(x, xrest);\n    assert Cons(x, xrest) == xs;\n}\nghost method LemmaReverseDistAppend(xs: List, ys: List)\nensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs));"
},
{
    "dafny": "method Main()\n{\n    var vazia: seq<int> := []; \n    var s := [1, 2, 3, 4, 5];\n    assert seq(3, n => n*n) == [0,1,4]; \n    assert |s| == 5; \n    assert s[0] == 1; \n    assert s[1..3] == [2, 3]; \n    assert s[1..] == [2, 3, 4, 5]; \n    assert s[..4] == [1, 2, 3, 4]; \n    assert [1,2,3] == [1] + [2,3]; \n    assert s[2 := 6] == [1,2,6,4,5]; \n    assert 1 in s; \n    assert 0 !in s; \n    assert forall i :: i in s ==> 1 <= i < 6; \n    assert vazia < s;\n    assert [1,2] < s;\n    assert [1,2,3,4,5] <= s;\n    var t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3]; \n    assert |t| == 3 && t[0] == [3.14] && t[1] == []; \n    assert t[2] == [2.7, 1.41, 1985.44];\n}"
},
{
    "dafny": "class Queue<T> {\n  var q : seq<T>; \n  constructor ()\n\t{\n    q := [];\n\t}\n  method Enqueue(elem: T)\n  modifies this;\n  ensures q == old(q) + [elem];\n  ensures q[|q|-1] == elem;\n  {\n    q := q + [elem];\n  }\n  method Dequeue() returns (r: T)\n  modifies this;\n  requires q != [];\n  ensures q == old(q)[0..|old(q)|-1];\n  ensures r == old(q)[|old(q)|-1];\n  {    \n    r := q[|q|-1];\n    q := q[0..|q|-1];\n  } \n  method Peek() returns (r: T)\n  requires q != [];\n  ensures q == old(q)\n  ensures r == old(q)[|old(q)|-1];\n  {    \n    r := q[|q|-1];\n  } \n}"
},
{
    "dafny": "module Set {\n    predicate greatestNum(a: set<int>, j: int) {\n        forall i :: i in a ==> j >= i\n    }\n    predicate smallestNum(a: set<int>, j: int) {\n        forall i :: i in a ==> j <= i\n    }\n    lemma sum(a: set<int>) returns (out: int)\n    {\n        var a' := a;\n        out := 0;\n        while a' != {}\n        decreases a'\n        {\n            var t :| t in a';\n            out := out + t;\n            a' := a' - {t};\n        }\n    }\n}"
},
{
    "dafny": "method foo(a: array<int>, e: int) returns (n:int)\n{\n  n :=0;\n  while n!=a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i<n ==> e!=a[i]\n  {\n    if e==a[n]{\n      return;\n    }\n    n:=n+1;\n  }\n}"
},
{
    "dafny": "method mean(x: int, y:int) returns (m : int)\n  requires x % 2 == y % 2;\n  ensures m == (x + y)/2;\n{\n  var i := x;\n  var j := y;\n  while (i != j)\n    invariant i < j ==> (x + y)/2 - i == j - (x + y)/2;\n    invariant i >= j ==> (x + y)/2 - j == i - (x + y)/2;\n    decreases if i < j then j - i else i - j;\n  {\n    if (i < j) {\n      i := i + 1;\n      j := j - 1;\n    } else {\n      j := j + 1;\n      i := i - 1;\n    }\n  }\n  m := i;\n}"
},
{
    "dafny": "datatype List = Nil | Cons(int, List)\nfunction Len(l:List): (v:int)\n  ensures v >= 0\n{\n  match l\n  case Nil => 0\n  case Cons(hd, tl) => Len(tl) + 1\n}\nfunction isEmpty(l:List): bool\n{\n    match l\n    case Nil => true\n    case Cons(hd, tl) => false\n}\nfunction Exists_eq(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd == x || Exists_eq(tl, x)\n}\nfunction Exists_neq(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd != x || Exists_neq(tl, x)\n}\nfunction Exists_lt(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd < x || Exists_lt(tl, x)\n}\nfunction Exists_gt(l:List, x:int): bool\n{\n  match l\n  case Nil => false\n  case Cons(hd, tl) => hd > x || Exists_gt(tl, x)\n}\nfunction Forall_eq(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd == x || Forall_eq(tl, x)\n}\nfunction Forall_neq(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd != x || Forall_neq(tl, x)\n}\nfunction Forall_le(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd <= x || Forall_le(tl, x)\n}\nfunction Forall_ge(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd >= x || Forall_ge(tl, x)\n}\nfunction Forall_lt(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd < x || Forall_lt(tl, x)\n}\nfunction Forall_gt(l:List, x:int): bool\n{\n  match l\n  case Nil => true\n  case Cons(hd, tl) => hd > x || Forall_gt(tl, x)\n}\nfunction ElemIndex(l:List, v:int): (idx: int)\n  ensures Len(l) > idx\n  ensures idx == -1 || Exists_eq(l, v)\n  ensures idx > -1 || Forall_neq(l, v)\n  ensures idx == -1 || idx == 0 || Exists_neq(l, v)\n{\n  match l\n  case Nil => -1\n  case Cons(hd, tl) => \n    if (v == hd) then 0 else\n      if (ElemIndex(tl, v) < 0) then -1 else ElemIndex(tl, v) + 1\n}"
},
{
    "dafny": "module {:options \"-functionSyntax:4\"} JSON.Utils.Seq {\n  lemma Neutral(l: seq)\n    ensures l == l + []\n  {}\n  lemma Assoc(a: seq, b: seq, c: seq)\n    ensures a + b + c == a + (b + c)\n  {}\n  lemma Assoc'(a: seq, b: seq, c: seq)\n    ensures a + (b + c) == a + b + c\n  {}\n  lemma Assoc2(a: seq, b: seq, c: seq, d: seq)\n    ensures a + b + c + d == a + (b + c + d)\n  {}\n}"
},
{
    "dafny": "datatype BloodType = AP | AN | BP | BN | ABP | ABN | OP | ON\nclass Blood {\n  var blood_id: int;\n  var blood_type: BloodType;\n  var volume: int;\n  var suitablity: bool;\n  var use_by_date: int;\n  var location: string;\n  var donor_name: string;\n  var donor_email: string;\n  var ordered: bool;\n  predicate Valid()\n  reads this;\n  {\n    volume > 0 && use_by_date > 0 &&\n    location != \"\" && donor_name != \"\" && donor_email != \"\"\n  }\n  constructor (id: int, b: BloodType, v: int, s: bool, u: int, \n    l: string, dn: string, de: string, o: bool) \n  requires v > 0 && u > 0;\n  requires l != \"\" && dn != \"\" && de != \"\"\n  ensures Valid();\n  modifies this;\n  {\n    blood_id := id;\n    blood_type := b;\n    volume := v;\n    suitablity := s;\n    use_by_date := u;\n    location := l;\n    donor_name := dn;\n    donor_email := de;\n    ordered := o;\n  }\n}\npredicate SortedExpiration(a: seq<Blood>, asc: bool)\nrequires forall j :: 0 <= j < |a| ==> a[j] != null && a[j].Valid();\nreads a;\nreads set x | x in a[..];\n{\n  asc ==> (forall j, k :: 0 <= j <= k < |a| \n    ==> a[j].use_by_date <= a[k].use_by_date) &&\n  !asc ==> (forall j, k :: 0 <= j <= k < |a| \n    ==> a[k].use_by_date <= a[j].use_by_date)\n}\nmethod hasEnoughVolume(blood: seq<Blood>, volume: int) returns (b: bool)\nrequires forall x :: 0 <= x < |blood| ==> blood[x] != null\n{   \n    b := false;\n    var i : int;\n    i := 0;\n    var totalVolume: int;\n    totalVolume := 0;\n    while i < |blood|\n    decreases |blood| - i\n    invariant 0 <= i <= |blood|\n    {\n        totalVolume := totalVolume + blood[i].volume;\n        i := i + 1;\n    }\n    if totalVolume > volume {\n        b:= true;\n    }\n}\nmethod requestBlood(allBlood: seq<Blood>, bt: BloodType, amount: int, deliverByDate: int) returns (allocation: seq<Blood>)\nrequires forall i :: 0 <= i < |allBlood| ==> allBlood[i] != null && allBlood[i].Valid()\nrequires SortedExpiration(allBlood, true)\nensures forall j :: 0 <= j < |allocation| ==> allocation[j] != null\nensures forall j :: 0 <= j < |allocation| ==> allocation[j].blood_type == bt\nensures forall j :: 0 <= j < |allocation| ==> allocation[j].use_by_date <= deliverByDate\n{\n    var i: int;\n    i := 0;\n    var suitable : seq<Blood>;\n    suitable := [];\n    while i < |allBlood|\n    decreases |allBlood| - i\n    invariant 0 <= i <= |allBlood|;\n    invariant forall j :: 0 <= j < |suitable| ==> suitable[j] != null && suitable[j].Valid();\n    invariant forall j :: 0 <= j < |suitable| ==> suitable[j].suitablity == true && suitable[j].use_by_date <= deliverByDate && suitable[j].blood_type == bt\n    {\n        if allBlood[i].suitablity == true && allBlood[i].use_by_date <= deliverByDate && allBlood[i].blood_type == bt\n        {\n            assert allBlood[i].Valid();\n            suitable := suitable + [allBlood[i]];\n        }\n        i := i + 1;\n    }\n    var check : bool;\n    check := hasEnoughVolume(suitable, amount);\n    if !check{\n        allocation := [];\n        return;\n    }\n    var True: bool;\n    True := true;\n    i := 0;\n    allocation := [];\n    while i < |suitable|\n    decreases |suitable| - i\n    invariant forall j :: 0 <= j < |suitable| ==> suitable[j] != null && suitable[j].suitablity == true && suitable[j].use_by_date <= deliverByDate && suitable[j].blood_type == bt && suitable[j].Valid()\n    invariant forall j :: 0 <= j < |allocation| ==> allocation[j] != null && allocation[j].suitablity == true && allocation[j].use_by_date <= deliverByDate && allocation[j].blood_type == bt && allocation[j].Valid()\n    {\n        check := hasEnoughVolume(allocation, amount);\n        if !check{\n            allocation := allocation + [suitable[i]];\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "function F(): int {\n    29\n}\nmethod M() returns (r: int)\n    ensures r == 29;\n{\n    r := 29;\n}\nmethod Caller() {\n    var a := F();\n    var b := M();\n    assert a == 29;\n    assert b == 29;\n}"
},
{
    "dafny": "predicate permutation (A:seq<int>, B:seq<int>)\n{ multiset (A) == multiset (B)}\npredicate partOrdered (A:array<int>, lo:int, hi:int)\n\trequires A != null\n\trequires 0 <= lo <= hi <= A.Length\n\treads A\n{ forall i,j:: lo <= i < j < hi ==> A[i] <= A[j] }\npredicate ordered (A:array<int>)\n\trequires A != null\n\treads A\n\t{\n\t\tpartOrdered (A, 0, A.Length)\n\t}\nmethod bubbleSort (A:array<int>)\n\trequires A != null\n\tmodifies A\n\tensures ordered(A)\n\tensures permutation (A[..], old(A[..]))\n{\n\tif A.Length > 1\n\t{\n\t\tvar i := 1;\n\t\twhile i < A.Length\n\t\t\tinvariant 1 <= i <= A.Length\n\t\t\tinvariant partOrdered (A, 0, i)\n\t\t\tinvariant permutation (A[..], old(A[..]))\n\t\t\tdecreases A.Length - i\n\t\t{\n\t\t\tbubble (A, i);\n\t\t\ti := i+1;\n\t\t}\n\t}\n}\nmethod bubble (A:array<int>, i:int)\n\trequires A != null && 0 <= i < A.Length\n\trequires partOrdered (A, 0, i)\n\tmodifies A\n\tensures partOrdered (A, 0, i+1)\n\tensures permutation (A[..], old(A[..]))\n{\n\tvar j:= i;\n\twhile j > 0 && A[j-1] > A[j]\n\t\tinvariant 0 <= j <= i\n\t\tinvariant partOrdered (A, 0, j) && partOrdered(A, j, i+1)\n\t\tinvariant permutation (A[..], old(A[..]))\n\t\tinvariant 1 < j+1 <= i ==> A[j-1] <= A[j+1]\n\t\tdecreases j\n\t{\n\t\tA[j-1], A[j] := A[j], A[j-1];\n\t\tj := j-1;\n\t}\n}\nmethod Main ()\n{\n\tvar A:= new int[10];\n\tA[0],A[1],A[2],A[3],A[4],A[5],A[6],A[7],A[8],A[9] := \n\t4,8,8,3,5,10,9,9,4,7;\n\tprint \"A = \", A[..], \"\\n\";\n\tbubbleSort (A);\n\tprint \"A = \", A[..], \"\\n\";\n}"
},
{
    "dafny": "function recsum(a: array?<int>,Max:nat) : int \n  reads a             \n  requires a != null  \n  requires 0 <= Max <= a.Length\n  decreases Max\n{ \n  if a.Length == 0 then 0\n  else if 0 == Max then 0\n  else a[Max - 1] + recsum(a, Max-1) \n}\nmethod sumarr(a: array?<int>) returns (sum:int)\n  requires a != null\n  ensures sum == recsum(a,a.Length)\n{\n  sum := 0;\n  if (a.Length==0) {return;}\n  var i : int := 0;\n  while (i < a.Length)\n  invariant 0 <= i <= a.Length \n  invariant sum == recsum(a, i) \n  decreases a.Length - i \n  {\n    sum := sum + a[i]; i:=i+1;\n  }\n}"
},
{
    "dafny": "class Switch\n{\n    var state:bool;\n    constructor ()\n        ensures this.state == false\n    {\n        this.state := false;\n    }\n    method toggle() returns (currentState : bool)\n        modifies this\n        ensures this.state != old(this.state)\n        ensures currentState == this.state\n    {\n        this.state := ! this.state;\n        currentState:= this.state;\n    }\n    method getState() returns (currentState : bool)\n        ensures currentState == this.state\n        ensures this.state ==  old(this.state)\n    {\n        currentState := this.state;\n    }\n}\nmethod Test()\n{\n    var s := new Switch();\n    var state := s.getState();\n    assert(state == false);\n    state := s.toggle();\n    assert(state == true);\n    state := s.toggle();\n    assert(state == false);\n    state := s.toggle();\n    assert(state == true);\n    state := s.toggle();\n    assert(state == false);\n}"
},
{
    "dafny": "method intDiv(n: nat, d: nat) returns(q: nat, r: nat) \nrequires n >= 0 && d > 0;\nensures n == q * d + r\nensures 0 <= r < d\n{\n    q := 0;\n    r := n;\n    while r >= d\n    invariant q * d + r == n\n    {\n        q := q + 1;\n        r := r - d;\n    }\n}"
},
{
    "dafny": "method Test()\n{\n    assert  IsPalindrome(\"\");\n    assert  IsPalindrome(\"a\");\n    assert  IsPalindrome(\"aa\");\n    assert !IsPalindrome(\"ab\");\n    assert  IsPalindrome(\"aba\");\n    assert !IsPalindrome(\"abc\");\n    assert  IsPalindrome(\"abba\");\n    assert !IsPalindrome(\"abca\");\n}\npredicate IsPalindrome(s: string)\n    decreases s;\n{\n    if |s| <= 1 then\n        true\n    else if s[0] != s[|s| - 1] then\n        false\n    else\n        IsPalindrome(s[1..|s| - 1])\n}"
},
{
    "dafny": "function Potencia(x:nat, y:nat):nat\n{\n    if y == 0\n    then 1\n    else x * Potencia(x, y-1)\n}\nmethod Pot(x:nat, y:nat) returns (r:nat)\nensures r == Potencia(x,y)\n{\n    r := 1;\n    var b := x;\n    var e := y;\n    while e > 0\n    invariant Potencia(b,e) * r == Potencia(x,y)\n    {\n        r := r * b;\n        e := e - 1;\n    }\n    return r;\n}"
},
{
    "dafny": "class ATM\n{\n    var insertcard : bool;\n    var wrongpincounter : int;\n    var authentication : bool;\n    constructor()\n    modifies this\n    ensures insertcard == false && wrongpincounter == 0 && authentication == false\n    {\n        insertcard := false;\n        wrongpincounter := 0;\n        authentication := false;\n    }\n    method enterpin(pin : int)\n    modifies this\n    requires wrongpincounter == 0 && authentication == false && insertcard == true\n    ensures pin == 4 && wrongpincounter <= 2 ==> authentication == true \n    ensures pin != 4 && wrongpincounter <= 2 ==> authentication == false && wrongpincounter == old(wrongpincounter) + 1\n    ensures pin != 4 && wrongpincounter >= 3 ==> insertcard == false && authentication == false\n    {\n        if(pin != 4)\n        { \n            authentication := false;\n            wrongpincounter := wrongpincounter + 1;\n        }\n        else \n        {\n            if(wrongpincounter >= 3)\n            {\n                authentication := false;\n                insertcard := false;\n            }\n            else\n            {\n                authentication := true;\n            }\n        }\n    }\n}"
},
{
    "dafny": "predicate unforgivenEqual(a:array<int>)\nreads a\n{ if (a.Length>=2) then (a[0]==a[1]) else false }\npredicate forgivenEqual(a:array<int>)\nreads a\n{ (a.Length>=2) ==> a[0]==a[1] }\npredicate forbiddenEqual(a:array<int>)\nrequires a.Length>=2\nreads a\n{ a[0]==a[1] }\nmethod Main()\n{\nvar a := new int[1]; \nvar b := new int[2]; \na[0] := 1;\nassert forgivenEqual(a); \nassert !unforgivenEqual(a); \nb[0], b[1] := 1, 2;\nassert !forbiddenEqual(b); \nassert !forgivenEqual(b);\nassert !unforgivenEqual(b);\n}"
},
{
    "dafny": "predicate ReverseSorted(a:array<int>, low:int, high:int)\n\treads a\n{\n\t0 <= low <= high <= a.Length &&\n\tforall i,j :: low <= i < j < high ==> a[i] >= a[j]\n}\nmethod BubbleSort(a:array<int>)\n\tmodifies a\n\trequires a.Length > 1\n\tensures ReverseSorted(a, 0, a.Length)\n\tensures multiset(a[..]) == multiset(old(a[..]))\n{\n\tvar i := 0;\n\twhile (i < a.Length)\n\t\tinvariant 0 <= i <= a.Length\n\t\tinvariant forall x :: a.Length-i <= x < a.Length ==> forall y :: 0 <= y < a.Length-i ==> a[x] <= a[y]\n\t\tinvariant ReverseSorted(a, a.Length - i, a.Length)\n\t\tinvariant multiset(a[..]) == multiset(old(a[..]))\n\t{\n\t\tvar j := 0;\n\t\twhile (j < a.Length-i-1)\n\t\t\tinvariant 0 <= j <= a.Length-i-1\n\t\t\tinvariant forall k :: 0 <= k <= j ==> a[k] >= a[j]\n\t\t\tinvariant forall x :: a.Length-i <= x < a.Length ==> forall y :: 0 <= y < a.Length-i ==> a[x] <= a[y]\n\t\t\tinvariant ReverseSorted(a, a.Length-i-1, a.Length)\n\t\t\tinvariant multiset(a[..]) == multiset(old(a[..]))\n\t\t{\n\t\t\tif (a[j] < a[j+1])\n\t\t\t{\n\t\t\t\ta[j], a[j+1] := a[j+1], a[j];\n\t\t\t}\n\t\t\tj := j + 1;\n\t\t}\n\t\ti := i + 1;\n\t}\n}"
},
{
    "dafny": "module Mathematics {\n\tfunction min(a: int, b: int) : int\n\t{\n\t\tif a < b\n\t\t\tthen a\n\t\telse\n\t\t\tb\n\t}\n\tfunction max(a: int, b: int) : int\n\t{\n\t\tif a < b\n\t\t\tthen b\n\t\telse\n\t\t\ta\n\t}\n  function Set<T>(ms: multiset<T>) : set<T>\n  {\n    set x : T | x in ms\n  }\n  function ISet<T>(ms: set<T>) : iset<T>\n  {\n    iset x : T | x in ms\n  }\n  lemma PosMulPosIsPos(x: int, y: int)\n    requires 0 < x\n    requires 0 < y\n    ensures 0 < x * y\n  {\n  }\n  lemma DivCeilLT(x: int, d: int)\n    requires 1 < d\n    requires 1 < x\n    ensures (x + d - 1) / d < x\n  {\n    PosMulPosIsPos(d-1, x-1);\n    calc <= {\n      0; <\n      (d-1) * (x-1);\n    }\n  }\n  lemma PosMulPreservesOrder(x: nat, y: nat, m: nat)\n    requires x <= y\n    ensures x * m <= y * m\n  {\n  }\n}"
},
{
    "dafny": "module NeedsAllLiteralsAxiom {\n  function trick(n: nat, m: nat): nat\n    decreases n  \n  {\n    if n < m || m==0 then n else trick(n-m, m) + m\n  }\n  lemma lemma_trick(n: nat, m: nat)\n    ensures trick(n, m) == n\n  {\n  }\n  lemma calc_trick(n: nat, m: nat)\n    ensures trick(100, 10) == 100\n  {\n  }\n}"
},
{
    "dafny": "method preserveSum(x: int, y:int, a:int) returns (p: int, q: int)\nensures p + q == x + y\n{\n    p := x + a;\n    q := y - a;\n}\nmethod preserveSumProduct(x: int, y:int) returns (p: int, q: int)\nensures p + q == x + y && p*q < 0\n{\n    p := x-y*y-1;\n    assert p == x-y*y-1;\n    q := y+y*y+1;\n    assert p == x-y*y-1 && q == y+y*y+1 && p+q == x + y;\n    if (x > y) {\n        assert x > y && p == x-y*y-1 && q == y+y*y+1;\n        p := x+x*x+1;\n        q := y-x*x-1;\n        assert x > y && p == x+x*x+1 && q == y-x*x-1;\n        assert x > y && p-x-1 == x*x && q == y-x*x-1;\n        assert x > y && x <= p-x-1 && q == y-x*x-1;\n        assert x > y && 1 <= p && q == y-x*x-1;\n        assert x > y && p > 0 && q == y-x*x-1;\n        assert x*x > y && p > 0 && q == y-x*x-1;\n        assert x*x > y && p > 0 && x*x == y-q-1;\n        assert p > 0 && y-q-1 > y;\n        assert p > 0 && -q-1 > 0;\n        assert p > 0 && q < -1;\n        assert p > 0 && q < 0;\n        assert p*q < 0;\n    }\n}"
},
{
    "dafny": "predicate acheck(a: array<int>, n: int)\nreads a\nrequires n >= 1\n{\n\ta.Length % 2 == 0 && \n\tforall i :: 0 <= i < a.Length ==> \n\t\tif i % n == 0 then a[i] == 0 else a[i] != 0\n}\nmethod Main()\n{\n\tvar arr: array<int> := new int[][0,42,0,42];\n\tvar res := acheck(arr, 2);\n\tassert res;\n\tarr := new int[][];\n\tres := acheck(arr, 2);\n\tassert res;\n\tarr := new int[][0,4,2,0];\n\tassert arr[2] == 2;\n\tres := acheck(arr, 2);\n\tassert !res;\n}"
},
{
    "dafny": "module DafnyVerification{\n    class SortingService {\n        predicate sorted(a: array?<int>, l: int, u: int)\n        reads a\n        requires a != null\n        {\n            forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]\n        }\n        predicate partitioned(a: array?<int>, i: int)\n        reads a\n        requires a != null\n        {\n            forall k, k' :: 0 <= k <= i < k' < a.Length ==> a[k] <= a[k']\n        }\n        method BubbleSort(a: array?<int>)\n        modifies a\n        requires a != null\n        ensures sorted(a, 0, a.Length-1)\n        {\n            var i := a.Length - 1;\n            while(i > 0)\n            invariant i < 0 ==> a.Length == 0 \n            invariant sorted(a, i, a.Length-1)\n            invariant partitioned(a, i)\n            {\n                var j := 0;\n                while (j < i)\n                invariant 0 < i < a.Length && 0 <= j <= i\n                invariant sorted(a, i, a.Length-1)\n                invariant partitioned(a, i)\n                invariant forall k :: 0 <= k <= j ==> a[k] <= a[j]\n                {\n                    if(a[j] > a[j+1])\n                    {\n                        a[j], a[j+1] := a[j+1], a[j];\n                    }\n                    j := j + 1;\n                }\n                i := i -1;\n            }\n        }\n    }\n    class BinarySearchService{\n        method BinarySearch(a: array<int>, key: int) returns (r: int)\n        requires forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n        ensures 0 <= r ==> r < a.Length && a[r] == key\n        ensures r < 0 ==> key !in a[..]\n        {\n        var lo, hi := 0, a.Length;\n        while lo < hi\n            invariant 0 <= lo <= hi <= a.Length\n            invariant key !in a[..lo] && key !in a[hi..]\n        {\n            var mid := (lo + hi) / 2;\n            if key < a[mid] {\n            hi := mid;\n            } else if a[mid] < key {\n            lo := mid + 1;\n            } else {\n            return mid;\n            }\n        }\n        return -1;\n        }\n    }\n}"
},
{
    "dafny": "datatype Color = Blue | Yellow | Green | Red\ndatatype Tree<T> = Leaf(data: T)\n                 | Node(left: Tree<T>, right: Tree<T>)\npredicate AllBlue(t: Tree<Color>) {\n  match t\n  case Leaf(c) => c == Blue\n  case Node(left, right) => AllBlue(left) && AllBlue(right) \n}\nfunction Size<T>(t: Tree<T>): nat {\n  match t\n  case Leaf(_) => 1\n  case Node(left, right) => Size(left) + Size(right)\n}\nlemma Test() {\n  var a := Leaf(Color.Blue);\n  var b := Leaf(Color.Yellow);\n  var t := Tree.Node(a, b);\n  assert Size(t) == Size(t) == 2;\n}"
},
{
    "dafny": "datatype List<T> = Nil | Cons(T, List<T>) {\n  function App(ys: List<T>): List<T> {\n    match this\n      case Nil => ys\n      case Cons(x, xs) => Cons(x, xs.App(ys))\n  }\n  static ghost function Concat<T>(l: List<List<T>>): List<T> {\n    match l\n      case Nil => Nil\n      case Cons(x, xs) => x.App(Concat(xs))\n  }\n  lemma AppAssoc(m: List<T>, n: List<T>)\n    ensures App(m).App(n) == App(m.App(n))\n  {}\n  static lemma ConcatApp<T>(l1: List<List<T>>, l2: List<List<T>>)\n    ensures Concat(l1.App(l2)) == Concat(l1).App(Concat(l2))\n  {\n      match l1\n        case Nil =>\n        case Cons(x, xs) =>\n          x.AppAssoc(Concat(xs), Concat(l2));\n  }\n}\nmethod Main() {}"
},
{
    "dafny": "method Find(a: array<int>, key: int) returns (index: int)\n  requires a != null\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n{\n  index := 0;\n  while index < a.Length\n    invariant 0 <= index <= a.Length\n  {\n    if a[index] == key {\n      return;\n    }\n    index := index + 1;\n  }\n  index := -1;\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string) {\n\t(|pre| <= |str|) && pre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string) {\n\t(|pre| > |str|) || pre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n\tensures !res <==> isNotPrefixPred(pre,str)\n\tensures  res <==> isPrefixPred(pre,str)\n{\n\tif (|pre| > |str|) {\n\t\treturn false;\n\t}\n\treturn str[..|pre|] == pre;\n}\npredicate isSubstringPred(sub:string, str:string) {\n\texists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..])\n}\npredicate isNotSubstringPred(sub:string, str:string) {\n\tforall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..])\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n\tensures  res ==> isSubstringPred(sub, str)\n\tensures isNotSubstringPred(sub, str) ==> !res\n\tensures isSubstringPred(sub, str) ==> res\n\tensures !res ==> isNotSubstringPred(sub, str)\n{\n\tif !(|sub| <= |str|) {\n\t\treturn false;\n\t}\n\tvar i := 0;\n\tres := false;\n\twhile (i <= |str| - |sub|)\n\tinvariant res ==> isSubstringPred(sub, str)\n\tinvariant i <= |str| - |sub| + 1\n\tinvariant forall x :: 0 <= x < i ==> isNotPrefixPred(sub, str[x..])\n\t{\n\t\tvar tail := str[i..];\n\t\tvar isAPrefix := isPrefix(sub, tail);\n\t\tif (isAPrefix) {\n\t\t\tassert isPrefixPred(sub, tail);\n\t\t\tassert isSubstringPred(sub, str);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tassert isNotPrefixPred(sub, tail);\n\t\t\tassert isNotSubstringPred(sub, tail[..|sub|]);\n\t\t\ti := i + 1;\n\t\t}\n\t}\n}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string) {\n\texists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string) {\n\tforall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n\tensures found ==> haveCommonKSubstringPred(k,str1,str2)\n\tensures haveNotCommonKSubstringPred(k,str1,str2) ==> !found\n\tensures haveCommonKSubstringPred(k,str1,str2) ==> found\n\tensures !found ==> haveNotCommonKSubstringPred(k,str1,str2)\n{\n\tif (|str1| < k || |str2| < k) {\n\t\tassert haveNotCommonKSubstringPred(k, str1, str2);\n\t\treturn false;\n\t}\n\tif (k == 0) {\n\t\tassert isPrefixPred(str1[0..0], str2[0..]);\n\t\tassert haveCommonKSubstringPred(k, str1, str2);\n\t\treturn true;\n\t}\n\tvar startIndex := 0;\n\tfound := false;\n\twhile (startIndex <= |str1| - k) \n\tinvariant startIndex + k <= |str1| + 1 \n\tinvariant forall si, ei :: 0 <= si < startIndex && ei == si + k ==> isNotSubstringPred(str1[si..ei], str2)\t\n\t{\n\t\tvar endIndex := startIndex + k;\n\t\tassert endIndex <= |str1|;\n\t\tvar substr := str1[startIndex..endIndex];\n\t\tassert |substr| == k;\n\t\tvar isSubstr := isSubstring(substr, str2);\n\t\tif (isSubstr) {\n\t\t\treturn true;\n\t\t}\n\t\tstartIndex := startIndex + 1;\n\t}\n\treturn false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n\trequires (|str1| <= |str2|)\n\tensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n\tensures haveCommonKSubstringPred(len,str1,str2)\n{\n\tlen := |str1|;\n\twhile (len > 0) \n\tinvariant forall x :: len < x <= |str1| ==> !haveCommonKSubstringPred(x, str1, str2)\n\t{\n\t\tvar hasCommonSubstrOfLen := haveCommonKSubstring(len, str1, str2);\n\t\tif (hasCommonSubstrOfLen) {\n\t\t\treturn len;\n\t\t}\n\t\tlen := len - 1;\n\t}\n\tassert isPrefixPred(str1[0..0], str2[0..]);\n\treturn len;\n}"
},
{
    "dafny": "method ZXCV(b: array<int>, f: int) returns (q:int)\n{\n  q :=0;\n  while q!=b.Length\n    invariant 0<=q<=b.Length\n    invariant forall i::0<=i<q ==> f!=b[i]\n  {\n    if f==b[q]{\n      return;\n    }\n    q:=q+1;\n  }\n}"
},
{
    "dafny": "method m(n: nat)\n{\n   var i: int := 0;\n   while i < n\n      invariant 0 <= i <= n  \n   {\n      i := i + 1;\n   }\n   assert i == n;\n}"
},
{
    "dafny": "module DiskTypesMod {\n  type AU = nat\n  datatype CU = CU(au: AU, offset: nat)\n  type UninterpretedDiskPage\n  function DiskSizeInAU() : (s:nat)\n    ensures 1<=s\n  function AUSizeInCUs() : (s:nat)\n    ensures 2<=s  \n  function {:opaque} CUsInDisk() : set<CU>\n  {\n    set au,offset | 0<=au<DiskSizeInAU() && 0<=offset<AUSizeInCUs() :: CU(au,offset)\n  }\n  predicate ValidCU(cu: CU) {\n    && 0 <= cu.au < DiskSizeInAU()\n    && 0 <= cu.offset < AUSizeInCUs()\n  }\n  type DiskView = map<CU, UninterpretedDiskPage>\n}"
},
{
    "dafny": "predicate isPrefixPred(pre:string, str:string)\n{\n\t(|pre| <= |str|) && \n\tpre == str[..|pre|]\n}\npredicate isNotPrefixPred(pre:string, str:string)\n{\n\t(|pre| > |str|) || \n\tpre != str[..|pre|]\n}\nlemma PrefixNegationLemma(pre:string, str:string)\n\tensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n\tensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n\tensures !res <==> isNotPrefixPred(pre,str)\n\tensures  res <==> isPrefixPred(pre,str)\n{\n\tif |pre| > |str|\n    \t{return false;}\n  \tvar i := 0;\n  \twhile i < |pre|\n    \tdecreases |pre| - i\n    \tinvariant 0 <= i <= |pre|\n    \tinvariant forall j :: 0 <= j < i ==> pre[j] == str[j]\n  \t{\n    \tif pre[i] != str[i]\n    \t{\n       \t\treturn false;\n    \t} \n    \ti := i + 1;\n  \t}\n \treturn true;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n\t(exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\npredicate isNotSubstringPred(sub:string, str:string)\n{\n\t(forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\nlemma SubstringNegationLemma(sub:string, str:string)\n\tensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n\tensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n\tensures  res <==> isSubstringPred(sub, str)\n{\n\tif |sub| > |str| {\n        return false;\n    }\n    var i := |str| - |sub|;\n    while i >= 0 \n    decreases i\n    invariant i >= -1\n    invariant forall j :: i <  j <= |str|-|sub| ==> !(isPrefixPred(sub, str[j..]))\n    {\n        var isPref := isPrefix(sub, str[i..]);\n        if isPref\n        {\n            return true;\n        }\n        i := i-1;\n    }\n    return false;\n}\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\texists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n\tforall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n\tensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n\tensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n\tensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n{\n\t if( |str1| < k || |str2| < k){\n        return false;\n    }\n    var i := |str1| - k;\n    while i >= 0\n      decreases i\n      invariant i >= -1 \n      invariant forall j,t :: i < j <= |str1| - k && t==j+k ==> !isSubstringPred(str1[j..t], str2)\n    {\n\t\t\t\tvar t := i+k;\n        var isSub := isSubstring(str1[i..t], str2);\n        if isSub \n        {\n            return true;\n        }\n        i := i-1;\n    }\n    return false;\n}\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n\trequires (|str1| <= |str2|)\n\tensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n\tensures haveCommonKSubstringPred(len,str1,str2)\n{\n\tvar i := |str1|;\n  \twhile i > 0\n  \tdecreases i\n  \tinvariant i >= 0\n  \tinvariant forall j :: i < j <= |str1| ==> !haveCommonKSubstringPred(j, str1, str2)\n  \t{\n    \tvar ans := haveCommonKSubstring(i, str1, str2);\n    \tif ans {\n       \t\treturn i;\n    \t}\n    \ti := i -1;\n  \t}\n  \tassert i == 0;\n\tassert isPrefixPred(str1[0..0],str2[0..]);\n  \treturn 0;\n}"
},
{
    "dafny": "method Product1 (m: nat, n: nat) returns (res:nat)\n     ensures res == m * n;\n {\n     var m1: nat := 0;\n     var n1: nat := 0;\n     res := 0;\n     while (m1 < m)\n       invariant m>=m1>=0\n       invariant res == m1*n\n     {\n         n1 := 0;\n         while (n1 < n)\n           invariant n>=n1>=0\n           invariant res == m1*n+n1\n         {\n             res := res + 1;\n             n1 := n1 + 1;\n         }\n         m1 := m1 + 1;\n     }\n  }"
},
{
    "dafny": "class Node\n{\n    var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n    reads graph\n{\n    forall i :: i in graph ==>\n        forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n    requires closed(graph)\n    reads graph\n{\n    |p| > 0 && \n    p[0] == start && p[|p|-1] == end && \n    path(p, graph) \n}\npredicate path(p: seq<Node>, graph: set<Node>)\n    requires closed(graph)\n    requires |p| > 0\n    reads graph\n{\n    p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next && \n        path(p[1..], graph)) \n}\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n    requires closed(subgraph)\n    requires closed(graph)\n    requires subgraph <= graph\n    requires root in subgraph\n    requires goal in graph - subgraph\n    ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n    forall p {\n        DisproofLemma(p, subgraph, root, goal, graph);\n    }\n}\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n    requires closed(subgraph)\n    requires closed(graph)\n    requires subgraph <= graph\n    requires root in subgraph\n    requires goal in graph - subgraph\n    ensures !pathSpecific(p, root, goal, graph)\n{\n    if |p| > 1 && p[0] == root && p[|p|-1] == goal {\n        if p[1] in p[0].next {\n            DisproofLemma(p[1..], subgraph, p[1], goal, graph);\n        }\n    }\n}"
},
{
    "dafny": "function factorial (n :nat) : nat\n  requires n > 0;\n{\n  if (n == 1) then 1\n  else n * factorial(n-1)\n}\nmethod Factorial (n: nat) returns (v:nat)\n  requires n > 0;\n  ensures v == factorial(n);\n{\n  v := 1;\n  if (n == 1) { return v; }\n  var i := 2;\n  while (i <= n)\n    invariant i <= n+1;\n    invariant v == factorial(i-1);\n  {\n    v := i * v;\n    i := i + 1;\n  }\n  return v;\n}\nmethod FactorialTuring(n: nat) returns (v: nat)\n  requires n > 0;\n  ensures v == factorial(n);\n{\n  var r := 1;\n  var u := 1;\n  while (true)\n    decreases n - r;\n    invariant u == factorial(r);\n    invariant r <= n;\n  {\n    v := u;\n    if (r - n >= 0)\n    { assert (r == n); return v; }\n    var s := 1;\n    while (true)\n      decreases r + 1 - s\n      invariant s <= r < n\n      invariant u == s * factorial(r)\n    {\n      u := u + v;\n      s := s + 1;\n      if ((s - (r + 1)) >= 0)\n      {\n        assert (s == r+1);\n        break;\n      }\n    }\n    r := r + 1;\n  }\n}"
},
{
    "dafny": "method findScarce(a:seq<array<int>>, limit: int) returns (scarce: seq<array<int>>)\n  requires a != [] && |a| > 0;\n  requires forall k :: 0 <= k < |a| ==> a[k] != null;\n  requires forall k :: 0 <= k < |a| ==> a[k].Length == 2;\n  ensures forall k: int :: (0 <= k < |a| ==> ((a[k][1] <= limit) ==> a[k] in scarce));\n  ensures forall k: int :: (0 <= k < |scarce| ==> (scarce[k] != null && scarce[k] in multiset(a[..])));\n{\n  var i : int := 0;\n  scarce := [];\n  while (i < |a|)\n    invariant 0 <= i <= |a|;\n    invariant forall k: int :: (0 <= k < i ==> ((a[k][1] <= limit) ==> a[k] in scarce));\n    invariant forall k: int :: (0 <= k < |scarce| ==> (scarce[k] != null && scarce[k] in multiset(a[..])));\n  {\n    if (a[i][1] <= limit) \n    { \n      scarce := scarce + [a[i]];\n    }\n    i := i + 1;\n  }\n}\nmethod Main() {\n  var a1: array<int> := new int[2];\n  a1[0], a1[1] := 0, 1000;\n  var a2: array<int> := new int[2];\n  a2[0], a2[1] := 1, 2000;\n  var a3: array<int> := new int[2];\n  a3[0], a3[1] := 2, 3000;\n  var a4: array<int> := new int[2];\n  a4[0], a4[1] := 3, 4000;\n  var deposits: seq<array<int>> := [];\n  deposits := deposits + [a1] + [a2] + [a3] + [a4];\n  var i: seq<array<int>> := findScarce(deposits,3000);\n  var j : int := 0;\n  while (j < |i|) {\n    var k : int := 0;\n    while (k < i[j].Length) {\n      print i[j][k];\n      print ' ';\n      k := k + 1;\n    }\n    print '\\n';\n    j := j + 1;\n  }\n}"
},
{
    "dafny": "function fib (n: nat) : nat\n{\n  if (n == 0) then 0\n  else if (n == 1) then 1\n  else fib(n-1) + fib(n-2)\n}\nmethod Fib (n: nat) returns (b: nat)\n  ensures b == fib(n)\n{\n  if (n == 0) { return 0; }\n  var a := 0;\n  b := 1;\n  var i := 1;\n  while (i < n)\n    invariant i <= n;\n    invariant a == fib(i-1);\n    invariant b == fib(i);\n  {\n    a, b := b, a + b;\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "method main(n: int) returns (sum: int, i: int)\nrequires n >= 0\n{\n    sum := 0;\n    i := 0;\n    while(i < n)\n    {\n        sum := sum + i;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method Reverse(str: array<char>) returns (reversedStr: array<char>)\n  requires str.Length >= 0\n{\n  var i := 0;\n  reversedStr := new char[str.Length];\n  while (i < str.Length)\n  invariant 0 <= i <= str.Length \n  {\n    reversedStr[i] := str[str.Length-1-i];\n    i:= i+1;\n  }\n}"
},
{
    "dafny": "datatype Op = Write(tid:int, loc: int)\ndatatype opt<T> = Just(value: T) | Nothing\ndatatype FtState = FtState(ts : ThreadsMap, vs: EpochMap, ls : VarsMap)\ndatatype DjitState = DjitState(ts : ThreadsMap, vs: VarsMap, ls : VarsMap)\ndatatype Epoch = Epoch(tid : int, val : int)\ntype ThreadsMap = map<int, VC>\ntype VarsMap = map<int, VC>\ntype EpochMap = map<int, Epoch>\ntype Trace = seq<Op>\ntype VC = map<int,int>\nfunction ftStart() : FtState\nensures (wellFormed(ftStart()))\n{\n\tvar tmap := map[];\n\tvar emap := map[];\n\tvar lmap := map[];\n\tFtState(tmap,emap,lmap)\n}\npredicate wellFormed(res : FtState) {\n (forall loc : int :: loc in res.vs ==> res.vs[loc].val <= lookupVC(lookup(res.ts, res.vs[loc].tid), res.vs[loc].tid)) \n }\nfunction addThread(tmap: ThreadsMap, tid:int) : ThreadsMap \n{ \n\ttmap[tid := map[tid := 0]]\n}\nfunction lookup(m:map<int, VC>, i:int) : VC\n{\n\tif(i in m) then m[i] else map[]\n}\nfunction lookupVC(vc:VC, tid:int) : int\n{\n\tif(tid in vc) then vc[tid] else 0\n}\nfunction lookupEpoch(m:map<int, Epoch>, i:int) : Epoch\n{\n\tif(i in m) then m[i] else Epoch(i,0)\n}\nfunction incrementVC(vc:VC, threadID:int) : VC\n{\n\tif(threadID in vc)\n\t\tthen vc[threadID := vc[threadID]+1]\n\t\telse vc[threadID :=  1]\n}\nfunction updateEpoch(threadID:int, threadVC:VC) : Epoch\n{\n\tEpoch(threadID, lookupVC(threadVC, threadID))\n}\nfunction updateLocVC(threadID:int, threadVC:VC, locVC:VC) : VC\n{\n\tlocVC[threadID := lookupVC(threadVC, threadID)]\n}\nlemma proof(fs : FtState, ds : DjitState, op : Op)\nrequires wellFormed(fs)\nrequires wellFormedDjit(ds)\nensures (ftStep(fs,op).Just? && djitStep(ds,op).Just?) ==> wellFormed(ftStep(fs,op).value) == wellFormedDjit(djitStep(ds,op).value);\n{\n}\nfunction ftStep(fs : FtState, op : Op) : opt<FtState>\nrequires(wellFormed(fs))\nensures (var res:= ftStep(fs,op); ftStep(fs,op).Just? ==> wellFormed(res.value))\n{\n\tmatch op\n\tcase Write(tid, loc) =>\n\t\tvar threadVC := lookup(fs.ts, tid);\n\t\tvar locEpoch := lookupEpoch(fs.vs, loc);\n\t\tvar threadVC' := incrementVC(threadVC, tid);\n\t\tvar locEpoch' := updateEpoch(tid, threadVC);\n\t\tif(lookupVC(threadVC', locEpoch.tid) < locEpoch.val) then Nothing\n\t\telse\n\t\t\tJust(FtState(fs.ts[tid := threadVC'], fs.vs[loc := locEpoch'], fs.ls))\n}\nfunction djitStart() : DjitState\nensures wellFormedDjit(djitStart())\n{\n\tvar tmap := map[];\n\tvar vmap := map[];\n\tvar lmap := map[];\n\tDjitState(tmap,vmap,lmap)\n}\npredicate wellFormedDjit(ds : DjitState) \n{\n\tforall i: int :: i in ds.vs ==> forall j : int :: j in lookup(ds.vs,i) ==> lookupVC(lookup(ds.ts,j),j) >= lookupVC(lookup(ds.vs,i),j)                     \n}\nfunction djitStep(ds : DjitState, op : Op) : opt<DjitState>\nrequires(wellFormedDjit(ds))\nensures (var res:= djitStep(ds,op); djitStep(ds,op).Just? ==> wellFormedDjit(res.value))\n{\n\tmatch op\n\tcase Write(tid, loc) =>\n\t\tvar threadVC := lookup(ds.ts, tid);\n\t\tvar locVC := lookup(ds.vs, loc);\n\t\tvar threadVC' := incrementVC(threadVC, tid);\n\t\tvar locVC' := updateLocVC(tid, threadVC',locVC);\n\t\tif(vcleq(threadVC, locVC)) then \n\t\t\tJust(DjitState(ds.ts[tid := threadVC'],ds.vs[loc := locVC'], ds.ls))\n\t\telse \n\t\t\tNothing\n}\npredicate vcleq ( threadVC : VC, locVC : VC)\n{\n\tforall i : int :: i in locVC ==> lookupVC(threadVC, i) >= lookupVC(locVC, i)\n}\nfunction getMaxIdF(t : Trace) : int\n{\n\tif(|t| == 0) then 0\n\telse 1\n}"
},
{
    "dafny": "lemma ExampleProposition()\n{\n  assert 2 < 3;\n}\nlemma SomethingFalse()\n{\n}\nlemma SomethingNonsensical()\n{\n}\nlemma AdditionCommutes(n: int, m: int)\n  ensures n + m == m + n\n{\n}\nlemma ProveAndFromBoth(p1: bool, p2: bool)\n  requires p1\n  requires p2\n  ensures p1 && p2\n{}\nlemma FromAndProveRight(p1: bool, p2: bool)\n  requires p1 && p2\n  ensures p2\n{}\nlemma ProveOrFromLeft(p1: bool, p2: bool)\n  requires p1\n  ensures p1 || p2\n{}\nlemma DoubleNegation(p: bool)\n  requires p\n  ensures !!p\n{}\nlemma LawOfExcludedMiddle(p: bool)\n  ensures p || !p\n{}\nlemma ImplicationTruthTable()\n  ensures false ==> false\n  ensures false ==> true\n  ensures !(true ==> false)\n  ensures false ==> true\n{}\nlemma ModusPonens(p1: bool, p2: bool)\n  requires p1 ==> p2\n  requires p1\n  ensures p2\n{}\nlemma AndProvesBoth(p1: bool, p2: bool)\n  ensures p1 && p2 ==> p1\n  ensures p1 && p2 ==> p2\n{}\nlemma ProveFromBiconditional(p1: bool, p2: bool)\n  requires p1\n  requires p1 <==> p2\n  ensures p2\n{}\nlemma SomeEquivalences(p1: bool, p2: bool)\n  ensures ((p1 ==> p2) && p1) ==> p2\n  ensures (p1 ==> p2) <==> (!p2 ==> !p1)\n  ensures !(p1 ==> !p2) <==> p1 && p2\n  ensures ((p1 ==> p2) && (!p1 ==> p2)) <==> p2\n  ensures (!p1 || (p1 ==> p2)) <==> (p1 ==> p2)\n{}\nlemma SomeMoreEquivalences(p1: bool, p2: bool, p3: bool)\n  ensures (p1 && p2) && p3 <==> p1 && p2 && p3\n  ensures p1 ==> p2 ==> p3 <==> p1 && p2 ==> p3\n  ensures p1 ==> (p2 ==> p3) <==> p1 && p2 ==> p3\n{}\nlemma AdditionCommutesAsForall()\n{\n  assert forall n: int, m: int :: n + m == m + n;\n  var does_addition_commute: bool := forall n: int, m: int :: n + m == m + n;\n  assert does_addition_commute == true;\n}\npredicate P(x: int)\npredicate Q(x: int)\npredicate R(x: int, y: int)\nlemma SimplifyingNegations(p: bool, q: bool)\n  ensures !(p && q) <==> !p || !q\n  ensures !(p || q) <==> !p && !q\n  ensures !(p ==> q) <==> p && !q\n  ensures !!p <==> p\n  ensures !(forall x :: P(x)) <==> (exists x :: !P(x))\n  ensures !(exists x :: P(x)) <==> (forall x :: !P(x))\n{}\nlemma WhereIsJustImplies()\n  ensures (forall x | P(x) :: Q(x)) <==> (forall x :: P(x) ==> Q(x))\n{}\nlemma NotForallWhere()\n  ensures !(forall x | P(x) :: Q(x)) <==> exists x :: P(x) && !Q(x)\n{}\nlemma ExistsWhereIsJustAnd()\n  ensures (exists x | P(x) :: Q(x)) <==> (exists x :: P(x) && Q(x))\n  ensures !(forall x | P(x) :: Q(x)) <==> (exists x | P(x) :: !Q(x))\n{}"
},
{
    "dafny": "module Utils {\n    export \n        reveals Assertions\n        provides Assertions.assertEquals\n    class Assertions {\n        static method {:axiom} assertEquals<T>(left : T, right : T)\n        requires left == right\n        static method {:axiom} assertTrue(value : bool)\n        requires value\n        static method {:axiom} assertFalse(value : bool)\n        requires !value\n    }\n}"
},
{
    "dafny": "method Main() {\n  TestAggregateArrayUpdate();\n  TestAggregateMultiArrayUpdate();\n  TestAggregateFieldUpdate();\n}\nmethod TestAggregateArrayUpdate() {\n  var a := new real[8](i => i as real - 4.0);\n  var b := new real[8];\n  var c := new bool[8];\n  forall i | 2-i <= 2 && i < a.Length {\n    b[7-i] := a[i] + 4.0;\n  }\n  forall i | 0 <= i < a.Length {\n    c[i] := a[i] < b[i];\n  }\n  PrintArray(a);  \n  PrintArray(b);  \n  PrintArray(c);  \n}\nmethod PrintArray(a: array) {\n  var i := 0;\n  while i < a.Length {\n    print a[i], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}\nmethod TestAggregateMultiArrayUpdate() {\n  var matrix := new int[12,3]((i,j) => i+j);\n  PrintMatrix(matrix);\n  var m' := new int[matrix.Length1, matrix.Length0](\n    (i,j) requires 0 <= i < matrix.Length1 && 0 <= j < matrix.Length0 reads matrix => matrix[j,i]);\n  var m0, m1, m2 := Transpose(matrix);\n  PrintMatrix(m');\n  PrintMatrix(m0);\n  PrintMatrix(m1);\n  PrintMatrix(m2);\n  print MatrixEqual(m0, m'), \"\\n\";  \n  m'[2,2] := 87;\n  print MatrixEqual(m0, m'), \"\\n\";  \n}\nmethod PrintMatrix(m: array2<int>) {\n  var i := 0;\n  while i < m.Length0 {\n    var j := 0;\n    while j < m.Length1 {\n      print m[i,j], \" \";\n      j := j + 1;\n    }\n    print \"\\n\";\n    i := i + 1;\n  }\n}\nmethod Transpose<T(0)>(m: array2<T>) returns (m0: array2<T>, m1: array2<T>, m2: array2<T>)\n  ensures fresh(m0) && fresh(m1) && fresh(m2)\n  ensures MatrixEqual(m0, m1) && MatrixEqual(m0, m2)\n{\n  var X, Y := m.Length1, m.Length0;\n  m0, m1, m2 := new T[X, Y], new T[X, Y], new T[X, Y];\n  forall i,j | 0 <= i < X && 0 <= j < Y {\n    m0[i,j] := m[j,i];\n  }\n  forall i: nat, j: nat | i < X && j < Y {\n    m1[i,j] := m[j,i];\n  }\n  forall i: nat, j | -Y < -j && 3+i < X+3 && j >= 0 {\n    m2[i,j] := m[j,i];\n  }\n}\npredicate MatrixEqual<T(==)>(m: array2, m': array2)\n  reads m, m'\n{\n  (m.Length0, m.Length1) == (m'.Length0, m'.Length1) &&\n  forall i,j :: 0 <= i < m.Length0 && 0 <= j < m.Length1 ==> m[i,j] == m'[i,j]\n}\nmethod TestAggregateFieldUpdate() {\n  var a := Node.Create(4);\n  var b := Node.Create(7);\n  a.Print();\n  b.Print();\n  print b.StartsWith(a), \"\\n\";  \n  a.IncEverything(3);\n  a.Print();\n  print b.StartsWith(a), \"\\n\";  \n}\nclass Node {\n  var Repr: set<Node>  \n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr && next.Valid())\n  }\n  var val: int\n  var next: Node?\n  constructor (val: int, next: Node?)\n    requires next != null ==> next.Valid()\n    ensures Valid() && fresh(Repr - if next == null then {} else next.Repr)\n  {\n    this.val, this.next := val, next;\n    Repr := {this} + if next == null then {} else next.Repr;\n  }\n  static method Create(n: nat) returns (d: Node)\n    ensures d.Valid() && fresh(d.Repr)\n  {\n    d := new Node(0, null);\n    var i := 1;\n    while i < n\n      invariant d.Valid() && fresh(d.Repr)\n    {\n      d := new Node(i, d);\n      i := i + 1;\n    }\n  }\n  method Print()\n    requires Valid()\n  {\n    var d := this;\n    while d != null\n      invariant d != null ==> d.Valid()\n      decreases if d == null then {} else d.Repr\n    {\n      print d.val, \" \";\n      d := d.next;\n    }\n    print \"\\n\";\n  }\n  predicate StartsWith(that: Node?)\n    requires Valid() && (that != null ==> that.Valid())\n    reads Repr, if that == null then {} else that.Repr\n    decreases Repr\n  {\n    that != null ==>\n      val == that.val && next != null && next.StartsWith(that.next)\n  }\n  method IncEverything(n: int)\n    requires Valid()\n    modifies Repr\n    ensures Valid()\n  {\n    forall d | d in Repr {\n      d.val := d.val + n;\n    }\n    StillValidAfterValChanges();\n  }\n  twostate lemma StillValidAfterValChanges()\n    requires old(Valid())\n    requires forall d :: d in old(Repr) ==> unchanged(d`next, d`Repr)\n    ensures Valid()\n    decreases old(Repr)\n  {\n    if next != null {\n      next.StillValidAfterValChanges();\n    }\n  }\n}"
},
{
    "dafny": "lemma SkippingLemma(a : array?<int>, j : int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.Length\n      decreases j + a[j] - i\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod FindZero(a: array?<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\n      decreases a.Length - index\n      invariant 0 <= index\n      invariant forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n   decreases a, b\n   ensures count(a + b) == count(a) + count(b)\n{\n   if a == []\n   {\n      assert a + b == b;\n   }\n   else\n   {\n      DistributiveLemma(a[1..], b);\n      assert a + b == [a[0]] + (a[1..] + b);\n   }\n}\nfunction count(a: seq<bool>): nat\n   decreases a\n{\n   if |a| == 0 then 0 else\n   (if a[0] then 1 else 0) + count(a[1..])\n}"
},
{
    "dafny": "method add_by_inc(n: nat, m: nat) returns (r: nat)\n  ensures r == m + n;\n{\n  r := n;\n  var i := 0;\n  while i < m\n    invariant i <= m;\n    invariant r == n + i;\n  {\n    i := i + 1;\n    r := r + 1;\n  }\n  return r;\n}\nmethod add_by_inc_int(n : int, m : int) returns (r : int)\n  ensures r == m + n;\n{\n  r := n;\n  var sign := if m < 0 then -1 else 1;\n  var m0 := if m < 0 then -m else m;\n  var i := 0;\n  while (i < m0)\n    invariant i <= m0;\n    invariant m < 0 ==> r == n - i;\n    invariant m >= 0 ==> r == n + i;\n  {\n    i := i + 1;\n    r := r + sign;\n  }\n}"
},
{
    "dafny": "method getEven(a : array?< int >) \n\trequires a != null && a.Length > 0;\n\tmodifies a;\n\tensures forall i:int :: 0 <= i < a.Length ==> a[i] % 2 == 0;\n{\n\tvar index := 0;\n\twhile index < a.Length \n\t\tinvariant 0 <= index <= a.Length;\n\t\tinvariant forall j:int :: 0 <= j < index ==> a[j] % 2 == 0;\n\t\tdecreases a.Length - index;\n\t{\n\t\tif (a[index] % 2 != 0) \n\t\t{\n\t\t\ta[index] := a[index] + 1;\n\t\t}\n\t\tindex := index + 1;\n\t}\n}"
},
{
    "dafny": "module Search{  \n  method FindMax(a: array<int>) returns (currentMaxIndex: int)\n    requires a != null && a.Length >= 1;\n    ensures 0 <= currentMaxIndex < a.Length;\n    ensures forall k :: 0 <= k < a.Length ==> a[currentMaxIndex] >= a[k];\n  {\n    var index := 1;\n    currentMaxIndex := 0;\n    while(index < a.Length)\n      decreases a.Length - index;\n      invariant 0 <= currentMaxIndex < index <= a.Length;\n      invariant forall k :: 0 <= k < index <= a.Length ==> a[currentMaxIndex] >= a[k];\n    {\n        if(a[index] > a[currentMaxIndex])\n        {\n          currentMaxIndex := index;\n        }\n        index := index + 1;\n    }\n  }\n  method FindMin(a: array<int>) returns (currentMinIndex: int)\n    requires a != null && a.Length >= 1;\n    ensures 0 <= currentMinIndex < a.Length;\n    ensures forall k :: 0 <= k < a.Length ==> a[currentMinIndex] <= a[k];\n  {\n    var index := 1;\n    currentMinIndex := 0;\n    while(index < a.Length)\n      decreases a.Length - index;\n      invariant 0 <= currentMinIndex < index <= a.Length;\n      invariant forall k :: 0 <= k < index <= a.Length ==> a[currentMinIndex] <= a[k];\n    {\n        if(a[index] < a[currentMinIndex])\n        {\n          currentMinIndex := index;\n        }\n        index := index + 1;\n    }\n  }\n  predicate sorted(a: array<int>, low: int, high : int)\n    requires a != null && 0 <= low <= high < a.Length;\n    reads a;\n  {\n    forall j, k :: low <= j < k <= high ==> a[j] <= a[k]\n  }\n}"
},
{
    "dafny": "predicate clean1(a:array?<int>,key:int)\n     reads a\n{\n  (a == null) || (forall k::0<= k < a.Length  ==> a[k] != key)\n}\nmethod IsClean(a: array?<int>, key: int) returns (clean: bool)\n    ensures clean1(a,key) == clean;\n{\n    var index := 0;\n    if(a==null){\n     assert a == null;\n     assert a == null;\n     return true;\n    }\n    assert a!= null;\n    assert index == 0;\n    while index < a.Length\n       invariant 0<=index<= a.Length;\n       invariant forall k :: 0 <= k < index ==> a[k] != key;\n       invariant !(exists k | 0 <= k < index :: a[k] == key);\n\t   decreases (a.Length - index)\n    {\n      if(a[index] == key){\n        assert a[index] == key;\n        assert exists k :: 0<= k <= index ==> a[k] == key;\n        assert a != null ==> exists k :: 0<= k <= index ==> a[k] == key;\n        return false;\n      }\n      index :=index+1;\n    }\n    assert  !(exists k | 0 <= k < a.Length :: a[k] == key); \n    assert a != null && !(exists k :: 0<= k < a.Length ==> a[k] == key) ==> forall k :: 0 <= k < index ==> a[k] != key;\n    return true;\n}\nmethod Test(){\n  var a1: array<int> := new int[][1,2,2,3];\n  assert a1[0] == 1 && a1[1] == 2 && a1[2] == 2 && a1[3] == 3;\n  var clean := IsClean(a1,1);\n  assert clean == false;\n  clean:=IsClean(a1,2); assert clean == false;\n  clean:=IsClean(a1,3); assert clean == false;\n  clean:=IsClean(a1,4); assert clean == true;\n  var a2:array<int> := new int[][1];\n  assert a2[0] == 1;\n  clean:=IsClean(a2,1); assert clean == false;\n  clean:=IsClean(a2,2); assert clean == true;\n  var a3 :array?<int>:= null;\n  assert a3 == null;\n  clean:=IsClean(a3,1); assert clean == true;\n}"
},
{
    "dafny": "module Types_s\n{\n    datatype condition = eq | ne | ugt | uge | ult | ule | sgt | sge | slt | sle\n    newtype{:nativeType \"byte\"} byte = i:int | 0 <= i < 0x100\n    newtype{:nativeType \"uint\"} uint = i:int | 0 <= i < 0x1_0000_0000\n    newtype{:nativeType \"ulong\"} ulong = i:int | 0 <= i < 0x1_0000_0000_0000_0000\n    type uint8   = i:int | 0 <= i < 0x100\n    type uint16  = i:int | 0 <= i < 0x10000\n    type uint32  = i:int | 0 <= i < 0x1_0000_0000\n    type uint64  = i:int | 0 <= i < 0x1_0000_0000_0000_0000\n    type sint8   = i:int | -0x80 <= i < 0x80 \n    type sint16  = i:int | -0x8000 <= i < 0x8000\n    type sint32  = i:int | -0x8000_0000 <= i < 0x8000_0000\n    type sint64  = i:int | -0x8000_0000_0000_0000 <= i < 0x8000_0000_0000_0000\n    type bitWidth = s:nat | (s == 1 || s == 2 || s == 4 || s == 8) ghost witness 1\n    datatype IntType_ = IntType(size:bitWidth, signed:bool)\n    type IntType = t:IntType_ | validBitWidth(t.size) ghost witness IntType(1, false)\n    type Byte = b:int | 0 <= b < 0x100\n    type Bytes = b:seq<Byte> | |b| > 0 ghost witness [0]\n    datatype Quadword = Quadword(lo:uint32, mid_lo:uint32, mid_hi:uint32, hi:uint32)\n    newtype{:nativeType \"byte\"} twobits = i:int | 0 <= i < 4\n    datatype BitsOfByte = BitsOfByte(lo:twobits,\n                                    mid_lo:twobits,\n                                    mid_hi:twobits,\n                                    hi:twobits)\n    datatype Data_ = Bytes(bytes:Bytes) |\n                    Ptr(block:nat, bid:nat, offset:nat, size:bitWidth) |\n                    Int(val:int, itype:IntType) | \n                    Void\n    type Data = d:Data_ | (d.Int? ==> IntFits(d.val, d.itype)) ghost witness Bytes([0])\n    predicate IntFits(val:int, itype:IntType) {\n        var bound := Pow256(itype.size);\n        if itype.signed then (-bound/2 <= val < bound/2)\n        else (0 <= val < bound)\n    }\n    predicate isInt(data:Data)\n    {\n        data.Int?\n    }\n    predicate validBitWidth(s:nat)\n    {\n        (s == 1 || s == 2 || s == 4 || s == 8)\n    }\n    predicate typesMatch(x:Data, y:Data)\n        requires (isInt(x) && isInt(y)) || (x.Ptr? && y.Ptr?)\n    {\n        if isInt(x) then \n            x.itype.size == y.itype.size && x.itype.signed == y.itype.signed\n        else\n            x.size == y.size\n    }\n    function Pow256(n:nat) : int\n        decreases n\n    {\n        if n == 0 then 1\n        else 0x100 * Pow256(n-1)\n    }\n    function Pow128(n:nat) : int\n        decreases n\n    {\n        if n == 0 then 1\n        else 0x80 * Pow128(n-1)\n    }\n    function  power2(exp: nat) : int\n        ensures power2(exp) > 0;\n    {\n        if (exp==0) then\n            1\n        else\n            2*power2(exp-1)\n    }\n    function DataToUInt8(data:Data) : (out:uint8) \n        requires isInt(data)\n        requires data.itype.size == 1 && !data.itype.signed\n        ensures out == data.val % 0x100 \n    function DataToUInt16(data:Data) : (out:uint16) \n        requires isInt(data)\n        requires data.itype.size == 2 && !data.itype.signed\n        ensures out == data.val % 0x10000\n    function DataToUInt32(data:Data) : (out:uint32) \n        requires isInt(data)\n        requires data.itype.size == 4 && !data.itype.signed\n        ensures out == data.val % 0x1_0000_0000\n    function DataToUInt64(data:Data) : (out:uint64) \n        requires isInt(data)\n        requires data.itype.size == 8 && !data.itype.signed\n        ensures out == data.val % 0x1_0000_0000_0000_0000  \n    function DataToSInt8(data:Data) : (out:sint8) \n        requires isInt(data)\n        requires data.itype.size == 1 && data.itype.signed\n        ensures out == data.val % 0x80  \n    function DataToSInt16(data:Data) : (out:sint16) \n        requires isInt(data)\n        requires data.itype.size == 2 && data.itype.signed\n        ensures out == data.val % 0x8000\n    function DataToSInt32(data:Data) : (out:sint32) \n        requires isInt(data)\n        requires data.itype.size == 4 && data.itype.signed\n        ensures out == data.val % 0x8000_0000  \n    function DataToSInt64(data:Data) : (out:sint64) \n        requires isInt(data)\n        requires data.itype.size == 8 && data.itype.signed\n        ensures out == data.val % 0x8000_0000_0000_0000 \n    function IntToBytes(data:Data) : (bytes:Bytes)\n        requires data.Int?\n        ensures |bytes| == data.itype.size\n}"
},
{
    "dafny": "datatype securityClearance = Lv1 | Lv2\nclass Tokeneer{\n  var uID : int;\n  var clearLv : securityClearance;\n  var valid : bool;\n  constructor(n : int, Lv : securityClearance)\n    ensures uID == n;\n    ensures valid;\n    ensures clearLv == Lv;\n    {\n      uID := n;\n      clearLv := Lv;\n      valid := true;\n    }\n    method invalidID()\n    modifies `valid;\n    requires valid == true;\n    ensures valid == false;\n    {\n      valid := false;\n    }\n}\nclass IDstn{\n  var doorState : securityClearance;\n  constructor (d : securityClearance)\n  ensures doorState == d;\n  {\n    doorState := d;\n  }\n}\nclass EnrollmentStn{\n  var user : map<int, Tokeneer>;\n  constructor ()\n  ensures |user| == 0; \n  {\n    user := map[];\n  }\n  method addUser(name: int, c : securityClearance) returns (t : Tokeneer)\n  modifies `user;\n  requires name !in user;\n  ensures name in user;\n  ensures user[name] == t;\n  ensures t != null;\n  ensures t.uID == name;\n  {\n    var token := new Tokeneer(name, c);\n    user := user[name := token];\n    return (token);\n  }\n}\nclass Actions{\n  var e : EnrollmentStn;\n  var i : IDstn;\n  var closed : bool;\n  var Alarm : bool;\n  constructor(green : securityClearance )\n  ensures i != null;\n  ensures e != null;\n  {\n    e := new EnrollmentStn();\n    i := new IDstn(green);\n  }\n  method OpensDoor(identity : int, t : Tokeneer)\n  modifies t;\n  modifies `closed;\n  modifies `Alarm;\n  requires t != null;\n  requires t.valid == true;\n  requires i != null;\n  requires e != null;\n  ensures(((t.uID == identity)&&(t.clearLv == i.doorState)) ==> !closed)||(!((t.uID == identity)&&(t.clearLv == i.doorState)) ==> ((Alarm == true) && (t.valid == false)));\n  {\n    if (t.uID == identity){\n             closed := false;\n    }\n    else {\n      t.invalidID();\n      Alarm := true;\n    }\n  }\n}"
},
{
    "dafny": "predicate maxSpec_incorrect(a:int,b:int,c:int) \n{\n    && (a > b ==> c == a)\n    && (b > a ==> c == b)\n}\nlemma maxT_correct(a:int,b:int) returns (c:int)\n    ensures maxSpec_incorrect(a,b,c)\n{\n    if(a > b){\n        c := a;\n    }else{\n        c := b;\n    }\n}\npredicate maxSpec_mutat1(a:int,b:int,c:int)\n{\n    (a > b ==> c == a) && (b > a - 1 ==> c == b)\n}\npredicate maxSpec_mutat2(a:int,b:int,c:int)\n{\n    (a > b ==> c == a) && (b > c ==> c == b)\n}\npredicate maxSpec_mutat3(a:int,b:int,c:int)\n{\n    (a > c ==> c == a) && (b > a ==> c == b)\n}\nlemma instance1(a:int, b:int, c:int) \n    requires a == b && c != b \n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat1(a,b,c)\n{}\nlemma instance1_test(a:int, b:int, c:int) \n    requires a == b == 1 && c == 2\n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat1(a,b,c)\n{}\nlemma instance2(a:int, b:int, c:int)\n    requires a >= b && b > c && (a <= b || a == c)\n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat2(a,b,c)\n{}\nlemma instance2_test(a:int, b:int, c:int)\n    requires a == b == 2 && c == 1\n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat2(a,b,c)\n{}\nlemma correct2_test1(a:int, b:int, c:int)\n    requires a == 2 && b == 1 && c == 102\n    ensures !maxSpec_mutat2(a,b,c)\n{}\nlemma correct2_test2(a:int, b:int, c:int)\n    requires a == 2 && b == 2 && c == 1 \n    ensures !maxSpec_mutat2(a,b,c)\n    ensures maxSpec_incorrect(a,b,c)\n{}\nlemma instance3(a:int, b:int, c:int)\n    requires a == b > c\n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma instance3_inverse(a:int, b:int, c:int)\n    requires maxSpec_incorrect(a,b,c)\n    requires !maxSpec_mutat3(a,b,c)\n    ensures a == b > c\n{}\nlemma instance3_test(a:int, b:int, c:int)\n    requires a == b == 2 && c == 1 \n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test1(a:int, b:int, c:int)\n    requires a == 4 && b == 0 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test2(a:int, b:int, c:int)\n    requires a == 4 && b == 3 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test3(a:int, b:int, c:int)\n    requires a == 4 && b == 5 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test4(a:int, b:int, c:int)\n    requires a == 4 && b == 2 && c == 2\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test5(a:int, b:int, c:int)\n    requires a == 4 && b == 4 && c == 2 \n    ensures maxSpec_incorrect(a,b,c)\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test6(a:int, b:int, c:int)\n    requires a == 3 && b == 5 && c == 4\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test7(a:int, b:int, c:int)\n    requires a == 3 && b == 5 && c == 0\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test8(a:int, b:int, c:int)\n    requires a == 3 && b == 5 && c == 6\n    ensures !maxSpec_mutat3(a,b,c)\n{}\nlemma correctness3_test9(a:int, b:int, c:int)\n    requires a == 3 && b == 5 && c == 3\n    ensures !maxSpec_mutat3(a,b,c)\n{}"
},
{
    "dafny": "method IAmTestNo7() {\n   var a: bool := true;\n   var b: nat := 2;\n   if (false) {\n\t  print a;\n     var a := 99;\n\t  print a;\n   } else if (!true || (a && b==2)) {\n      print a;\n      var a := 99;\n\t  print a;\n   } else {\n      print a;\n      var a := 99;\n\t  print a;\n   }\n   while  (b < 10)\n   decreases 10-b\n   {\n     b := b+1;\n   }\n}\nmethod Main() {\nIAmTestNo7();    \n}"
},
{
    "dafny": "function fib(n : nat ) : nat {\n    if n < 2 then n else fib(n - 2) + fib(n - 1)\n}  by method\n{\n    var x, y := 0, 1; \n    for i := 0 to n \n      invariant x == fib(i) && y == fib(i+1)\n    {\n        x, y := y, x + y; \n    }\n    return x;\n}\nmethod testFib()\n{\n  assert fib(0) == 0;\n  assert fib(1) == 1;\n  assert fib(2) == 1;\n  assert fib(3) == 2;\n  assert fib(4) == 3;\n  assert fib(5) == 5;\n}"
},
{
    "dafny": "method computeDivision(x:int, y:int) returns (a:int, b:int)\nrequires x > 0 && y > 0\nensures x == y*a + b\nensures b < y\n{\n    var n:int := x;\n    var cnt:int := 0;\n    while(n >= y)\n    decreases x - cnt * y\n    invariant 0 <= n <= x;\n    invariant cnt >= 0\n    invariant (cnt * y + n) == x\n    {\n        cnt := cnt + 1;\n        n := n - y;\n    }\n    return cnt, n;\n}\nfunction factorial(n:int):int\ndecreases n\nrequires n >= 0\n{\n    if(n <= 1) then 1 else n * factorial(n - 1)\n}\nmethod computeFactorial(x:int) returns (z:int)\nrequires x >= 0\nensures z == factorial(x)\n{\n    var n:int := 1;\n    var acc := 1;\n    while(n <= x)\n    decreases x - n\n    invariant 1 <= n <= x + 1\n    invariant acc == factorial(n - 1)\n    {\n        acc := acc * n;\n        n := n + 1;\n    }\n    return acc;\n}\nfunction fib(n:int):int\ndecreases n\nrequires n >= 0\n{\n    if(n <= 1) then n else fib(n-1) + fib (n-2)\n}\nmethod computeFibonacci(x:int) returns (z:int)\nrequires x >= 0\nensures z == fib(x)\n{\n    if(x <= 1) {\n        return x;\n    }\n    var n:int := 2;\n    var acc1:int := 1;\n    var acc2:int := 0;\n    assert acc1 + acc2 == fib(n);\n    while(n <= x)\n    decreases x - n\n    invariant 2 <= n <= x + 1\n    invariant acc1 == fib(n-1)\n    invariant acc2 == fib(n-2)\n    invariant acc1 + acc2 == fib(n)\n    {\n        var temp:int := acc1 + acc2;\n        acc2 := acc1;\n        acc1 := temp;\n        n := n+1;\n    }\n    return acc1;\n}\nmethod indexOf(a:array<int>, n:int, elem:int) returns (z:int)\nrequires 0 <= n <= a.Length\nensures z < n\nensures (z >= 0) ==> a[z] == elem\nensures z < 0 <==> forall i :: (0 <= i < n) ==> a[i] != elem\n{\n    var idx:int := 0;\n    while(idx < n)\n    decreases n - idx\n    invariant 0 <= idx <= n\n    invariant forall i :: (0 <= i < idx) ==> a[i] != elem\n    {\n        if(a[idx] == elem){\n            return idx;\n        }\n        idx := idx +1;\n    }\n    assert forall i :: (0 <= i < n) ==> a[i] != elem;\n    return -1;\n}\nmethod max(a:array<int>, n:int) returns (maxVal:int, maxIdx:int)\nrequires 0 < n < a.Length\nensures 0 <= maxIdx < n\nensures forall i :: (0 <= i < n) ==> maxVal >= a[i]\n{\n    var i:int := 1;\n    var mi:int := 0;\n    while(i < n)\n    decreases n - i\n    invariant 0 <= i <= n\n    invariant 0 <= mi < i\n    invariant forall j :: (0 <= j < i) ==> a[mi] >= a[j]\n    {\n        if(a[i] >= a[mi]) {\n            mi := i;\n        }\n        i := i + 1;\n    }\n    return a[mi], mi;\n}\nmethod min(a:array<int>, n:int) returns (minVal:int, minIdx:int)\nrequires n > 0 && n <=a.Length\nensures 0 <= minIdx < n\nensures forall i :: (0 <= i < n) ==> minVal <= a[i]\n{\n    var i:int := 1;\n    var mi:int := 0;\n    while(i < n)\n    decreases n - i\n    invariant 0 <= i <= n\n    invariant 0 <= mi < i\n    invariant forall j :: (0 <= j < i) ==> a[mi] <= a[j]\n    {\n        if(a[i] <= a[mi]) {\n            mi := i;\n        }\n        i := i + 1;\n    }\n    return a[mi], mi;\n}\nmethod fillK(a:array<int>, n:int, k:int, count:int) returns (b:bool)\nrequires 0 <= count <= n < a.Length\nensures  b <==> forall i :: (0 <= i < count) ==> a[i] == k\n{\n    var i:int := 0;\n    while(i < count )\n    decreases count - i\n    invariant 0 <= i <= count\n    invariant forall j :: (0 <= j < i) ==> a[j] == k\n    {\n        if(a[i] != k) {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\nmethod fillk(a:array<int>, n:int, k:int, count:int) returns (b:bool)\nrequires 0 <= count <= n < a.Length\nensures  b <==> forall i :: (0 <= i < count) ==> a[i] == k\n{\n    var i:int := 0;\n    while(i < count )\n    decreases count - i\n    invariant 0 <= i <= count\n    invariant forall j :: (0 <= j < i) ==> a[j] == k\n    {\n        if(a[i] != k) {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\nfunction substring(a:array<char>, b:array<char>, pos:int, n:int):bool\nreads a,b\nrequires a.Length >= b.Length\nrequires 0 <= n <= b.Length\nrequires 0 <= pos < a.Length - b.Length\n{\n    forall i :: (0 <= i < n) ==> a[pos + i] == b[i]\n}\nmethod isSubString(a:array<char>, b:array<char>, pos:int) returns (z:bool)\nrequires a.Length >= b.Length\nrequires 0 <= pos < a.Length - b.Length\nensures z <==> substring(a,b,pos,b.Length)\n{\n    var i:int := 0;\n    while(i < b.Length)\n    decreases b.Length - i\n    invariant 0 <= i <= b.Length\n    invariant substring(a, b, pos, i)\n    {\n        if(a[pos + i] != b[i]){\n            return false;\n        }\n        i := i +1;\n    }\n    return true;\n}\nmethod containsSubString(a:array<char>, b:array<char>) returns (pos:int)\n    requires a.Length >= b.Length\n    ensures pos < a.Length - b.Length\n    ensures pos >= 0 ==> substring(a,b,pos,b.Length)\n    ensures pos < 0 <==> forall i :: (0 <= i < a.Length-b.Length) ==> !substring(a,b,i,b.Length)\n{\n    var i:int := 0;\n    while (i < a.Length - b.Length)\n    decreases a.Length - b.Length - i\n    invariant 0 <= i <= a.Length - b.Length\n    invariant forall j :: (0 <= j < i) ==> !substring(a,b,j,b.Length)\n    {\n        var isss:bool := isSubString(a,b,i);\n        if(isss) {\n            return i;\n        }\n        i := i + 1;\n    }\n    return -1;\n}\nmethod resize(a:array<int>) returns (z:array<int>)\nrequires true\nrequires a.Length > 0\nensures z.Length == 2 * a.Length\nensures forall i :: (0 <= i < a.Length) ==> a[i] == z[i]\n{\n    z := new int[a.Length * 2];\n    var i:int := 0;\n    while(i < a.Length)\n    decreases a.Length - i\n    invariant 0 <= i <= a.Length\n    invariant forall j :: (0 <= j < i) ==> a[j] == z[j]\n    {\n        z[i] := a[i];\n        i := i + 1;\n    }\n}\nmethod reverse(a:array<int>, n:int) returns (z:array<int>)\nrequires 0 <= n <= a.Length\nensures a.Length == z.Length\nensures forall i :: (0 <= i < n) ==> a[i] == z[n-1 - i]\n{\n    z := new int[a.Length];\n    var i:int := 0;\n    while(i < n)\n    decreases n - i\n    invariant 0 <= i <= n\n    invariant forall j :: (0 <= j < i) ==> a[j] == z[n-1 - j]\n    {\n        z[n-1 - i] := a[i];\n        i := i + 1;\n    }\n}\nmethod push(a:array<int>, na:int, elem:int) returns (b:array<int>, nb:int)\nrequires 0 <= na < a.Length\nensures nb == na + 1\nensures a == b\nensures forall i :: (0 <= i < na) ==> a[i] == b[i]\nensures b[na] == elem\nmodifies a\n{\n    a[na] := elem;\n    return a, na + 1;\n}\nmethod pop(a:array<int>, na:int) returns (b:array<int>, nb:int, elem:int)\nrequires 0 < na <= a.Length\nensures nb == na - 1\nensures a == b\nensures forall i :: (0 <= i < na - 1) ==> a[i] == b[i]\nensures elem == a[nb]\n{\n    return a, na - 1, a[na - 1];\n}\nfunction count(a:array<int>, n:int, v:int):int\ndecreases n\nrequires 0 <= n <= a.Length\nreads a\n{\n    if (n == 0)\n    then 0 \n    else if (a[n-1] == v) then 1 + count(a, n-1, v) else count(a, n-1, v)\n}\nmethod Count(a:array<int>, v:int) returns (z:int)\nrequires true\nensures z == count(a, a.Length , v)\n{\n    var i:int := 0;\n    var acc:= 0;\n    assert acc == count(a, i, v);\n    while(i < a.Length)\n    decreases a.Length - i;\n    invariant 0 <= i <= a.Length\n    invariant acc == count(a, i, v)\n    {\n        if(a[i] == v) {\n            acc := acc + 1;\n        }\n        i := i + 1;\n    }\n    return acc;\n}"
},
{
    "dafny": "ghost function missing_number(nums: seq<nat>): nat\n  requires |set i | i in nums| == |nums|\n  requires forall x :: x in nums ==> 0 <= x <= |nums|\n{\n  var p := x => 0 <= x <= |nums| && x !in nums;\n  assert exists x :: p(x) && forall y :: p(y) ==> y == x by {\n    var range := set i | 0 <= i <= |nums|;\n    assume |range| == |nums| + 1;\n    var missing := range - set i | i in nums;\n    assert |missing| == 1;\n    var x :| x in missing;\n    assert p(x);\n    var y: int;\n    forall y | p(y) ensures y in missing {}\n    assume forall x, y :: x in missing && y in missing ==> x == y;\n    forall y | p(y) ensures y == x {}\n  }\n  var x :| p(x);\n  x\n}"
},
{
    "dafny": "method moveZero(a: array<int>) returns (first0: int)\n  requires a != null && a.Length > 0;\n  modifies a;\n  ensures a.Length == old(a.Length);\n  ensures forall j :: 0 <= j < first0 <= a.Length ==> a[j] != 0;\n  ensures forall j :: 0 <= first0 <= j < a.Length ==> a[j] == 0;\n  ensures multiset(a[..]) == old(multiset(a[..]));\n{\n  first0 := 0;\n  var cur := 0;\n  while(cur < a.Length)\n  invariant 0 <= first0 <= cur <= a.Length;\n  invariant forall j :: 0 <= j < first0 <= a.Length ==> a[j] != 0;\n  invariant forall j :: 0 <= first0 <= j < cur <= a.Length ==> a[j] == 0;\n  invariant multiset(a[..]) == old(multiset(a[..]));\n  {\n    if(a[cur] != 0){\n      swap(a, first0, cur);\n      first0 := first0 + 1;\n    }\n    cur := cur + 1;\n  }\n  return first0;\n}\nmethod swap(a: array<int>, i: int, j: int)\n  requires a != null && 0 <= i <= j < a.Length;\n  modifies a;\n  ensures a[i] == old(a[j]);\n  ensures a[j] == old(a[i]);\n  ensures multiset(a[..]) == old(multiset(a[..]));\n  ensures forall k :: 0 <= k < a.Length && k != i && k != j ==> a[k] == old(a[k]);\n{\n  var temp := a[i];\n  a[i] := a[j];\n  a[j] := temp;\n}"
},
{
    "dafny": "datatype List = Nil | Cons(int, List)\nfunction Len(l:List): (v: int)\n  ensures v >= 0\n{\n  match l\n  case Nil => 0\n  case Cons(hd, tl) => Len(tl) + 1\n}\nfunction isEmpty(l:List): bool\n{\n    match l\n    case Nil => true\n    case Cons(hd, tl) => false\n}\nfunction Stutter(l:List): (lout: List)\n  ensures Len(lout) == Len(l) + 1 || Len(l) > 1 || l == lout\n  ensures isEmpty(l) || Len(lout) > Len(l)\n  ensures l == lout || Len(l) == 1 || Len(lout) > Len(l) + 1\n{\n  match l\n  case Nil => Nil\n  case Cons(hd, tl) => Cons(hd, Cons(hd, Stutter(tl)))\n}"
},
{
    "dafny": "method Mult(x:nat, y:nat) returns (r:nat)\nensures r == x * y\n{\n    var m := x;\n    var n := y;\n    r := 0;\n    while m > 0\n    invariant m*n+r == x*y\n    invariant m>=0\n    {\n        r := r + n;\n        m := m - 1;\n    }\n    return r; \n}"
},
{
    "dafny": "method AddFriends(friends: nat)\n  requires friends >= 1\n{\n    var R1 := 0;\n    var R2 := 0;\n    var i := 0;\n    var identities := 0;\n    while i < friends\n        invariant identities == i\n        invariant i <= friends\n    {\n        identities := identities + 1;\n        i := i + 1;\n    }\n    identities := identities - 1;\n    R1 := R1 + identities;\n    assert R1 <= friends; \n    assert 0 <= identities <= friends; \n    identities := 0;\n    identities := identities + 1;\n    i := 0;\n    while i < friends\n    {\n        R2 := R2 - identities;\n        assert R2 <= 0; \n        i := i + 1;\n    }\n    assert R2 <= 0; \n}"
},
{
    "dafny": "datatype S = S(G: array<int>)\ndatatype T = T(F: array<S>, ghost Repr: set<object>)\nghost predicate Valid(t: T)\n  reads t.F\n  reads (set i | 0 <= i < t.F.Length :: t.F[i].G)\n{\n  var short := t.F;\n  t.Repr == (set i | 0 <= i < short.Length :: short[i].G) + {short}\n}\nmethod Main() {\n}"
},
{
    "dafny": "function Abs(x:int):int{\n    if x<0 then -x else x\n}\nmethod IncDec(x: int, y: int) returns (sum: int)\n    ensures sum == x + y\n{\n    sum := 0;\n    var tmp_x , tmp_y := x,y;\n    while tmp_x != 0 || tmp_y != 0\n        invariant x + y == sum + tmp_x + tmp_y\n        decreases Abs(tmp_x) \n        decreases Abs(tmp_y)\n    {\n        if tmp_x < 0{\n            sum := sum - 1;\n            tmp_x:= tmp_x +1;\n        }\n        else if tmp_x > 0{\n            sum := sum + 1;\n            tmp_x := tmp_x - 1;\n        }\n        if tmp_y < 0{\n            sum := sum - 1;\n            tmp_y:= tmp_y + 1;\n        }\n        else if tmp_y > 0{\n            sum := sum + 1;\n            tmp_y := tmp_y -1;\n        }\n    }\n}\nmethod Test(){\n    var sum: int;\n    sum := IncDec( 5, 15);\n    assert sum ==  20;\n    sum := IncDec( 5,-15);\n    assert sum == -10;\n    sum := IncDec( 5,  0);\n    assert sum ==   5;\n    sum := IncDec(-5, 15);\n    assert sum ==  10;\n    sum := IncDec(-5,-15);\n    assert sum == -20;\n    sum := IncDec(-5,  0);\n    assert sum == - 5;\n}"
},
{
    "dafny": "function max(x: int, y: int): int\n{\n    if x > y then\n        x \n    else if y > x then\n        y\n    else \n        x\n}\nmethod testaMax()\n{\n    assert max(3, 2) == 3;\n    assert max(1, 4) == 4;\n    assert max(5, 5) == 5;\n}"
},
{
    "dafny": "ghost predicate isEven(x:int)\n{\n  x % 2 == 0\n}\nghost function f(x:int, y:int): (z:int)\n  requires x>0 && y > 0\n  ensures z >= 10\n\tensures f(x,y) == z\n  ensures isEven(z)\n{\n\t  2*(x+y) + 10\n}\ntwostate function P2(x: int) : (z: int)\n  ensures z == x - 1\n\tensures P2(x) == z\n\tensures P2(x) == x - 1\n{\n   x - 1\n}\nmodule Interface\n{\n  ghost function addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nmodule Implementation refines Interface\n{\n  ghost function addSome(n: nat): (z: nat)\n    ensures z == n + 1\n  {\n    n + 1\n  }\n}\nghost function foo(x:int, y:int) : (v: (int, int))\n  ensures v == (x, y)\n{\n  (x, y)\n}\nghost function bar(x:int, y:int) : int\n ensures bar(x, y) == 10\n{\n   10\n}\nghost function bar1(x:int, y:int) : int\n ensures bar1(x, y+0) == 10\n{\n   10\n}\nghost function bar2(x:int, y:int) : int\n  ensures bar2((x), y) == 10\n{\n  10\n}"
},
{
    "dafny": "method Max(n1: int, n2: int) returns (max: int)\n  ensures n1 > n2 ==> max == n1\n  ensures n2 > n1 ==> max == n2\n  ensures n1 == n2 ==> ( n1 == n2 == max)\n{\n  max := n1;\n  if n2 > max\n  {\n    max := n2;\n  }\n}\nmethod Testing(a: int, b: int) returns (result: int)\n{\n  result := Max(a, b);\n  if a > b\n  {\n    assert result == a;\n  }\n  else if a <= b\n  {\n    assert result == b;\n  }\n}"
},
{
    "dafny": "method kthEven(k : int ) returns (e : int)\nrequires k > 0 ;\nensures e / 2 == k - 1;\n{\n  e := 0;\n  var i := 1;\n  while (i < k)\n  invariant e / 2 == i - 1 ;\n  invariant 0 < i <= k\n  decreases k - i ;\n  {\n    e := e + 2;\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "predicate sorted (a:array<int>, start:int, end:int) \n requires a!=null       \n requires 0<=start<=end<=a.Length       \n reads a       \n {           \n   forall j,k:: start<=j<k<end ==> a[j]<=a[k]\n }\nmethod InsertionSort (a:array<int>)\nrequires a!=null && a.Length>1 \nensures sorted(a, 0, a.Length) \nmodifies a\n{  \n    var up := 1;   \n    while (up < a.Length)   \n    invariant 1 <= up <= a.Length \n    invariant sorted(a,0,up)\n    {  \n        var down := up-1;      \n        var temp := a[up];          \n        while down >= 0 && a[down+1] < a[down]    \n            invariant forall j,k | 0 <= j < k < up+1 && k != down+1 :: a[j]<=a[k]\n        {\n            a[down],a[down+1] := a[down+1],a[down];           \n            down := down-1;       \n        }            \n        up := up+1;\n    }\n}      \nmethod Main(){\n  var a := new int[5];\n  a[0],a[1],a[2],a[3],a[4] := 3,2,5,1,8;\n  InsertionSort(a);\n  print a[..];\n}"
},
{
    "dafny": "method findMin(startArray:array<int>, startIndex:int) returns (minValue: int)\nrequires 0 <= startIndex < startArray.Length-1 \nensures forall j :: startIndex <= j < startArray.Length-1 ==> minValue <= startArray[j]\n{\n    var i:int := startIndex;\n    assert(i==startIndex);\n    if (startIndex == startArray.Length-1){\n        minValue := startArray[startIndex];\n        assert(minValue <= startArray[startIndex]);\n    }\n    else{\n        minValue := startArray[startIndex];\n        assert(minValue<= startArray[startIndex]);\n        i := i+1;\n        while (i < startArray.Length-1)\n        invariant (startIndex <= i < startArray.Length)\n        invariant forall j :: startIndex <= j < i ==> minValue <= startArray[j]\n        decreases startArray.Length-i\n        {\n            var minTemp:int:= findMinHelper(startArray[i], startArray[i+1]);\n            minValue := findMinHelper(minValue, minTemp);\n            assert (minValue <= startArray[i] && minValue <= startArray[i+1]);\n            i := i+1;\n        }\n    }\n}\nmethod findMinHelper(num1: int, num2: int) returns (min: int)\nensures min <= num1 && min <= num2\n{\n    if(num1 < num2)\n    {\n        min := num1;\n    }\n    else {\n        min := num2;\n    }\n}\nmethod Main(){\n    var arr := new int[6];\n    arr[0], arr[1], arr[2], arr[3], arr[4], arr[5] := 12, 7, 8, 18, 26, 14;\n    assert arr.Length > 0;\n    var min:int := findMin(arr, 0);\n    print \"The smallest value in the array is \";\n    print min;\n}"
},
{
    "dafny": "predicate IsSorted( a: seq<int> )\n{\n    forall p,q | 0 <= p < q < |a| :: a[p] <= a[q]\n}\npredicate IsSegmented( a: seq<int> , b: seq<int> )\n{\n    (forall z,w | z in a && w in b :: z <= w) &&\n    (forall p,q | 0 <= p < |a| && 0 <= q < |b| :: a[p] <= b[q])\n}\nlemma SortedEquals( a: seq<int>, b: seq<int> )\n    requires multiset(a) == multiset(b);\n    requires IsSorted(a);\n    requires IsSorted(b);\n    ensures a == b;\n{\n    if a == []\n    {\n        assert |b| == 0 || b[0] in multiset(a);\n        return;\n    }\n    if b == []\n    {\n        assert |a| == 0 || a[0] in multiset(b);\n        return;\n    }\n    assert a[0] in multiset(b);\n    assert b[0] in multiset(a);\n    assert a == a[0..1]+a[1..];\n    assert b == b[0..1]+b[1..];\n    assert a[0] == b[0];\n    assert multiset(a[1..]) == multiset(a)-multiset{a[0]};\n    assert multiset(b[1..]) == multiset(b)-multiset{b[0]};\n    SortedEquals(a[1..],b[1..]);\n}\nfunction MergeFun( a: seq<int>, b: seq<int> ): seq<int>\n    decreases |a|+|b|;\n{\n    if a == [] then\n        b\n    else if b == [] then\n        a\n    else if a[0] <= b[0] then\n        [a[0]]+MergeFun(a[1..],b)\n    else\n        [b[0]]+MergeFun(a,b[1..])\n}\nlemma MergeFunWorks( a: seq<int>, b: seq<int>, c: seq<int> )\n    decreases |a|+|b|;\n    requires IsSorted(a);\n    requires IsSorted(b);\n    requires c == MergeFun(a,b);\n    ensures multiset(c) == multiset(a)+multiset(b);\n    ensures IsSorted(c);\n    ensures a!=[] && b!=[] && a[0]<=b[0] ==> c==a[0..1]+MergeFun(a[1..],b);\n    ensures a!=[] && b!=[] && a[0]>=b[0] ==> c==b[0..1]+MergeFun(a,b[1..]);\n{\n    if a == [] || b == [] { return; }\n    if a[0] <= b[0]\n    {\n        MergeFunWorks(a[1..],b,c[1..]);\n        calc ==\n        {\n            multiset(c);\n            multiset(c[0..1]+c[1..]);\n            multiset(c[0..1])+multiset(c[1..]);\n            multiset(c[0..1])+multiset(a[1..])+multiset(b);\n            multiset(a[0..1])+multiset(a[1..])+multiset(b);\n            multiset(a[0..1]+a[1..])+multiset(b);\n            assert a[0..1]+a[1..] == a;\n            multiset(a)+multiset(b);\n        }\n    }\n    else\n    {\n        MergeFunWorks(a,b[1..],c[1..]);\n        calc ==\n        {\n            multiset(c);\n            multiset(c[0..1]+c[1..]);\n            multiset(c[0..1])+multiset(c[1..]);\n            multiset(c[0..1])+multiset(a)+multiset(b[1..]);\n            multiset(b[0..1])+multiset(a)+multiset(b[1..]);\n            multiset(a)+multiset(b[0..1])+multiset(b[1..]);\n            multiset(a)+multiset(b[0..1]+b[1..]);\n            assert b[0..1]+b[1..] == b;\n            multiset(a)+multiset(b);\n        }\n    }\n}\nlemma Singleton( m: multiset<int>, s: seq<int>, x: int )\n    requires x in m;\n    requires x in s;\n    requires |s| == 1 == |m|;\n    ensures |m-multiset{x}| == 0;\n    ensures s == [x];\n    ensures m == multiset{x};\n    ensures m == multiset(s);\n    ensures IsSorted(s);\n{}\nmethod Sort( a: multiset<int> ) returns ( b: seq<int> )\n    decreases |a|;\n    ensures a == multiset(b);\n    ensures IsSorted(b);\n{\n    if |a| == 0 { return []; }\n    if |a| == 1\n    {\n        var x :| x in a;\n        Singleton(a,[x],x);\n        return [x];\n    }\n    var c, d := Split(a);\n    var e := Sort(c);\n    var f := Sort(d);\n    b := MergeLoop(e,f);\n}\nmethod Split( a: multiset<int> )\n        returns ( b: multiset<int>\n                , c: multiset<int>\n                )\n    decreases a;\n    ensures a == b+c;\n    ensures |b| == |c| || |b| == |c|+1;\n{\n    if |a| < 2\n    {\n        b := a;\n        c := multiset{};\n        return;\n    }\n    var rest,x,y := RemoveTwo(a);\n    b, c := Split(rest);\n    b := b+multiset{x};\n    c := c+multiset{y};\n}\nmethod MergeLoop( a: seq<int>, b: seq<int> ) returns( c: seq<int> )\n    requires IsSorted(a);\n    requires IsSorted(b);\n    ensures IsSorted(c);\n    ensures multiset(a)+multiset(b) == multiset(c);\n    ensures c == MergeFun(a,b);\n{\n    c := [];\n    var a' := a;\n    var b' := b;\n    while a' != [] && b' != []\n        decreases |a'|+|b'|;\n        invariant multiset(a)+multiset(b) == multiset(c)+multiset(a')+multiset(b');\n        invariant IsSegmented(c,a');\n        invariant IsSegmented(c,b');\n        invariant IsSorted(a');\n        invariant IsSorted(b');\n        invariant IsSorted(c);\n    {\n        assert a' == a'[0..1]+a'[1..];\n        assert b' == b'[0..1]+b'[1..];\n        if a'[0] <= b'[0]\n        {\n            c := c+a'[0..1];\n            a' := a'[1..];\n        }\n        else\n        {\n            c := c+b'[0..1];\n            b' := b'[1..];\n        }\n    }\n    c := c+a'+b';\n    MergeFunWorks(a,b,MergeFun(a,b));\n    SortedEquals(c,MergeFun(a,b));\n}\nmethod MergeRecursive( a: seq<int>, b: seq<int> ) returns( c: seq<int> )\n    requires IsSorted(a);\n    requires IsSorted(b);\n    ensures IsSorted(c);\n    ensures multiset(a)+multiset(b) == multiset(c);\n    ensures c == MergeFun(a,b);\n{\n    if a == [] { return b; }\n    if b == [] { return a; }\n    if a[0] <= b[0]\n    {\n        c := MergeRecursive(a[1..],b);\n        c := a[0..1]+c;\n        MergeFunWorks(a,b,c);\n    }\n    else\n    {\n        c := MergeRecursive(a,b[1..]);\n        c := b[0..1]+c;\n        MergeFunWorks(a,b,c);\n    }\n}\nmethod RemoveTwo( a: multiset<int> ) returns( b: multiset<int>, x: int, y: int )\n    requires |a| >= 2;\n    ensures a == b+multiset{x,y};\n{\n    b := a;\n    x :| x in b;\n    b := b-multiset{x};\n    assert |b| >= 1;\n    y :| y in b;\n    b := b-multiset{y};\n}\nmethod SplitLoop( a: multiset<int> )\n        returns ( b: multiset<int>\n                , c: multiset<int>\n                )\n    ensures a == b+c;\n    ensures |b| == |c| || |b| == |c|+1;\n{\n    var rest := a;\n    var x,y : int;\n    b := multiset{};\n    c := multiset{};\n    while |rest| >= 2\n        decreases rest;\n        invariant a == rest+b+c;\n        invariant |b| == |c|;\n    {\n        rest, x, y := RemoveTwo(rest);\n        b := b+multiset{x};\n        c := c+multiset{y};\n    }\n    b := b+rest;\n}\nmethod Test( x: multiset<int> )\n{\n    var a,b := Split(x);\n    assert a+b == x;\n    assert (|a|==|b|) || (|a|==|b|+1);\n    a,b := SplitLoop(x);\n    assert a+b == x;\n    assert (|a|==|b|) || (|a|==|b|+1);\n    var c := Sort(x);\n    assert multiset(c) == x;\n    assert IsSorted(c);\n}\nmethod Main()\n{\n    var x := Sort(multiset{0,9,1,8,2,7,3,6,4,5\n                          ,0,9,1,8,2,7,3,6,4,5\n                          }\n                 );\n    print x;    \n}"
},
{
    "dafny": "method CalculaQuociente(x: nat, y: nat) returns (d: nat, r: nat)\n  requires x >= 0 && y > 0\n  ensures r < y\n  ensures x == y * d + r\n{\n  d := 0;\n  r := x;\n  while r >= y\n    decreases r - y\n    invariant x == y * d + r\n    invariant r >= 0\n  {\n    r := r - y;\n    d := d + 1;\n  }\n}"
},
{
    "dafny": "class A {\n  var a:array<array<int>>; \n  constructor(b: array<array<int>>) {\n  }\n}\nmethod sub(a: array<array<int>>)\nrequires a.Length > 0\nrequires a[0].Length > 0\n{\n  print a[0][0];\n  var b := a;\n  print b[0][0];\n}\nmethod Main() {\n  var a := new array<int>[2];\n  a[0] := new int[2];\n  a[0][0] := 42;\n  print a[0][0];\n  sub(a); \n  var b := new A(a); \n}"
},
{
    "dafny": "class AdvertisingManager {\n    var availableBanners: seq<Banner>;\n    var publishers: seq<Publisher>;\n    var ads: map <Publisher, Ad>;\n    var adService : AdvertisingService;\n    constructor()\n    modifies this;\n    {\n        availableBanners := [];\n        publishers := [];\n        ads := map[];\n        adService := new AdvertisingService ();\n    }\n    method addBanner(banner : Banner)\n    modifies this\n    requires adService != null\n    requires banner !in availableBanners\n    {\n        availableBanners := adService.addBanner(banner, availableBanners);\n    }\n    method stopPublish (publisher: Publisher) \n    modifies this\n    requires adService != null \n    requires publisher in ads && ads[publisher] != null\n    requires ads[publisher].banner !in availableBanners \n    {\n      publishers := adService.removePublisher(publisher, publishers);\n      availableBanners := adService.addBanner(ads[publisher].banner, availableBanners);\n      ads := adService.removeAdOfPublisher(publisher, ads);      \n    }\n    method startPublish (publisher : Publisher, price : int) \n    modifies this\n    requires adService != null  \n\t  requires forall p :: p in publishers <==> p in ads\n    requires forall p :: p in publishers ==> p != null && ads[p] != null && ads[p].banner != null\n\t  requires forall p :: p in ads ==> ads[p] != null\n    requires forall i :: 0 <= i < |availableBanners| ==> availableBanners[i] != null\n    requires |availableBanners| > 0 ==> availableBanners[0] !in availableBanners[1..]\n    {\n        publishers, ads, availableBanners := adService.startPublish(publisher, price, publishers, ads, availableBanners);\n    }        \n}\nclass AdvertisingService \n{\n    constructor () \n    {  \n    }\n    method addBanner(banner : Banner, banners : seq<Banner>) returns (retBanners : seq<Banner>)\n    requires banner !in banners\n    ensures banner in retBanners\n    {\n        return banners + [banner];\n    }\n    method removeAdOfPublisher(publisher : Publisher, ads : map <Publisher, Ad>) returns (retAds : map <Publisher, Ad>)\n    ensures publisher !in retAds\n    {\n      return map p | p in ads && p != publisher :: ads[p];\n    }\n    method removePublisher(publisher : Publisher, publishers : seq<Publisher>) returns (retPublishers : seq<Publisher>)\n    ensures publisher !in retPublishers\n    {\n        var index := 0;\n        var newPublishers : seq<Publisher> := [];\n        while (index < |publishers|)\n        decreases |publishers| - index \n        invariant 0 <= index <= |publishers| && publisher !in newPublishers \n        {\n            if (publishers[index] != publisher)\n            {\n                newPublishers := newPublishers + [publishers[index]];\n            }\n            index := index + 1;\n        }\n        return newPublishers;\n    }\n    method addPublisher (publisher : Publisher, publishers : seq<Publisher>) returns (retPublishers : seq<Publisher>)\n    ensures publisher in retPublishers\n    {\n      return publishers + [publisher];     \n    }\n    method addAd (publisher : Publisher, price : int, banner : Banner, ads : map <Publisher, Ad>) returns (retAds : map <Publisher, Ad>)\n    requires banner != null;\n    ensures publisher in retAds && retAds[publisher] != null\n    ensures retAds[publisher].price == price && retAds[publisher].banner == banner\n    {\n      var newAd : Ad := new Ad(banner, price);\n      return ads[publisher := newAd]; \n    }\n    method popFirstBanner(banners : seq<Banner>) returns (retBanners : seq<Banner>)\n    requires |banners| > 0\n    requires banners[0] !in banners[1..] \n    ensures banners[0] !in retBanners    \n\tensures retBanners == banners[1..]\n    {\n      return banners[1..];\n    }\n    method findMinPublisher(publishers : seq<Publisher>, ads : map <Publisher, Ad>) returns (retPublisher : Publisher, retPrice : int)\n    requires |publishers| > 0\n    requires forall p :: p in publishers ==> p != null && p in ads && ads[p] != null && ads[p].banner != null\n    requires forall p :: p in publishers <==> p in ads\n\t  requires forall p :: p in ads ==> ads[p] != null\n    ensures retPublisher in ads\n    ensures retPublisher != null && ads[retPublisher] != null && ads[retPublisher].banner != null\n    ensures ads[retPublisher].price == retPrice\n  \tensures forall p :: p in ads ==> ads[p].price >= retPrice \n    {\n      var minPublisher := publishers[0];\n      var minPrice := ads[minPublisher].price;\n      var index := 1;\n      while (index < |publishers|)\n      decreases |publishers| - index\n      invariant  forall p :: p in publishers ==> p in ads && minPublisher in ads && ads[minPublisher] != null && ads[minPublisher].price == minPrice && minPublisher in publishers \n      invariant 0 <= index <= |publishers| && minPublisher in ads && forall i :: 0 <= i < index ==> minPrice <= ads[publishers[i]].price && forall p :: p in ads ==> ads[p] != null\n\t  {\n        var curPrice := ads[publishers[index]].price;\n        if (curPrice < minPrice)\n        {\n          minPrice := curPrice;\n          minPublisher := publishers[index];\n        }\n        index := index + 1;\n      }\n      return minPublisher, minPrice;\n    }    \n\tfunction isPriceLessThanMinPrice (price : int, ads: map <Publisher, Ad>) : bool\n    reads valuesOfAds(ads)\n    {\n      forall p :: p in ads && ads[p] != null ==> ads[p].price >= price\n    }\n    function valuesOfAds (myAds : map<Publisher, Ad>) : set<Ad>\n    {\n      set p: Publisher | p in myAds :: myAds[p]\n    }\n    method startPublish(publisher : Publisher, price : int, publishers : seq<Publisher>, ads : map <Publisher, Ad>, availableBanners : seq<Banner>) returns (retPublishers : seq<Publisher>, retAds : map <Publisher, Ad>, retBanners : seq<Banner>)\n    requires forall p :: p in publishers <==> p in ads\n    requires forall p :: p in publishers ==> p != null && ads[p] != null && ads[p].banner != null\n\trequires forall p :: p in ads ==> ads[p] != null\n    requires forall i :: 0 <= i < |availableBanners| ==> availableBanners[i] != null\n    requires |availableBanners| > 0 ==> availableBanners[0] !in availableBanners[1..]   \n\tensures |availableBanners| > 0 ==> publisher in retPublishers && publisher in retAds && retAds[publisher] != null && retAds[publisher].price == price  && availableBanners[0] == retAds[publisher].banner && retBanners == availableBanners[1..] && availableBanners[0] !in retBanners\n    ensures (|availableBanners| == 0 && |publishers| > 0 && isPriceLessThanMinPrice(price, ads)) ==> publishers == retPublishers && ads == retAds\n\t{\n      var newPublishers : seq<Publisher> := publishers;\n      var newAds : map <Publisher, Ad> := ads;\n      var newBanners : seq<Banner> := availableBanners;\n      if (|availableBanners| > 0)\n      {\n        newPublishers := addPublisher(publisher, newPublishers);\n        newAds := addAd(publisher, price, newBanners[0], newAds);          \n        newBanners := popFirstBanner(newBanners);               \n      } \n      else\n      {\n        if (|newPublishers| > 0)\n        {\n          var minPublisher, minPrice := findMinPublisher(newPublishers, newAds);\n          if (price > minPrice) \n          {\n            newAds := addAd(publisher, price, newAds[minPublisher].banner, newAds); \n            newAds := removeAdOfPublisher(minPublisher, newAds);   \n            newPublishers := removePublisher(minPublisher, newPublishers);   \n            newPublishers := addPublisher(publisher, newPublishers);            \n          }\n        }\n      }  \n     return newPublishers, newAds, newBanners; \n    }        \n}\nclass Publisher\n{\n    constructor () \n    {\n    }\n}\nclass Banner\n{\n    constructor () \n    {\n    }\n}\nclass Ad\n{\n    var banner : Banner;\n    var price : int;\n    constructor(bannerArg : Banner, priceArg : int)\n    modifies this;\n    requires bannerArg != null;\n    ensures banner == bannerArg;\n    ensures price == priceArg;\n    {\n        banner := bannerArg;\n        price := priceArg;\n    }\n}"
},
{
    "dafny": "module Io {\n  predicate AdvanceTime(oldTime:int) { oldTime > 2 }\n  class Time\n  {\n    static method GetTime()\n        ensures AdvanceTime(1);\n  }\n  function MaxPacketSize() : int { 65507 }\n  class UdpClient\n  {\n    method Receive()\n        ensures AdvanceTime(3);\n    method Send() returns(ok:bool)\n        requires 0 <= MaxPacketSize();\n  }\n}\nabstract module Host {\n}\nabstract module Main {\n}"
},
{
    "dafny": "ghost function sum(n: nat): int\n{\n    if n == 0 then 0 else n + sum(n - 1)\n}\nmethod Sum(n: nat) returns (s: int)\nensures s == sum(n)\n{\n    var x:nat := 0;\n    var y:nat := 1;\n    var k:nat := n;\n    while k > 0\n    invariant sum(n) == x + y*sum(k)\n    invariant 0 <= k <= n\n    decreases k\n    {\n        assert sum(n) == x + y*sum(k);\n        assert sum(n) == x + y*(k+sum(k-1));\n        assert sum(n) == x + y*k + y*sum(k-1);\n        x := x + y*k;\n        assert sum(n) == x + y*sum(k-1);\n        assert sum(n) == x + y*sum(k-1);\n        k := k-1;\n        assert sum(n) == x + y*sum(k);\n    }\n    assert k == 0;\n    assert sum(n) == x + y*sum(0);\n    assert sum(n) == x + y*0;\n    s := x;\n    assert sum(n) == s;\n}"
},
{
    "dafny": "function max(x:nat, y:nat) : nat\n{\n  if (x < y) then y else x\n}\nmethod slow_max(a: nat, b: nat) returns (z: nat)\n  ensures z == max(a, b)\n{\n  z := 0;\n  var x := a;\n  var y := b;\n  while (z < x && z < y)\n    invariant x >=0;\n    invariant y >=0;\n    invariant z == a - x && z == b - y; \n    invariant a-x == b-y\n    decreases x,y;\n  {\n    z := z + 1;\n    x := x - 1;\n    y := y - 1;\n  }\n if (x <= y) { return b; }\n else { return a;}\n}"
},
{
    "dafny": "method InsertionSort(a: array<int>)\n    modifies a;\n    ensures  Sorted(a, 0, a.Length);\n    ensures  multiset(a[..]) == multiset(old(a[..]));\n{\n    if a.Length == 0 {\n        return;\n    }\n    var up := 1;\n    while up < a.Length\n        decreases a.Length - up;\n        invariant 1 <= up <= a.Length;\n        invariant Sorted(a, 0, up);\n        invariant multiset(a[..]) == multiset(old(a[..]));\n    {\n        var temp := a[up];\n        var down := up;\n        while (down >= 1 && a[down - 1] > temp)\n            decreases down;\n            invariant 0 <= down <= up;\n            invariant forall i, j | 0 <= i < j <= up && j != down :: a[i] <= a[j];\n            invariant temp <= a[down];\n            invariant multiset(a[..][down := temp]) == multiset(old(a[..]));\n        {\n            a[down] := a[down - 1];\n            down := down - 1;\n        }\n        a[down] := temp;\n        up := up + 1;\n    }\n}\npredicate Sorted(a: array<int>, l: int, r: int)\n    reads a;\n    requires 0 <= l <= r <= a.Length;\n{\n    forall i, j :: 0 <= i < j < r ==> a[i] <= a[j]\n}"
},
{
    "dafny": "newtype uint32 = i:int | 0 <= i < 0x100000000\ndatatype Op =\n  | NoOp\n  | PushOp(ghost id: int)\ndatatype Example1 = Example1(u:uint32, b:bool)\ndatatype Example2 = Ex2a(u:uint32) | Ex2b(b:bool)\ndatatype Example3 = Example3(e:Example1)\ndatatype Example4 = Ex4a | Ex4b\ndatatype Example5<V> = Ex5a(v:V) | Ex5b(b:bool)\ndatatype Example6 = Ex6a(u:uint32) | Ex6b(b:bool) | Ex6c(u:uint32, s:seq<bool>)\ntype Ex1Sub = d:Example1 | d.u == 0 witness Example1(0, true)\ntype Ex2Sub = d:Example2 | d.Ex2a? && d.u == 0 witness Ex2a(0)\ntype Ex3Sub = d:Example3 | d.e.b witness Example3(Example1(42, true))\ndatatype DtPointer = DtPointer(s:seq<uint32>)\ndatatype DtPointerHolder = DtPointerHolder(e:DtPointer) | Other(f:bool)\nmethod Matcher(e:Example1) {\n  match e {\n    case Example1(u, b) => print u, b;\n  }\n}\nmethod TupleMatch(e1:Example2, e2:Example2) {\n  match (e1, e2) {\n    case (Ex2a(u1), Ex2a(u2)) => print u1, u2, \"\\n\";\n    case (Ex2b(u1), Ex2a(u2)) => print u1, u2, \"\\n\";\n    case (Ex2a(u1), Ex2b(u2)) => print u1, u2, \"\\n\";\n    case (Ex2b(u1), Ex2b(u2)) => print u1, u2, \"\\n\";\n  }\n}\nmethod Callee(e:Example2) {\n  match e {\n    case Ex2a(u) => print \"Case A: \", u, \"\\n\";\n    case Ex2b(b) => print \"Case B: \", b, \"\\n\";\n  }\n}\nmethod DtUpdate(e:Example1)\n{\n  var x := e.(u := 0);\n}\nmethod TestDestructor() {\n  var e1 := Example1(22, false);\n  var x := e1.u;\n  if x == 22 {\n    print \"This is expected\\n\";\n  } else {\n    assert false;\n    print \"This is unexpected!!!\\n\";\n  }\n}\ndatatype Option<V> = None | Some(value:V)\nmethod TestGenericDefault() {\n  var x:Option<Example5<bool>>;\n}\ndatatype Err<V> = Fail(err:bool) | Ok(value:V)\nmethod matcher(e:Err<uint32>) {\n  match e {\n    case Fail(s) => print s;\n    case Ok(v) => print v;\n  }\n  print \"\\n\";\n}\nmethod GenericTest() {\n  var v:Option<uint32> := Some(32);\n  matcher(Ok(42));\n  matcher(Fail(true));\n  if v.Some? { print \"Got some:\", v.value, \"\\n\"; }\n}\nmethod Comparison(x0:Example1, x1:Example1, y0:Example4, y1:Example4) {\n  if x0 == x1 {\n    print \"Example1s are equal\\n\";\n  }\n  if x0 != x1 {\n    print \"Example1s are not equal\\n\";\n  }\n  if y0 == y1 {\n    print \"Example4s are equal\\n\";\n  }\n  if y0 != y1 {\n    print \"Example4s are not equal\\n\";\n  }\n}\ndatatype Dup = Dup1(b:bool, x:uint32) | Dup2(x:uint32)\nmethod DupTest(d:Dup)\n{\n  var y := d.x;\n  print y;\n  print \"\\n\";\n}\nmethod DupTestTest()\n{\n  DupTest(Dup1(false, 42));\n  DupTest(Dup2(330));\n}\ndatatype IntList =\n  | Nil\n  | Cons(hd:uint32, tl:IntList)\nmethod IntListLen(l:IntList) returns (len:uint32)\n{\n  match l {\n    case Nil => len := 0;\n    case Cons(hd, tl) =>\n      var len_rest := IntListLen(tl);\n      if len_rest < 0xFFFFFFFF {\n        len := len_rest + 1;\n      } else {\n        len := len_rest;\n      }\n  }\n}\ndatatype Foo<A> = Foo(a: A) {\n  static method Alloc(a: A) returns (f: Foo<A>) {\n    f := Foo(a);\n  }\n}\ndatatype Test<A> = Test(a:A) | Empty\n{\n  static method Alloc() returns (t:Test<A>) {\n    return Empty;\n  }\n  static method Invoke() {\n    var a := Alloc();\n  }\n}\nmethod Main() {\n  var e1 := Example1(22, false);\n  var e2 := Ex2a(42);\n  Callee(e2);\n  e2 := Ex2b(true);\n  Callee(e2);\n  TestDestructor();\n  GenericTest();\n  Comparison(Example1(42, true), Example1(42, true), Ex4b, Ex4b);\n  Comparison(Example1(42, false), Example1(42, true), Ex4a, Ex4a);\n  Comparison(Example1(2,  false), Example1(42, false), Ex4a, Ex4b);\n  DupTestTest();\n  var len := IntListLen(Cons(15, Cons(18, Cons(330, Nil))));\n  print len, \"\\n\";\n}"
},
{
    "dafny": "method Main() {\n  Mod1.Test();\n  ConstInit.Test();\n  TwoArgumentExtern.Test();\n}\nmodule {:extern \"Modx\"} Mod1\n{\n  class {:extern \"classx\"} Class1\n  {\n    static function {:extern \"Fun1x\"} Fun1() : int\n      ensures Fun1() > 0\n    static method {:extern \"Method1x\"} Method1() returns (x: int)\n      ensures x > 0\n    static function Fun2() : int\n      ensures Fun2() > 0\n    {\n      Fun1()\n    }\n    static method Method2() returns (x: int)\n      ensures x > 0\n    {\n      x := Method1();\n    }\n  }\n  method Test()\n  {\n    var m2 := Class1.Method2();\n    print \"Fun2() = \", Class1.Fun2(), \", Method2() = \", m2, \"\\n\";\n  }\n}\nmodule {:extern \"ConstInit\"} ConstInit {\n  class C { }\n  const {:extern} c: C  \n  class W {\n    static const {:extern} f: C  \n  }\n  class U {\n    var d: C\n    const e: C\n    constructor {:extern} (b: bool)\n  }\n  method Test() {\n    Check(c);\n    Check(W.f);\n    var u := new U(true);\n    Check(u.d);\n    Check(u.e);\n  }\n  method Check(o: object?)\n    requires o != null\n  {\n    print if o == null then \"null\" else \"good\", \"\\n\";\n  }\n}\nmodule TwoArgumentExtern {\n  method {:extern \"ABC.DEF\", \"MX\"} M(x: int) returns (r: int)\n  function {:extern \"ABC.DEF\", \"FX\"} F(x: int): int\n  method Test() {\n    var y := M(2);  \n    var z := F(2);  \n    print y, \" \", z, \"\\n\";  \n  }\n}"
},
{
    "dafny": "method partA(z: int) returns (x: int, y: int)\nrequires z == 2\nensures y - x == 3\n{\n    x:= z;\n    x:= x + 1;\n    y:= 2*x;\n}\nmethod partB(z: int) returns (x:int, y:int)\nrequires z == 4\nensures y - x == 3\n{\n    x:= z;\n    x, y := x + 1, 2*x;\n}"
},
{
    "dafny": "method zune(d: int) returns (year: int)\n{\n  var b;\n  var days := d;\n  year := 0;\n  while (days > 366)\n    decreases days;\n  {\n    b := IsLeapYear(year);\n    if (b)\n    {\n        days := days - 366;        \n    }\n    else\n    {\n        days := days - 365;\n    }\n    year := year + 1;\n  }\n  if(days > 365)\n  {\n    b := IsLeapYear(year);\n    if(b)\n    {\n      year := year + 1;\n      days := days - 365;\n    }\n  }\n}\nmethod IsLeapYear(years: int) returns (res: bool)"
},
{
    "dafny": "least predicate Natural(x: int) {\n  x == 0 || Natural(x - 1)\n}\ngreatest predicate Positive(x: int) {\n  x != 0 && Positive(x + 1)\n}\nleast lemma NaturalIsNat(x: int)\n  requires Natural(x)\n  ensures 0 <= x\n{\n}\nlemma NatIsNatural(x: int)\n  requires 0 <= x\n  ensures Natural(x)\n{\n}\nlemma PositiveIsPos(x: int)\n  requires x <= 0\n  ensures !Positive(x)\n  decreases -x\n{\n}\ngreatest lemma PosIsPositive(x: int)\n  requires 0 < x\n  ensures Positive(x)\n{\n}\nlemma AboutNatural(x: int)\n  ensures Natural(x) <==> 0 <= x\n{\n  if Natural(x) {\n    NaturalIsNat(x);\n  }\n  if 0 <= x {\n    NatIsNatural(x);\n  }\n}\nlemma AboutPositive(x: int)\n  ensures Positive(x) <==> 0 < x\n{\n  if 0 < x {\n    PosIsPositive(x);\n  } else {\n    PositiveIsPos(x);\n  }\n}\nmethod least(x: int, y: int) returns (least: int) {\n  var greatest;\n  least, greatest := mixmax(x, y);\n}\nmethod greatest(x: int, y: int) returns (greatest: int) {\n  var least;\n  least, greatest := mixmax(x, y);\n}\nmethod mixmax(x: int, y: int) returns (least: int, greatest: int)\n  ensures {x, y} == {least, greatest}\n  ensures least <= greatest\n{\n  if x < y {\n    least, greatest := x, y;\n  } else {\n    least, greatest := y, x;\n  }\n}"
},
{
    "dafny": "predicate upperbound(s: seq<int>, max: int) {\n\tforall i :: 0 <= i < |s| ==> s[i] <= max\n}\npredicate member(s: seq<int>, n: int) {\n\texists i :: 0 <= i <|s| && s[i] == n\n}\nmethod Max1(s: seq<int>) returns (max:int)\n\trequires |s| > 0  \t\t\t\n\tensures member(s, max) \t\t\n\tensures upperbound(s, max)\t\n{\n\tassert (|s| > 0);  \n\tassert 0 < 1 <= |s| && member(s[..1], s[0]);  \n\tmax := s[0];\n\tassert 0 < 1 <= |s| && member(s[..1], max);  \n\tvar i := 1;\n\tassert 0 < i <= |s| && member(s[..i], max);  \n\twhile(i != |s|)\n\tinvariant 0 < i <= |s|\n\tinvariant member(s[..i], max); \n\tinvariant upperbound(s[..i], max); \n\t{\n\t\tassert 0 < i <= |s| && member(s[..i], max) && i != |s|;\t\t\t\n\t\tassert s[i]>max ==> 0 < i+1 <= |s| && member(s[..i+1], s[i]);  \n\t\tif (s[i] > max) { \n\t\t\tassert 0 < i+1 <= |s| && member(s[..i+1], s[i]);\t\n\t\t\tmax := s[i];\t\n\t\t\tassert 0 < i+1 <= |s| && member(s[..i+1], max);\t\t\n\t\t}\n\t\tassert 0 < i+1 <= |s| && member(s[..i+1], max);\t\t\t\n\t\ti := i + 1;\n\t\tassert 0 < i <= |s| && member(s[..i], max);\t\t\t\t\n\t}\n\tassert member(s[..i], max) && i <= |s| && !(i != |s|);\t\t\n\tassert member(s, max);\t\t\t\t\t\t\t\t\t\t\n}\nmethod MaxInd(s: seq<int>) returns (maxind:nat)\n\trequires |s| > 0\t\t\t\t\n{\n\tmaxind := 0;\n\tvar i := 1;\n\twhile(i < |s|)\n\t\tinvariant 0 < i <= |s|\n\t\tinvariant 0 <= maxind < |s|\n\t{\n\t\tif (s[i] > s[maxind]) { \n\t\t\tmaxind := i;\t\n\t\t}\n\t\ti := i + 1;\n\t}\n}"
},
{
    "dafny": "method Main()\n{\n    var a := new int[][3, 5, 2, 1, 4];\n    var min := ArrayMin(a);\n    assert min == 1;\n}\nmethod ArrayMin(a: array<int>) returns (min: int)\n    requires a.Length > 0;\n    ensures  min in a[..];\n    ensures  forall i | 0 <= i < a.Length :: min <= a[i];\n{\n    min := a[0];\n    var i := 1;\n    while i < a.Length\n        decreases a.Length - i;\n        invariant 0 <= i <= a.Length;\n        invariant min in a[..];\n        invariant forall j | 0 <= j < i :: min <= a[j];\n    {\n        if a[i] < min {\n            min := a[i];\n        }\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "method square(x: int) returns (res: nat)\n    ensures res == x * x;\n{\n    res:= x*x;\n}\nmethod check_square()\n{\n    var r;\n    r := square(0);\n    assert(r == 0);\n    r := square(1);\n    r := square(r);\n    assert(r == 1);\n    var r3, r4;\n    r3 := square(3);\n    r4 := square(4);\n    r  := square(5);\n    assert(r3 + r4 == r);\n}"
},
{
    "dafny": "predicate p2(a : seq<int>, b : seq<int>)\n{\n    forall i :: 0 < i < |a| ==> Count(a[i],a) == Count(a[i],b)\n}\nfunction Count(val : int, s : seq<int>) : int\n{\n  if |s| == 0 then 0 else\n  if val == s[0] then Count(val, s[1..]) else Count(val, s[1..])\n}\nmethod Main()\n{\n    var s1 := [1,2,2,3,4];\n    var s2 := [1,3,4,2,2];\n    assert p2(s1,s2);\n}"
},
{
    "dafny": "predicate isLeapYear(y: int) {\n    y % 4 == 0 && (y % 100 != 0 || y % 400 == 0)\n}\nmethod WhichYear(daysSince1980: int) returns (year: int) {\n    var days := daysSince1980;\n    year := 1980;\n    while days > 365\n    decreases days\n    {\n        if isLeapYear(year) {\n            if days > 366 {\n                days := days - 366;\n                year := year + 1;\n            } else {\n                break;\n            }\n        } else {\n            days := days - 365;\n            year := year + 1;\n        }\n    }\n}"
},
{
    "dafny": "method copy( src: array<int>, sStart: nat\n     , dest: array<int>, dStart: nat, len: nat)\n    returns (r: array<int>)\n  requires dest != null && src != null;\n  requires src.Length >= sStart + len;\n  requires dest.Length >= dStart + len;\n  ensures r != null;\n  ensures r.Length == dest.Length;\n  ensures r[..dStart] == dest[..dStart];\n  ensures r[dStart + len..] == dest[dStart + len..];\n  ensures forall k: nat :: k < len\n          ==> r[dStart + k] == src[sStart + k];\n{\n  if len == 0 { return dest; }\n  var i: nat := 0;\n  r := new int[dest.Length];\n  while (i < r.Length)\n    invariant i <= r.Length\n    invariant forall k: nat :: k < i ==> r[k] == dest[k]\n  {\n    r[i] := dest[i];\n    i := i + 1;\n  }\n  assert r[..] == dest[..];\n  i := 0;\n  while (i < len)\n    invariant i <= len\n    invariant r[..dStart] == dest[..dStart]\n    invariant r[dStart..dStart + i] == src[sStart..sStart + i]\n    invariant r[dStart + len..] == dest[dStart + len..]\n  {\n    r[dStart + i] := src[sStart + i];\n    i := i + 1;\n  }\n}"
},
{
    "dafny": "lemma TestMap(a: map<int, (int,int)>) {\n  assert (map k | k in a :: k := a[k].0)\n      == (map k | k in a :: a[k].0);\n}\nlemma TestSet0(a: set<int>) {\n  assert (set k | k in a && k < 7 :: k)\n      == (set k | k in a && k < 7);\n}\nlemma TestSet1(a: set<int>, m: int) {\n  assert (set k | k in a && k < 7 :: k)\n      == (set k | k in a && k < 7 :: m + (k - m));\n}\nlemma TestSet2(a: set<int>, m: int)\n  requires m in a && m < 7\n{\n  assert (set k | k < 7 && k in a)\n      == (set k | k in a :: if k < 7 then k else m);\n}"
},
{
    "dafny": "method flip (a: array<int>, num: int)\nrequires 0 <= num < a.Length;\nrequires a.Length > 0;\nrequires a != null;\nmodifies a;\nensures forall i :: 0 <= i <= num ==> a[i] == old(a[num-i]);\nensures forall j :: num < j < a.Length ==> a[j] == old(a[j]);\nensures multiset(a[..]) == multiset(old(a[..]));\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\n  invariant multiset(a[..]) == multiset(old(a[..]));\n  invariant i + j == num;\n  invariant forall k :: i <= k <= j ==> a[k] == old(a[k]);\n  invariant forall k :: num < k < a.Length ==> a[k] == old(a[k]);\n  invariant forall k :: 0 <= k < i ==> a[k] == old(a[num-k]);\n  invariant forall k :: j < k <= num ==> a[k] == old(a[num-k]);\n  decreases num - i;\n  decreases j - i;\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}"
},
{
    "dafny": "module IMapHelpers {\n  ghost predicate IsKey(k: int) { true }  \n  ghost function ZeroMap() : imap<int,int>\n  {\n    imap i | IsKey(i) :: 0\n  }\n  ghost function EmptyMap() : imap<int,int>\n  {\n    imap i | !IsKey(i) :: 0\n  }\n  ghost function MapUnionPreferLeft<K(!new),V>(a:map<K,V>, b:map<K,V>) : map<K,V>\n  {\n    map key | key in a.Keys + b.Keys :: if key in a then a[key] else b[key]\n  }\n  ghost function IMapUnionPreferLeft(a:imap<int,int>, b:imap<int,int>) : imap<int,int>\n  {\n    imap key | key in a || key in b :: if key in a then a[key] else b[key]\n  }\n  ghost function MapRemove(table:imap<int,int>, removeKeys:iset<int>) : imap<int,int>\n    requires removeKeys <= table.Keys\n  {\n    imap key | key in table && key !in removeKeys :: table[key]\n  }\n  ghost predicate IsFull(m:imap<int, int>) {\n    forall i :: i in m\n  }\n}"
},
{
    "dafny": "function IntToChar(i:int):char\n  requires 0 <= i < 10\n{\n  (48 + i) as char\n}\nfunction CharToInt(i:char):int\n{\n  i as int - 48\n}\nmethod Main() {\n  print IntToChar(8), \"\\n\";\n  print CharToInt('8'), \"\\n\";\n  Regression();\n}\nmethod Regression() {\n  var i := '8';\n  var u := i as myNative;  \n  var v := i as mySubtype;  \n  print i, \" \", u, \" \", v, \"\\n\";\n}\ntype mySubtype = x:int | 0 <= x < 100_000\nnewtype myNative = x:int | 0 <= x < 100_000"
},
{
    "dafny": "method weight_multiplication(w: seq<seq<real>>, x: seq<real>) returns (y: seq<real>) \n    requires valid_wieght(w,x);\n    ensures |w| == |y|;\n {\n    var t := new real[|w|];\n    var i := 0;\n    var j := 0;\n    while i < |w| \n        decreases |w| - i;\n        invariant 0 <= i <= |w|\n    {\n        var j := 0;\n        var s := 0.0;\n        assert |w[i]| == |w[0]|;\n        assert |w[i]| == |x|;\n        while j < |w[i]| \n            decreases |w[i]| - j;\n            invariant 0 <= j <= |w[i]|\n        {\n            s := s + w[i][j] * x[j];\n            j := j + 1;\n        }\n        t[i] := s;\n        i := i + 1;\n    }\n    y := t[..];\n}\nmethod vector_addiction(x: seq<real>, b: seq<real>) returns (y: seq<real>) \n    requires |x| == |b|;\n    ensures |y| == |x|;\n    ensures forall i :: 0 <= i < |x| ==> y[i] == x[i] + b[i]; \n{\n    var t := new real[|x|];\n    var i := 0;\n    while i < |x|\n        decreases |x| - i;\n        invariant 0 <= i <= |x|;\n        invariant forall j :: 0 <= j < i ==> t[j] == x[j] + b[j];\n    {\n        t[i] := x[i] + b[i];\n        i := i + 1;\n    }\n    y := t[..];\n}\nmethod vector_multiplication(x_1: seq<real>, x_2: seq<real>) returns (y: seq<real>) \n    requires |x_1| == |x_2|;\n    ensures |y| == |x_1|;\n    ensures forall i :: 0 <= i < |x_1| ==> y[i] == x_1[i] * x_2[i]; \n{\n    var t := new real[|x_1|];\n    var i := 0;\n    while i < |x_1|\n        decreases |x_1| - i;\n        invariant 0 <= i <= |x_1|;\n        invariant forall j :: 0 <= j < i ==> t[j] == x_1[j] * x_2[j];\n    {\n        t[i] := x_1[i] * x_2[i];\n        i := i + 1;\n    }\n    y := t[..];\n}\npredicate valid_wieght(w: seq<seq<real>>, x: seq<real>) {\n    |w| > 0 && |w[0]| > 0 && |w[0]| == |x|\n    && forall i :: 0 <= i < |w| ==> |w[i]| == |w[0]|\n}\npredicate valid_bias(w: seq<seq<real>>, b: seq<real>) {\n    |w| == |b|\n}\nmethod e_power(x: real) returns (y: real) \n    ensures y > 0.0;\n{\n    var xx := if x >= 0.0 then x else -x;\n    var ep := 1.0;\n    var tmp := 1.0;\n    var i := 1;\n    var ii := 1.0;\n    while i < 1000\n        decreases 1000 - i;\n        invariant ep > 0.0;\n    {\n        tmp := tmp * xx / ii;\n        assert tmp >= 0.0;\n        ep := ep + tmp;\n        ii := ii + 1.0;\n        i := i + 1;\n    }\n    y := if x >= 0.0 then ep else 1.0 / ep;\n}\nmethod sigmoid(x: real) returns (y: real) \n{\n    var ep := e_power(-x);\n    y := 1.0 / (1.0 + ep);\n}\nmethod tanh(x: real) returns (y: real)\n{\n    var epp := e_power(x);\n    var epn := e_power(-x);\n    y := (epp - epn) / (epp + epn);\n} \nmethod vector_sigmoid(x: seq<real>) returns (y: seq<real>) \n    ensures |y| == |x|;\n{\n    var t := new real[|x|];\n    var i:= 0;\n    while i < |x|\n        decreases |x| - i;\n        invariant 0 <= i <= |x|;\n    {\n        t[i] := sigmoid(x[i]);\n        i := i + 1;\n    }\n    y := t[..];\n}\nmethod vector_tanh(x: seq<real>) returns (y: seq<real>) \n    ensures |y| == |x|;\n{\n    var t := new real[|x|];\n    var i:= 0;\n    while i < |x|\n        decreases |x| - i;\n        invariant 0 <= i <= |x|;\n    {\n        t[i] := tanh(x[i]);\n        i := i + 1;\n    }\n    y := t[..];\n}\nmethod sigmoid_with_weight(w: seq<seq<real>>, x: seq<real>, b: seq<real>) returns (y: seq<real>)\n    requires valid_wieght(w, x);\n    requires valid_bias(w, b);\n    ensures |b| == |y|;\n{\n    var f := weight_multiplication(w, x);\n    assert (|w| == |f|);\n    f := vector_addiction(f , b);\n    y := vector_sigmoid(f);\n}\nmethod tanh_with_weight(w: seq<seq<real>>, x: seq<real>, b: seq<real>) returns (y: seq<real>)\n    requires valid_wieght(w, x);\n    requires valid_bias(w, b);\n    ensures |b| == |y|;\n{\n    var f := weight_multiplication(w, x);\n    assert (|w| == |f|);\n    f := vector_addiction(f , b);\n    y := vector_tanh(f);\n}\nmethod lstm_cell(x: seq<real>, \n                 h_prev: seq<real>, \n                 c_prev: seq<real>,\n                 w_f: seq<seq<real>>,\n                 b_f: seq<real>,\n                 w_i: seq<seq<real>>,\n                 b_i: seq<real>,\n                 w_c: seq<seq<real>>,\n                 b_c: seq<real>,\n                 w_o: seq<seq<real>>,\n                 b_o: seq<real>) \n       returns (c: seq<real>, h: seq<real>)\n    requires valid_wieght(w_f, h_prev + x);\n    requires valid_bias(w_f, b_f);\n    requires valid_wieght(w_i, h_prev + x);\n    requires valid_bias(w_i, b_i);\n    requires valid_wieght(w_c, h_prev + x);\n    requires valid_bias(w_c, b_c);\n    requires valid_wieght(w_o, h_prev + x);\n    requires valid_bias(w_o, b_o);\n    requires |c_prev| == |h_prev|;\n    requires |b_i| == |c_prev|;\n    requires |b_c| == |b_i|;\n    requires |b_f| == |b_c|;\n    requires |b_o| == |b_f|;\n    ensures |h| == |h_prev|;\n    ensures |c| == |c_prev|;\n{\n    var f_t := sigmoid_with_weight(w_f, h_prev + x, b_f);\n    var i_t := sigmoid_with_weight(w_i, h_prev + x, b_i);    \n    var c_t := tanh_with_weight(w_c, h_prev + x, b_c);\n    c_t := vector_multiplication(c_t, i_t);\n    var c_temp := vector_multiplication(c_prev, f_t);\n    c := vector_addiction(c_temp, c_t);\n    var o_t := sigmoid_with_weight(w_o, h_prev + x, b_o);\n    var tanh_c := vector_tanh(c);\n    h := vector_multiplication(o_t, tanh_c);\n}"
},
{
    "dafny": "method Reverse(a: array?<int>)\n  requires a != null;\n  modifies a;\n  ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length-1) - k]);\n{\n  var l := a.Length - 1;\n  var i := 0;\n  while (i < (l+1)/2)\n    invariant 0 <= i <= (l+1)/2;\n    invariant forall k :: 0 <= k < i || l-i < k <= l ==> a[k] == old(a[l-k]);\n    invariant forall k :: i <= k <= l-i ==> a[k] == old(a[k]);\n  {\n    var h := a[i]; a[i] := a[l-i]; a[l-i] := h;\n    i := i + 1;\n  }\n}\nmethod Main() {\n  var a := new int[5];\n  a[0] := 12;\n  a[1] := 3;\n  a[2] := 5;\n  a[3] := 2;\n  a[4] := 1;\n  print a[0], \" \", a[1], \" \", a[2], \" \", a[3], \" \", a[4], \"\\n\";\n  Reverse(a);\n  print a[0], \" \", a[1], \" \", a[2], \" \", a[3], \" \", a[4], \" \";\n}"
},
{
    "dafny": "function sorted(a:array<int>, n:int):bool\n    requires 0 <= n <= a.Length\n    reads a\n{ \n    forall i, j:: (0 <= i < j < n) ==> a[i] <= a[j]\n}\nfunction unique(b:array<int>, l:int, h:int):bool\n    reads b\n    requires 0 <= l <= h <= b.Length\n{ \n    forall k::(l <= k < h ) ==> forall j::(k<j<h)  ==> b[k] != b[j] \n}\nmethod Deduplicate(a:array<int>, n:int) returns (b:array<int>, m:int) \n    requires 0 <= n <= a.Length \n    requires sorted(a,n) \n    ensures 0 <= m <= b.Length \n    ensures sorted(b,m) && unique(b,0,m)\n    ensures forall i, j:: (0 <= i < j < m) ==> b[i] != b[j]\n{\n    m := 0;\n    b := new int[a.Length];\n    var i,j,c := 0, 0, 0;\n    while i < n\n        decreases n - i;\n        invariant 0 <= j <= i <= n\n        invariant 0 <= m <= n\n    {\n        c := a[i];\n        i := i+1;\n        b[j] := c;\n        while i < n && a[i] == c\n            decreases n - i\n            invariant 0 <= i <= n\n        {\n            i := i + 1;\n        }\n        j := j + 1;\n    }\n    if m > 0 {m := j;} \n}"
},
{
    "dafny": "method swap3(a: array<int>, h: int, i: int, j: int)\n  modifies a\n  requires 0 <= h < a.Length\n  requires 0 <= i < a.Length\n  requires 0 <= j < a.Length\n  requires i != j && j != h && h != i;\n  ensures a[h] == old(a[i]);\n  ensures a[j] == old(a[h]);\n  ensures a[i] == old(a[j]);\n  ensures forall k: int :: 0 <= k < a.Length && k != h && k != i && k != j ==> a[k] == old(a[k]); \n{\n    var tmp := a[h];\n    a[h] := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n}\nmethod testSwap3(a: array<int>, h: int, i: int, j:int )\n  modifies a\n  requires 0 <= h < a.Length\n  requires 0 <= i < a.Length\n  requires 0 <= j < a.Length\n  requires i != j && j != h && h != i;\n{\n  swap3(a, h, i, j);\n  assert a[h] == old(a[i]);\n  assert a[j] == old(a[h]);\n  assert a[i] == old(a[j]);\n  assert forall k: int :: 0 <= k < a.Length && k != h && k != i && k != j ==> a[k] == old(a[k]); \n}"
},
{
    "dafny": "class Node<T> {\n  var next: Node?<T>\n}\nclass List<T> {\n    ghost var spine: seq<Node<T>>\n    ghost var repr: set<object>\n    ghost predicate Valid()\n        reads this, repr\n    {\n        && forall i | 0 <= i < |spine| ::\n            && spine[i] in repr\n            && (spine[i].next == (if i < |spine| - 1 then spine[i+1] else null))\n    }\n}"
},
{
    "dafny": "method Abs(x:int) returns (r:int)\nensures r >= 0 && (r == x || r == -x)\n{\n    if x < 0\n    {\n        return -x;\n    }\n    else\n    {\n        return x;\n    }\n}"
},
{
    "dafny": "ghost predicate ContainsNothingBut5(s: set<int>)\n{\n  forall q :: q in s ==> q == 5\n}\nghost predicate YeahContains5(s: set<int>)\n{\n  exists q :: q in s && q == 5\n}\nghost predicate ViaSetComprehension(s: set<int>) {\n  |set q | q in s && q == 5| != 0\n}\nghost predicate LambdaTest(s: set<int>) {\n  (q => q in s)(5)\n}\nghost predicate ViaMapComprehension(s: set<int>) {\n  |(map q | q in s && q == 5 :: true).Keys| != 0\n}\nghost predicate Contains5(s: set<int>)\n{\n  var q := 5; q in s\n}\ndatatype R = MakeR(int) | Other\nghost predicate RIs5(r: R) {\n  match r case MakeR(q) => q == 5 case Other => false\n}\nlemma NonemptySet(x: int, s: set<int>)\n  requires x in s\n  ensures |s| != 0\n{\n}\nlemma NonemptyMap(x: int, s: map<int,bool>)\n  requires x in s.Keys\n  ensures |s| != 0\n{\n}\nmethod M(s: set<int>, r: R, q: int)\n  requires s == {5} && r == MakeR(5)\n{\n  assert ContainsNothingBut5(s);  \n  assert YeahContains5(s);  \n  NonemptySet(5, set q | q in s && q == 5);\n  assert ViaSetComprehension(s);  \n  NonemptyMap(5, map q | q in s && q == 5 :: true);\n  assert ViaMapComprehension(s);  \n  assert LambdaTest(s);  \n  assert Contains5(s);  \n  assert RIs5(r);  \n}"
},
{
    "dafny": "module HashsetInterface{\n    class Hashset{\n        ghost var Contents: set<int>;\n        ghost var Repr: set<object>;\n        predicate Valid()\n            reads Repr, this;\n        constructor (size: int)\n            requires size > 0;\n            ensures Valid();\n            ensures fresh(Repr);\n        method insert(e: int) returns (r: bool)\n            modifies Repr, this;\n            requires Valid();\n            ensures Valid();\n            ensures Repr == old(Repr);\n            ensures !r ==> Contents == old(Contents);\n            ensures r ==> Contents == old(Contents) + {e};\n            ensures r == (e in Contents);\n        method remove(e: int) returns (r: bool)\n            modifies Repr, this;\n            requires Valid();\n            ensures Valid();\n            ensures Repr == old(Repr);\n            ensures Contents == old(Contents) - {e};\n            ensures r == (e in old(Contents));\n        method get(e: int) returns (r: int)\n            requires Valid();\n            ensures Valid();\n            ensures Repr == old(Repr);\n            ensures (r >= 0) == (e in Contents);\n            ensures (r == -1) == (e !in Contents);\n    }\n}"
},
{
    "dafny": "module fast_exp{ \nlemma exp_even (x:real, n:nat)\n  requires n % 2 == 0;\n  ensures (exp (x, n) == exp (x*x, n/2));\n{\n  assume (false);\n}\nlemma exp_odd(x:real, n:nat)\n  requires n % 2 == 1;\n  ensures (exp (x, n) == exp (x*x, (n-1)/2)*x);\n{\n  assume (false);\n}\nfunction exp (x: real, n:nat): real\n{\n  if (x == 0.0) then 0.0\n  else if (n == 0) then 1.0\n  else x * exp(x, n-1)\n}\nmethod exp_by_sqr(x0: real, n0: int)returns (r:real)\n\t\trequires n0 >= 0\n\t\trequires x0 >= 0.0;\n\t  ensures r == exp (x0, n0);{\n\tif x0 == 0.0 {\n\t\treturn 0.0;\n\t}\n\tif n0 == 0 {\n\t\treturn 1.0;\n\t}\n\tvar x, n, y := x0, n0, 1.0;\n\twhile n > 1 \n\t\tinvariant 1 <= n <= n0;\n\t\t  invariant exp (x0, n0) == exp (x, n) * y;{\n\t\tif n%2 == 0 {\n\t\t\texp_even(x, n);\n\t\t\tx := x * x;\n\t\t\tn := n / 2;\n\t\t} else {\n\t\t\texp_odd(x, n);\n\t\t\ty := x * y;\n\t\t\tx := x * x;\n\t\t\tn := (n - 1) / 2;\n\t\t}\n\t}\n\treturn x * y;\n}\n}"
},
{
    "dafny": "method init_array(arr: array<int>)\nrequires (arr != null);\nmodifies arr;\n{\n    var i := 0;\n    var high := arr.Length;\n    while (i < high)\n        modifies arr;\n        invariant 0 <= i <= high <= arr.Length;\n    {\n        arr[i] := 0;\n        i := i + 1;\n    }\n}"
},
{
    "dafny": "module {:extern \"Extern\"} Extern {\n  newtype uint64 = i:int | 0 <= i < 0x10000000000000000\n  method {:extern \"Extern\", \"Caller\"} Caller(inc:uint64-->uint64, x:uint64) returns (y:uint64)\n    requires inc.requires(x)\n  method {:extern \"Extern\", \"GenericCaller\"} GenericCaller<A>(inc:A-->A, x:A) returns (y:A)\n    requires inc.requires(x)\n  class {:extern} GenericClass<A>\n  {\n    constructor {:extern \"Extern\", \"GenericClass\"} (inc:A-->A, x:A)\n      requires inc.requires(x)\n    method {:extern \"Extern\", \"get\"} get() returns (y:A)\n  }\n}\nmodule Test {\n  newtype uint32  = i:int | 0 <= i < 0x100000000\n  function Test(x:uint32) : uint64 {\n    x as uint64 + 1\n  }\n  function Seqs<T>(s:seq<T>, x:uint32, default_val:T) : T\n    requires |s| < 1000\n  {\n    if |s| as uint32 > x then s[x] else default_val\n  }\n  function AddOne(x:uint64) : uint64\n    requires x < 100\n  {\n    x + 1\n  }\n  method CallTest() {\n    var x := Caller(AddOne, 5);\n    print x, \"\\n\";\n    var y := GenericCaller(AddOne, 6);\n    print y, \"\\n\";\n    var c := new GenericClass(AddOne, 7);\n    var z := c.get();\n    print z, \"\\n\";\n  }\n  method Main() {\n    var y := Test(12);  \n    CallTest();         \n    print y, \"\\n\";\n  }\n}"
},
{
    "dafny": "method iter_copy<T(0)>(s: array<T>) returns (t: array<T>)\n{\n  t := new T[s.Length];\n  var i:= 0;\n  while (i < s.Length)\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> s[x] == t[x]\n  {\n    t[i] := s[i];\n    i:=i+1;\n  }\n}"
},
{
    "dafny": "trait Shape {\n  function Center(): (real, real) reads this\n  method PrintCenter() {\n    print \"Center: \", this.Center(), \"\\n\";\n  }\n}\nclass Square extends Shape {\n  var x1: real, y1: real, x2: real, y2: real\n  constructor(x1: real, y1: real, x2: real, y2: real) {\n    this.x1 := x1;\n    this.y1 := y1;\n    this.x2 := x2;\n    this.y2 := y2;\n  }\n  function Center(): (real, real) reads this {\n    var x := (this.x1 + this.x2) / 2.0;\n    var y := (this.y1 + this.y2) / 2.0;\n    (x, y)\n  }\n}\nclass Circle extends Shape {\n  var x: real, y: real, r: real\n  constructor(x: real, y: real, r: real) {\n    this.x := x;\n    this.y := y;\n    this.r := r;\n  }\n  function Center(): (real, real) reads this {\n    (this.x, this.y)\n  }\n}\nmethod PrintArray(shapes: array<Shape?>) {\n  var i : int := 0;\n  while i < shapes.Length\n    invariant 0 <= i <= shapes.Length\n    decreases shapes.Length - i\n  {\n    if shapes[i] != null {\n      shapes[i].PrintCenter();\n    }\n    i := i + 1;\n  }\n}\nmethod PrintSeq(shapes: seq<Shape>) {\n  var i : int := 0;\n  while i < |shapes|\n    invariant 0 <= i <= |shapes|\n    decreases |shapes| - i\n  {\n    shapes[i].PrintCenter();\n    i := i + 1;\n  }\n}\nlemma ThereIsASmallest(s: set<Shape>) returns (shape: Shape)\n  requires s != {}\n  ensures shape in s && forall shape' :: shape' in s ==> shape.Center().0 <= shape'.Center().0\n{\n  shape :| shape in s;\n  if shape' :| shape' in s && shape'.Center().0 < shape.Center().0 {\n    var s' := s - {shape};\n    assert shape' in s';\n    shape := ThereIsASmallest(s');\n  }\n}\nmethod PrintSet(shapes: set<Shape>) {\n  var s := shapes;\n  var ordered := [];\n  while |s| != 0 {\n    ghost var _ := ThereIsASmallest(s);\n    var shape :| shape in s && forall shape' :: shape' in s ==> shape.Center().0 <= shape'.Center().0;\n    ordered := ordered + [shape];\n    s := s - {shape};\n  }\n  PrintSeq(ordered);\n}\nlemma ThereIsASmallestInMultiset(s: multiset<Shape>) returns (shape: Shape)\n  requires s != multiset{}\n  ensures shape in s && forall shape' :: shape' in s ==> shape.Center().0 <= shape'.Center().0\n{\n  shape :| shape in s;\n  if shape' :| shape' in s && shape'.Center().0 < shape.Center().0 {\n    var s' := s - multiset{shape};\n    assert shape' in s';\n    shape := ThereIsASmallestInMultiset(s');\n  }\n}\nmethod PrintMultiSet(shapes: multiset<Shape>) {\n  var s := shapes;\n  var ordered := [];\n  while |s| != 0 {\n    ghost var _ := ThereIsASmallestInMultiset(s);\n    var shape :| shape in s && forall shape' :: shape' in s ==> shape.Center().0 <= shape'.Center().0;\n    ordered := ordered + [shape];\n    s := s - multiset{shape};\n  }\n  PrintSeq(ordered);\n}\nlemma ThereIsASmallestInt(s: set<int>) returns (k: int)\n  requires s != {}\n  ensures k in s && forall k' :: k' in s ==> k <= k'\n{\n  k :| k in s;\n  if k' :| k' in s && k' < k {\n    var s' := s - {k};\n    assert s == s' + {k};\n    assert k' in s';  \n    k := ThereIsASmallestInt(s');\n  }\n}\nmethod PrintMap(shapes: map<nat, Shape>) {\n  var s := shapes.Keys;\n  var ordered := [];\n  while |s| != 0\n    invariant s <= shapes.Keys\n  {\n    ghost var _ := ThereIsASmallestInt(s);\n    var k :| k in s && forall k' :: k' in s ==> k <= k';\n    ordered := ordered + [shapes[k]];\n    s := s - {k};\n  }\n  PrintSeq(ordered);\n}\nmethod Main() {\n  var square := new Square(0.0, 1.0, 1.0, 0.0);\n  print \"Center of square: \", square.Center(), \"\\n\";  \n  var circle := new Circle(1.0, 1.0, 4.0);  \n  print \"Center of circle: \", circle.Center(), \"\\n\";\n  var shapes : array<Shape?> := new Shape?[2];\n  shapes[0] := square;\n  shapes[1] := circle;\n  PrintArray(shapes);\n  PrintSeq([square, circle]);\n  PrintSet({square, circle});\n  PrintMultiSet(multiset{square, circle});\n  PrintMap(map[0 := square, 1 := circle]);\n}"
}
]
